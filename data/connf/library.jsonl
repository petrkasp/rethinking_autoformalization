{"full_name": "ConNF.mem_cloud", "url": "ConNF/NewTangle/Cloud.html#ConNF.mem_cloud", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mem_cloud [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ³Î² : Î³ â‰  â†‘Î²} {t : ConNF.Tangle â†‘Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)} :t âˆˆ ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² s â†” âˆƒ t' âˆˆ s, âˆƒ (N : ConNF.NearLitter), N.fst = ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² t' âˆ§ t = ConNF.typedNearLitter N", "code": "theorem mem_cloud {t : Tangle Î²} {s : Set (Tangle Î³)} :\n    t âˆˆ cloud hÎ³Î² s â†”\n      âˆƒ t' âˆˆ s, âˆƒ (N : NearLitter), N.1 = fuzz hÎ³Î² t' âˆ§ t = typedNearLitter N := by\n  simp only [cloud, mem_image, mem_iUnion, mem_localCardinal, exists_prop]\n  constructor\n  Â· rintro âŸ¨N, âŸ¨t, htâ‚, htâ‚‚âŸ©, rflâŸ©\n    exact âŸ¨t, htâ‚, N, htâ‚‚, rflâŸ©\n  Â· rintro âŸ¨t, htâ‚, N, htâ‚‚, rflâŸ©\n    exact âŸ¨N, âŸ¨t, htâ‚, htâ‚‚âŸ©, rflâŸ©\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 77, 78], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [56, 65], "informalization": "The `ConNF.mem_cloud` theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4 states that a tangle `t` of type `Î²` belongs to the `ConNF.cloud` of a set `s` of tangles of type `Î³` if and only if there exists a tangle `t'` in `s` and a near-litter `N` such that `N` is the `ConNF.fuzz` of `t'` and `t` is the `ConNF.typedNearLitter` of `N`."}
{"full_name": "ConNF.Params", "url": "ConNF/BaseType/Params.html#ConNF.Params", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.Params :Type (u + 1)\n | Î› : Type  u\n | Î›_linearOrder : LinearOrderğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î›\n | Î›_isWellOrder : IsWellOrderğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î› fun (x x_1 : ConNF.Î›) => x <  x_1\n | Î›_zero : ZeroğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î›\n | Î›_succ : SuccOrderğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î›\n | Î›_zero_le : âˆ€ (Î± : ConNF.Î›), 0 â‰¤  Î±\n | Î›_isLimit : Ordinal.IsLimitğŸ”—<|PREMISE|>ğŸ”—  (Ordinal.typeğŸ”—<|PREMISE|>ğŸ”—  fun (x x_1 : ConNF.Î›) => x <  x_1)\n | Îº : Type  u\n | Îº_linearOrder : LinearOrderğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº\n | Îº_isWellOrder : IsWellOrderğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº fun (x x_1 : ConNF.Îº) => x <  x_1\n | Îº_ord : (Ordinal.typeğŸ”—<|PREMISE|>ğŸ”—  fun (x x_1 : ConNF.Îº) => x <  x_1) =  Cardinal.ordğŸ”—<|PREMISE|>ğŸ”—  (Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº)\n | Îº_isRegular : Cardinal.IsRegularğŸ”—<|PREMISE|>ğŸ”—  (Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº)\n | Îº_succ : SuccOrderğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº\n | Îº_addMonoid : AddMonoidğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº\n | Îº_sub : SubğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº\n | Îº_add_typein : âˆ€ (i j : ConNF.Îº),\n Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”—  (fun (x x_1 : ConNF.Îº) => x <  x_1) (i +  j) =  Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”—  (fun (x x_1 : ConNF.Îº) => x <  x_1) i +  Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”—  (fun (x x_1 : ConNF.Îº) => x <  x_1) j\n | Îº_sub_typein : âˆ€ (i j : ConNF.Îº),\n Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”—  (fun (x x_1 : ConNF.Îº) => x <  x_1) (i -  j) =  Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”—  (fun (x x_1 : ConNF.Îº) => x <  x_1) i -  Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”—  (fun (x x_1 : ConNF.Îº) => x <  x_1) j\n | Î›_lt_Îº : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î› <  Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº\n | Î¼ : Type  u\n | Î¼_linearOrder : LinearOrderğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î¼\n | Î¼_isWellOrder : IsWellOrderğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î¼ fun (x x_1 : ConNF.Î¼) => x <  x_1\n | Î¼_ord : (Ordinal.typeğŸ”—<|PREMISE|>ğŸ”—  fun (x x_1 : ConNF.Î¼) => x <  x_1) =  Cardinal.ordğŸ”—<|PREMISE|>ğŸ”—  (Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î¼)\n | Î¼_isStrongLimit : Cardinal.IsStrongLimitğŸ”—<|PREMISE|>ğŸ”—  (Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î¼)\n | Îº_lt_Î¼ : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº <  Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î¼\n | Îº_le_Î¼_ord_cof : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Îº â‰¤  Ordinal.cofğŸ”—<|PREMISE|>ğŸ”—  (Cardinal.ordğŸ”—<|PREMISE|>ğŸ”—  (Cardinal.mkğŸ”—<|PREMISE|>ğŸ”—  ConNF.Î¼))", "code": "class Params where\n  /--\n  The type indexing the levels of our model.\n  This type is well-ordered.\n  We inductively construct each type level by induction over `Î›`.\n  Its cardinality is smaller than `Îº` and `Î¼`.\n  -/\n  Î› : Type u\n  [Î›_linearOrder : LinearOrder Î›]\n  [Î›_isWellOrder : IsWellOrder Î› (Â· < Â·)]\n  [Î›_zero : Zero Î›]\n  [Î›_succ : SuccOrder Î›]\n  Î›_zero_le (Î± : Î›) : 0 â‰¤ Î±\n  Î›_isLimit : (Ordinal.type ((Â· < Â·) : Î› â†’ Î› â†’ Prop)).IsLimit\n  /--\n  The type indexing the atoms in each litter.\n  Its cardinality is regular, and is larger than `Î›` but smaller than `Îº`.\n  It also has an additive monoid structure, which is covariant in both variables with respect to the\n  ordering.\n  -/\n  Îº : Type u\n  [Îº_linearOrder : LinearOrder Îº]\n  [Îº_isWellOrder : IsWellOrder Îº (Â· < Â·)]\n  Îº_ord : Ordinal.type ((Â· < Â·) : Îº â†’ Îº â†’ Prop) = (#Îº).ord\n  Îº_isRegular : (#Îº).IsRegular\n  [Îº_succ : SuccOrder Îº]\n  [Îº_addMonoid : AddMonoid Îº]\n  [Îº_sub : Sub Îº]\n  Îº_add_typein (i j : Îº) : Ordinal.typein (Â· < Â·) (i + j : Îº) =\n    Ordinal.typein (Â· < Â·) i + Ordinal.typein (Â· < Â·) j\n  Îº_sub_typein (i j : Îº) : Ordinal.typein (Â· < Â·) (i - j : Îº) =\n    Ordinal.typein (Â· < Â·) i - Ordinal.typein (Â· < Â·) j\n  Î›_lt_Îº : #Î› < #Îº\n  /--\n  A large type used in indexing the litters.\n  This type is well-ordered.\n  Its cardinality is a strong limit, larger than `Î›` and `Îº`.\n  The cofinality of the order type of `Î¼` is at least `Îº`.\n  -/\n  Î¼ : Type u\n  [Î¼_linearOrder : LinearOrder Î¼]\n  [Î¼_isWellOrder : IsWellOrder Î¼ (Â· < Â·)]\n  Î¼_ord : Ordinal.type ((Â· < Â·) : Î¼ â†’ Î¼ â†’ Prop) = (#Î¼).ord\n  Î¼_isStrongLimit : (#Î¼).IsStrongLimit\n  Îº_lt_Î¼ : #Îº < #Î¼\n  Îº_le_Î¼_ord_cof : #Îº â‰¤ (#Î¼).ord.cof\n", "additional_info": "The parameters of the construction. We collect them all in one class for simplicity.\nNote that the ordinal `Î»` in the paper is instead referred to here as `ğŸ—ŸÎ›ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î›ğŸ”—` , since the symbol `Î»` is\nused for lambda abstractions.\nOrdinals and cardinals are represented here as arbitrary types (not sets) with certain properties.\nFor instance, `ğŸ—ŸÎ›ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î›ğŸ”—`  is an arbitrary type that has an ordering `<`, which is assumed to be a\nwell-ordering (the `Î›wo` term is a proof of this fact).\nThe prefix `#` denotes the cardinality of a type.\n- ConNF.Params.Î›: The type indexing the levels of our model.\nThis type is well-ordered.\nWe inductively construct each type level by induction over `ğŸ—ŸÎ›ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î›ğŸ”—` .\nIts cardinality is smaller than `ğŸ—ŸÎºğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.ÎºğŸ”—`  and `ğŸ—ŸÎ¼ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î¼ğŸ”—` .\n\n\n- ConNF.Params.Îº: The type indexing the atoms in each litter.\nIts cardinality is regular, and is larger than `ğŸ—ŸÎ›ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î›ğŸ”—`  but smaller than `ğŸ—ŸÎºğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.ÎºğŸ”—` .\nIt also has an additive monoid structure, which is covariant in both variables with respect to the\nordering.\n\n\n- ConNF.Params.Î¼: A large type used in indexing the litters.\nThis type is well-ordered.\nIts cardinality is a strong limit, larger than `ğŸ—ŸÎ›ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î›ğŸ”—`  and `ğŸ—ŸÎºğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.ÎºğŸ”—` .\nThe cofinality of the order type of `ğŸ—ŸÎ¼ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î¼ğŸ”—`  is at least `ğŸ—ŸÎºğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.ÎºğŸ”—` .\n\n\n", "used_premises": [2, 15, 20, 21, 24, 26, 2, 15, 26, 27, 29, 30, 29, 21, 31, 35, 36, 36, 36, 36, 36, 36, 29, 29, 2, 15, 26, 27, 29, 37, 29, 29, 29, 29, 38, 27, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [32, 78], "informalization": "The `ConNF.Params` class in Lean 4 defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Î›`, `Îº`, and `Î¼`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "LinearOrder", "url": "Mathlib/Init/Order/Defs.html#LinearOrder", "code_src": "mathlib4", "ptype": "class", "header": "class LinearOrder (Î± : Type u) extends PartialOrderğŸ”—<|PREMISE|>ğŸ”— , MinğŸ”—<|PREMISE|>ğŸ”— , MaxğŸ”—<|PREMISE|>ğŸ”— , OrdğŸ”—<|PREMISE|>ğŸ”— :Type u\n | le : Î± â†’ Î± â†’ Prop \n | lt : Î± â†’ Î± â†’ Prop \n | le_refl : âˆ€ (a : Î±), a â‰¤  a\n | le_trans : âˆ€ (a b c : Î±), a â‰¤  b â†’ b â‰¤  c â†’ a â‰¤  c\n | lt_iff_le_not_le : âˆ€ (a b : Î±), a <  b â†”  a â‰¤  b âˆ§  Â¬ b â‰¤  a\n | le_antisymm : âˆ€ (a b : Î±), a â‰¤  b â†’ b â‰¤  a â†’ a =  b\n | min : Î± â†’ Î± â†’ Î±\n | max : Î± â†’ Î± â†’ Î±\n | compare : Î± â†’ Î± â†’ OrderingğŸ”—<|PREMISE|>ğŸ”— \n | le_total : âˆ€ (a b : Î±), a â‰¤  b âˆ¨  b â‰¤  a\n | decidableLE : DecidableRelğŸ”—<|PREMISE|>ğŸ”—  fun (x x_1 : Î±) => x â‰¤  x_1\n | decidableEq : DecidableEqğŸ”—<|PREMISE|>ğŸ”—  Î±\n | decidableLT : DecidableRelğŸ”—<|PREMISE|>ğŸ”—  fun (x x_1 : Î±) => x <  x_1\n | min_def : âˆ€ (a b : Î±), min  a b =  if a â‰¤  b then a else b\n | max_def : âˆ€ (a b : Î±), max  a b =  if a â‰¤  b then b else a\n | compare_eq_compareOfLessAndEq : âˆ€ (a b : Î±), compare  a b =  compareOfLessAndEqğŸ”—<|PREMISE|>ğŸ”—  a b", "code": "class LinearOrder (Î± : Type u) extends PartialOrder Î±, Min Î±, Max Î±, Ord Î± :=\n  /-- A linear order is total. -/\n  le_total (a b : Î±) : a â‰¤ b âˆ¨ b â‰¤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (Â· â‰¤ Â· : Î± â†’ Î± â†’ Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq Î± := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (Â· < Â· : Î± â†’ Î± â†’ Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  min := fun a b => if a â‰¤ b then a else b\n  max := fun a b => if a â‰¤ b then b else a\n  /-- The minimum function is equivalent to the one you get from `minOfLe`. -/\n  min_def : âˆ€ a b, min a b = if a â‰¤ b then a else b := by intros; rfl\n  /-- The minimum function is equivalent to the one you get from `maxOfLe`. -/\n  max_def : âˆ€ a b, max a b = if a â‰¤ b then b else a := by intros; rfl\n  compare a b := compareOfLessAndEq a b\n  /-- Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. -/\n  compare_eq_compareOfLessAndEq : âˆ€ a b, compare a b = compareOfLessAndEq a b := by\n    compareOfLessAndEq_rfl\n", "additional_info": "A linear order is reflexive, transitive, antisymmetric and total relation `â‰¤`.\nWe assume that every linear ordered type has decidable `(â‰¤)`, `(<)`, and `(=)`.\n- LinearOrder.le_total: A linear order is total.\n\n\n- LinearOrder.decidableLE: In a linearly ordered type, we assume the order relations are all decidable.\n\n\n- LinearOrder.decidableEq: In a linearly ordered type, we assume the order relations are all decidable.\n\n\n- LinearOrder.decidableLT: In a linearly ordered type, we assume the order relations are all decidable.\n\n\n- LinearOrder.min_def: The minimum function is equivalent to the one you get from `ğŸ—ŸminOfLeğŸ—ŸğŸ”—../../.././Init/Prelude.html#minOfLeğŸ”—` .\n\n\n- LinearOrder.max_def: The minimum function is equivalent to the one you get from `ğŸ—ŸmaxOfLeğŸ—ŸğŸ”—../../.././Init/Prelude.html#maxOfLeğŸ”—` .\n\n\n- LinearOrder.compare_eq_compareOfLessAndEq: Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`.\n\n\n", "used_premises": [3, 7, 8, 9, 10, 11, 12, 11, 13], "def_path": "Mathlib/Init/Order/Defs.lean", "pos": [262, 282], "informalization": "Class `LinearOrder` represents a type `Î±` with a total, reflexive, transitive, and antisymmetric binary relation `â‰¤`, along with decidable comparisons and operations for minimum and maximum."}
{"full_name": "PartialOrder", "url": "Mathlib/Init/Order/Defs.html#PartialOrder", "code_src": "mathlib4", "ptype": "class", "header": "class PartialOrder (Î± : Type u) extends PreorderğŸ”—<|PREMISE|>ğŸ”— :Type u\n | le : Î± â†’ Î± â†’ Prop \n | lt : Î± â†’ Î± â†’ Prop \n | le_refl : âˆ€ (a : Î±), a â‰¤  a\n | le_trans : âˆ€ (a b c : Î±), a â‰¤  b â†’ b â‰¤  c â†’ a â‰¤  c\n | lt_iff_le_not_le : âˆ€ (a b : Î±), a <  b â†”  a â‰¤  b âˆ§  Â¬ b â‰¤  a\n | le_antisymm : âˆ€ (a b : Î±), a â‰¤  b â†’ b â‰¤  a â†’ a =  b", "code": "class PartialOrder (Î± : Type u) extends Preorder Î± where\n  le_antisymm : âˆ€ a b : Î±, a â‰¤ b â†’ b â‰¤ a â†’ a = b\n", "additional_info": "A partial order is a reflexive, transitive, antisymmetric relation `â‰¤`.\n", "used_premises": [4], "def_path": "Mathlib/Init/Order/Defs.lean", "pos": [175, 177], "informalization": "Class `PartialOrder` represents a type with a reflexive, transitive, and antisymmetric binary relation `â‰¤`, where `a â‰¤ b âˆ§ b â‰¤ a â†’ a = b`."}
{"full_name": "Preorder", "url": "Mathlib/Init/Order/Defs.html#Preorder", "code_src": "mathlib4", "ptype": "class", "header": "class Preorder (Î± : Type u) extends LEğŸ”—<|PREMISE|>ğŸ”— , LTğŸ”—<|PREMISE|>ğŸ”— :Type u\n | le : Î± â†’ Î± â†’ Prop \n | lt : Î± â†’ Î± â†’ Prop \n | le_refl : âˆ€ (a : Î±), a â‰¤  a\n | le_trans : âˆ€ (a b c : Î±), a â‰¤  b â†’ b â‰¤  c â†’ a â‰¤  c\n | lt_iff_le_not_le : âˆ€ (a b : Î±), a <  b â†”  a â‰¤  b âˆ§  Â¬ b â‰¤  a", "code": "class Preorder (Î± : Type u) extends LE Î±, LT Î± where\n  le_refl : âˆ€ a : Î±, a â‰¤ a\n  le_trans : âˆ€ a b c : Î±, a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c\n  lt := fun a b => a â‰¤ b âˆ§ Â¬b â‰¤ a\n  lt_iff_le_not_le : âˆ€ a b : Î±, a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a := by intros; rfl\n", "additional_info": "A preorder is a reflexive, transitive relation `â‰¤` with `a < b` defined in the obvious way.\n", "used_premises": [5, 6], "def_path": "Mathlib/Init/Order/Defs.lean", "pos": [30, 35], "informalization": "Class `Preorder` represents a type with a reflexive and transitive binary relation `â‰¤`, and defines `a < b` as `a â‰¤ b âˆ§ Â¬b â‰¤ a`."}
{"full_name": "LE", "url": "Init/Prelude.html#LE", "code_src": "lean4", "ptype": "class", "header": "class LE (Î± : Type u) :Type u\n | le : Î± â†’ Î± â†’ Prop ", "code": "class LE (Î± : Type u) where\n  /-- The less-equal relation: `x â‰¤ y` -/\n  le : Î± â†’ Î± â†’ Prop\n", "additional_info": "`ğŸ—ŸLEğŸ—ŸğŸ”—.././Init/Prelude.html#LEğŸ”—  Î±` is the typeclass which supports the notation `x â‰¤ y` where `x y : Î±`.\n- LE.le: The less-equal relation: `x â‰¤ y`\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1099, 1102], "informalization": "Class `LE` represents the concept of a less-equal relation, which is a binary relation that defines an ordering on elements of a type `Î±`."}
{"full_name": "LT", "url": "Init/Prelude.html#LT", "code_src": "lean4", "ptype": "class", "header": "class LT (Î± : Type u) :Type u\n | lt : Î± â†’ Î± â†’ Prop ", "code": "class LT (Î± : Type u) where\n  /-- The less-than relation: `x < y` -/\n  lt : Î± â†’ Î± â†’ Prop\n", "additional_info": "`ğŸ—ŸLTğŸ—ŸğŸ”—.././Init/Prelude.html#LTğŸ”—  Î±` is the typeclass which supports the notation `x < y` where `x y : Î±`.\n- LT.lt: The less-than relation: `x < y`\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1104, 1107], "informalization": "Class `LT` represents the concept of a less-than relation on a type `Î±`, defining a binary predicate `lt` that determines whether one element is less than another."}
{"full_name": "Min", "url": "Init/Prelude.html#Min", "code_src": "lean4", "ptype": "class", "header": "class Min (Î± : Type u) :Type u\n | min : Î± â†’ Î± â†’ Î±", "code": "class Min (Î± : Type u) where\n  /-- The minimum operation: `min x y`. -/\n  min : Î± â†’ Î± â†’ Î±\n", "additional_info": "`ğŸ—ŸMinğŸ—ŸğŸ”—.././Init/Prelude.html#MinğŸ”—  Î±` is the typeclass which supports the operation `ğŸ—ŸminğŸ—ŸğŸ”—.././Init/Prelude.html#Min.minğŸ”—  x y` where `x y : Î±`.\n- Min.min: The minimum operation: `ğŸ—ŸminğŸ—ŸğŸ”—.././Init/Prelude.html#Min.minğŸ”—  x y`.\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1127, 1130], "informalization": "Class `Min` represents the concept of a binary minimum operation on a type `Î±`, which returns the lesser of two elements."}
{"full_name": "Max", "url": "Init/Prelude.html#Max", "code_src": "lean4", "ptype": "class", "header": "class Max (Î± : Type u) :Type u\n | max : Î± â†’ Î± â†’ Î±", "code": "class Max (Î± : Type u) where\n  /-- The maximum operation: `max x y`. -/\n  max : Î± â†’ Î± â†’ Î±\n", "additional_info": "`ğŸ—ŸMaxğŸ—ŸğŸ”—.././Init/Prelude.html#MaxğŸ”—  Î±` is the typeclass which supports the operation `ğŸ—ŸmaxğŸ—ŸğŸ”—.././Init/Prelude.html#Max.maxğŸ”—  x y` where `x y : Î±`.\n- Max.max: The maximum operation: `ğŸ—ŸmaxğŸ—ŸğŸ”—.././Init/Prelude.html#Max.maxğŸ”—  x y`.\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1114, 1117], "informalization": "Class `Max` represents the concept of a maximum operation, which is a binary operation that returns the greater of two elements of a type `Î±`."}
{"full_name": "Ord", "url": "Init/Data/Ord.html#Ord", "code_src": "lean4", "ptype": "class", "header": "class Ord (Î± : Type u) :Type u\n | compare : Î± â†’ Î± â†’ OrderingğŸ”—<|PREMISE|>ğŸ”— ", "code": "class Ord (Î± : Type u) where\n  compare : Î± â†’ Î± â†’ Ordering\n", "additional_info": "", "used_premises": [10], "def_path": "Init/Data/Ord.lean", "pos": [103, 105], "informalization": "Class `Ord` represents the concept of a total ordering for a type `Î±`, providing a function `compare` that returns the `Ordering` of two elements."}
{"full_name": "Ordering", "url": "Init/Data/Ord.html#Ordering", "code_src": "lean4", "ptype": "inductive", "header": "inductive Ordering :Type", "code": "inductive Ordering where\n  | lt | eq | gt\nderiving Inhabited, BEq\n", "additional_info": "", "used_premises": [], "def_path": "Init/Data/Ord.lean", "pos": [10, 13], "informalization": "Type `Ordering` represents the result of a comparison operation, indicating whether one element is less than (`lt`), equal to (`eq`), or greater than (`gt`) another."}
{"full_name": "DecidableRel", "url": "Init/Prelude.html#DecidableRel", "code_src": "lean4", "ptype": "abbrev", "header": "@[inline, reducible]abbrev DecidableRel {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop ) :Sort (max 1 u)", "code": "abbrev DecidableRel {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) :=\n  (a b : Î±) â†’ Decidable (r a b)\n", "additional_info": "A decidable relation. See `ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—` .\nEquations\n* ğŸ—ŸDecidableRelğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableRelğŸ”—  r ğŸ—Ÿ=ğŸ—ŸğŸ”—.././Init/Prelude.html#EqğŸ”—  ((a b : Î±) â†’ ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—  (r a b))\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [855, 857], "informalization": "`DecidableRel` is an abbreviation for a type of binary relations on a type `Î±` that can be decided, meaning for any pair `(a, b)` in `Î±`, it can be determined whether the relation `r a b` holds or not."}
{"full_name": "DecidableEq", "url": "Init/Prelude.html#DecidableEq", "code_src": "lean4", "ptype": "abbrev", "header": "@[inline, reducible]abbrev DecidableEq (Î± : Sort u) :Sort (max 1 u)", "code": "abbrev DecidableEq (Î± : Sort u) :=\n  (a b : Î±) â†’ Decidable (Eq a b)\n", "additional_info": "Asserts that `Î±` has decidable equality, that is, `a = b` is decidable\nfor all `a b : Î±`. See `ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—` .\nEquations\n* ğŸ—ŸDecidableEqğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableEqğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—.././Init/Prelude.html#EqğŸ”—  ((a b : Î±) â†’ ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—  (a ğŸ—Ÿ=ğŸ—ŸğŸ”—.././Init/Prelude.html#EqğŸ”—  b))\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [862, 864], "informalization": "`DecidableEq` is a type class that provides a decision procedure for equality on a type `Î±`, meaning it can determine whether any two elements of `Î±` are equal or not."}
{"full_name": "compareOfLessAndEq", "url": "Init/Data/Ord.html#compareOfLessAndEq", "code_src": "lean4", "ptype": "def", "header": "@[inline]def compareOfLessAndEq {Î± : Type u_1} (x : Î±) (y : Î±) [LTğŸ”—<|PREMISE|>ğŸ”— Î±] [DecidableğŸ”—<|PREMISE|>ğŸ”— (x < y)] [DecidableEqğŸ”—<|PREMISE|>ğŸ”— Î±] :OrderingğŸ”—<|PREMISE|>ğŸ”—", "code": "@[inline] def compareOfLessAndEq {Î±} (x y : Î±) [LT Î±] [Decidable (x < y)] [DecidableEq Î±] : Ordering :=\n  if x < y then Ordering.lt\n  else if x = y then Ordering.eq\n  else Ordering.gt\n", "additional_info": "Equations\n* ğŸ—ŸcompareOfLessAndEqğŸ—ŸğŸ”—../.././Init/Data/Ord.html#compareOfLessAndEqğŸ”—  x y ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  if x ğŸ—Ÿ<ğŸ—ŸğŸ”—../.././Init/Prelude.html#LT.ltğŸ”—  y then ğŸ—ŸOrdering.ltğŸ—ŸğŸ”—../.././Init/Data/Ord.html#Ordering.ltğŸ”—  else if x ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  y then ğŸ—ŸOrdering.eqğŸ—ŸğŸ”—../.././Init/Data/Ord.html#Ordering.eqğŸ”—  else ğŸ—ŸOrdering.gtğŸ—ŸğŸ”—../.././Init/Data/Ord.html#Ordering.gtğŸ”—\n\n", "used_premises": [6, 14, 12, 10], "def_path": "Init/Data/Ord.lean", "pos": [90, 94], "informalization": "Function `compareOfLessAndEq` performs a comparison between two elements `x` and `y` of a type `Î±` by checking if `x` is less than `y`, equal to `y`, or greater than `y`, returning the corresponding `Ordering` value."}
{"full_name": "Decidable", "url": "Init/Prelude.html#Decidable", "code_src": "lean4", "ptype": "class inductive", "header": "class inductive Decidable (p : Prop ) :Type", "code": "class inductive Decidable (p : Prop) where\n  /-- Prove that `p` is decidable by supplying a proof of `Â¬p` -/\n  | isFalse (h : Not p) : Decidable p\n  /-- Prove that `p` is decidable by supplying a proof of `p` -/\n  | isTrue (h : p) : Decidable p\n", "additional_info": "`ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—  p` is a data-carrying class that supplies a proof that `p` is\neither `ğŸ—ŸtrueğŸ—ŸğŸ”—.././Init/Prelude.html#Bool.trueğŸ”—`  or `ğŸ—ŸfalseğŸ—ŸğŸ”—.././Init/Prelude.html#Bool.falseğŸ”—` . It is equivalent to `ğŸ—ŸBoolğŸ—ŸğŸ”—.././Init/Prelude.html#BoolğŸ”—`  (and in fact it has the\nsame code generation as `ğŸ—ŸBoolğŸ—ŸğŸ”—.././Init/Prelude.html#BoolğŸ”—` ) together with a proof that the `ğŸ—ŸBoolğŸ—ŸğŸ”—.././Init/Prelude.html#BoolğŸ”—`  is\ntrue iff `p` is.\n`ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—`  instances are used to infer \"computation strategies\" for\npropositions, so that you can have the convenience of writing propositions\ninside `if` statements and executing them (which actually executes the inferred\ndecidability instance instead of the proposition, which has no code).\nIf a proposition `p` is `ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—` , then `(by ğŸ—ŸdecideğŸ—ŸğŸ”—.././Init/Prelude.html#Decidable.decideğŸ”—  : p)` will prove it by\nevaluating the decidability instance to `ğŸ—ŸisTrueğŸ—ŸğŸ”—.././Init/Prelude.html#Decidable.isTrueğŸ”—  h` and returning `h`.\nBecause `ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—`  carries data,\nwhen writing `@[simp]` lemmas which include a `ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—`  instance on the LHS,\nit is best to use `{_ : ğŸ—ŸDecidableğŸ—ŸğŸ”—.././Init/Prelude.html#DecidableğŸ”—  p}` rather than `[Decidable p]`\nso that non-canonical instances can be found via unification rather than\ntypeclass search.\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [833, 838], "informalization": "Class `Decidable` represents the concept of a proposition being decidable, meaning it can be determined to be either true or false, providing a way to include propositions in computations and proofs."}
{"full_name": "IsWellOrder", "url": "Mathlib/Order/RelClasses.html#IsWellOrder", "code_src": "mathlib4", "ptype": "class", "header": "class IsWellOrder (Î± : Type u) (r : Î± â†’ Î± â†’ Prop ) extends IsTrichotomousğŸ”—<|PREMISE|>ğŸ”— , IsTransğŸ”—<|PREMISE|>ğŸ”— , IsWellFoundedğŸ”—<|PREMISE|>ğŸ”— :Prop", "code": "class IsWellOrder (Î± : Type u) (r : Î± â†’ Î± â†’ Prop) extends\n  IsTrichotomous Î± r, IsTrans Î± r, IsWellFounded Î± r : Prop\n", "additional_info": "A well order is a well-founded linear order.\n", "used_premises": [16, 17, 18], "def_path": "Mathlib/Order/RelClasses.lean", "pos": [378, 380], "informalization": "A well order is a well-founded linear order."}
{"full_name": "IsTrichotomous", "url": "Mathlib/Init/Algebra/Classes.html#IsTrichotomous", "code_src": "mathlib4", "ptype": "class", "header": "class IsTrichotomous (Î± : Sort u) (lt : Î± â†’ Î± â†’ Prop ) :Prop\n | trichotomous : âˆ€ (a b : Î±), lt a b âˆ¨  a =  b âˆ¨  lt b a", "code": "class IsTrichotomous (Î± : Sort u) (lt : Î± â†’ Î± â†’ Prop) : Prop where\n  trichotomous : âˆ€ a b, lt a b âˆ¨ a = b âˆ¨ lt b a\n", "additional_info": "`ğŸ—ŸIsTrichotomousğŸ—ŸğŸ”—../../.././Mathlib/Init/Algebra/Classes.html#IsTrichotomousğŸ”—  X lt` means that the binary relation `lt` on `X` is trichotomous, that is,\neither `lt a b` or `a = b` or `lt b a` for any `a` and `b`.\n", "used_premises": [], "def_path": "Mathlib/Init/Algebra/Classes.lean", "pos": [263, 265], "informalization": "Class `IsTrichotomous` represents the concept of a trichotomous binary relation `lt` on a type `Î±`, meaning that for any two elements `a` and `b` of `Î±`, exactly one of the following holds: `lt a b`, `a = b`, or `lt b a`."}
{"full_name": "IsTrans", "url": "Mathlib/Init/Algebra/Classes.html#IsTrans", "code_src": "mathlib4", "ptype": "class", "header": "class IsTrans (Î± : Sort u) (r : Î± â†’ Î± â†’ Prop ) :Prop\n | trans : âˆ€ (a b c : Î±), r a b â†’ r b c â†’ r a c", "code": "class IsTrans (Î± : Sort u) (r : Î± â†’ Î± â†’ Prop) : Prop where\n  trans : âˆ€ a b c, r a b â†’ r b c â†’ r a c\n", "additional_info": "`ğŸ—ŸIsTransğŸ—ŸğŸ”—../../.././Mathlib/Init/Algebra/Classes.html#IsTransğŸ”—  X r` means the binary relation `r` on `X` is transitive.\n", "used_premises": [], "def_path": "Mathlib/Init/Algebra/Classes.lean", "pos": [192, 194], "informalization": "Class `IsTrans` represents the concept of a transitive binary relation `r` on a type `Î±`, meaning if `r a b` and `r b c` hold, then `r a c` must also hold."}
{"full_name": "IsWellFounded", "url": "Mathlib/Order/RelClasses.html#IsWellFounded", "code_src": "mathlib4", "ptype": "class", "header": "class IsWellFounded (Î± : Type u) (r : Î± â†’ Î± â†’ Prop ) :Prop\n | wf : WellFoundedğŸ”—<|PREMISE|>ğŸ”—  r", "code": "@[mk_iff] class IsWellFounded (Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop where\n  /-- The relation is `WellFounded`, as a proposition. -/\n  wf : WellFounded r\n", "additional_info": "A well-founded relation. Not to be confused with `ğŸ—ŸIsWellOrderğŸ—ŸğŸ”—../.././Mathlib/Order/RelClasses.html#IsWellOrderğŸ”—` .\n- IsWellFounded.wf: The relation is `ğŸ—ŸWellFoundedğŸ—ŸğŸ”—../.././Init/WF.html#WellFoundedğŸ”—` , as a proposition.\n\n\n", "used_premises": [19], "def_path": "Mathlib/Order/RelClasses.lean", "pos": [274, 277], "informalization": "A well-founded relation. Not to be confused with `IsWellOrder`."}
{"full_name": "WellFounded", "url": "Init/WF.html#WellFounded", "code_src": "lean4", "ptype": "inductive", "header": "inductive WellFounded {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop ) :Prop", "code": "inductive WellFounded {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) : Prop where\n  | intro (h : âˆ€ a, Acc r a) : WellFounded r\n", "additional_info": "", "used_premises": [], "def_path": "Init/WF.lean", "pos": [33, 35], "informalization": "Type `WellFounded` represents a well-founded relation on a type `Î±`, which means that every non-empty subset of `Î±` has a minimal element with respect to the relation `r`."}
{"full_name": "Zero", "url": "Mathlib/Init/ZeroOne.html#Zero", "code_src": "mathlib4", "ptype": "class", "header": "class Zero (Î± : Type u) :Type u\n | zero : Î±", "code": "class Zero.{u} (Î± : Type u) where\n  zero : Î±\n", "additional_info": "", "used_premises": [], "def_path": "Mathlib/Init/ZeroOne.lean", "pos": [12, 14], "informalization": "Class `Zero` represents the concept of a zero element."}
{"full_name": "SuccOrder", "url": "Mathlib/Order/SuccPred/Basic.html#SuccOrder", "code_src": "mathlib4", "ptype": "class", "header": "class SuccOrder (Î± : Type u_3) [PreorderğŸ”—<|PREMISE|>ğŸ”— Î±] :Type u_3\n | succ : Î± â†’ Î±\n | le_succ : âˆ€ (a : Î±), a â‰¤  SuccOrder.succğŸ”—<|PREMISE|>ğŸ”—  a\n | max_of_succ_le : âˆ€ {a : Î±}, SuccOrder.succğŸ”—<|PREMISE|>ğŸ”—  a â‰¤  a â†’ IsMaxğŸ”—<|PREMISE|>ğŸ”—  a\n | succ_le_of_lt : âˆ€ {a b : Î±}, a <  b â†’ SuccOrder.succğŸ”—<|PREMISE|>ğŸ”—  a â‰¤  b\n | le_of_lt_succ : âˆ€ {a b : Î±}, a <  SuccOrder.succğŸ”—<|PREMISE|>ğŸ”—  b â†’ a â‰¤  b", "code": "class SuccOrder (Î± : Type*) [Preorder Î±] where\n  /--Successor function-/\n  succ : Î± â†’ Î±\n  /--Proof of basic ordering with respect to `succ`-/\n  le_succ : âˆ€ a, a â‰¤ succ a\n  /--Proof of interaction between `succ` and maximal element-/\n  max_of_succ_le {a} : succ a â‰¤ a â†’ IsMax a\n  /--Proof that `succ` satisfies ordering invariants between `LT` and `LE`-/\n  succ_le_of_lt {a b} : a < b â†’ succ a â‰¤ b\n  /--Proof that `succ` satisfies ordering invariants between `LE` and `LT`-/\n  le_of_lt_succ {a b} : a < succ b â†’ a â‰¤ b\n", "additional_info": "Order equipped with a sensible successor function.\n- SuccOrder.succ: Successor function\n\n\n- SuccOrder.le_succ: Proof of basic ordering with respect to `ğŸ—ŸsuccğŸ—ŸğŸ”—../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succğŸ”—` \n\n\n- SuccOrder.max_of_succ_le: Proof of interaction between `ğŸ—ŸsuccğŸ—ŸğŸ”—../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succğŸ”—`  and maximal element\n\n\n- SuccOrder.succ_le_of_lt: Proof that `ğŸ—ŸsuccğŸ—ŸğŸ”—../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succğŸ”—`  satisfies ordering invariants between `ğŸ—ŸLTğŸ—ŸğŸ”—../../.././Init/Prelude.html#LTğŸ”—`  and `ğŸ—ŸLEğŸ—ŸğŸ”—../../.././Init/Prelude.html#LEğŸ”—` \n\n\n- SuccOrder.le_of_lt_succ: Proof that `ğŸ—ŸsuccğŸ—ŸğŸ”—../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succğŸ”—`  satisfies ordering invariants between `ğŸ—ŸLEğŸ—ŸğŸ”—../../.././Init/Prelude.html#LEğŸ”—`  and `ğŸ—ŸLTğŸ—ŸğŸ”—../../.././Init/Prelude.html#LTğŸ”—` \n\n\n", "used_premises": [4, 22, 22, 23, 22, 22], "def_path": "Mathlib/Order/SuccPred/Basic.lean", "pos": [62, 73], "informalization": "Class `SuccOrder` represents an order equipped with a sensible successor function, where the successor of an element `a` is the smallest element greater than `a`. It includes axioms that ensure the successor function correctly interacts with the order relation and that the successor of a non-maximal element is always greater than the element itself."}
{"full_name": "SuccOrder.succ", "url": "Mathlib/Order/SuccPred/Basic.html#SuccOrder", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field SuccOrderğŸ”—<|PREMISE|>ğŸ”—.succ : Î± â†’ Î±", "code": "class SuccOrder (Î± : Type*) [Preorder Î±] where\n  /--Successor function-/\n  succ : Î± â†’ Î±\n  /--Proof of basic ordering with respect to `succ`-/\n  le_succ : âˆ€ a, a â‰¤ succ a\n  /--Proof of interaction between `succ` and maximal element-/\n  max_of_succ_le {a} : succ a â‰¤ a â†’ IsMax a\n  /--Proof that `succ` satisfies ordering invariants between `LT` and `LE`-/\n  succ_le_of_lt {a b} : a < b â†’ succ a â‰¤ b\n  /--Proof that `succ` satisfies ordering invariants between `LE` and `LT`-/\n  le_of_lt_succ {a b} : a < succ b â†’ a â‰¤ b\n", "additional_info": "Successor function\n\n", "used_premises": [21], "def_path": "Mathlib/Order/SuccPred/Basic.lean", "pos": [62, 73], "informalization": "Function `SuccOrder.succ` is a part of the `SuccOrder` class, which represents an order equipped with a successor function. The successor of an element `a` is the smallest element greater than `a`. The class includes axioms that ensure the successor function correctly interacts with the order relation and that the successor of a non-maximal element is always greater than the element itself."}
{"full_name": "IsMax", "url": "Mathlib/Order/Max.html#IsMax", "code_src": "mathlib4", "ptype": "def", "header": "def IsMax {Î± : Type u_1} [LEğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) :Prop", "code": "def IsMax (a : Î±) : Prop :=\n  âˆ€ â¦ƒbâ¦„, a â‰¤ b â†’ b â‰¤ a\n", "additional_info": "`a` is a maximal element of `Î±` if no element is strictly greater than it. We spell it without\n`<` to avoid having to convert between `â‰¤` and `<`. Instead, `ğŸ—ŸisMax_iff_forall_not_ltğŸ—ŸğŸ”—../.././Mathlib/Order/Max.html#isMax_iff_forall_not_ltğŸ”—`  does the\nconversion.\nEquations\n* ğŸ—ŸIsMaxğŸ—ŸğŸ”—../.././Mathlib/Order/Max.html#IsMaxğŸ”—  a ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒb : Î±â¦„, a ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../.././Init/Prelude.html#LE.leğŸ”—  b â†’ b ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../.././Init/Prelude.html#LE.leğŸ”—  a\n\n", "used_premises": [5], "def_path": "Mathlib/Order/Max.lean", "pos": [208, 210], "informalization": "Function `IsMax` checks if an element `a` of a preordered type `Î±` is a maximal element, meaning there is no element strictly greater than `a`."}
{"full_name": "Ordinal.IsLimit", "url": "Mathlib/SetTheory/Ordinal/Arithmetic.html#Ordinal.IsLimit", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal.IsLimit (o : OrdinalğŸ”—<|PREMISE|>ğŸ”— ) :Prop", "code": "def IsLimit (o : Ordinal) : Prop :=\n  o â‰  0 âˆ§ âˆ€ a < o, succ a < o\n", "additional_info": "A limit ordinal is an ordinal which is not zero and not a successor.\nEquations\n* ğŸ—ŸOrdinal.IsLimitğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Arithmetic.html#Ordinal.IsLimitğŸ”—  o ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (o ğŸ—Ÿâ‰ ğŸ—ŸğŸ”—../../.././Init/Core.html#NeğŸ”—  0 ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  âˆ€ a < o, ğŸ—ŸOrder.succğŸ—ŸğŸ”—../../.././Mathlib/Order/SuccPred/Basic.html#Order.succğŸ”—  a ğŸ—Ÿ<ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LT.ltğŸ”—  o)\n\n", "used_premises": [25], "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "pos": [237, 239], "informalization": "Function `Ordinal.IsLimit` checks if an ordinal is a limit ordinal, meaning it is neither zero nor a successor of another ordinal."}
{"full_name": "Ordinal", "url": "Mathlib/SetTheory/Ordinal/Basic.html#Ordinal", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal :Type (u + 1)", "code": "def Ordinal : Type (u + 1) :=\n  Quotient Ordinal.isEquivalent\n", "additional_info": "`Ordinal.{u}` is the type of well orders in `Type u`, up to order isomorphism.\nEquations\n* ğŸ—ŸOrdinal.{u}ğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#OrdinalğŸ”—  ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸQuotientğŸ—ŸğŸ”—../../.././Init/Core.html#QuotientğŸ”—  ğŸ—ŸOrdinal.isEquivalentğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.isEquivalentğŸ”—\n\n", "used_premises": [], "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "pos": [151, 153], "informalization": "`Ordinal.{u}` is the type of well orders in `Type u`, up to order isomorphism."}
{"full_name": "Ordinal.type", "url": "Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.type", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal.type {Î± : Type u} (r : Î± â†’ Î± â†’ Prop ) [wo : IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± r] :OrdinalğŸ”—<|PREMISE|>ğŸ”—", "code": "def type (r : Î± â†’ Î± â†’ Prop) [wo : IsWellOrder Î± r] : Ordinal :=\n  âŸ¦âŸ¨Î±, r, woâŸ©âŸ§\n", "additional_info": "The order type of a well order is an ordinal.\nEquations\n* ğŸ—ŸOrdinal.typeğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typeğŸ”—  r ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âŸ¦{ Î± := Î±, r := r, wo := wo }âŸ§\n\n", "used_premises": [15, 25], "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "pos": [172, 174], "informalization": "Function `Ordinal.type` constructs an ordinal from a well order `r` on a type `Î±`."}
{"full_name": "Cardinal.ord", "url": "Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.ord (c : CardinalğŸ”—<|PREMISE|>ğŸ”— ) :OrdinalğŸ”—<|PREMISE|>ğŸ”—", "code": "def ord (c : Cardinal) : Ordinal :=\n  let F := fun Î± : Type u => â¨… r : { r // IsWellOrder Î± r }, @type Î± r.1 r.2\n  Quot.liftOn c F\n    (by\n      suffices âˆ€ {Î± Î²}, Î± â‰ˆ Î² â†’ F Î± â‰¤ F Î² from\n        fun Î± Î² h => (this h).antisymm (this (Setoid.symm h))\n      rintro Î± Î² âŸ¨fâŸ©\n      refine' le_ciInf_iff'.2 fun i => _\n      haveI := @RelEmbedding.isWellOrder _ _ (f â»Â¹'o i.1) _ (â†‘(RelIso.preimage f i.1)) i.2\n      exact\n        (ciInf_le' _\n              (Subtype.mk (f â»Â¹'o i.val)\n                (@RelEmbedding.isWellOrder _ _ _ _ (â†‘(RelIso.preimage f i.1)) i.2))).trans_eq\n          (Quot.sound âŸ¨RelIso.preimage f i.1âŸ©))\n", "additional_info": "The ordinal corresponding to a cardinal `c` is the least ordinal\nwhose cardinal is `c`. For the order-embedding version, see `ord.order_embedding`.\nEquations\n* ğŸ—ŸCardinal.ordğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ordğŸ”—  c ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  let F := fun (Î± : ğŸ—ŸTypeğŸ—ŸğŸ”—../../.././foundational_types.htmlğŸ”—  u) => â¨… (r : { r : Î± â†’ Î± â†’ ğŸ—ŸPropğŸ—ŸğŸ”—../../.././foundational_types.htmlğŸ”—  // ğŸ—ŸIsWellOrderğŸ—ŸğŸ”—../../.././Mathlib/Order/RelClasses.html#IsWellOrderğŸ”—  Î± r }), ğŸ—ŸOrdinal.typeğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typeğŸ”—  â†‘r;\n ğŸ—ŸQuot.liftOnğŸ—ŸğŸ”—../../.././Init/Core.html#Quot.liftOnğŸ”—  c F ğŸ—ŸCardinal.ord.proof_2ğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord.proof_2ğŸ”—\n\n", "used_premises": [28, 25], "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "pos": [1307, 1321], "informalization": "Function `Cardinal.ord` maps a cardinal number `c` to the smallest ordinal number whose cardinality is `c`."}
{"full_name": "Cardinal", "url": "Mathlib/SetTheory/Cardinal/Basic.html#Cardinal", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal :Type (u + 1)", "code": "def Cardinal : Type (u + 1) :=\n  Quotient Cardinal.isEquivalent\n", "additional_info": "`Cardinal.{u}` is the type of cardinal numbers in `Type u`,\ndefined as the quotient of `Type u` by existence of an equivalence\n(a bijection with explicit inverse).\nEquations\n* ğŸ—ŸCardinal.{u}ğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Basic.html#CardinalğŸ”—  ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸQuotientğŸ—ŸğŸ”—../../.././Init/Core.html#QuotientğŸ”—  ğŸ—ŸCardinal.isEquivalentğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.isEquivalentğŸ”—\n\n", "used_premises": [], "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "pos": [106, 108], "informalization": "`Cardinal.{u}` is the type of cardinal numbers in `Type u`, defined as the quotient of `Type u` by existence of an equivalence (a bijection with explicit inverse)."}
{"full_name": "Cardinal.mk", "url": "Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.mk :Type u â†’ CardinalğŸ”—<|PREMISE|>ğŸ”—", "code": "def mk : Type u â†’ Cardinal :=\n  Quotient.mk'\n", "additional_info": "The cardinal number of a type\nEquations\n* ğŸ—ŸCardinal.mkğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mkğŸ”—  ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  Quotient.mk'\n\n", "used_premises": [28], "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "pos": [113, 115], "informalization": "Function `Cardinal.mk` maps a given type to its corresponding cardinal number, which is an equivalence class of types under the equivalence relation of having the same number of elements."}
{"full_name": "Cardinal.IsRegular", "url": "Mathlib/SetTheory/Cardinal/Cofinality.html#Cardinal.IsRegular", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.IsRegular (c : CardinalğŸ”—<|PREMISE|>ğŸ”— ) :Prop", "code": "def IsRegular (c : Cardinal) : Prop :=\n  â„µâ‚€ â‰¤ c âˆ§ c â‰¤ c.ord.cof\n", "additional_info": "A cardinal is regular if it is infinite and it equals its own cofinality.\nEquations\n* ğŸ—ŸCardinal.IsRegularğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Cardinal.IsRegularğŸ”—  c ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸCardinal.aleph0ğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0ğŸ”—  ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LE.leğŸ”—  c ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  c ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LE.leğŸ”—  ğŸ—ŸOrdinal.cofğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Ordinal.cofğŸ”—  (ğŸ—ŸCardinal.ordğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ordğŸ”—  c))\n\n", "used_premises": [28], "def_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "pos": [943, 945], "informalization": "Function `Cardinal.IsRegular` is a predicate that checks if a given cardinal number `c` is regular, meaning it is infinite and equals its own cofinality."}
{"full_name": "AddMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddMonoid (M : Type u) extends AddSemigroupğŸ”—<|PREMISE|>ğŸ”— , ZeroğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : M â†’ M â†’ M\n | add_assoc : âˆ€ (a b c : M), a +  b +  c =  a +  (b +  c)\n | zero : M\n | zero_add : âˆ€ (a : M), 0 +  a =  a\n | add_zero : âˆ€ (a : M), a +  0 =  a\n | nsmul : â„•  â†’ M â†’ M\n | nsmul_zero : âˆ€ (x : M), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : M), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x", "code": "class AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  /-- Multiplication by a natural number. -/\n  protected nsmul : â„• â†’ M â†’ M := nsmulRec\n  /-- Multiplication by `(0 : â„•)` gives `0`. -/\n  protected nsmul_zero : âˆ€ x, nsmul 0 x = 0 := by intros; rfl\n  /-- Multiplication by `(n + 1 : â„•)` behaves as expected. -/\n  protected nsmul_succ : âˆ€ (n : â„•) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl\n", "additional_info": "An `ğŸ—ŸAddMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddMonoidğŸ”—`  is an `ğŸ—ŸAddSemigroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddSemigroupğŸ”—`  with an element `0` such that `0 + a = a + 0 = a`.\n- AddMonoid.zero_add: Zero is a left neutral element for addition\n\n\n- AddMonoid.add_zero: Zero is a right neutral element for addition\n\n\n- AddMonoid.nsmul: Multiplication by a natural number.\n\n\n- AddMonoid.nsmul_zero: Multiplication by `(0 : â„•)` gives `0`.\n\n\n- AddMonoid.nsmul_succ: Multiplication by `(n + 1 : â„•)` behaves as expected.\n\n\n", "used_premises": [32, 20, 34, 34, 34], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [594, 601], "informalization": "Class `AddMonoid` represents the concept of an additive monoid. An additive monoid is a type with an associative addition operation, a zero element, and a natural number multiplication operation. The zero element satisfies the properties of being a left and right neutral element for addition, meaning adding zero to any element does not change it. Multiplying by zero results in the zero element, and multiplying by `n + 1` is equivalent to adding the element to its multiplication by `n`."}
{"full_name": "AddSemigroup", "url": "Mathlib/Algebra/Group/Defs.html#AddSemigroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddSemigroup (G : Type u) extends AddğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : G â†’ G â†’ G\n | add_assoc : âˆ€ (a b c : G), a +  b +  c =  a +  (b +  c)", "code": "class AddSemigroup (G : Type u) extends Add G where\n  /-- Addition is associative -/\n  protected add_assoc : âˆ€ a b c : G, a + b + c = a + (b + c)\n", "additional_info": "An additive semigroup is a type with an associative `(+)`.\n- AddSemigroup.add_assoc: Addition is associative\n\n\n", "used_premises": [33], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [271, 274], "informalization": "Class `AddSemigroup` represents the concept of an additive semigroup. It can perform associative addition."}
{"full_name": "Add", "url": "Init/Prelude.html#Add", "code_src": "lean4", "ptype": "class", "header": "class Add (Î± : Type u) :Type u\n | add : Î± â†’ Î± â†’ Î±", "code": "class Add (Î± : Type u) where\n  /-- `a + b` computes the sum of `a` and `b`. See `HAdd`. -/\n  add : Î± â†’ Î± â†’ Î±\n", "additional_info": "The homogeneous version of `ğŸ—ŸHAddğŸ—ŸğŸ”—.././Init/Prelude.html#HAddğŸ”—` : `a + b : Î±` where `a b : Î±`.\n- Add.add: `a + b` computes the sum of `a` and `b`. See `ğŸ—ŸHAddğŸ—ŸğŸ”—.././Init/Prelude.html#HAddğŸ”—` .\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1289, 1292], "informalization": "Class `Add` represents the concept of addition."}
{"full_name": "AddMonoid.nsmul", "url": "Mathlib/Algebra/Group/Defs.html#AddMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field AddMonoidğŸ”—<|PREMISE|>ğŸ”—.nsmul : â„•  â†’ M â†’ M", "code": "class AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  /-- Multiplication by a natural number. -/\n  protected nsmul : â„• â†’ M â†’ M := nsmulRec\n  /-- Multiplication by `(0 : â„•)` gives `0`. -/\n  protected nsmul_zero : âˆ€ x, nsmul 0 x = 0 := by intros; rfl\n  /-- Multiplication by `(n + 1 : â„•)` behaves as expected. -/\n  protected nsmul_succ : âˆ€ (n : â„•) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl\n", "additional_info": "Multiplication by a natural number.\n\n", "used_premises": [31], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [594, 601], "informalization": "Function `AddMonoid.nsmul` takes a natural number and an element from an additive monoid, and returns the result of their multiplication."}
{"full_name": "Sub", "url": "Init/Prelude.html#Sub", "code_src": "lean4", "ptype": "class", "header": "class Sub (Î± : Type u) :Type u\n | sub : Î± â†’ Î± â†’ Î±", "code": "class Sub (Î± : Type u) where\n  /-- `a - b` computes the difference of `a` and `b`. See `HSub`. -/\n  sub : Î± â†’ Î± â†’ Î±\n", "additional_info": "The homogeneous version of `ğŸ—ŸHSubğŸ—ŸğŸ”—.././Init/Prelude.html#HSubğŸ”—` : `a - b : Î±` where `a b : Î±`.\n- Sub.sub: `a - b` computes the difference of `a` and `b`. See `ğŸ—ŸHSubğŸ—ŸğŸ”—.././Init/Prelude.html#HSubğŸ”—` .\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1294, 1297], "informalization": "Class `Sub` represents the concept of subtraction, which is a binary operation that computes the difference between two elements of the same type. This operation is defined for homogeneous types, meaning both operands and the result are of the same type. The comment suggests that this class is related to a more general concept of subtraction (`HSub`), which might handle heterogeneous types or more complex scenarios."}
{"full_name": "Ordinal.typein", "url": "Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typein", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal.typein {Î± : Type u} (r : Î± â†’ Î± â†’ Prop ) [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± r] (a : Î±) :OrdinalğŸ”—<|PREMISE|>ğŸ”—", "code": "def typein (r : Î± â†’ Î± â†’ Prop) [IsWellOrder Î± r] (a : Î±) : Ordinal :=\n  type (Subrel r { b | r b a })\n", "additional_info": "The order type of an element inside a well order. For the embedding as a principal segment, see\n`ğŸ—Ÿtypein.principalSegğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typein.principalSegğŸ”—` .\nEquations\n* ğŸ—ŸOrdinal.typeinğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typeinğŸ”—  r a ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸOrdinal.typeğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typeğŸ”—  (ğŸ—ŸSubrelğŸ—ŸğŸ”—../../.././Mathlib/Order/RelIso/Set.html#SubrelğŸ”—  r {b : Î± | r b a})\n\n", "used_premises": [15, 25], "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "pos": [187, 189], "informalization": "Function `Ordinal.typein` computes the order type of an element `a` within a well-ordered type `Î±`, using the relation `r` to determine the order."}
{"full_name": "Cardinal.IsStrongLimit", "url": "Mathlib/SetTheory/Cardinal/Cofinality.html#Cardinal.IsStrongLimit", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.IsStrongLimit (c : CardinalğŸ”—<|PREMISE|>ğŸ”— ) :Prop", "code": "def IsStrongLimit (c : Cardinal) : Prop :=\n  c â‰  0 âˆ§ âˆ€ x < c, (2^x) < c\n", "additional_info": "A cardinal is a strong limit if it is not zero and it is\nclosed under powersets. Note that `â„µâ‚€` is a strong limit by this definition.\nEquations\n* ğŸ—ŸCardinal.IsStrongLimitğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Cardinal.IsStrongLimitğŸ”—  c ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (c ğŸ—Ÿâ‰ ğŸ—ŸğŸ”—../../.././Init/Core.html#NeğŸ”—  0 ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  âˆ€ x < c, 2 ğŸ—Ÿ^ğŸ—ŸğŸ”—../../.././Init/Prelude.html#HPow.hPowğŸ”—  x ğŸ—Ÿ<ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LT.ltğŸ”—  c)\n\n", "used_premises": [28], "def_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "pos": [853, 855], "informalization": "Function `Cardinal.IsStrongLimit` checks if a given cardinal number `c` is a strong limit. A cardinal is a strong limit if it is not zero and for any cardinal `x` less than `c`, the power set of `x` (denoted as `2^x`) is also less than `c`."}
{"full_name": "Ordinal.cof", "url": "Mathlib/SetTheory/Cardinal/Cofinality.html#Ordinal.cof", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal.cof (o : OrdinalğŸ”—<|PREMISE|>ğŸ”— ) :CardinalğŸ”—<|PREMISE|>ğŸ”—", "code": "def cof (o : Ordinal.{u}) : Cardinal.{u} :=\n  o.liftOn (fun a => StrictOrder.cof a.r)\n    (by\n      rintro âŸ¨Î±, r, woâ‚âŸ© âŸ¨Î², s, woâ‚‚âŸ© âŸ¨âŸ¨f, hfâŸ©âŸ©\n      haveI := woâ‚; haveI := woâ‚‚\n      dsimp only\n      apply @RelIso.cof_eq _ _ _ _ ?_ ?_\n      Â· constructor\n        exact @fun a b => not_iff_not.2 hf\n      Â· dsimp only [swap]\n        exact âŸ¨fun _ => irrefl _âŸ©\n      Â· dsimp only [swap]\n        exact âŸ¨fun _ => irrefl _âŸ©)\n", "additional_info": "Cofinality of an ordinal. This is the smallest cardinal of a\nsubset `S` of the ordinal which is unbounded, in the sense\n`âˆ€ a, âˆƒ b âˆˆ S, a â‰¤ b`. It is defined for all ordinals, but\n`ğŸ—ŸcofğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Order.cofğŸ”—  0 = 0` and `ğŸ—ŸcofğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Order.cofğŸ”—  (succ o) = 1`, so it is only really\ninteresting on limit ordinals (when it is an infinite cardinal).\nEquations\n* ğŸ—ŸOrdinal.cofğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Ordinal.cofğŸ”—  o ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸQuotient.liftOnğŸ—ŸğŸ”—../../.././Init/Core.html#Quotient.liftOnğŸ”—  o (fun (a : ğŸ—ŸWellOrderğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Ordinal/Basic.html#WellOrderğŸ”— ) => ğŸ—ŸStrictOrder.cofğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#StrictOrder.cofğŸ”—  a.r) ğŸ—ŸOrdinal.cof.proof_1ğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Ordinal.cof.proof_1ğŸ”—\n\n", "used_premises": [25, 28], "def_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "pos": [140, 153], "informalization": "Function `Ordinal.cof` computes the cofinality of an ordinal, which is the smallest cardinality of a subset of the ordinal that is unbounded in the sense that every element of the ordinal is less than or equal to some element in the subset."}
{"full_name": "ConNF.TangleData", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.TangleData", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.TangleData [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Type (u + 1)\n | Tangle : Type  u\n | Allowable : Type  u\n | allowableGroup : GroupğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Allowable  Î±)\n | allowableToStructPerm : ConNF.Allowable  Î± â†’*  ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”—  Î±\n | allowableAction : MulActionğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Allowable  Î±) (ConNF.Tangle  Î±)\n | support : ConNF.Tangle  Î± â†’ ConNF.SupportğŸ”—<|PREMISE|>ğŸ”—  Î±\n | support_supports : âˆ€ (t : ConNF.Tangle  Î±),\n MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Allowable  Î±) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”—  (ConNF.TangleData.supportğŸ”—<|PREMISE|>ğŸ”—  t).enum) t", "code": "class TangleData (Î± : TypeIndex) where\n  /-- The type of tangles that we assume were constructed at stage `Î±`.\n  Later in the recursion, we will construct this type explicitly, but for now, we will just assume\n  that it exists. -/\n  (Tangle : Type u)\n  /-- The type of allowable permutations that we assume exists on `Î±`-tangles. -/\n  (Allowable : Type u)\n  [allowableGroup : Group Allowable]\n  allowableToStructPerm : Allowable â†’* StructPerm Î±\n  [allowableAction : MulAction Allowable Tangle]\n  support : Tangle â†’ Support Î±\n  support_supports (t : Tangle) :\n    haveI : MulAction Allowable (Address Î±) :=\n      MulAction.compHom _ allowableToStructPerm\n    MulAction.Supports Allowable (support t : Set (Address Î±)) t\n", "additional_info": "Data about the model elements at level `Î±`. This class asserts the existence of a type of\ntangles at level `Î±`, and a group of allowable permutations at level `Î±` that act on the\n`Î±`-tangles. We also stipulate that each tangle has a prescribed small support, called its\ndesignated support.\n- ConNF.TangleData.Tangle: The type of tangles that we assume were constructed at stage `Î±`.\nLater in the recursion, we will construct this type explicitly, but for now, we will just assume\nthat it exists.\n\n\n- ConNF.TangleData.Allowable: The type of allowable permutations that we assume exists on `Î±`-tangles.\n\n\n", "used_premises": [1, 40, 55, 56, 58, 68, 70, 71], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [33, 48], "informalization": "Class `ConNF.TangleData` represents data about the model elements at level `Î±` in the context of Constructive Ordinal Notation (ConNF). It asserts the existence of a type of tangles at level `Î±`, and a group of allowable permutations at level `Î±` that act on the `Î±`-tangles. Additionally, it stipulates that each tangle has a designated small support."}
{"full_name": "Group", "url": "Mathlib/Algebra/Group/Defs.html#Group", "code_src": "mathlib4", "ptype": "class", "header": "class Group (G : Type u) extends DivInvMonoidğŸ”—<|PREMISE|>ğŸ”— :Type u\n | mul : G â†’ G â†’ G\n | mul_assoc : âˆ€ (a b c : G), a *  b *  c =  a *  (b *  c)\n | one : G\n | one_mul : âˆ€ (a : G), 1 *  a =  a\n | mul_one : âˆ€ (a : G), a *  1 =  a\n | npow : â„•  â†’ G â†’ G\n | npow_zero : âˆ€ (x : G), Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  0 x =  1\n | npow_succ : âˆ€ (n : â„• ) (x : G), Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x *  Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  n x\n | inv : G â†’ G\n | div : G â†’ G â†’ G\n | div_eq_mul_inv : âˆ€ (a b : G), a /  b =  a *  bâ»Â¹ \n | zpow : â„¤  â†’ G â†’ G\n | zpow_zero' : âˆ€ (a : G), DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  0 a =  1\n | zpow_succ' : âˆ€ (n : â„• ) (a : G), DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  (Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a =  a *  DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  n) a\n | zpow_neg' : âˆ€ (n : â„• ) (a : G), DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  (Int.negSuccğŸ”—<|PREMISE|>ğŸ”—  n) a =  (DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  (â†‘(Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a)â»Â¹ \n | mul_left_inv : âˆ€ (a : G), aâ»Â¹  *  a =  1", "code": "class Group (G : Type u) extends DivInvMonoid G where\n  protected mul_left_inv : âˆ€ a : G, aâ»Â¹ * a = 1\n", "additional_info": "A `ğŸ—ŸGroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#GroupğŸ”—`  is a `ğŸ—ŸMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#MonoidğŸ”—`  with an operation `â»Â¹` satisfying `aâ»Â¹ * a = 1`.\nThere is also a division operation `/` such that `a / b = a * bâ»Â¹`,\nwith a default so that `a / b = a * bâ»Â¹` holds by definition.\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minumum proof obligations.\n", "used_premises": [41, 46, 46, 46, 49, 49, 50, 53, 49, 50, 49, 54, 49, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1111, 1113], "informalization": "Class `Group` represents a monoid with an additional inverse operation satisfying `aâ»Â¹ * a = 1`, forming a fundamental algebraic structure with associative multiplication, identity element, and inverses."}
{"full_name": "DivInvMonoid", "url": "Mathlib/Algebra/Group/Defs.html#DivInvMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class DivInvMonoid (G : Type u) extends MonoidğŸ”—<|PREMISE|>ğŸ”— , InvğŸ”—<|PREMISE|>ğŸ”— , DivğŸ”—<|PREMISE|>ğŸ”— :Type u\n | mul : G â†’ G â†’ G\n | mul_assoc : âˆ€ (a b c : G), a *  b *  c =  a *  (b *  c)\n | one : G\n | one_mul : âˆ€ (a : G), 1 *  a =  a\n | mul_one : âˆ€ (a : G), a *  1 =  a\n | npow : â„•  â†’ G â†’ G\n | npow_zero : âˆ€ (x : G), Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  0 x =  1\n | npow_succ : âˆ€ (n : â„• ) (x : G), Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x *  Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  n x\n | inv : G â†’ G\n | div : G â†’ G â†’ G\n | div_eq_mul_inv : âˆ€ (a b : G), a /  b =  a *  bâ»Â¹ \n | zpow : â„¤  â†’ G â†’ G\n | zpow_zero' : âˆ€ (a : G), DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  0 a =  1\n | zpow_succ' : âˆ€ (n : â„• ) (a : G), DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  (Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a =  a *  DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  n) a\n | zpow_neg' : âˆ€ (n : â„• ) (a : G), DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  (Int.negSuccğŸ”—<|PREMISE|>ğŸ”—  n) a =  (DivInvMonoid.zpowğŸ”—<|PREMISE|>ğŸ”—  (â†‘(Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a)â»Â¹ ", "code": "class DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  /-- `a / b := a * bâ»Â¹` -/\n  protected div_eq_mul_inv : âˆ€ a b : G, a / b = a * bâ»Â¹ := by intros; rfl\n  /-- The power operation: `a ^ n = a * Â·Â·Â· * a`; `a ^ (-n) = aâ»Â¹ * Â·Â·Â· aâ»Â¹` (`n` times) -/\n  protected zpow : â„¤ â†’ G â†’ G := zpowRec\n  /-- `a ^ 0 = 1` -/\n  protected zpow_zero' : âˆ€ a : G, zpow 0 a = 1 := by intros; rfl\n  /-- `a ^ (n + 1) = a * a ^ n` -/\n  protected zpow_succ' (n : â„•) (a : G) : zpow (Int.ofNat n.succ) a = a * zpow (Int.ofNat n) a := by\n    intros; rfl\n  /-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\n  protected zpow_neg' (n : â„•) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)â»Â¹ := by intros; rfl\n", "additional_info": "A `ğŸ—ŸDivInvMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#DivInvMonoidğŸ”—`  is a `ğŸ—ŸMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#MonoidğŸ”—`  with operations `/` and `â»Â¹` satisfying\n`ğŸ—Ÿdiv_eq_mul_invğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#div_eq_mul_invğŸ”—  : âˆ€ a b, a / b = a * bâ»Â¹`.\nThis deduplicates the name `ğŸ—Ÿdiv_eq_mul_invğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#div_eq_mul_invğŸ”—` .\nThe default for `div` is such that `a / b = a * bâ»Â¹` holds by definition.\nAdding `div` as a field rather than defining `a / b := a * bâ»Â¹` allows us to\navoid certain classes of unification failures, for example:\nLet `Foo X` be a type with a `âˆ€ X, ğŸ—ŸDivğŸ—ŸğŸ”—../../.././Init/Prelude.html#DivğŸ”—  (Foo X)` instance but no\n`âˆ€ X, ğŸ—ŸInvğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#InvğŸ”—  (Foo X)`, e.g. when `Foo X` is a `EuclideanDomain`. Suppose we\nalso have an instance `âˆ€ X [Cromulent X], GroupWithZero (Foo X)`. Then the\n`(/)` coming from `GroupWithZero.div` cannot be definitionally equal to\nthe `(/)` coming from `Foo.ğŸ—ŸDivğŸ—ŸğŸ”—../../.././Init/Prelude.html#DivğŸ”—` .\nIn the same way, adding a `ğŸ—ŸzpowğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#DivInvMonoid.zpowğŸ”—`  field makes it possible to avoid definitional failures\nin diamonds. See the definition of `ğŸ—ŸMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#MonoidğŸ”—`  and Note [forgetful inheritance] for more\nexplanations on this.\n- DivInvMonoid.div_eq_mul_inv: `a / b := a * bâ»Â¹`\n\n\n- DivInvMonoid.zpow: The power operation: `a ^ n = a * Â·Â·Â· * a`; `a ^ (-n) = aâ»Â¹ * Â·Â·Â· aâ»Â¹` (`n` times)\n\n\n- DivInvMonoid.zpow_zero': `a ^ 0 = 1`\n\n\n- DivInvMonoid.zpow_succ': `a ^ (n + 1) = a * a ^ n`\n\n\n- DivInvMonoid.zpow_neg': `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹`\n\n\n", "used_premises": [42, 47, 48, 46, 46, 46, 49, 49, 50, 53, 49, 50, 49, 54, 49, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [875, 888], "informalization": "Class `DivInvMonoid` represents the concept of a monoid with additional operations: inversion (`Inv`) and division (`Div`). It extends a monoid by including the unary operation of inversion and the binary operation of division, defined in terms of multiplication and inversion, and introduces integer power operations (`zpow`), extending natural number powers to include negative integers."}
{"full_name": "Monoid", "url": "Mathlib/Algebra/Group/Defs.html#Monoid", "code_src": "mathlib4", "ptype": "class", "header": "class Monoid (M : Type u) extends SemigroupğŸ”—<|PREMISE|>ğŸ”— , OneğŸ”—<|PREMISE|>ğŸ”— :Type u\n | mul : M â†’ M â†’ M\n | mul_assoc : âˆ€ (a b c : M), a *  b *  c =  a *  (b *  c)\n | one : M\n | one_mul : âˆ€ (a : M), 1 *  a =  a\n | mul_one : âˆ€ (a : M), a *  1 =  a\n | npow : â„•  â†’ M â†’ M\n | npow_zero : âˆ€ (x : M), Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  0 x =  1\n | npow_succ : âˆ€ (n : â„• ) (x : M), Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x *  Monoid.npowğŸ”—<|PREMISE|>ğŸ”—  n x", "code": "class Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  /-- Raising to the power of a natural number. -/\n  protected npow : â„• â†’ M â†’ M := npowRec\n  /-- Raising to the power `(0 : â„•)` gives `1`. -/\n  protected npow_zero : âˆ€ x, npow 0 x = 1 := by intros; rfl\n  /-- Raising to the power `(n + 1 : â„•)` behaves as expected. -/\n  protected npow_succ : âˆ€ (n : â„•) (x), npow (n + 1) x = x * npow n x := by intros; rfl\n", "additional_info": "A `ğŸ—ŸMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#MonoidğŸ”—`  is a `ğŸ—ŸSemigroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#SemigroupğŸ”—`  with an element `1` such that `1 * a = a * 1 = a`.\n- Monoid.one_mul: One is a left neutral element for multiplication\n\n\n- Monoid.mul_one: One is a right neutral element for multiplication\n\n\n- Monoid.npow: Raising to the power of a natural number.\n\n\n- Monoid.npow_zero: Raising to the power `(0 : â„•)` gives `1`.\n\n\n- Monoid.npow_succ: Raising to the power `(n + 1 : â„•)` behaves as expected.\n\n\n", "used_premises": [43, 45, 46, 46, 46], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [611, 618], "informalization": "Class `Monoid` represents the concept of a monoid, which is an algebraic structure that extends a semigroup by adding a multiplicative identity element. A monoid is defined on a type `M` and includes a binary operation `mul` (often thought of as multiplication) that is associative, and an element `one` (often denoted as `1`) that acts as a neutral element for multiplication. This means that for any element `a` in `M`, the identity element `1` satisfies `1 * a = a` and `a * 1 = a`. Additionally, a monoid includes a method `npow` for raising elements to natural number powers, which is defined recursively such that `npow 0 x = 1` for any `x` in `M`, and `npow (n + 1) x = x * npow n x`. This power operation captures the repeated application of the monoid's multiplication, providing a way to express iterated multiplication succinctly. Monoids are fundamental in abstract algebra and computer science, serving as the basis for more complex algebraic structures and as models for various computational processes involving composition and aggregation."}
{"full_name": "Semigroup", "url": "Mathlib/Algebra/Group/Defs.html#Semigroup", "code_src": "mathlib4", "ptype": "class", "header": "class Semigroup (G : Type u) extends MulğŸ”—<|PREMISE|>ğŸ”— :Type u\n | mul : G â†’ G â†’ G\n | mul_assoc : âˆ€ (a b c : G), a *  b *  c =  a *  (b *  c)", "code": "class Semigroup (G : Type u) extends Mul G where\n  /-- Multiplication is associative -/\n  protected mul_assoc : âˆ€ a b c : G, a * b * c = a * (b * c)\n", "additional_info": "A semigroup is a type with an associative `(*)`.\n- Semigroup.mul_assoc: Multiplication is associative\n\n\n", "used_premises": [44], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [262, 265], "informalization": "Class `Semigroup` represents the concept of a semigroup, which is a type `G` equipped with a binary operation `mul` (often thought of as multiplication) that is associative. This means that for any elements `a`, `b`, and `c` in `G`, the operation satisfies the property `(a * b) * c = a * (b * c)`. Semigroups are a fundamental algebraic structure in abstract algebra, providing a basis for more complex structures like monoids and groups by ensuring that the operation is well-behaved under composition."}
{"full_name": "Mul", "url": "Init/Prelude.html#Mul", "code_src": "lean4", "ptype": "class", "header": "class Mul (Î± : Type u) :Type u\n | mul : Î± â†’ Î± â†’ Î±", "code": "class Mul (Î± : Type u) where\n  /-- `a * b` computes the product of `a` and `b`. See `HMul`. -/\n  mul : Î± â†’ Î± â†’ Î±\n", "additional_info": "The homogeneous version of `ğŸ—ŸHMulğŸ—ŸğŸ”—.././Init/Prelude.html#HMulğŸ”—` : `a * b : Î±` where `a b : Î±`.\n- Mul.mul: `a * b` computes the product of `a` and `b`. See `ğŸ—ŸHMulğŸ—ŸğŸ”—.././Init/Prelude.html#HMulğŸ”—` .\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1299, 1302], "informalization": "Class `Mul` represents the concept of multiplication."}
{"full_name": "One", "url": "Mathlib/Init/ZeroOne.html#One", "code_src": "mathlib4", "ptype": "class", "header": "class One (Î± : Type u) :Type u\n | one : Î±", "code": "class One (Î± : Type u) where\n  one : Î±\n", "additional_info": "", "used_premises": [], "def_path": "Mathlib/Init/ZeroOne.lean", "pos": [24, 26], "informalization": "Class `One` represents the concept of a multiplicative identity element, often denoted as `1`."}
{"full_name": "Monoid.npow", "url": "Mathlib/Algebra/Group/Defs.html#Monoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field MonoidğŸ”—<|PREMISE|>ğŸ”—.npow : â„•  â†’ M â†’ M", "code": "class Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  /-- Raising to the power of a natural number. -/\n  protected npow : â„• â†’ M â†’ M := npowRec\n  /-- Raising to the power `(0 : â„•)` gives `1`. -/\n  protected npow_zero : âˆ€ x, npow 0 x = 1 := by intros; rfl\n  /-- Raising to the power `(n + 1 : â„•)` behaves as expected. -/\n  protected npow_succ : âˆ€ (n : â„•) (x), npow (n + 1) x = x * npow n x := by intros; rfl\n", "additional_info": "Raising to the power of a natural number.\n\n", "used_premises": [42], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [611, 618], "informalization": "Function `Monoid.npow` takes a natural number and an element from a monoid, returning the result of raising the element to that natural number power, essential for iterated multiplication in monoids."}
{"full_name": "Inv", "url": "Mathlib/Algebra/Group/Defs.html#Inv", "code_src": "mathlib4", "ptype": "class", "header": "class Inv (Î± : Type u) :Type u\n | inv : Î± â†’ Î±", "code": "class Inv (Î± : Type u) where\n  /-- Invert an element of Î±. -/\n  inv : Î± â†’ Î±\n", "additional_info": "Class of types that have an inversion operation.\n- Inv.inv: Invert an element of Î±.\n\n\n", "used_premises": [], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [162, 165], "informalization": "Class `Inv` represents the concept of an inversion operation, which is a unary operation that maps an element of a type `Î±` to another element of `Î±`. This operation is denoted by `inv` and is intended to represent the inverse of an element in the context of the type `Î±`. The specific interpretation of \"inverse\" can vary depending on the type and the algebraic structure it possesses. For example, in the context of a group, the inverse of an element `a` is an element `b` such that `a * b = b * a = 1`, where `1` is the identity element of the group and `*` is the group operation. In other contexts, such as rings or fields, the inverse might refer to the additive inverse (negation) or the multiplicative inverse (reciprocal), depending on the operation associated with the `Inv` class. This class provides a uniform way to define and work with inversion operations across different mathematical structures."}
{"full_name": "Div", "url": "Init/Prelude.html#Div", "code_src": "lean4", "ptype": "class", "header": "class Div (Î± : Type u) :Type u\n | div : Î± â†’ Î± â†’ Î±", "code": "class Div (Î± : Type u) where\n  /-- `a / b` computes the result of dividing `a` by `b`. See `HDiv`. -/\n  div : Î± â†’ Î± â†’ Î±\n", "additional_info": "The homogeneous version of `ğŸ—ŸHDivğŸ—ŸğŸ”—.././Init/Prelude.html#HDivğŸ”—` : `a / b : Î±` where `a b : Î±`.\n- Div.div: `a / b` computes the result of dividing `a` by `b`. See `ğŸ—ŸHDivğŸ—ŸğŸ”—.././Init/Prelude.html#HDivğŸ”—` .\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1313, 1316], "informalization": "Class `Div` represents the concept of division, which is a binary operation that computes the quotient of two elements of the same type. This operation is defined for homogeneous types, meaning both operands and the result are of the same type. The comment suggests that this class is related to a more general concept of division (`HDiv`), which might handle heterogeneous types or more complex scenarios."}
{"full_name": "DivInvMonoid.zpow", "url": "Mathlib/Algebra/Group/Defs.html#DivInvMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field DivInvMonoidğŸ”—<|PREMISE|>ğŸ”—.zpow : â„¤  â†’ G â†’ G", "code": "class DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  /-- `a / b := a * bâ»Â¹` -/\n  protected div_eq_mul_inv : âˆ€ a b : G, a / b = a * bâ»Â¹ := by intros; rfl\n  /-- The power operation: `a ^ n = a * Â·Â·Â· * a`; `a ^ (-n) = aâ»Â¹ * Â·Â·Â· aâ»Â¹` (`n` times) -/\n  protected zpow : â„¤ â†’ G â†’ G := zpowRec\n  /-- `a ^ 0 = 1` -/\n  protected zpow_zero' : âˆ€ a : G, zpow 0 a = 1 := by intros; rfl\n  /-- `a ^ (n + 1) = a * a ^ n` -/\n  protected zpow_succ' (n : â„•) (a : G) : zpow (Int.ofNat n.succ) a = a * zpow (Int.ofNat n) a := by\n    intros; rfl\n  /-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\n  protected zpow_neg' (n : â„•) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)â»Â¹ := by intros; rfl\n", "additional_info": "The power operation: `a ^ n = a * Â·Â·Â· * a`; `a ^ (-n) = aâ»Â¹ * Â·Â·Â· aâ»Â¹` (`n` times)\n\n", "used_premises": [41], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [875, 888], "informalization": "Function `DivInvMonoid.zpow` takes an integer and an element from a monoid with division and inversion, returning the result of raising the element to the power of the integer, handling both positive and negative exponents."}
{"full_name": "Int.ofNat", "url": "Init/Data/Int/Basic.html#Int", "code_src": "lean4", "ptype": "constructor", "header": "constructor IntğŸ”—<|PREMISE|>ğŸ”—.ofNat: NatğŸ”—<|PREMISE|>ğŸ”—  â†’ IntğŸ”—<|PREMISE|>ğŸ”—", "code": "inductive Int : Type where\n  /-- A natural number is an integer (`0` to `âˆ`). -/\n  | ofNat   : Nat â†’ Int\n  /-- The negation of the successor of a natural number is an integer\n    (`-1` to `-âˆ`). -/\n  | negSucc : Nat â†’ Int\n", "additional_info": "A natural number is an integer (`0` to `âˆ`).\n\n", "used_premises": [51, 52, 51], "def_path": "Init/Data/Int/Basic.lean", "pos": [39, 45], "informalization": "Constructor `Int.ofNat` is a method within the `Int` inductive type that constructs an integer from a natural number. Specifically, if `n` is a natural number, `Int.ofNat n` represents the integer `n`. This constructor is used to include natural numbers within the set of integers."}
{"full_name": "Int", "url": "Init/Data/Int/Basic.html#Int", "code_src": "lean4", "ptype": "inductive", "header": "inductive Int :Type", "code": "inductive Int : Type where\n  /-- A natural number is an integer (`0` to `âˆ`). -/\n  | ofNat   : Nat â†’ Int\n  /-- The negation of the successor of a natural number is an integer\n    (`-1` to `-âˆ`). -/\n  | negSucc : Nat â†’ Int\n", "additional_info": "The type of integers. It is defined as an inductive type based on the\nnatural number type `ğŸ—ŸNatğŸ—ŸğŸ”—../../.././Init/Prelude.html#NatğŸ”—`  featuring two constructors: \"a natural\nnumber is an integer\", and \"the negation of a successor of a natural\nnumber is an integer\". The former represents integers between `0`\n(inclusive) and `âˆ`, and the latter integers between `-âˆ` and `-1`\n(inclusive).\nThis type is special-cased by the compiler. The runtime has a special\nrepresentation for `ğŸ—ŸIntğŸ—ŸğŸ”—../../.././Init/Data/Int/Basic.html#IntğŸ”—`  which stores \"small\" signed numbers directly,\nand larger numbers use an arbitrary precision \"bignum\" library\n(usually ğŸ—ŸGMPğŸ—ŸğŸ”—https://gmplib.org/ğŸ”— ). A \"small number\" is an integer\nthat can be encoded with 63 bits (31 bits on 32-bits architectures).\n", "used_premises": [], "def_path": "Init/Data/Int/Basic.lean", "pos": [39, 45], "informalization": "Type `Int` represents the integers, which include both natural numbers (0, 1, 2, ...) and their negative counterparts (-1, -2, -3, ...)."}
{"full_name": "Nat", "url": "Init/Prelude.html#Nat", "code_src": "lean4", "ptype": "inductive", "header": "inductive Nat :Type", "code": "inductive Nat where\n  /-- `Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\n  This is one of the two constructors of `Nat`. -/\n  | zero : Nat\n  /-- The successor function on natural numbers, `succ n = n + 1`.\n  This is one of the two constructors of `Nat`. -/\n  | succ (n : Nat) : Nat\n", "additional_info": "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\nYou can prove a theorem `P n` about `n : ğŸ—ŸNatğŸ—ŸğŸ”—.././Init/Prelude.html#NatğŸ”—`  by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\nopen ğŸ—ŸNatğŸ—ŸğŸ”—.././Init/Prelude.html#NatğŸ”— \nexample (n : Nat) : n < ğŸ—ŸsuccğŸ—ŸğŸ”—.././Init/Prelude.html#Nat.succğŸ”—  n := by\n  induction n with\n  | ğŸ—ŸzeroğŸ—ŸğŸ”—.././Init/Prelude.html#Nat.zeroğŸ”—  =>\n    show 0 < 1\n    ğŸ—ŸdecideğŸ—ŸğŸ”—.././Init/Prelude.html#Decidable.decideğŸ”— \n  | ğŸ—ŸsuccğŸ—ŸğŸ”—.././Init/Prelude.html#Nat.succğŸ”—  i ih => -- ih : i < ğŸ—ŸsuccğŸ—ŸğŸ”—.././Init/Prelude.html#Nat.succğŸ”—  i\n    show ğŸ—ŸsuccğŸ—ŸğŸ”—.././Init/Prelude.html#Nat.succğŸ”—  i < ğŸ—ŸsuccğŸ—ŸğŸ”—.././Init/Prelude.html#Nat.succğŸ”—  (succ i)\n    exact ğŸ—ŸNat.succ_lt_succğŸ—ŸğŸ”—.././Init/Data/Nat/Basic.html#Nat.succ_lt_succğŸ”—  ih\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`ğŸ—ŸNatğŸ—ŸğŸ”—.././Init/Prelude.html#NatğŸ”—`  literals\" as a primitive constructor,\nand the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\nlinked list with `n` links, which is horribly inefficient. Instead, the\nruntime itself has a special representation for `ğŸ—ŸNatğŸ—ŸğŸ”—.././Init/Prelude.html#NatğŸ”—`  which stores numbers up\nto 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\nlibrary (usually ğŸ—ŸGMPğŸ—ŸğŸ”—https://gmplib.org/ğŸ”— ).\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1064, 1071], "informalization": "Type `Nat` represents the natural numbers by Peano axioms. It provides a way to represent both the smallest natural number, `0`, and any other natural number through the successor function."}
{"full_name": "Nat.succ", "url": "Init/Prelude.html#Nat", "code_src": "lean4", "ptype": "constructor", "header": "constructor NatğŸ”—<|PREMISE|>ğŸ”—.succ: NatğŸ”—<|PREMISE|>ğŸ”—  â†’ NatğŸ”—<|PREMISE|>ğŸ”—", "code": "inductive Nat where\n  /-- `Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\n  This is one of the two constructors of `Nat`. -/\n  | zero : Nat\n  /-- The successor function on natural numbers, `succ n = n + 1`.\n  This is one of the two constructors of `Nat`. -/\n  | succ (n : Nat) : Nat\n", "additional_info": "The successor function on natural numbers, `ğŸ—ŸsuccğŸ—ŸğŸ”—.././Init/Prelude.html#Nat.succğŸ”—  n = n + 1`.\nThis is one of the two constructors of `ğŸ—ŸNatğŸ—ŸğŸ”—.././Init/Prelude.html#NatğŸ”—` .\n\n", "used_premises": [52, 52, 52], "def_path": "Init/Prelude.lean", "pos": [1064, 1071], "informalization": "Constructor `Nat.succ` is a method within the `Nat` inductive type that represents the successor function on natural numbers. This function takes a natural number `n` and returns its successor, which is `n + 1`."}
{"full_name": "Int.negSucc", "url": "Init/Data/Int/Basic.html#Int", "code_src": "lean4", "ptype": "constructor", "header": "constructor IntğŸ”—<|PREMISE|>ğŸ”—.negSucc: NatğŸ”—<|PREMISE|>ğŸ”—  â†’ IntğŸ”—<|PREMISE|>ğŸ”—", "code": "inductive Int : Type where\n  /-- A natural number is an integer (`0` to `âˆ`). -/\n  | ofNat   : Nat â†’ Int\n  /-- The negation of the successor of a natural number is an integer\n    (`-1` to `-âˆ`). -/\n  | negSucc : Nat â†’ Int\n", "additional_info": "The negation of the successor of a natural number is an integer\n(`-1` to `-âˆ`).\n\n", "used_premises": [51, 52, 51], "def_path": "Init/Data/Int/Basic.lean", "pos": [39, 45], "informalization": "Constructor `Int.negSucc` is a method within the `Int` inductive type that constructs an integer from a natural number by representing the negation of the successor of that natural number. Specifically, if `n` is a natural number, `Int.negSucc n` represents the integer `-(n + 1)`. This constructor is used to generate the negative integers starting from `-1` and going down to `-âˆ`."}
{"full_name": "ConNF.StructPerm", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm", "code_src": "con-nf", "ptype": "abbrev", "header": "@[inline, reducible]abbrev ConNF.StructPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :ConNF.TypeIndex â†’ Type u", "code": "abbrev StructPerm : TypeIndex â†’ Type u :=\n  Tree NearLitterPerm\n", "additional_info": "A *structural permutation* on a proper type index `Î±` is a near-litter permutation for\neach `Î±`-extended index. This represents how the permutation acts along each path down the type\nlevels in the model. Note that we define structural permutations as trees of near-litter\npermutations.\nEquations\n* ConNF.StructPerm ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.TreeğŸ—ŸğŸ”—../.././ConNF/Structural/Tree.html#ConNF.TreeğŸ”—  ConNF.NearLitterPerm\n\n", "used_premises": [1], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [33, 35], "informalization": "A *structural permutation* on a proper type index `Î±` is a near-litter permutation for each `Î±`-extended index. This represents how the permutation acts along each path down the type levels in the model. Note that we define structural permutations as trees of near-litter permutations."}
{"full_name": "MulAction", "url": "Mathlib/GroupTheory/GroupAction/Defs.html#MulAction", "code_src": "mathlib4", "ptype": "class", "header": "class MulAction (Î± : Type u_10) (Î² : Type u_11) [MonoidğŸ”—<|PREMISE|>ğŸ”— Î±] extends SMulğŸ”—<|PREMISE|>ğŸ”— :Type (max u_10 u_11)\n | smul : Î± â†’ Î² â†’ Î²\n | one_smul : âˆ€ (b : Î²), 1 â€¢  b =  b\n | mul_smul : âˆ€ (x y : Î±) (b : Î²), (x *  y) â€¢  b =  x â€¢  y â€¢  b", "code": "class MulAction (Î± : Type*) (Î² : Type*) [Monoid Î±] extends SMul Î± Î² where\n  /-- One is the neutral element for `â€¢` -/\n  protected one_smul : âˆ€ b : Î², (1 : Î±) â€¢ b = b\n  /-- Associativity of `â€¢` and `*` -/\n  mul_smul : âˆ€ (x y : Î±) (b : Î²), (x * y) â€¢ b = x â€¢ y â€¢ b\n", "additional_info": "Typeclass for multiplicative actions by monoids. This generalizes group actions.\n- MulAction.one_smul: One is the neutral element for `â€¢`\n\n\n- MulAction.mul_smul: Associativity of `â€¢` and `*`\n\n\n", "used_premises": [42, 57], "def_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "pos": [107, 112], "informalization": "Class `MulAction` represents the concept of a multiplicative action of a monoid `Î±` on a type `Î²`, where the action is associative with the monoid's multiplication and the identity element of the monoid acts as a neutral element for the action."}
{"full_name": "SMul", "url": "Mathlib/Algebra/Group/Defs.html#SMul", "code_src": "mathlib4", "ptype": "class", "header": "class SMul (M : Type u) (Î± : Type v) :Type (max u v)\n | smul : M â†’ Î± â†’ Î±", "code": "class SMul (M : Type u) (Î± : Type v) where\n  /-- `a â€¢ b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\n  but it is intended to be used for left actions. -/\n  smul : M â†’ Î± â†’ Î±\n", "additional_info": "Typeclass for types with a scalar multiplication operation, denoted `â€¢` (`\\bu`)\n- SMul.smul: `a â€¢ b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions.\n\n\n", "used_premises": [], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [98, 102], "informalization": "Class `SMul` represents the concept of scalar multiplication, which is a binary operation between elements of a type `M` (the scalar) and elements of another type `Î±` (the target), resulting in an element of `Î±`. This operation is denoted by `â€¢` (read as \"smul\") and is intended to be used for left actions, meaning the scalar `a` acts on the element `b` from the left. The specific interpretation of this operation can vary depending on the types involved, but it is commonly used in contexts such as vector spaces, where it represents the multiplication of a vector by a scalar. This class provides a uniform way to define and work with scalar multiplication across different mathematical structures."}
{"full_name": "ConNF.Support", "url": "ConNF/Structural/Support.html#ConNF.Support", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Support [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Type u\n | enum : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”—  (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”—  Î±)\n | mem_of_mem_symmDiff' : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  Î±) (Nâ‚ Nâ‚‚ : ConNF.NearLitter) (a : ConNF.Atom),\n Nâ‚.fst =  Nâ‚‚.fst â†’\n a âˆˆ  symmDiffğŸ”—<|PREMISE|>ğŸ”—  â†‘Nâ‚ â†‘Nâ‚‚ â†’\n { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  Nâ‚ } âˆˆ  self.enum â†’\n { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  Nâ‚‚ } âˆˆ  self.enum â†’ { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } âˆˆ  self.enum", "code": "structure Support (Î± : TypeIndex) where\n  enum : Enumeration (Address Î±)\n  mem_of_mem_symmDiff' (A : ExtendedIndex Î±) (Nâ‚ Nâ‚‚ : NearLitter) (a : Atom) :\n    Nâ‚.1 = Nâ‚‚.1 â†’ a âˆˆ (Nâ‚ : Set Atom) âˆ† Nâ‚‚ â†’\n    âŸ¨A, inr Nâ‚âŸ© âˆˆ enum â†’ âŸ¨A, inr Nâ‚‚âŸ© âˆˆ enum â†’ âŸ¨A, inl aâŸ© âˆˆ enum\n", "additional_info": "A *support* is a function from an initial segment of Îº to the type of addresses,\nsuch that if `Nâ‚, Nâ‚‚` are near-litters near the same litter, any atoms in their symmetric difference\nare included in the enumeration.\n", "used_premises": [1, 59, 60, 61, 62, 65, 65, 67], "def_path": "ConNF/Structural/Support.lean", "pos": [121, 126], "informalization": "Structure `ConNF.Support` represents a function from an initial segment of `Îº` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.Enumeration", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Enumeration [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : Type u_1) :Type (max u u_1)\n | max : ConNF.Îº\n | f : (i : ConNF.Îº) â†’ i <  self.max â†’ Î±", "code": "structure Enumeration (Î± : Type _) where\n  max : Îº\n  f : (i : Îº) â†’ i < max â†’ Î±\n", "additional_info": "An *`Î±`-enumeration* is a function from an initial segment of Îº to `Î±`.\n", "used_premises": [1], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [16, 19], "informalization": "An `Î±`-enumeration is a function from an initial segment of `Îº` to `Î±`."}
{"full_name": "ConNF.Address", "url": "ConNF/Structural/Support.html#ConNF.Address", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Address [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Type u\n | path : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  Î±\n | value : ConNF.Atom âŠ•  ConNF.NearLitter", "code": "structure Address (Î± : TypeIndex) : Type u\n    where\n  path : ExtendedIndex Î±\n  value : Atom âŠ• NearLitter\n", "additional_info": "A *address* is an extended type index together with an atom or a near-litter.\nThis represents an object in the base type (the atom or near-litter) together with the path\ndetailing how we descend from type `Î±` to type `âŠ¥` by looking at elements of elements and so on\nin the model.\n", "used_premises": [1, 61], "def_path": "ConNF/Structural/Support.lean", "pos": [31, 35], "informalization": "Structure `ConNF.Address` represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `Î±` to type `âŠ¥` by looking at elements of elements and so on in the model."}
{"full_name": "ConNF.ExtendedIndex", "url": "ConNF/Structural/Index.html#ConNF.ExtendedIndex", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.ExtendedIndex [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Type u", "code": "def ExtendedIndex (Î± : TypeIndex) :=\n  Quiver.Path Î± âŠ¥\n", "additional_info": "A (finite) path from the type `ğŸ—ŸÎ±ğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.Level.Î±ğŸ”—`  to the base type.\nThis is a way that we can perceive extensionality, iteratively descending to lower\ntypes in the hierarchy until we reach the base type.\nAs `Î›` is well-ordered, there are no infinite descending paths.\nEquations\n* ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸQuiver.PathğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.PathğŸ”—  Î± ğŸ—ŸâŠ¥ğŸ—ŸğŸ”—../.././Mathlib/Order/Notation.html#Bot.botğŸ”—\n\n", "used_premises": [1], "def_path": "ConNF/Structural/Index.lean", "pos": [59, 61], "informalization": "Function `ConNF.ExtendedIndex` defines a finite path from a type `Î±` to the base type `âŠ¥` in the context of Constructive Ordinal Notation (ConNF). This path represents a way to understand extensionality by iteratively descending to lower types in the hierarchy until reaching the base type. Since `Î›` is well-ordered, there are no infinite descending paths."}
{"full_name": "symmDiff", "url": "Mathlib/Order/SymmDiff.html#symmDiff", "code_src": "mathlib4", "ptype": "def", "header": "def symmDiff {Î± : Type u_2} [SupğŸ”—<|PREMISE|>ğŸ”— Î±] [SDiffğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) (b : Î±) :Î±", "code": "def symmDiff [Sup Î±] [SDiff Î±] (a b : Î±) : Î± :=\n  a \\ b âŠ” b \\ a\n", "additional_info": "The symmetric difference operator on a type with `âŠ”` and `\\` is `(A \\ B) âŠ” (B \\ A)`.\nEquations\n* ğŸ—ŸsymmDiffğŸ—ŸğŸ”—../.././Mathlib/Order/SymmDiff.html#symmDiffğŸ”—  a b ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  a ğŸ—Ÿ\\ğŸ—ŸğŸ”—../.././Init/Core.html#SDiff.sdiffğŸ”—  b ğŸ—ŸâŠ”ğŸ—ŸğŸ”—../.././Mathlib/Order/Notation.html#Sup.supğŸ”—  b ğŸ—Ÿ\\ğŸ—ŸğŸ”—../.././Init/Core.html#SDiff.sdiffğŸ”—  a\n\n", "used_premises": [63, 64], "def_path": "Mathlib/Order/SymmDiff.lean", "pos": [59, 61], "informalization": "Function `symmDiff` calculates the symmetric difference between two sets `a` and `b`, which is defined as the union of the relative complements `a \\ b` and `b \\ a`."}
{"full_name": "Sup", "url": "Mathlib/Order/Notation.html#Sup", "code_src": "mathlib4", "ptype": "class", "header": "class Sup (Î± : Type u_1) :Type u_1\n | sup : Î± â†’ Î± â†’ Î±", "code": "class Sup (Î± : Type*) where\n  /-- Least upper bound (`\\lub` notation) -/\n  sup : Î± â†’ Î± â†’ Î±\n", "additional_info": "Typeclass for the `âŠ”` (`\\lub`) notation\n- Sup.sup: Least upper bound (`\\lub` notation)\n\n\n", "used_premises": [], "def_path": "Mathlib/Order/Notation.lean", "pos": [46, 49], "informalization": "Class `Sup` represents the concept of a least upper bound operation, often denoted as `âŠ”` (`\\lub`), for a type `Î±`."}
{"full_name": "SDiff", "url": "Init/Core.html#SDiff", "code_src": "lean4", "ptype": "class", "header": "class SDiff (Î± : Type u) :Type u\n | sdiff : Î± â†’ Î± â†’ Î±", "code": "class SDiff (Î± : Type u) where\n  /--\n  `a \\ b` is the set difference of `a` and `b`,\n  consisting of all elements in `a` that are not in `b`.\n  -/\n  sdiff : Î± â†’ Î± â†’ Î±\n", "additional_info": "Notation type class for the set difference `\\`.\n- SDiff.sdiff: `a \\ b` is the set difference of `a` and `b`,\nconsisting of all elements in `a` that are not in `b`.\n\n\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [407, 413], "informalization": "Class `SDiff` represents the concept of set difference, providing a binary operation `sdiff` that returns the elements of `a` not in `b`."}
{"full_name": "Sum.inr", "url": "Init/Core.html#Sum", "code_src": "lean4", "ptype": "constructor", "header": "constructor SumğŸ”—<|PREMISE|>ğŸ”—.inr: {Î± : Type  u} â†’ {Î² : Type  v} â†’ Î² â†’ Î± âŠ•  Î²", "code": "inductive Sum (Î± : Type u) (Î² : Type v) where\n  /-- Left injection into the sum type `Î± âŠ• Î²`. If `a : Î±` then `.inl a : Î± âŠ• Î²`. -/\n  | inl (val : Î±) : Sum Î± Î²\n  /-- Right injection into the sum type `Î± âŠ• Î²`. If `b : Î²` then `.inr b : Î± âŠ• Î²`. -/\n  | inr (val : Î²) : Sum Î± Î²\n", "additional_info": "Right injection into the sum type `Î± âŠ• Î²`. If `b : Î²` then `.ğŸ—ŸinrğŸ—ŸğŸ”—.././Init/Core.html#Sum.inrğŸ”—  b : Î± âŠ• Î²`.\n\n", "used_premises": [66], "def_path": "Init/Core.lean", "pos": [129, 134], "informalization": "Constructor `Sum.inr` is a method within the `Sum` inductive type that constructs an element of the sum type `Î± âŠ• Î²` from an element of type `Î²`. Specifically, if `b` is an element of type `Î²`, then `Sum.inr b` represents the right injection of `b` into the sum type `Î± âŠ• Î²`."}
{"full_name": "Sum", "url": "Init/Core.html#Sum", "code_src": "lean4", "ptype": "inductive", "header": "inductive Sum (Î± : Type u) (Î² : Type v) :Type (max u v)", "code": "inductive Sum (Î± : Type u) (Î² : Type v) where\n  /-- Left injection into the sum type `Î± âŠ• Î²`. If `a : Î±` then `.inl a : Î± âŠ• Î²`. -/\n  | inl (val : Î±) : Sum Î± Î²\n  /-- Right injection into the sum type `Î± âŠ• Î²`. If `b : Î²` then `.inr b : Î± âŠ• Î²`. -/\n  | inr (val : Î²) : Sum Î± Î²\n", "additional_info": "`ğŸ—ŸSumğŸ—ŸğŸ”—.././Init/Core.html#SumğŸ”—  Î± Î²`, or `Î± âŠ• Î²`, is the disjoint union of types `Î±` and `Î²`.\nAn element of `Î± âŠ• Î²` is either of the form `.ğŸ—ŸinlğŸ—ŸğŸ”—.././Init/Core.html#Sum.inlğŸ”—  a` where `a : Î±`,\nor `.ğŸ—ŸinrğŸ—ŸğŸ”—.././Init/Core.html#Sum.inrğŸ”—  b` where `b : Î²`.\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [129, 134], "informalization": "Type `Sum Î± Î²` represents the disjoint union of types `Î±` and `Î²`, containing elements of the form `.inl a` where `a : Î±`, or `.inr b` where `b : Î²`."}
{"full_name": "Sum.inl", "url": "Init/Core.html#Sum", "code_src": "lean4", "ptype": "constructor", "header": "constructor SumğŸ”—<|PREMISE|>ğŸ”—.inl: {Î± : Type  u} â†’ {Î² : Type  v} â†’ Î± â†’ Î± âŠ•  Î²", "code": "inductive Sum (Î± : Type u) (Î² : Type v) where\n  /-- Left injection into the sum type `Î± âŠ• Î²`. If `a : Î±` then `.inl a : Î± âŠ• Î²`. -/\n  | inl (val : Î±) : Sum Î± Î²\n  /-- Right injection into the sum type `Î± âŠ• Î²`. If `b : Î²` then `.inr b : Î± âŠ• Î²`. -/\n  | inr (val : Î²) : Sum Î± Î²\n", "additional_info": "Left injection into the sum type `Î± âŠ• Î²`. If `a : Î±` then `.ğŸ—ŸinlğŸ—ŸğŸ”—.././Init/Core.html#Sum.inlğŸ”—  a : Î± âŠ• Î²`.\n\n", "used_premises": [66], "def_path": "Init/Core.lean", "pos": [129, 134], "informalization": "Function `Sum.inl` injects an element of type `Î±` into the left side of the sum type `Î± âŠ• Î²`."}
{"full_name": "MulAction.Supports", "url": "Mathlib/GroupTheory/GroupAction/Support.html#MulAction.Supports", "code_src": "mathlib4", "ptype": "def", "header": "def MulAction.Supports (G : Type u_1) {Î± : Type u_3} {Î² : Type u_4} [SMulğŸ”—<|PREMISE|>ğŸ”— G Î±] [SMulğŸ”—<|PREMISE|>ğŸ”— G Î²] (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (b : Î²) :Prop", "code": "def Supports (s : Set Î±) (b : Î²) :=\n  âˆ€ g : G, (âˆ€ â¦ƒaâ¦„, a âˆˆ s â†’ g â€¢ a = a) â†’ g â€¢ b = b\n", "additional_info": "A set `s` supports `b` if `g â€¢ b = b` whenever `g â€¢ a = a` for all `a âˆˆ s`.\nEquations\n* ğŸ—ŸMulAction.SupportsğŸ—ŸğŸ”—../../.././Mathlib/GroupTheory/GroupAction/Support.html#MulAction.SupportsğŸ”—  G s b ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (g : G), (âˆ€ â¦ƒa : Î±â¦„, a ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s â†’ g ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  a ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  a) â†’ g ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  b ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  b\n\n", "used_premises": [57, 57, 69], "def_path": "Mathlib/GroupTheory/GroupAction/Support.lean", "pos": [30, 32], "informalization": "Function `MulAction.Supports` checks if a set `s` supports an element `b` under the action of a monoid `G`, meaning that for any `g` in `G`, if `g` acts trivially on every element of `s`, then it also acts trivially on `b`."}
{"full_name": "Set", "url": "Mathlib/Init/Set.html#Set", "code_src": "mathlib4", "ptype": "def", "header": "def Set (Î± : Type u) :Type u", "code": "def Set (Î± : Type u) := Î± â†’ Prop\n", "additional_info": "A set is a collection of elements of some type `Î±`.\nAlthough `ğŸ—ŸSetğŸ—ŸğŸ”—../.././Mathlib/Init/Set.html#SetğŸ”—`  is defined as `Î± â†’ Prop`, this is an implementation detail which should not be\nrelied on. Instead, `ğŸ—ŸsetOfğŸ—ŸğŸ”—../.././Mathlib/Init/Set.html#setOfğŸ”—`  and membership of a set (`âˆˆ`) should be used to convert between sets\nand predicates.\nEquations\n* ğŸ—ŸSetğŸ—ŸğŸ”—../.././Mathlib/Init/Set.html#SetğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  (Î± â†’ ğŸ—ŸPropğŸ—ŸğŸ”—../.././foundational_types.htmlğŸ”— )\n\n", "used_premises": [], "def_path": "Mathlib/Init/Set.lean", "pos": [46, 47], "informalization": "Function `Set` maps a given type to a proposition, which means that for each element of that type, it determines whether that element belongs to the set. A set a collection of elements of some type Î±."}
{"full_name": "ConNF.Enumeration.carrier", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.carrier", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.carrier [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :SetğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def Enumeration.carrier (E : Enumeration Î±) : Set Î± :=\n  { c | âˆƒ i, âˆƒ (h : i < E.max), c = E.f i h }\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Enumeration.carrierğŸ—ŸğŸ”—../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.carrierğŸ”—  E ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  {c : Î± | âˆƒ (i : ConNF.Îº) (h : i ğŸ—Ÿ<ğŸ—ŸğŸ”—../.././Init/Prelude.html#LT.ltğŸ”—  E.max), c ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  E.f i h}\n\n", "used_premises": [1, 59, 69], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [20, 22], "informalization": "Function `ConNF.Enumeration.carrier` defines the carrier set of an `Î±`-enumeration `E`, which consists of all elements `c` of type `Î±` that can be expressed as `E.f i h` for some `i < E.max`."}
{"full_name": "ConNF.TangleData.support", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.TangleData", "code_src": "con-nf", "ptype": "structure_field", "header": "structure_field ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”—.support : ConNF.Tangle  Î± â†’ ConNF.SupportğŸ”—<|PREMISE|>ğŸ”—  Î±", "code": "class TangleData (Î± : TypeIndex) where\n  /-- The type of tangles that we assume were constructed at stage `Î±`.\n  Later in the recursion, we will construct this type explicitly, but for now, we will just assume\n  that it exists. -/\n  (Tangle : Type u)\n  /-- The type of allowable permutations that we assume exists on `Î±`-tangles. -/\n  (Allowable : Type u)\n  [allowableGroup : Group Allowable]\n  allowableToStructPerm : Allowable â†’* StructPerm Î±\n  [allowableAction : MulAction Allowable Tangle]\n  support : Tangle â†’ Support Î±\n  support_supports (t : Tangle) :\n    haveI : MulAction Allowable (Address Î±) :=\n      MulAction.compHom _ allowableToStructPerm\n    MulAction.Supports Allowable (support t : Set (Address Î±)) t\n", "additional_info": "", "used_premises": [39, 58], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [33, 48], "informalization": "Function `ConNF.TangleData.support` maps an `Î±`-tangle to a function from an initial segment of `Îº` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.PositionedTangles", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.PositionedTangles", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.PositionedTangles [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] :Type u\n | pos : ConNF.Tangle  Î± â†ª  ConNF.Î¼", "code": "class PositionedTangles (Î± : TypeIndex) [TangleData Î±] where\n  /-- A position function, giving each tangle a unique position `Î½ : Î¼`.\n  The existence of this injection proves that there are at most `Î¼` tangles at level `Î±`.\n  Since `Î¼` has a well-ordering, this induces a well-ordering on `Î±`-tangles: to compare two\n  tangles, simply compare their images under this map. -/\n  pos : Tangle Î± â†ª Î¼\n", "additional_info": "- ConNF.PositionedTangles.pos: A position function, giving each tangle a unique position `Î½ : Î¼`.\nThe existence of this injection proves that there are at most `Î¼` tangles at level `Î±`.\nSince `Î¼` has a well-ordering, this induces a well-ordering on `Î±`-tangles: to compare two\ntangles, simply compare their images under this map.\n\n\n", "used_premises": [1, 39], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [134, 140], "informalization": "Class `ConNF.PositionedTangles` represents the concept of a position function for tangles at level `Î±` in the context of Constructive Ordinal Notation (ConNF), which gives each tangle a unique position `Î½ : Î¼`. This injection proves that there are at most `Î¼` tangles at level `Î±`, and it induces a well-ordering on `Î±`-tangles."}
{"full_name": "ConNF.TypedObjects", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.TypedObjects", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.TypedObjects [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.Î›) [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î±] :Type u\n | typedAtom : ConNF.Atom â†ª  ConNF.Tangle  â†‘Î±\n | typedNearLitter : ConNF.NearLitter â†ª  ConNF.Tangle  â†‘Î±\n | smul_typedNearLitter : âˆ€ (Ï : ConNF.Allowable  â†‘Î±) (N : ConNF.NearLitter),\n Ï â€¢  ConNF.typedNearLitter N =  ConNF.typedNearLitter (ConNF.Allowable.toStructPerm Ï (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  â‹¯) â€¢  N)", "code": "class TypedObjects where\n  /-- Encode an atom as an `Î±`-tangle. The resulting model element has a `âŠ¥`-extension which\n  contains only this atom. -/\n  typedAtom : Atom â†ª Tangle Î±\n  /-- Encode a near-litter as an `Î±`-tangle. The resulting model element has a `âŠ¥`-extension which\n  contains only this near-litter. -/\n  typedNearLitter : NearLitter â†ª Tangle Î±\n  smul_typedNearLitter :\n    âˆ€ (Ï : Allowable Î±) (N : NearLitter),\n    Ï â€¢ typedNearLitter N =\n    typedNearLitter ((Allowable.toStructPerm Ï) (Quiver.Hom.toPath <| bot_lt_coe Î±) â€¢ N)\n", "additional_info": "Allows us to encode atoms and near-litters as `Î±`-tangles. These maps are expected to cohere\nwith the conditions given in `BasePositions`, but this requirement is expressed later.\n- ConNF.TypedObjects.typedAtom: Encode an atom as an `Î±`-tangle. The resulting model element has a `âŠ¥`-extension which\ncontains only this atom.\n\n\n- ConNF.TypedObjects.typedNearLitter: Encode a near-litter as an `Î±`-tangle. The resulting model element has a `âŠ¥`-extension which\ncontains only this near-litter.\n\n\n", "used_premises": [1, 39, 74], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [148, 159], "informalization": "Class `ConNF.TypedObjects` allows us to encode atoms and near-litters as `Î±`-tangles. These maps are expected to cohere with the conditions given in `BasePositions`, but this requirement is expressed later."}
{"full_name": "Quiver.Hom.toPath", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath", "code_src": "mathlib4", "ptype": "def", "header": "def Quiver.Hom.toPath {V : Type u_1} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {a : V} {b : V} (e : a âŸ¶ b) :Quiver.PathğŸ”—<|PREMISE|>ğŸ”— a b", "code": "def Hom.toPath {V} [Quiver V] {a b : V} (e : a âŸ¶ b) : Path a b :=\n  Path.nil.cons e\n", "additional_info": "An arrow viewed as a path of length one.\nEquations\n* ğŸ—ŸQuiver.Hom.toPathğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPathğŸ”—  e ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  Quiver.Path.nil e\n\n", "used_premises": [75, 76], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [33, 35], "informalization": "Function `Quiver.Hom.toPath` converts a single arrow in a quiver into a path of length one."}
{"full_name": "Quiver", "url": "Mathlib/Combinatorics/Quiver/Basic.html#Quiver", "code_src": "mathlib4", "ptype": "class", "header": "class Quiver (V : Type u) :Type (max u v)\n | Hom : V â†’ V â†’ Sort  v", "code": "class Quiver (V : Type u) where\n  /-- The type of edges/arrows/morphisms between a given source and target. -/\n  Hom : V â†’ V â†’ Sort v\n", "additional_info": "A quiver `G` on a type `V` of vertices assigns to every pair `a b : V` of vertices\na type `a âŸ¶ b` of arrows from `a` to `b`.\nFor graphs with no repeated edges, one can use `Quiver.{0} V`, which ensures\n`a âŸ¶ b : Prop`. For multigraphs, one can use `Quiver.{v+1} V`, which ensures\n`a âŸ¶ b : Type v`.\nBecause `Category` will later extend this class, we call the field `ğŸ—ŸHomğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.HomğŸ”—` .\nExcept when constructing instances, you should rarely see this, and use the `âŸ¶` notation instead.\n- Quiver.Hom: The type of edges/arrows/morphisms between a given source and target.\n\n\n", "used_premises": [], "def_path": "Mathlib/Combinatorics/Quiver/Basic.lean", "pos": [45, 48], "informalization": "A `Quiver` on a type `V` of vertices assigns to every pair `a b : V` of vertices a type `a âŸ¶ b` of arrows from `a` to `b`."}
{"full_name": "Quiver.Path", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path", "code_src": "mathlib4", "ptype": "inductive", "header": "inductive Quiver.Path {V : Type u} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] (a : V) :V â†’ Sort (max (u + 1) v)", "code": "inductive Path {V : Type u} [Quiver.{v} V] (a : V) : V â†’ Sort max (u + 1) v\n  | nil : Path a a\n  | cons : âˆ€ {b c : V}, Path a b â†’ (b âŸ¶ c) â†’ Path a c\n", "additional_info": "`ğŸ—ŸPathğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.PathğŸ”—  a b` is the type of paths from `a` to `b` through the arrows of `G`.\n", "used_premises": [75], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [24, 27], "informalization": "Type `Quiver.Path` represents the type of paths between two vertices in a quiver, defined inductively as either a trivial path (`nil`) or a path extended by an arrow (`cons`)."}
{"full_name": "ConNF.cloud", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.cloud [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] (hÎ³Î² : Î³ â‰  â†‘Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)) :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle â†‘Î²)", "code": "def cloud (s : Set (Tangle Î³)) : Set (Tangle Î²) :=\n  typedNearLitter '' â‹ƒ t âˆˆ s, localCardinal (fuzz hÎ³Î² t)\n", "additional_info": "The cloud map. We map each tangle to all typed near-litters near the `fuzz`ed tangle, and take\nthe union over all tangles in the input.\nEquations\n* ğŸ—ŸConNF.cloudğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudğŸ”—  hÎ³Î² s ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  â‡‘ConNF.typedNearLitter ğŸ—Ÿ''ğŸ—ŸğŸ”—../.././Mathlib/Init/Set.html#Set.imageğŸ”—  â‹ƒ t âˆˆ s, ğŸ—ŸConNF.localCardinalğŸ—ŸğŸ”—../.././ConNF/BaseType/NearLitter.html#ConNF.localCardinalğŸ”—  (ğŸ—ŸConNF.fuzzğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzğŸ”—  hÎ³Î² t)\n\n", "used_premises": [1, 39, 72, 39, 72, 73, 69, 69], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [50, 52], "informalization": "Function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input."}
{"full_name": "ConNF.fuzz", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.fuzz [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] (hÎ²Î³ : Î² â‰  â†‘Î³) (t : ConNF.Tangle Î²) :ConNF.Litter", "code": "noncomputable def fuzz (t : Tangle Î²) : Litter :=\n  âŸ¨chooseWf (fuzzDeny Î³) mk_fuzzDeny t, Î², Î³, hÎ²Î³âŸ©\n", "additional_info": "The `ğŸ—ŸfuzzğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzğŸ”—`  map for a particular pair of type indices.\nIn tangled type theory, a given model element has extensions at each level below it.\nWe have a \"preferred\" extension, and must find a way to compute the other extensions from that\ninformation. In order to do this, we need to be able to convert arbitrary model elements into\n\"junk\" at other levels, which can then be clearly interpreted as a \"non-preferred\" extension.\nThe `ğŸ—ŸfuzzğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzğŸ”—`  maps perform this task. They are parametrised by a pair of type indices, representing\nthe source type level and target type level. At each pair of levels, the `ğŸ—ŸfuzzğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzğŸ”—`  map is an injection\nfrom tangles to litters. An arbitrary litter can only be the image of a `ğŸ—ŸfuzzğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzğŸ”—`  map defined at a\nsingle pair of type levels.\nTreating the output of a `ğŸ—ŸfuzzğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzğŸ”—`  map as a typed near-litter, its pos is always greater than\nthe pos of the input to the function. This ensures a well-foundedness condition that we use\nin many places later.\nEquations\n* ğŸ—ŸConNF.fuzzğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzğŸ”—  hÎ²Î³ t ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  { Î½ := ğŸ—ŸConNF.chooseWfğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.chooseWfğŸ”—  (ğŸ—ŸConNF.fuzzDenyğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzDenyğŸ”—  Î³) â‹¯ t, Î² := Î², Î³ := Î³, Î²_ne_Î³ := hÎ²Î³ }\n\n", "used_premises": [1, 39, 72, 39, 72, 73], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [182, 184], "informalization": "Function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `Î²` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `Î²`, a `Î›` object `Î³`, and a proof that `Î²` is not equal to `Î³`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny Î³`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `Î²` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `Î²`, the `Î›` object `Î³`, and the proof that `Î²` is not equal to `Î³`."}
{"full_name": "ConNF.cloud_empty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_empty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloud_empty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ³Î² : Î³ â‰  â†‘Î²} :ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² âˆ… = âˆ…", "code": "theorem cloud_empty : cloud hÎ³Î² (âˆ… : Set (Tangle Î³)) = âˆ… := by\n  simp only [cloud, mem_empty_iff_false, iUnion_of_empty, iUnion_empty, image_empty]\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [67, 69], "informalization": "Function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. This theorem states that if the input set of tangles is empty, then the output set of near-litters is also empty."}
{"full_name": "ConNF.cloud_singleton", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloud_singleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ³Î² : Î³ â‰  â†‘Î²} (t : ConNF.Tangle Î³) :ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² {t} = â‡‘ConNF.typedNearLitter '' ConNF.localCardinalğŸ”—<|PREMISE|>ğŸ”— (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² t)", "code": "theorem cloud_singleton (t : Tangle Î³) :\n    cloud hÎ³Î² {t} = typedNearLitter '' localCardinal (fuzz hÎ³Î² t) := by\n  simp only [cloud, mem_singleton_iff, iUnion_iUnion_eq_left]\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 77, 81, 78], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [71, 74], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The function `ConNF.localCardinal` defines the local cardinal of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). The local cardinal of a litter `L` is defined as the set of all near-litters `N` such that the first component of `N` is equal to `L`. In other words, the local cardinal of a litter `L` consists of all near-litters that have `L` as their first component. The function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `Î²` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `Î²`, a `Î›` object `Î³`, and a proof that `Î²` is not equal to `Î³`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny Î³`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `Î²` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `Î²`, the `Î›` object `Î³`, and the proof that `Î²` is not equal to `Î³`."}
{"full_name": "ConNF.localCardinal", "url": "ConNF/BaseType/NearLitter.html#ConNF.localCardinal", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.localCardinal [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.NearLitter", "code": "def localCardinal (L : Litter) : Set NearLitter :=\n  {N : NearLitter | N.1 = L}\n", "additional_info": "The *local cardinal* of a litter is the set of all near-litters to that litter.\nEquations\n* ğŸ—ŸConNF.localCardinalğŸ—ŸğŸ”—../.././ConNF/BaseType/NearLitter.html#ConNF.localCardinalğŸ”—  L ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  {N : ConNF.NearLitter | N.fst ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  L}\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [184, 186], "informalization": "Function `ConNF.localCardinal` defines the local cardinal of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). The local cardinal of a litter `L` is defined as the set of all near-litters `N` such that the first component of `N` is equal to `L`. In other words, the local cardinal of a litter `L` consists of all near-litters that have `L` as their first component."}
{"full_name": "Set.Nonempty.cloud", "url": "ConNF/NewTangle/Cloud.html#Set.Nonempty.cloud", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Set.Nonempty.cloud [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ³Î² : Î³ â‰  â†‘Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)} (h : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— s) :Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² s)", "code": "theorem Set.Nonempty.cloud (h : s.Nonempty) : (cloud hÎ³Î² s).Nonempty := by\n  refine (nonempty_iUnion.2 ?_).image _\n  refine âŸ¨h.choose, âŸ¨(fuzz hÎ³Î² h.choose).toNearLitter, ?_âŸ©âŸ©\n  simp only [mem_iUnion, mem_localCardinal, Litter.toNearLitter_fst, exists_prop, and_true]\n  exact h.choose_spec\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 83, 83, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [77, 82], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `Set.Nonempty.cloud` asserts that if `s` is a non-empty set of `Î³`-tangles, then the set obtained by applying `ConNF.cloud` to `s` is also non-empty."}
{"full_name": "Set.Nonempty", "url": "Mathlib/Init/Set.html#Set.Nonempty", "code_src": "mathlib4", "ptype": "def", "header": "def Set.Nonempty {Î± : Type u_1} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "protected def Nonempty (s : Set Î±) : Prop :=\n  âˆƒ x, x âˆˆ s\n", "additional_info": "The property `s.ğŸ—ŸNonemptyğŸ—ŸğŸ”—../.././Init/Prelude.html#NonemptyğŸ”—`  expresses the fact that the set `s` is not empty. It should be used\nin theorem assumptions instead of `âˆƒ x, x âˆˆ s` or `s â‰  âˆ…` as it gives access to a nice API thanks\nto the dot notation.\nEquations\n* ğŸ—ŸSet.NonemptyğŸ—ŸğŸ”—../.././Mathlib/Init/Set.html#Set.NonemptyğŸ”—  s ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆƒ (x : Î±), x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../.././Init/Prelude.html#Membership.memğŸ”—  s\n\n", "used_premises": [69], "def_path": "Mathlib/Init/Set.lean", "pos": [217, 219], "informalization": "Function `Set.Nonempty` is a predicate that checks if a given set `s` of type `Î±` contains at least one element, providing a convenient API for theorem assumptions."}
{"full_name": "ConNF.cloud_eq_empty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_eq_empty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloud_eq_empty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)} (hÎ³Î² : Î³ â‰  â†‘Î²) :ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² s = âˆ… â†” s = âˆ…", "code": "theorem cloud_eq_empty (hÎ³Î² : Î³ â‰  Î²) : cloud hÎ³Î² s = âˆ… â†” s = âˆ… := by\n  refine' âŸ¨fun h => not_nonempty_iff_eq_empty.1 fun hs => hs.cloud.ne_empty h, _âŸ©\n  rintro rfl\n  exact cloud_empty\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [84, 88], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `ConNF.cloud_eq_empty` states that the `ConNF.cloud` of a set of tangles is empty if and only if the set of tangles itself is empty."}
{"full_name": "ConNF.cloud_nonempty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloud_nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)} (hÎ³Î² : Î³ â‰  â†‘Î²) :Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² s) â†” Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— s", "code": "theorem cloud_nonempty (hÎ³Î² : Î³ â‰  Î²) : (cloud hÎ³Î² s).Nonempty â†” s.Nonempty := by\n  simp_rw [nonempty_iff_ne_empty, Ne.def, cloud_eq_empty]\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 83, 77, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [90, 92], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `ConNF.cloud_nonempty` asserts that the resulting set is nonempty if and only if the input set is nonempty."}
{"full_name": "ConNF.subset_cloud", "url": "ConNF/NewTangle/Cloud.html#ConNF.subset_cloud", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.subset_cloud [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ³Î² : Î³ â‰  â†‘Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)} {t : ConNF.Tangle Î³} (ht : t âˆˆ s) :â‡‘ConNF.typedNearLitter '' ConNF.localCardinalğŸ”—<|PREMISE|>ğŸ”— (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² t) âŠ† ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² s", "code": "theorem subset_cloud (ht : t âˆˆ s) :\n    typedNearLitter '' localCardinal (fuzz hÎ³Î² t) âŠ† cloud hÎ³Î² s :=\n  image_subset _ <| subset_iUnionâ‚‚ (s := fun t' _ => localCardinal (fuzz hÎ³Î² t')) t ht\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 81, 78, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [93, 96], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.subset_cloud` asserts that for any tangle `t` of type `Î³` that belongs to a set `s` of tangles of type `Î³`, the set of all typed near-litters near the `fuzz`ed tangle `t` is a subset of the `cloud` of `s`."}
{"full_name": "ConNF.Î¼_le_mk_cloud", "url": "ConNF/NewTangle/Cloud.html#ConNF.Î¼_le_mk_cloud", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Î¼_le_mk_cloud [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ³Î² : Î³ â‰  â†‘Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)} :Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— s â†’ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼ â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² s)", "code": "theorem Î¼_le_mk_cloud : s.Nonempty â†’ #Î¼ â‰¤ #(cloud hÎ³Î² s) := by\n  rintro âŸ¨t, htâŸ©\n  refine' (Cardinal.mk_le_mk_of_subset <| subset_cloud ht).trans_eq' _\n  rw [Cardinal.mk_image_eq, mk_localCardinal]\n  exact typedNearLitter.inj'\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 83, 29, 29, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [97, 102], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Î¼_le_mk_cloud` asserts that for any non-empty set `s` of `Î³`-tangles, the cardinality of `Î¼` is less than or equal to the cardinality of the set of all `Î²`-typed near-litters near the `fuzz`ed tangles in `s`."}
{"full_name": "ConNF.cloud_injective", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloud_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ³Î² : Î³ â‰  â†‘Î²} :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î²)", "code": "theorem cloud_injective : Injective (cloud hÎ³Î²) :=\n  typedNearLitter.injective.image_injective.comp <|\n    Pairwise.biUnion_injective (fun _ _ h => localCardinal_disjoint <| (fuzz_injective _).ne h)\n      fun _ => localCardinal_nonempty _\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 89, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [103, 107], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloud_injective` asserts that the function `ConNF.cloud`, which maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input, is injective."}
{"full_name": "Function.Injective", "url": "Mathlib/Init/Function.html#Function.Injective", "code_src": "mathlib4", "ptype": "def", "header": "def Function.Injective {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) :Prop", "code": "def Injective (f : Î± â†’ Î²) : Prop :=\n  âˆ€ â¦ƒaâ‚ aâ‚‚â¦„, f aâ‚ = f aâ‚‚ â†’ aâ‚ = aâ‚‚\n", "additional_info": "A function `f : Î± â†’ Î²` is called injective if `f x = f y` implies `x = y`.\nEquations\n* ğŸ—ŸFunction.InjectiveğŸ—ŸğŸ”—../.././Mathlib/Init/Function.html#Function.InjectiveğŸ”—  f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒaâ‚ aâ‚‚ : Î±â¦„, f aâ‚ ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  f aâ‚‚ â†’ aâ‚ ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  aâ‚‚\n\n", "used_premises": [], "def_path": "Mathlib/Init/Function.lean", "pos": [115, 117], "informalization": "Function `Function.Injective` checks if a function `f` from `Î±` to `Î²` is injective, meaning `f aâ‚ = f aâ‚‚` implies `aâ‚ = aâ‚‚` for all `aâ‚, aâ‚‚` in `Î±`."}
{"full_name": "ConNF.cloud_disjoint_range", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_disjoint_range", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloud_disjoint_range [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ³Î² : Î³ â‰  â†‘Î²} {Î´ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î´] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î´] {hÎ´Î² : Î´ â‰  â†‘Î²} (c : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)) (d : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î´)) (hc : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— c) (h : ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ³Î² c = ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— hÎ´Î² d) :Î³ = Î´", "code": "theorem cloud_disjoint_range {hÎ´Î²} (c : Set (Tangle Î³)) (d : Set (Tangle Î´)) (hc : c.Nonempty)\n    (h : cloud hÎ³Î² c = cloud hÎ´Î² d) : Î³ = Î´ := by\n  obtain âŸ¨b, hbâŸ© := hc\n  have := (subset_iUnionâ‚‚ b hb).trans (typedNearLitter.injective.image_injective h).subset\n  obtain âŸ¨i, -, hiâŸ© := mem_iUnionâ‚‚.1 (this (fuzz _ b).toNearLitter_mem_localCardinal)\n  exact fuzz_congr_Î² hi\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 39, 72, 69, 69, 83, 77, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [110, 116], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloud_disjoint_range` asserts that for any two different types of tangles `Î³` and `Î´`, and any non-empty set of `Î³`-tangles `c` and any set of `Î´`-tangles `d`, if the `ConNF.cloud` of `c` equals the `ConNF.cloud` of `d`, then `Î³` must equal `Î´`."}
{"full_name": "ConNF.wellFounded_pos", "url": "ConNF/NewTangle/Cloud.html#ConNF.wellFounded_pos", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.wellFounded_pos [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] :WellFoundedğŸ”—<|PREMISE|>ğŸ”— fun (a b : ConNF.Tangle Î³) => ConNF.pos a < ConNF.pos b", "code": "theorem wellFounded_pos : WellFounded fun a b : Tangle Î³ => pos a < pos b :=\n  InvImage.wf _ IsWellFounded.wf\n", "additional_info": "", "used_premises": [1, 39, 72, 19], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [125, 127], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.wellFounded_pos` asserts that the relation defined by comparing the positions of tangles is well-founded. This means that every non-empty set of tangles has a minimal element with respect to this relation."}
{"full_name": "ConNF.minTangle_mem", "url": "ConNF/NewTangle/Cloud.html#ConNF.minTangle_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.minTangle_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)) (hs : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.minTangleğŸ”—<|PREMISE|>ğŸ”— s hs âˆˆ s", "code": "theorem minTangle_mem (s : Set (Tangle Î³)) (hs : s.Nonempty) : minTangle s hs âˆˆ s :=\n  WellFounded.min_mem _ s hs\n", "additional_info": "", "used_premises": [1, 39, 72, 69, 83, 93], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [132, 134], "informalization": "Given a nonempty set of tangles at level `Î³` in the context of Constructive Ordinal Notation (ConNF), `ConNF.minTangle_mem` asserts that the tangle with the smallest position among all tangles in the set is indeed a member of that set."}
{"full_name": "ConNF.minTangle", "url": "ConNF/NewTangle/Cloud.html#ConNF.minTangle", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.minTangle [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)) (hs : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.Tangle Î³", "code": "noncomputable def minTangle (s : Set (Tangle Î³)) (hs : s.Nonempty) : Tangle Î³ :=\n  wellFounded_pos.min s hs\n", "additional_info": "The minimum tangle of a nonempty set of tangles.\nEquations\n* ğŸ—ŸConNF.minTangleğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.minTangleğŸ”—  s hs ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸWellFounded.minğŸ—ŸğŸ”—../.././Mathlib/Order/WellFounded.html#WellFounded.minğŸ”—  â‹¯ s hs\n\n", "used_premises": [1, 39, 72, 69, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [129, 131], "informalization": "Function `ConNF.minTangle` is a noncomputable function that, given a nonempty set of tangles at level `Î³` in the context of Constructive Ordinal Notation (ConNF), returns the tangle with the smallest position among all tangles in the set."}
{"full_name": "ConNF.minTangle_le", "url": "ConNF/NewTangle/Cloud.html#ConNF.minTangle_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.minTangle_le [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î³ : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î³] (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î³)) (hs : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— s) {t : ConNF.Tangle Î³} (ht : t âˆˆ s) :ConNF.pos (ConNF.minTangleğŸ”—<|PREMISE|>ğŸ”— s hs) â‰¤ ConNF.pos t", "code": "theorem minTangle_le (s : Set (Tangle Î³)) (hs : s.Nonempty) {t : Tangle Î³} (ht : t âˆˆ s) :\n    pos (minTangle s hs) â‰¤ pos t :=\n  not_lt.1 <| wellFounded_pos.not_lt_min s hs ht\n", "additional_info": "", "used_premises": [1, 39, 72, 69, 83, 93], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [135, 138], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.minTangle_le` asserts that for any nonempty set of tangles at level `Î³`, the position of the tangle with the smallest position is less than or equal to the position of any other tangle in the set."}
{"full_name": "ConNF.invImage_codeMinMap_wf", "url": "ConNF/NewTangle/Cloud.html#ConNF.invImage_codeMinMap_wf", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.invImage_codeMinMap_wf [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] :WellFoundedğŸ”—<|PREMISE|>ğŸ”— (InvImageğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.Î¼) => x < x_1) ConNF.codeMinMap)", "code": "theorem invImage_codeMinMap_wf : WellFounded (InvImage (Â· < Â·) (codeMinMap : NonemptyCode â†’ Î¼)) :=\n  InvImage.wf codeMinMap IsWellFounded.wf\n", "additional_info": "The pullback `<` relation on codes is well-founded.", "used_premises": [1, 19, 96], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [158, 160], "informalization": "The theorem `ConNF.invImage_codeMinMap_wf` states that the inverse image of the `<` relation on codes under the function `ConNF.codeMinMap` is well-founded. This means that every non-empty set of codes has a minimal element with respect to this relation."}
{"full_name": "InvImage", "url": "Init/Core.html#InvImage", "code_src": "lean4", "ptype": "def", "header": "def InvImage {Î± : Sort u} {Î² : Sort v} (r : Î² â†’ Î² â†’ Prop ) (f : Î± â†’ Î²) :Î± â†’ Î± â†’ Prop", "code": "def InvImage {Î± : Sort u} {Î² : Sort v} (r : Î² â†’ Î² â†’ Prop) (f : Î± â†’ Î²) : Î± â†’ Î± â†’ Prop :=\n  fun aâ‚ aâ‚‚ => r (f aâ‚) (f aâ‚‚)\n", "additional_info": "The inverse image of `ğŸ—ŸrğŸ—ŸğŸ”—.././Init/Core.html#Setoid.rğŸ”—  : Î² â†’ Î² â†’ Prop` by a function `Î± â†’ Î²` is the relation\n`s : Î± â†’ Î± â†’ Prop` defined by `s a b = ğŸ—ŸrğŸ—ŸğŸ”—.././Init/Core.html#Setoid.rğŸ”—  (f a) (f b)`.\nEquations\n* ğŸ—ŸInvImageğŸ—ŸğŸ”—.././Init/Core.html#InvImageğŸ”—  r f aâ‚ aâ‚‚ ğŸ—Ÿ=ğŸ—ŸğŸ”—.././Init/Prelude.html#EqğŸ”—  r (f aâ‚) (f aâ‚‚)\n\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [1082, 1084], "informalization": "`InvImage` is a function that takes a relation `r : Î² â†’ Î² â†’ Prop` and a function `f : Î± â†’ Î²`, and returns a new relation `s : Î± â†’ Î± â†’ Prop` such that `s aâ‚ aâ‚‚` holds if and only if `r (f aâ‚) (f aâ‚‚)` holds. In other words, `s` is the inverse image of `r` under `f`."}
{"full_name": "ConNF.extension_self", "url": "ConNF/NewTangle/Cloud.html#ConNF.extension_self", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.extension_self [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle â†‘Î³)) :ConNF.extensionğŸ”—<|PREMISE|>ğŸ”— s Î³ = s", "code": "theorem extension_self {Î³ : Î›} [LtLevel Î³] (s : Set (Tangle Î³)) : extension s Î³ = s :=\n  dif_pos rfl\n", "additional_info": "", "used_premises": [1, 98, 69, 99], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [171, 173], "informalization": "Function `ConNF.extension` maps a set of `Î²`-tangles to a set of `Î³`-tangles, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF). If `Î²` equals `Î³`, the function is the identity. Otherwise, it uses the `ConNF.cloud` function to map the set of `Î²`-tangles to a set of `Î³`-tangles. The theorem `ConNF.extension_self` states that when `Î²` equals `Î³`, the function `ConNF.extension` is the identity, meaning it maps the set of `Î²`-tangles to itself."}
{"full_name": "ConNF.LtLevel", "url": "ConNF/Structural/Index.html#ConNF.LtLevel", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.LtLevel [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] (Î² : ConNF.TypeIndex) :Prop\n | elim : Î² <  â†‘ConNF.Î±", "code": "class LtLevel (Î² : TypeIndex) : Prop where\n  elim : Î² < Î±\n", "additional_info": "The type index `Î²` is less than our current level.\n", "used_premises": [1], "def_path": "ConNF/Structural/Index.lean", "pos": [33, 35], "informalization": "The `ConNF.LtLevel` class in Lean 4 represents the condition that a type index `Î²` is less than the current level `Î±` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.extension", "url": "ConNF/NewTangle/Cloud.html#ConNF.extension", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.extension [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Î² : ConNF.TypeIndex} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î²)) (Î³ : ConNF.Î›) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle â†‘Î³)", "code": "def extension (s : Set (Tangle Î²)) (Î³ : Î›) [LtLevel Î³] : Set (Tangle Î³) :=\n  if hÎ²Î³ : Î² = Î³ then cast (by subst hÎ²Î³; rfl) s else cloud hÎ²Î³ s\n", "additional_info": "The `ğŸ—ŸcloudğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudğŸ”—`  map, phrased as a function on sets of `Î³`-tangles, but if `Î³ = Î²`, this is the\nidentity function.\nEquations\n* ğŸ—ŸConNF.extensionğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.extensionğŸ”—  s Î³ ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  if hÎ²Î³ : Î² ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  â†‘Î³ then ğŸ—ŸcastğŸ—ŸğŸ”—../.././Init/Prelude.html#castğŸ”—  â‹¯ s else ğŸ—ŸConNF.cloudğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudğŸ”—  hÎ²Î³ s\n\n", "used_premises": [1, 98, 69, 98, 69], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [167, 169], "informalization": "`ConNF.extension` is a function that maps a set of `Î²`-tangles to a set of `Î³`-tangles, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF). If `Î²` equals `Î³`, the function is the identity. Otherwise, it uses the `ConNF.cloud` function to map the set of `Î²`-tangles to a set of `Î³`-tangles."}
{"full_name": "ConNF.cloudCode_eq", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudCode_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Î² : ConNF.Î›) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (c : ConNF.Code) (hcÎ² : c.Î² = â†‘Î²) :ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² c = c", "code": "theorem cloudCode_eq (hcÎ² : c.1 = Î²) : cloudCode Î² c = c := by\n  rw [cloudCode, extension_eq _ _ hcÎ²]\n  ext : 1\n  Â· exact hcÎ².symm\n  Â· simp only [cast_heq]\n", "additional_info": "", "used_premises": [1, 98, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [194, 199], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the `ConNF.cloudCode` function takes a type index `Î²` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `Î²`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `Î²`."}
{"full_name": "ConNF.cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Î² : ConNF.Î›) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (c : ConNF.Code) :ConNF.Code", "code": "def cloudCode (c : Code) : Code :=\n  mk Î² (extension c.members Î²)\n", "additional_info": "The `ğŸ—ŸcloudğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudğŸ”—`  map, phrased as a function on `Î±`-codes, but if the code's level matches `Î²`,\nthis is the identity function. This is written in a weird way in order to make `(cloudCode Î² c).1`\ndefeq to `Î²`.\nEquations\n* ğŸ—ŸConNF.cloudCodeğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudCodeğŸ”—  Î² c ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.Code.mkğŸ—ŸğŸ”—../.././ConNF/NewTangle/Code.html#ConNF.Code.mkğŸ”—  (â†‘Î²) (ğŸ—ŸConNF.extensionğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.extensionğŸ”—  c.members Î²)\n\n", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [191, 193], "informalization": "`ConNF.cloudCode` is a function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes a type index `Î²` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `Î²`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `Î²`."}
{"full_name": "ConNF.fst_cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.fst_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.fst_cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Î² : ConNF.Î›) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (c : ConNF.Code) :(ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² c).Î² = â†‘Î²", "code": "theorem fst_cloudCode : (cloudCode Î² c).1 = Î² :=\n  rfl\n", "additional_info": "", "used_premises": [1, 98, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [204, 206], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the function `ConNF.cloudCode` takes a type index `Î²` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `Î²`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `Î²`."}
{"full_name": "ConNF.cloudCode_mk_eq", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_mk_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloudCode_mk_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Î² : ConNF.Î›) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle â†‘Î²)) :ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— (â†‘Î²) s) = ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— (â†‘Î²) s", "code": "theorem cloudCode_mk_eq (s) : cloudCode Î² (mk Î² s) = mk Î² s := by\n  rw [cloudCode_eq]\n  rfl\n", "additional_info": "", "used_premises": [1, 98, 69, 101, 104, 104], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [214, 217], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloudCode` takes a type index `Î²` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `Î²`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `Î²`."}
{"full_name": "ConNF.Code.mk", "url": "ConNF/NewTangle/Code.html#ConNF.Code", "code_src": "con-nf", "ptype": "structure_mk", "header": "structure_mk ConNF.CodeğŸ”—<|PREMISE|>ğŸ”—.mk  [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] :Type u\n | Î² : ConNF.TypeIndex\n | inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  self.Î²\n | members : SetğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Tangle  self.Î²)", "code": "structure Code : Type u where\n  (Î² : TypeIndex)\n  [inst : LtLevel Î²]\n  (members : Set (Tangle Î²))\n", "additional_info": "", "used_premises": [105, 1, 98, 69], "def_path": "ConNF/NewTangle/Code.lean", "pos": [23, 27], "informalization": "Structure `ConNF.Code` represents a type index `Î²` less than the current level `Î±` in the context of Constructive Ordinal Notation (ConNF), along with a set of tangles of type `Î²`."}
{"full_name": "ConNF.Code", "url": "ConNF/NewTangle/Code.html#ConNF.Code", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Code [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] :Type u\n | Î² : ConNF.TypeIndex\n | inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  self.Î²\n | members : SetğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Tangle  self.Î²)", "code": "structure Code : Type u where\n  (Î² : TypeIndex)\n  [inst : LtLevel Î²]\n  (members : Set (Tangle Î²))\n", "additional_info": "An `Î±` code is a type index `ğŸ—ŸÎ²ğŸ—ŸğŸ”—../.././ConNF/NewTangle/Code.html#ConNF.Code.Î²ğŸ”—  < Î±` together with a set of tangles of type `ğŸ—ŸÎ²ğŸ—ŸğŸ”—../.././ConNF/NewTangle/Code.html#ConNF.Code.Î²ğŸ”—` .\n", "used_premises": [1, 98, 69], "def_path": "ConNF/NewTangle/Code.lean", "pos": [23, 27], "informalization": "Structure `ConNF.Code` represents a type index `Î²` less than the current level `Î±` in the context of Constructive Ordinal Notation (ConNF), along with a set of tangles of type `Î²`."}
{"full_name": "ConNF.cloudCode_isEmpty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_isEmpty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloudCode_isEmpty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Î² : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {c : ConNF.Code} :ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² c) â†” ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— c", "code": "theorem cloudCode_isEmpty : (cloudCode Î² c).IsEmpty â†” c.IsEmpty := by\n  obtain âŸ¨Î³, sâŸ© := c\n  by_cases h : Î³ = Î²\n  Â· rw [cloudCode_eq]\n    exact h\n  Â· rw [cloudCode_ne]\n    exact cloud_eq_empty h\n", "additional_info": "", "used_premises": [1, 98, 107, 101, 107], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [225, 232], "informalization": "Function `ConNF.cloudCode` is defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes a type index `Î²` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem `ConNF.cloudCode_isEmpty` states that the new `ConNF.Code` object returned by `ConNF.cloudCode` is empty if and only if the original `ConNF.Code` object `c` is empty."}
{"full_name": "ConNF.Code.IsEmpty", "url": "ConNF/NewTangle/Code.html#ConNF.Code.IsEmpty", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Code.IsEmpty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] (c : ConNF.Code) :Prop", "code": "protected def IsEmpty (c : Code) : Prop :=\n  c.members = âˆ…\n", "additional_info": "A code is empty if it has no element.\nEquations\n* ğŸ—ŸConNF.Code.IsEmptyğŸ—ŸğŸ”—../.././ConNF/NewTangle/Code.html#ConNF.Code.IsEmptyğŸ”—  c ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  (c.members ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—Ÿâˆ…ğŸ—ŸğŸ”—../.././Init/Core.html#EmptyCollection.emptyCollectionğŸ”— )\n\n", "used_premises": [1], "def_path": "ConNF/NewTangle/Code.lean", "pos": [43, 45], "informalization": "Function `ConNF.Code.IsEmpty` checks if a `ConNF.Code` object is empty, meaning it contains no elements."}
{"full_name": "ConNF.cloudCode_nonempty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloudCode_nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Î² : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {c : ConNF.Code} :Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² c).members â†” Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— c.members", "code": "theorem cloudCode_nonempty : (cloudCode Î² c).members.Nonempty â†” c.members.Nonempty := by\n  simp_rw [nonempty_iff_ne_empty]; exact cloudCode_isEmpty.not\n", "additional_info": "", "used_premises": [1, 98, 83, 101, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [234, 236], "informalization": "Function `ConNF.cloudCode` in the context of Constructive Ordinal Notation (ConNF) in Lean 4 takes a type index `Î²` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem `ConNF.cloudCode_nonempty` states that the set of members of the returned `ConNF.Code` object is nonempty if and only if the set of members of the original `ConNF.Code` object `c` is nonempty."}
{"full_name": "ConNF.Code.IsEmpty.cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.Code.IsEmpty.cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEmpty.cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Î² : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {c : ConNF.Code} :ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— c â†’ ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² c)", "code": "alias âŸ¨_, Code.IsEmpty.cloudCodeâŸ© := cloudCode_isEmpty\n", "additional_info": "**Alias** of the reverse direction of `ğŸ—ŸConNF.cloudCode_isEmptyğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudCode_isEmptyğŸ”—` .", "used_premises": [1, 98, 107, 107, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [237, 238], "informalization": "Function `ConNF.Code.IsEmpty.cloudCode` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if a `ConNF.Code` object `c` is empty, then applying the `ConNF.cloudCode` function to `c` with a type index `Î²` that is less than the current level will also result in an empty `ConNF.Code` object."}
{"full_name": "ConNF.cloudCode_injOn", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_injOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudCode_injOn [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Î² : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] :Set.InjOnğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î²) {c : ConNF.Code | c.Î² â‰  â†‘Î² âˆ§ Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— c.members}", "code": "theorem cloudCode_injOn : {c : Code | c.1 â‰  Î² âˆ§ c.members.Nonempty}.InjOn (cloudCode Î²) := by\n  rintro âŸ¨Î³, sâŸ© âŸ¨hÎ³Î², hsâŸ© âŸ¨Î´, tâŸ© âŸ¨hÎ´Î², htâŸ© h\n  rw [cloudCode_ne _ _ hÎ³Î², cloudCode_ne _ _ hÎ´Î²] at h\n  have := (congr_arg_heq Code.members h).eq\n  obtain rfl := cloud_disjoint_range _ _ hs this\n  dsimp only at this\n  rw [cloud_injective this]\n", "additional_info": "", "used_premises": [1, 98, 111, 101, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [239, 246], "informalization": "The theorem `ConNF.cloudCode_injOn` states that the function `ConNF.cloudCode` is injective when restricted to the set of `ConNF.Code` objects `c` such that the level of `c` is not equal to `Î²` and the set of members of `c` is nonempty."}
{"full_name": "Set.InjOn", "url": "Mathlib/Data/Set/Defs.html#Set.InjOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.InjOn {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "def InjOn (f : Î± â†’ Î²) (s : Set Î±) : Prop :=\n  âˆ€ â¦ƒxâ‚ : Î±â¦„, xâ‚ âˆˆ s â†’ âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ s â†’ f xâ‚ = f xâ‚‚ â†’ xâ‚ = xâ‚‚\n", "additional_info": "`f` is injective on `a` if the restriction of `f` to `a` is injective.\nEquations\n* ğŸ—ŸSet.InjOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.InjOnğŸ”—  f s ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒxâ‚ : Î±â¦„, xâ‚ ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s â†’ âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s â†’ f xâ‚ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  f xâ‚‚ â†’ xâ‚ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  xâ‚‚\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [289, 291], "informalization": "Function `Set.InjOn` checks if a function `f` is injective when restricted to a set `s`, meaning that for any `xâ‚, xâ‚‚` in `s`, `f(xâ‚) = f(xâ‚‚)` implies `xâ‚ = xâ‚‚`."}
{"full_name": "ConNF.Î¼_le_mk_cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.Î¼_le_mk_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Î¼_le_mk_cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Î² : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (c : ConNF.Code) (hcÎ² : c.Î² â‰  â†‘Î²) :Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— c.members â†’ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼ â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² c).members", "code": "theorem Î¼_le_mk_cloudCode (c : Code) (hcÎ² : c.1 â‰  Î²) :\n    c.members.Nonempty â†’ #Î¼ â‰¤ #(cloudCode Î² c).members := by\n  rw [cloudCode_ne Î² c hcÎ²]\n  exact Î¼_le_mk_cloud (hÎ³Î² := hcÎ²)\n", "additional_info": "", "used_premises": [1, 98, 83, 29, 29, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [247, 251], "informalization": "This theorem states that, given a `ConNF.Code` object `c` with a level different from `Î²`, and assuming `c` has at least one member, the cardinality of `ConNF.Î¼` (the type of all `ConNF.Code` objects) is less than or equal to the cardinality of the members of the `ConNF.Code` object obtained by applying the `ConNF.cloudCode` function to `Î²` and `c`. The `ConNF.cloudCode` function is defined in such a way that it returns a `ConNF.Code` object with a level equal to `Î²`, and its members are a subset of the members of `c`. The assumption `Set.Nonempty c.members` ensures that `c` has at least one member, which is necessary for the inequality to hold. The `ConNF.Params` class provides the foundation for the Constructive Ordinal Notation (ConNF) system in Lean 4."}
{"full_name": "ConNF.cloudRel_iff", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (c : ConNF.Code) :âˆ€ (a : ConNF.Code), c â†â‚€ a â†” âˆƒ (Î² : ConNF.Î›) (inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²), c.Î² â‰  â†‘Î² âˆ§ a = ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² c", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 98, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [265, 266], "informalization": "`ConNF.cloudRel_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any two `ConNF.Code` objects `c` and `a`, the relation `c â†â‚€ a` holds if and only if there exists a type index `Î²` such that `c.Î²` is not equal to `Î²`, and `a` is equal to the result of applying `ConNF.cloudCode` to `Î²` and `c`."}
{"full_name": "ConNF.cloudRel_subsingleton", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel_subsingleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel_subsingleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} (hc : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— c.members) :Set.SubsingletonğŸ”—<|PREMISE|>ğŸ”— {d : ConNF.Code | d â†â‚€ c}", "code": "theorem cloudRel_subsingleton (hc : c.members.Nonempty) : {d : Code | d â†â‚€ c}.Subsingleton := by\n  intro d hd e he\n  simp only [cloudRel_iff] at hd he\n  obtain âŸ¨Î², hÎ², hdÎ², rflâŸ© := hd\n  obtain âŸ¨Î³, hÎ³, heÎ³, hâŸ© := he\n  have := ((Code.ext_iff _ _).1 h).1\n  simp only [fst_cloudCode, coe_inj] at this\n  subst this\n  refine' cloudCode_injOn âŸ¨hdÎ², cloudCode_nonempty.1 hcâŸ© _ h\n  rw [h] at hc\n  exact âŸ¨heÎ³, cloudCode_nonempty.1 hcâŸ©\n", "additional_info": "", "used_premises": [1, 83, 115], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [271, 282], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel_subsingleton` asserts that the set of all `ConNF.Code` objects that are related to a given `ConNF.Code` object `c` by the `ConNF.cloudRel` relation is a `Set.Subsingleton`. This means that there is at most one `ConNF.Code` object that is related to `c` by the `ConNF.cloudRel` relation."}
{"full_name": "Set.Subsingleton", "url": "Mathlib/Data/Set/Basic.html#Set.Subsingleton", "code_src": "mathlib4", "ptype": "def", "header": "def Set.Subsingleton {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "protected def Subsingleton (s : Set Î±) : Prop :=\n  âˆ€ â¦ƒxâ¦„ (_ : x âˆˆ s) â¦ƒyâ¦„ (_ : y âˆˆ s), x = y\n", "additional_info": "A set `s` is a `ğŸ—ŸSubsingletonğŸ—ŸğŸ”—../../.././Init/Core.html#SubsingletonğŸ”—`  if it has at most one element.\nEquations\n* ğŸ—ŸSet.SubsingletonğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Basic.html#Set.SubsingletonğŸ”—  s ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒx : Î±â¦„, x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s â†’ âˆ€ â¦ƒy : Î±â¦„, y ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s â†’ x ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  y\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Basic.lean", "pos": [2336, 2338], "informalization": "A set is a `Subsingleton` if it contains at most one element."}
{"full_name": "ConNF.cloudRel_cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel_cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Î² : ConNF.Î›) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {c : ConNF.Code} {d : ConNF.Code} (hd : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— d.members) (hdÎ² : d.Î² â‰  â†‘Î²) :c â†â‚€ ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² d â†” c = d", "code": "theorem cloudRel_cloudCode (hd : d.members.Nonempty) (hdÎ² : d.1 â‰  Î²) :\n    c â†â‚€ cloudCode Î² d â†” c = d := by\n  refine'\n    âŸ¨fun h => cloudRel_subsingleton (by rwa [cloudCode_nonempty]) h <| CloudRel.intro _ hdÎ², _âŸ©\n  rintro rfl\n  exact âŸ¨_, hdÎ²âŸ©\n", "additional_info": "", "used_premises": [1, 98, 83, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [283, 289], "informalization": "Function `ConNF.cloudRel_cloudCode` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that given a type index `Î²` and two `ConNF.Code` objects `c` and `d`, if `d` is nonempty and its level does not match `Î²`, then `c` is related to `ConNF.cloudCode Î² d` by the `ConNF.cloudRel` relation if and only if `c` is equal to `d`."}
{"full_name": "ConNF.CloudRel.nonempty_iff", "url": "ConNF/NewTangle/Cloud.html#ConNF.CloudRel.nonempty_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CloudRel.nonempty_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} :c â†â‚€ d â†’ (Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— c.members â†” Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— d.members)", "code": "theorem CloudRel.nonempty_iff : c â†â‚€ d â†’ (c.members.Nonempty â†” d.members.Nonempty) := by\n  rintro âŸ¨Î², hcÎ²âŸ©\n  exact cloudCode_nonempty.symm\n", "additional_info": "", "used_premises": [1, 83, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [290, 293], "informalization": "The theorem `ConNF.CloudRel.nonempty_iff` states that for any two codes `c` and `d` in the context of Constructive Ordinal Notation (ConNF), if there is a relation `c â†â‚€ d` between them, then the set of members of `c` is nonempty if and only if the set of members of `d` is nonempty."}
{"full_name": "ConNF.cloudRelEmptyEmpty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRelEmptyEmpty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRelEmptyEmpty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Î³ : ConNF.TypeIndex) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î³] (Î² : ConNF.Î›) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (hÎ³Î² : Î³ â‰  â†‘Î²) :ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î³ âˆ… â†â‚€ ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— â†‘Î² âˆ…", "code": "theorem cloudRelEmptyEmpty (hÎ³Î² : Î³ â‰  Î²) : mk Î³ âˆ… â†â‚€ mk Î² âˆ… :=\n  (cloudRel_iff _ _).2\n    âŸ¨Î², inferInstance, hÎ³Î², by\n      ext : 1\n      Â· rfl\n      Â· refine heq_of_eq ?_\n        simp only [snd_cloudCode _ (mk Î³ âˆ…) hÎ³Î², cloud_empty]âŸ©\n", "additional_info": "", "used_premises": [1, 98, 98, 104, 104], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [294, 301], "informalization": "Given a set of parameters for Constructive Ordinal Notation, and assuming that a type index `Î³` is less than the current level `Î±`, and another type index `Î²` is also less than `Î±`, and `Î³` is not equal to `Î²`, the theorem `ConNF.cloudRelEmptyEmpty` proves that if there is a tangle of type `Î²` and `Î³` with an empty set of tangles, then there is a tangle of type `Î²` with an empty set of tangles, with the condition that `Î³` is not equal to `Î²`."}
{"full_name": "ConNF.eq_of_cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.eq_of_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.eq_of_cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {Î² : ConNF.Î›} {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (hc : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— c.members) (hcÎ² : c.Î² â‰  â†‘Î²) (hdÎ³ : d.Î² â‰  â†‘Î³) (h : ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î² c = ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ d) :c = d", "code": "theorem eq_of_cloudCode {Î² Î³ : Î›} [LtLevel Î²] [LtLevel Î³]\n    (hc : c.members.Nonempty) (hcÎ² : c.1 â‰  Î²) (hdÎ³ : d.1 â‰  Î³)\n    (h : cloudCode Î² c = cloudCode Î³ d) : c = d := by\n  refine cloudRel_subsingleton (by rwa [cloudCode_nonempty]) (CloudRel.intro _ hcÎ²) ?_\n  rw [h]\n  exact CloudRel.intro _ hdÎ³\n", "additional_info": "", "used_premises": [1, 98, 98, 83, 101, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [302, 308], "informalization": "Given a type index Î² less than the current level and a code object c of a higher level, if c is not equal to Î², then the cloud code operation ConNF.cloudCode Î² c will return a new code object that is not equal to the original code object c. However, if we apply the same cloud code operation to another code object d of the same level but not equal to Î², and the resulting code objects are the same, then the original code objects c and d must also be equal. This theorem formalizes this property in the context of Constructive Ordinal Notation (ConNF) in Lean 4."}
{"full_name": "ConNF.cloudRel_coe_coe", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel_coe_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloudRel_coe_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.NonemptyCode} {d : ConNF.NonemptyCode} :â†‘c â†â‚€ â†‘d â†” c â† d", "code": "theorem cloudRel_coe_coe {c d : NonemptyCode} : (c : Code) â†â‚€ d â†” c â† d := by\n  rw [cloudRel_iff, cloudRel'_iff]\n  aesop\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [319, 322], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel_coe_coe` states that for any two nonempty codes `c` and `d`, the relation `c â† d` holds if and only if the relation `â†‘c â†â‚€ â†‘d` holds, where `â†‘c` and `â†‘d` are the coercions of `c` and `d` to their respective types in the context of ConNF."}
{"full_name": "ConNF.cloud_subrelation", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_subrelation", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloud_subrelation [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :SubrelationğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.NonemptyCode) => x â† x_1) (InvImageğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.Î¼) => x < x_1) ConNF.codeMinMap)", "code": "theorem cloud_subrelation : Subrelation (Â· â† Â·) (InvImage (Â· < Â·) (codeMinMap : NonemptyCode â†’ Î¼))\n  | c, _, CloudRel'.intro Î² hc => codeMinMap_lt_codeMinMap_cloudCode Î² c hc\n", "additional_info": "", "used_premises": [1, 122, 96], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [323, 325], "informalization": "The theorem `ConNF.cloud_subrelation` states that the relation `â†` on `ConNF.NonemptyCode` is a subrelation of the inverse image of the relation `<` on `ConNF.Î¼` under the function `ConNF.codeMinMap`. This means that if `x â† y` holds, then `ConNF.codeMinMap x < ConNF.codeMinMap y` also holds."}
{"full_name": "Subrelation", "url": "Init/Core.html#Subrelation", "code_src": "lean4", "ptype": "def", "header": "def Subrelation {Î± : Sort u} (q : Î± â†’ Î± â†’ Prop ) (r : Î± â†’ Î± â†’ Prop ) :Prop", "code": "def Subrelation {Î± : Sort u} (q r : Î± â†’ Î± â†’ Prop) :=\n  âˆ€ {x y}, q x y â†’ r x y\n", "additional_info": "`ğŸ—ŸSubrelationğŸ—ŸğŸ”—.././Init/Core.html#SubrelationğŸ”—  q ğŸ—ŸrğŸ—ŸğŸ”—.././Init/Core.html#Setoid.rğŸ”—`  means that `q âŠ† ğŸ—ŸrğŸ—ŸğŸ”—.././Init/Core.html#Setoid.rğŸ”—`  or `âˆ€ x y, q x y â†’ ğŸ—ŸrğŸ—ŸğŸ”—.././Init/Core.html#Setoid.rğŸ”—  x y`.\nIt is the analogue of the subset relation on relations.\nEquations\n* ğŸ—ŸSubrelationğŸ—ŸğŸ”—.././Init/Core.html#SubrelationğŸ”—  q r ğŸ—Ÿ=ğŸ—ŸğŸ”—.././Init/Prelude.html#EqğŸ”—  âˆ€ {x y : Î±}, q x y â†’ r x y\n\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [1075, 1077], "informalization": "Function `Subrelation` checks if a relation `q` is a subrelation of another relation `r`, meaning that `q` is always true whenever `r` is true."}
{"full_name": "ConNF.cloudRel'_wellFounded", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel'_wellFounded", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel'_wellFounded [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :WellFoundedğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : ConNF.NonemptyCode) => x â† x_1", "code": "theorem cloudRel'_wellFounded : WellFounded ((Â· â† Â·) : _ â†’ NonemptyCode â†’ Prop) :=\n  cloud_subrelation.wf invImage_codeMinMap_wf\n", "additional_info": "There are only finitely many iterated images under any inverse `ğŸ—ŸcloudğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudğŸ”—`  map.", "used_premises": [1, 19], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [327, 329], "informalization": "The theorem `ConNF.cloudRel'_wellFounded` in Lean 4 establishes that the relation `â†` defined on `ConNF.NonemptyCode` is well-founded. This means that every nonempty set of `ConNF.NonemptyCode` objects has a minimal element with respect to the relation `â†`. The relation `â†` is defined in terms of the `cloud` map, which is a key part of the ConNF (Constructive Notation For Numbers) system, used to express and manipulate natural numbers. The theorem's proof indicates that the iterated images under the `cloud` map (and its inverse) can be shown to be finite, thus ensuring the well-foundedness of the relation `â†`."}
{"full_name": "ConNF.cloudRel'_subsingleton", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel'_subsingleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel'_subsingleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (c : ConNF.NonemptyCode) :Set.SubsingletonğŸ”—<|PREMISE|>ğŸ”— {d : ConNF.NonemptyCode | d â† c}", "code": "theorem cloudRel'_subsingleton (c : NonemptyCode) :\n    {d : NonemptyCode | d â† c}.Subsingleton := by\n  intro d hd e he\n  simp only [Ne.def, cloudRel'_iff, mem_setOf_eq] at hd he\n  obtain âŸ¨Î², hÎ², hdÎ², rflâŸ© := hd\n  obtain âŸ¨Î³, hÎ³, heÎ³, hâŸ© := he\n  rw [Subtype.ext_iff] at h\n  have := ((Code.ext_iff _ _).1 h).1\n  simp only [Subtype.coe_mk, fst_cloudCode, coe_eq_coe] at this\n  subst this\n  exact Subtype.coe_injective (cloudCode_injOn âŸ¨hdÎ², d.2âŸ© âŸ¨heÎ³, e.2âŸ© h)\n", "additional_info": "There is at most one inverse under an `ğŸ—ŸcloudğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudğŸ”—`  map. This corresponds to the fact that there is\nonly one code which is related (on the left) to any given code under the `ğŸ—ŸcloudğŸ—ŸğŸ”—../.././ConNF/NewTangle/Cloud.html#ConNF.cloudğŸ”—`  map relation.", "used_premises": [1, 115], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [335, 346], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel'_subsingleton` states that for any given nonempty code `c`, there is at most one nonempty code `d` such that `d` is related to `c` under the `cloud` map relation."}
{"full_name": "ConNF.Code.ext_iff", "url": "ConNF/NewTangle/Code.html#ConNF.Code.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.ext_iff :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } {inst_1 : ConNF.Level} {inst_2 : ConNF.TangleDataLt} (x y : ConNF.Code), x = y â†” x.Î² = y.Î² âˆ§ HEqğŸ”—<|PREMISE|>ğŸ”— x.members y.members", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 126], "def_path": "ConNF/NewTangle/Code.lean", "pos": [22, 23], "informalization": "The theorem `ConNF.Code.ext_iff` states that two `ConNF.Code` objects are equal if and only if their `Î²` components are equal and their `members` components are equal up to heterogeneous equality (`HEq`)."}
{"full_name": "HEq", "url": "Init/Prelude.html#HEq", "code_src": "lean4", "ptype": "inductive", "header": "inductive HEq {Î± : Sort u} :Î± â†’ {Î² : Sort u} â†’ Î² â†’ Prop", "code": "inductive HEq : {Î± : Sort u} â†’ Î± â†’ {Î² : Sort u} â†’ Î² â†’ Prop where\n  /-- Reflexivity of heterogeneous equality. -/\n  | refl (a : Î±) : HEq a a\n", "additional_info": "Heterogeneous equality. `ğŸ—ŸHEqğŸ—ŸğŸ”—.././Init/Prelude.html#HEqğŸ”—  a b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `ğŸ—ŸEqğŸ—ŸğŸ”—.././Init/Prelude.html#EqğŸ”—` , because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\nimportant non-theorem is the analogue of `ğŸ—ŸcongrğŸ—ŸğŸ”—.././Init/Prelude.html#congrğŸ”—` : If `ğŸ—ŸHEqğŸ—ŸğŸ”—.././Init/Prelude.html#HEqğŸ”—  f g` and `ğŸ—ŸHEqğŸ—ŸğŸ”—.././Init/Prelude.html#HEqğŸ”—  x y`\nand `f x` and `g y` are well typed it does not follow that `ğŸ—ŸHEqğŸ—ŸğŸ”—.././Init/Prelude.html#HEqğŸ”—  (f x) (g y)`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `ğŸ—ŸHEqğŸ—ŸğŸ”—.././Init/Prelude.html#HEqğŸ”—  a b` are equivalent.\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [455, 458], "informalization": "Type `HEq` represents the concept of heterogeneous equality, which states that two objects of different types are considered equal if they have the same structure and properties, despite their types being different."}
{"full_name": "ConNF.Code.ext", "url": "ConNF/NewTangle/Code.html#ConNF.Code.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.ext :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } {inst_1 : ConNF.Level} {inst_2 : ConNF.TangleDataLt} (x y : ConNF.Code), x.Î² = y.Î² â†’ HEqğŸ”—<|PREMISE|>ğŸ”— x.members y.members â†’ x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 126], "def_path": "ConNF/NewTangle/Code.lean", "pos": [22, 23], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Code.ext` states that two `ConNF.Code` objects are equal if their `Î²` components are equal and their `members` components are equal up to heterogeneous equality (`HEq`)."}
{"full_name": "ConNF.Code.IsEmpty.eq", "url": "ConNF/NewTangle/Code.html#ConNF.Code.IsEmpty.eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEmpty.eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] {c : ConNF.Code} :ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— c â†’ c.members = âˆ…", "code": "protected theorem IsEmpty.eq : c.IsEmpty â†’ c.members = âˆ… :=\n  id\n", "additional_info": "", "used_premises": [1, 107], "def_path": "ConNF/NewTangle/Code.lean", "pos": [46, 48], "informalization": "Function `ConNF.Code.IsEmpty.eq` is a theorem in Lean 4 that states that if a `ConNF.Code` object `c` is empty, then the set of members of `c` is equal to the empty set."}
{"full_name": "ConNF.Code.isEmpty_mk", "url": "ConNF/NewTangle/Code.html#ConNF.Code.isEmpty_mk", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEmpty_mk [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] {Î² : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle â†‘Î²)} :ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— (â†‘Î²) s) â†” s = âˆ…", "code": "theorem isEmpty_mk : (mk Î² s).IsEmpty â†” s = âˆ… :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 98, 69, 107, 104], "def_path": "ConNF/NewTangle/Code.lean", "pos": [50, 52], "informalization": "The theorem `ConNF.Code.isEmpty_mk` states that a `ConNF.Code` object is empty if and only if the set of tangles it contains is empty."}
{"full_name": "ConNF.Code.mk_inj", "url": "ConNF/NewTangle/Code.html#ConNF.Code.mk_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.mk_inj [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] {Î² : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle â†‘Î²)} {t : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle â†‘Î²)} :ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— (â†‘Î²) s = ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— (â†‘Î²) t â†” s = t", "code": "theorem mk_inj : mk Î² s = mk Î² t â†” s = t :=\n  by simp only [mk.injEq, heq_eq_eq, true_and]\n", "additional_info": "", "used_premises": [1, 98, 69, 69, 104, 104], "def_path": "ConNF/NewTangle/Code.lean", "pos": [54, 56], "informalization": "The theorem `ConNF.Code.mk_inj` states that for two sets of tangles `s` and `t` of the same type index `Î²` less than the current level `Î±` in the context of Constructive Ordinal Notation (ConNF), the codes `ConNF.Code.mk (â†‘Î²) s` and `ConNF.Code.mk (â†‘Î²) t` are equal if and only if the sets `s` and `t` are equal."}
{"full_name": "ConNF.SemiallowablePerm.mul_apply", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.mul_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.mul_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] (Î² : ConNF.TypeIndex) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï : ConNF.SemiallowablePerm) (Ï' : ConNF.SemiallowablePerm) :(Ï * Ï') Î² = Ï Î² * Ï' Î²", "code": "theorem mul_apply (Ï Ï' : SemiallowablePerm) :\n    (Ï * Ï') Î² = Ï Î² * Ï' Î² :=\n  rfl\n", "additional_info": "", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [48, 51], "informalization": "The `ConNF.SemiallowablePerm.mul_apply` theorem states that the application of the product of two semiallowable permutations `Ï` and `Ï'` to a type index `Î²` is equal to the product of the applications of `Ï` and `Ï'` to `Î²`."}
{"full_name": "ConNF.SemiallowablePerm.inv_apply", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.inv_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.inv_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] (Î² : ConNF.TypeIndex) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï : ConNF.SemiallowablePerm) :Ïâ»Â¹ Î² = (Ï Î²)â»Â¹", "code": "theorem inv_apply :\n    Ïâ»Â¹ Î² = (Ï Î²)â»Â¹ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [53, 56], "informalization": "The theorem `ConNF.SemiallowablePerm.inv_apply` states that for any semiallowable permutation `Ï` and any type index `Î²` less than the current level, the inverse of `Ï` applied to `Î²` is equal to the inverse of `Ï` applied to `Î²`."}
{"full_name": "ConNF.SemiallowablePerm.pathTop_toPath_comp", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop_toPath_comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.SemiallowablePerm.pathTop_toPath_comp {V : Type u_2} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {x : V} {y : V} {z : V} (e : x âŸ¶ y) (p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— y z) :ConNF.SemiallowablePerm.pathTopğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”— e) p) = y", "code": "theorem pathTop_toPath_comp {x y z : V} (e : x âŸ¶ y) (p : Quiver.Path y z) :\n    pathTop ((e.toPath).comp p) = y := by\n  induction p with\n  | nil => rfl\n  | cons p f ih =>\n    cases p with\n    | nil => rfl\n    | cons p g => exact ih\n", "additional_info": "", "used_premises": [75, 76, 134, 135, 74], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [75, 83], "informalization": "Function `ConNF.SemiallowablePerm.pathTop` takes a path in a quiver from vertex `x` to vertex `y` and returns the second vertex in the path if the path is nonempty, or `y` if the path is empty. Function `Quiver.Path.comp` composes two paths in a quiver. Given a path from vertex `a` to vertex `b` and a path from vertex `b` to vertex `c`, it returns a path from vertex `a` to vertex `c`. Function `Quiver.Hom.toPath` converts a single arrow in a quiver into a path of length one. The theorem `ConNF.SemiallowablePerm.pathTop_toPath_comp` states that if `e` is an arrow from vertex `x` to vertex `y`, and `p` is a path from vertex `y` to vertex `z`, then `ConNF.SemiallowablePerm.pathTop (Quiver.Path.comp (Quiver.Hom.toPath e) p) = y`."}
{"full_name": "ConNF.SemiallowablePerm.pathTop", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.pathTop {V : Type u_1} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {x : V} {y : V} :Quiver.PathğŸ”—<|PREMISE|>ğŸ”— x y â†’ V", "code": "def pathTop {x y : V} : Quiver.Path x y â†’ V\n| Quiver.Path.cons Quiver.Path.nil e => y\n| Quiver.Path.cons (Quiver.Path.cons p e) _ => pathTop (Quiver.Path.cons p e)\n| Quiver.Path.nil => y\n", "additional_info": "If the path is nonempty, extract the second element of the path.\nThis requires induction over paths because paths in quivers are expressed with their `cons`\noperation at the end, not the start.\nEquations\n* ğŸ—ŸConNF.SemiallowablePerm.pathTopğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTopğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  Quiver.Path.nil e) ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  y\n* ğŸ—ŸConNF.SemiallowablePerm.pathTopğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTopğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  p e) a) ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.SemiallowablePerm.pathTopğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTopğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  p e)\n* ğŸ—ŸConNF.SemiallowablePerm.pathTopğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTopğŸ”—  Quiver.Path.nil ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  x\n\n", "used_premises": [75, 76], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [70, 74], "informalization": "Function `ConNF.SemiallowablePerm.pathTop` takes a path in a quiver from vertex `x` to vertex `y` and returns the second vertex in the path if the path is nonempty, or `y` if the path is empty."}
{"full_name": "Quiver.Path.comp", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.comp", "code_src": "mathlib4", "ptype": "def", "header": "def Quiver.Path.comp {V : Type u} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {a : V} {b : V} {c : V} :Quiver.PathğŸ”—<|PREMISE|>ğŸ”— a b â†’ Quiver.PathğŸ”—<|PREMISE|>ğŸ”— b c â†’ Quiver.PathğŸ”—<|PREMISE|>ğŸ”— a c", "code": "def comp {a b : V} : âˆ€ {c}, Path a b â†’ Path b c â†’ Path a c\n  | _, p, nil => p\n  | _, p, cons q e => (p.comp q).cons e\n", "additional_info": "Composition of paths.\nEquations\n* ğŸ—ŸQuiver.Path.compğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.compğŸ”—  x Quiver.Path.nil ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  x\n* ğŸ—ŸQuiver.Path.compğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.compğŸ”—  x (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  q e) ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  (ğŸ—ŸQuiver.Path.compğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.compğŸ”—  x q) e\n\n", "used_premises": [75, 76, 76, 76], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [87, 90], "informalization": "Function `Quiver.Path.comp` composes two paths in a quiver. Given a path from vertex `a` to vertex `b` and a path from vertex `b` to vertex `c`, it returns a path from vertex `a` to vertex `c`."}
{"full_name": "ConNF.SemiallowablePerm.pathTop_pathTail", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop_pathTail", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.SemiallowablePerm.pathTop_pathTail {V : Type u_2} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {x : V} {y : V} (p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— x y) (h : Quiver.Path.lengthğŸ”—<|PREMISE|>ğŸ”— p â‰  0) :Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”— (ConNF.SemiallowablePerm.pathTop_homğŸ”—<|PREMISE|>ğŸ”— p h)) (ConNF.SemiallowablePerm.pathTailğŸ”—<|PREMISE|>ğŸ”— p) = p", "code": "theorem pathTop_pathTail {x y : V} (p : Quiver.Path x y) (h : p.length â‰  0) :\n    (Quiver.Hom.toPath (pathTop_hom p h)).comp (pathTail p) = p := by\n  induction p with\n  | nil => cases h rfl\n  | cons p e ih =>\n    cases p with\n    | nil => rfl\n    | cons p e => simp_rw [â† ih (by simp)]; rfl\n", "additional_info": "We can remove the first morphism from a path and compose it back to form the original path.", "used_premises": [75, 76, 137, 135, 74, 138, 139], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [104, 112], "informalization": "The theorem `ConNF.SemiallowablePerm.pathTop_pathTail` states that given a path `p` from vertex `x` to vertex `y` in a quiver, if the length of `p` is not zero (meaning `p` is not a trivial path), then we can remove the first morphism from `p` and compose it back to form the original path `p`."}
{"full_name": "Quiver.Path.length", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.length", "code_src": "mathlib4", "ptype": "def", "header": "def Quiver.Path.length {V : Type u} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {a : V} {b : V} :Quiver.PathğŸ”—<|PREMISE|>ğŸ”— a b â†’ â„•", "code": "def length {a : V} : âˆ€ {b : V}, Path a b â†’ â„•\n  | _, nil => 0\n  | _, cons p _ => p.length + 1\n", "additional_info": "The length of a path is the number of arrows it uses.\nEquations\n* ğŸ—ŸQuiver.Path.lengthğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.lengthğŸ”—  Quiver.Path.nil ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  0\n* ğŸ—ŸQuiver.Path.lengthğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.lengthğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  p a_1) ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸQuiver.Path.lengthğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.lengthğŸ”—  p ğŸ—Ÿ+ğŸ—ŸğŸ”—../../.././Init/Prelude.html#HAdd.hAddğŸ”—  1\n\n", "used_premises": [75, 76], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [62, 65], "informalization": "Function `Quiver.Path.length` calculates the length of a path in a quiver, which is defined as the number of arrows in the path. For a trivial path (`nil`), the length is 0, and for a path extended by an arrow (`cons`), the length is the length of the previous path plus 1."}
{"full_name": "ConNF.SemiallowablePerm.pathTop_hom", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop_hom", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.pathTop_hom {V : Type u_1} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {x : V} {y : V} (p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— x y) (h : Quiver.Path.lengthğŸ”—<|PREMISE|>ğŸ”— p â‰  0) :x âŸ¶ ConNF.SemiallowablePerm.pathTopğŸ”—<|PREMISE|>ğŸ”— p", "code": "def pathTop_hom {x y : V} (p : Quiver.Path x y) (h : p.length â‰  0) : x âŸ¶ pathTop p :=\n  Quiver.Path.rec\n    (fun h => (h rfl).elim)\n    (fun {y z} p e ih _ => Quiver.Path.rec\n      (motive := fun {y} p =>\n        (e : y âŸ¶ z) â†’\n        (ih : Quiver.Path.length p â‰  0 â†’ (x âŸ¶ pathTop p)) â†’\n        x âŸ¶ pathTop (Quiver.Path.cons p e))\n      (fun e _ => e)\n      (fun {v w} p _ _ _ ih => ih (by simp))\n      p e ih)\n    p h\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [75, 76, 137, 134], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [84, 96], "informalization": "Function `ConNF.SemiallowablePerm.pathTop_hom` takes a path in a quiver from vertex `x` to vertex `y` and returns the second vertex in the path if the path is nonempty, or `y` if the path is empty."}
{"full_name": "ConNF.SemiallowablePerm.pathTail", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTail", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.pathTail {V : Type u_1} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {x : V} {y : V} (p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— x y) :Quiver.PathğŸ”—<|PREMISE|>ğŸ”— (ConNF.SemiallowablePerm.pathTopğŸ”—<|PREMISE|>ğŸ”— p) y", "code": "def pathTail {x : V} : {y : V} â†’ (p : Quiver.Path x y) â†’ Quiver.Path (pathTop p) y\n| _, Quiver.Path.cons Quiver.Path.nil _ => Quiver.Path.nil\n| _, Quiver.Path.cons (Quiver.Path.cons p e) f => (pathTail (Quiver.Path.cons p e)).cons f\n| _, Quiver.Path.nil => Quiver.Path.nil\n", "additional_info": "Extract the portion of the path after the first morphism.\nEquations\n* ğŸ—ŸConNF.SemiallowablePerm.pathTailğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTailğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  Quiver.Path.nil e) ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  Quiver.Path.nil\n* ğŸ—ŸConNF.SemiallowablePerm.pathTailğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTailğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  p e) a) ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  (ğŸ—ŸConNF.SemiallowablePerm.pathTailğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTailğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  p e)) a\n* ğŸ—ŸConNF.SemiallowablePerm.pathTailğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTailğŸ”—  Quiver.Path.nil ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  Quiver.Path.nil\n\n", "used_premises": [75, 76, 76, 134], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [98, 102], "informalization": "Function `ConNF.SemiallowablePerm.pathTail` takes a path in a quiver from vertex `x` to vertex `y` and returns the portion of the path after the first morphism."}
{"full_name": "ConNF.SemiallowablePerm.toStructPerm'_one", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.toStructPerm'_one", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.SemiallowablePerm.toStructPerm'_one [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] :ConNF.SemiallowablePerm.toStructPerm'ğŸ”—<|PREMISE|>ğŸ”— 1 = 1", "code": "theorem toStructPerm'_one : (toStructPerm' 1 : StructPerm Î±) = 1 := by\n  funext A\n  rw [toStructPerm', one_apply, map_one]\n  rfl\n", "additional_info": "", "used_premises": [1, 141], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [128, 132], "informalization": "The theorem `ConNF.SemiallowablePerm.toStructPerm'_one` states that the function `ConNF.SemiallowablePerm.toStructPerm'`, which converts a semi-allowable permutation to a structural permutation in the context of Constructive Ordinal Notation (ConNF), maps the identity permutation to itself."}
{"full_name": "ConNF.SemiallowablePerm.toStructPerm'", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.toStructPerm'", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.toStructPerm' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] (Ï : ConNF.SemiallowablePerm) :ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±", "code": "def toStructPerm' (Ï : SemiallowablePerm) : StructPerm Î± :=\n  fun A => Allowable.toStructPerm (Ï (pathTop A)) (pathTail A)\n", "additional_info": "Convert a semi-allowable permutation to a structural permutation.\nTo work out the `A`-derivative, we extract the first morphism in the path `A` and use it to\ndetermine which of the `Î²`-allowable permutations in `Ï` we will use.\nEquations\n* ğŸ—ŸConNF.SemiallowablePerm.toStructPerm'ğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.toStructPerm'ğŸ”—  Ï A ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ConNF.Allowable.toStructPerm (Ï (ğŸ—ŸConNF.SemiallowablePerm.pathTopğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTopğŸ”—  A)) (ğŸ—ŸConNF.SemiallowablePerm.pathTailğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTailğŸ”—  A)\n\n", "used_premises": [1, 55], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [125, 127], "informalization": "Function `ConNF.SemiallowablePerm.toStructPerm'` converts a semi-allowable permutation to a structural permutation in the context of Constructive Ordinal Notation (ConNF). It takes a semi-allowable permutation `Ï` and converts it into a tree of near-litter permutations, which represents how the permutation acts along each path down the type levels in the model."}
{"full_name": "ConNF.SemiallowablePerm.toStructPerm_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.toStructPerm_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.toStructPerm_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±) X] (Ï : ConNF.SemiallowablePerm) (x : X) :Ï â€¢ x = ConNF.SemiallowablePerm.toStructPerm Ï â€¢ x", "code": "theorem toStructPerm_smul (Ï : SemiallowablePerm) (x : X) :\n    Ï â€¢ x = SemiallowablePerm.toStructPerm Ï â€¢ x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 56, 55], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [160, 163], "informalization": "The theorem `ConNF.SemiallowablePerm.toStructPerm_smul` states that the action of a semiallowable permutation `Ï` on an element `x` of a type `X` with a multiplicative action by structural permutations is equal to the action of the corresponding structural permutation `ConNF.SemiallowablePerm.toStructPerm Ï` on `x`."}
{"full_name": "ConNF.SemiallowablePerm.Î²_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.Î²_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.Î²_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] (Ï : ConNF.SemiallowablePerm) (c : ConNF.Code) :(Ï â€¢ c).Î² = c.Î²", "code": "theorem Î²_smul : (Ï â€¢ c).Î² = c.Î² :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [175, 177], "informalization": "The theorem `ConNF.SemiallowablePerm.Î²_smul` states that for any semiallowable permutation `Ï` and any code `c`, the `Î²` value of `Ï` acting on `c` is equal to the `Î²` value of `c`."}
{"full_name": "ConNF.SemiallowablePerm.coe_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.coe_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.coe_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] (Ï : ConNF.SemiallowablePerm) (c : ConNF.NonemptyCode) :â†‘(Ï â€¢ c) = Ï â€¢ â†‘c", "code": "theorem coe_smul (c : NonemptyCode) : (â†‘(Ï â€¢ c) : Code) = Ï â€¢ (c : Code) :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [191, 193], "informalization": "The theorem `ConNF.SemiallowablePerm.coe_smul` states that for any semiallowable permutation `Ï` and any nonempty code `c`, the action of `Ï` on `c` (denoted as `Ï â€¢ c`) is equal to the action of `Ï` on the underlying value of `c` (denoted as `Ï â€¢ â†‘c`)."}
{"full_name": "ConNF.isAllowable_one", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_one", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_one [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— 1", "code": "theorem isAllowable_one : (1 : SemiallowablePerm).IsAllowable := by\n  intro\n  simp only [ne_eq, SemiallowablePerm.one_apply, map_one, Tree.one_apply, one_smul, implies_true]\n", "additional_info": "", "used_premises": [1, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [209, 212], "informalization": "The theorem `ConNF.isAllowable_one` states that the semiallowable permutation `1` is allowable in the context of Constructive Ordinal Notation (ConNF). A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutation `1` behaves consistently with the `fuzz` maps across different levels of the ConNF hierarchy."}
{"full_name": "ConNF.SemiallowablePerm.IsAllowable", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.IsAllowable", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.IsAllowable [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.SemiallowablePerm) :Prop", "code": "def SemiallowablePerm.IsAllowable (Ï : SemiallowablePerm) : Prop :=\n  âˆ€ â¦ƒÎ² : TypeIndexâ¦„ [LtLevel Î²] â¦ƒÎ³ : Î›â¦„ [LtLevel Î³] (hÎ²Î³ : Î² â‰  Î³) (t : Tangle Î²),\n  Allowable.toStructPerm (Ï Î³) (Quiver.Hom.toPath <| bot_lt_coe _) â€¢ fuzz hÎ²Î³ t = fuzz hÎ²Î³ (Ï Î² â€¢ t)\n", "additional_info": "We say that a semiallowable permutation is allowable if its one-step derivatives commute with\nthe `fuzz` maps.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [203, 206], "informalization": "Function `ConNF.SemiallowablePerm.IsAllowable` checks if a semiallowable permutation `Ï` in the context of Constructive Ordinal Notation (ConNF) is allowable. A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutation `Ï` behaves consistently with the `fuzz` maps across different levels of the ConNF hierarchy."}
{"full_name": "ConNF.isAllowable_inv", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_inv [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ï) :ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ïâ»Â¹", "code": "theorem isAllowable_inv (h : Ï.IsAllowable) : Ïâ»Â¹.IsAllowable := by\n  intros Î² _ Î³ _ hÎ²Î³ t\n  have := h hÎ²Î³ (Ïâ»Â¹ Î² â€¢ t)\n  simp only [SemiallowablePerm.inv_apply, smul_inv_smul] at this\n  rw [â† this]\n  simp only [SemiallowablePerm.inv_apply, map_inv, Tree.inv_apply, inv_smul_smul]\n", "additional_info": "", "used_premises": [1, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [213, 219], "informalization": "Given a semiallowable permutation `Ï` in the context of Constructive Ordinal Notation (ConNF), if `Ï` is allowable, then its inverse `Ïâ»Â¹` is also allowable."}
{"full_name": "ConNF.isAllowable_mul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_mul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_mul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.SemiallowablePerm} {Ï' : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ï) (h' : ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ï') :ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— (Ï * Ï')", "code": "theorem isAllowable_mul (h : Ï.IsAllowable) (h' : Ï'.IsAllowable) : (Ï * Ï').IsAllowable := by\n  intros Î² _ Î³ _ hÎ²Î³ t\n  simp only [SemiallowablePerm.mul_apply, map_mul, Tree.mul_apply, mul_smul]\n  rw [h' hÎ²Î³ t, h hÎ²Î³ (Ï' Î² â€¢ t)]\n", "additional_info": "", "used_premises": [1, 146, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [220, 224], "informalization": "Function `ConNF.isAllowable_mul` proves that the product of two allowable semiallowable permutations in the context of Constructive Ordinal Notation (ConNF) is also allowable. A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutations behave consistently with the `fuzz` maps across different levels of the ConNF hierarchy."}
{"full_name": "ConNF.isAllowable_div", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_div", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_div [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.SemiallowablePerm} {Ï' : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ï) (h' : ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ï') :ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— (Ï / Ï')", "code": "theorem isAllowable_div (h : Ï.IsAllowable) (h' : Ï'.IsAllowable) : (Ï / Ï').IsAllowable := by\n  rw [div_eq_mul_inv]\n  exact isAllowable_mul h (isAllowable_inv h')\n", "additional_info": "", "used_premises": [1, 146, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [225, 228], "informalization": "Function `ConNF.SemiallowablePerm.IsAllowable` checks if a semiallowable permutation `Ï` in the context of Constructive Ordinal Notation (ConNF) is allowable. A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutation `Ï` behaves consistently with the `fuzz` maps across different levels of the ConNF hierarchy. The theorem `ConNF.isAllowable_div` states that if `Ï` and `Ï'` are both allowable semiallowable permutations, then their quotient `Ï / Ï'` is also allowable."}
{"full_name": "ConNF.isAllowable_pow", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_pow", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_pow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ï) (n : â„• ) :ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— (Ï ^ n)", "code": "theorem isAllowable_pow (h : Ï.IsAllowable) (n : â„•) : (Ï ^ n).IsAllowable := by\n  induction n with\n  | zero =>\n    rw [pow_zero]\n    exact isAllowable_one\n  | succ n ih =>\n    rw [pow_succ]\n    exact isAllowable_mul h ih\n", "additional_info": "", "used_premises": [1, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [229, 237], "informalization": "The theorem `ConNF.isAllowable_pow` states that if `Ï` is an allowable semiallowable permutation in the context of Constructive Ordinal Notation (ConNF), then any power of `Ï` is also allowable."}
{"full_name": "ConNF.isAllowable_zpow", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_zpow", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_zpow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ï) (n : â„¤ ) :ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— (Ï ^ n)", "code": "theorem isAllowable_zpow (h : Ï.IsAllowable) (n : â„¤) : (Ï ^ n).IsAllowable := by\n  cases n with\n  | ofNat n =>\n    rw [Int.ofNat_eq_coe, zpow_coe_nat]\n    exact isAllowable_pow h n\n  | negSucc n =>\n    rw [zpow_negSucc]\n    exact isAllowable_inv (isAllowable_pow h (n + 1))\n", "additional_info": "", "used_premises": [1, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [238, 246], "informalization": "The theorem `ConNF.isAllowable_zpow` states that if `Ï` is an allowable semiallowable permutation in the context of Constructive Ordinal Notation (ConNF), then `Ï` raised to any integer power `n` is also an allowable semiallowable permutation."}
{"full_name": "ConNF.NewAllowable.coe_one", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_one", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_one [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :â†‘1 = 1", "code": "theorem coe_one : ((1 : NewAllowable) : SemiallowablePerm) = 1 :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [281, 283], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.coe_one` states that the natural number 1, when coerced into the type `ConNF.NewAllowable`, is equal to 1. This theorem is marked as `simp` in Lean, indicating that it can be used as a simplification rule."}
{"full_name": "ConNF.NewAllowable.coe_inv", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_inv [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.NewAllowable) :â†‘Ïâ»Â¹ = (â†‘Ï)â»Â¹", "code": "theorem coe_inv (Ï : NewAllowable) : â†‘(Ïâ»Â¹) = (Ï : SemiallowablePerm)â»Â¹ :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [285, 287], "informalization": "The theorem `ConNF.NewAllowable.coe_inv` states that the inverse of a `ConNF.NewAllowable` object, when coerced to a real number, is equal to the inverse of the real number obtained by coercing the `ConNF.NewAllowable` object."}
{"full_name": "ConNF.NewAllowable.coe_mul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_mul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_mul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.NewAllowable) (Ï' : ConNF.NewAllowable) :â†‘(Ï * Ï') = â†‘Ï * â†‘Ï'", "code": "theorem coe_mul (Ï Ï' : NewAllowable) : â†‘(Ï * Ï') = (Ï : SemiallowablePerm) * Ï' :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [289, 291], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.coe_mul` states that the natural number representation of the product of two `ConNF.NewAllowable` objects is equal to the product of their natural number representations."}
{"full_name": "ConNF.NewAllowable.coe_div", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_div", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_div [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.NewAllowable) (Ï' : ConNF.NewAllowable) :â†‘(Ï / Ï') = â†‘Ï / â†‘Ï'", "code": "theorem coe_div (Ï Ï' : NewAllowable) : â†‘(Ï / Ï') = (Ï : SemiallowablePerm) / Ï' :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [293, 295], "informalization": "The theorem `ConNF.NewAllowable.coe_div` states that the natural number representation of the division of two `ConNF.NewAllowable` objects is equal to the division of their natural number representations."}
{"full_name": "ConNF.NewAllowable.coe_pow", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_pow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_pow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.NewAllowable) (n : â„• ) :â†‘(Ï ^ n) = â†‘Ï ^ n", "code": "theorem coe_pow (Ï : NewAllowable) (n : â„•) : â†‘(Ï ^ n) = (Ï : SemiallowablePerm) ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [297, 299], "informalization": "The theorem `ConNF.NewAllowable.coe_pow` states that for any `ConNF.NewAllowable` object `Ï` and any natural number `n`, the `n`th power of `Ï` (denoted as `Ï ^ n`) is equal to the `n`th power of the underlying value of `Ï` (denoted as `â†‘Ï ^ n`)."}
{"full_name": "ConNF.NewAllowable.coe_zpow", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_zpow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_zpow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.NewAllowable) (n : â„¤ ) :â†‘(Ï ^ n) = â†‘Ï ^ n", "code": "theorem coe_zpow (Ï : NewAllowable) (n : â„¤) : â†‘(Ï ^ n) = (Ï : SemiallowablePerm) ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [301, 303], "informalization": "The theorem `ConNF.NewAllowable.coe_zpow` states that for any `ConNF.NewAllowable` object `Ï` and any integer `n`, the natural number representation of `Ï` raised to the power `n` is equal to the natural number representation of `Ï` raised to the power `n`."}
{"full_name": "ConNF.NewAllowable.coeHom_apply", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coeHom_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coeHom_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (self : { Ï : ConNF.SemiallowablePerm // ConNF.SemiallowablePerm.IsAllowableğŸ”—<|PREMISE|>ğŸ”— Ï }) :ConNF.NewAllowable.coeHom self = â†‘self", "code": "@[simps]\n", "additional_info": "", "used_premises": [1, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [315, 316], "informalization": "Function `ConNF.NewAllowable.coeHom_apply` is a simplification theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for a semiallowable permutation `Ï` that is allowable (i.e., its one-step derivatives commute with the `fuzz` maps), the function `ConNF.NewAllowable.coeHom` applied to `Ï` simply returns `Ï` itself."}
{"full_name": "ConNF.NewAllowable.coe_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— ConNF.SemiallowablePerm X] (Ï : ConNF.NewAllowable) (x : X) :â†‘Ï â€¢ x = Ï â€¢ x", "code": "theorem coe_smul (Ï : NewAllowable) (x : X) : (Ï : SemiallowablePerm) â€¢ x = Ï â€¢ x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 56], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [334, 336], "informalization": "The theorem `ConNF.NewAllowable.coe_smul` is a simplication lemma in Lean 4. It states that for any `ConNF.NewAllowable` object `Ï` and any type `X` with a `MulAction` of `ConNF.SemiallowablePerm` on `X`, the action of `Ï` on `x : X` is the same whether `Ï` is considered as an element of `ConNF.NewAllowable` or as an element of `ConNF.SemiallowablePerm`."}
{"full_name": "ConNF.NewAllowable.Î²_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.Î²_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.Î²_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.NewAllowable) (c : ConNF.Code) :(Ï â€¢ c).Î² = c.Î²", "code": "theorem Î²_smul (Ï : NewAllowable) (c : Code) : (Ï â€¢ c).Î² = c.Î² :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [347, 349], "informalization": "The theorem `ConNF.NewAllowable.Î²_smul` states that for any `ConNF.NewAllowable` object `Ï` and any `ConNF.Code` object `c`, the `Î²` component of the `ConNF.Code` object `(Ï â€¢ c)` is equal to the `Î²` component of `c`."}
{"full_name": "ConNF.NewAllowable.smul_cloudCode", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.smul_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NewAllowable.smul_cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} (Ï : ConNF.NewAllowable) (hc : c.Î² â‰  â†‘Î³) :Ï â€¢ ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ c = ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ (Ï â€¢ c)", "code": "theorem smul_cloudCode (Ï : NewAllowable) (hc : c.1 â‰  Î³) :\n    Ï â€¢ cloudCode Î³ c = cloudCode Î³ (Ï â€¢ c) := by\n  simp only [cloudCode_ne Î³ c hc, smul_mk, cloudCode_ne Î³ (Ï â€¢ c) hc, Î²_smul, members_smul, mk_inj]\n  rw [smul_cloud]\n", "additional_info": "Allowable permutations commute with the `cloudCode` map.", "used_premises": [1, 98, 101, 101], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [385, 389], "informalization": "Function `ConNF.NewAllowable.smul_cloudCode` proves that allowable permutations commute with the `cloudCode` map in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.CloudRel.smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.CloudRel.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CloudRel.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {c : ConNF.Code} {d : ConNF.Code} :c â†â‚€ d â†’ Ï â€¢ c â†â‚€ Ï â€¢ d", "code": "theorem CloudRel.smul : c â†â‚€ d â†’ Ï â€¢ c â†â‚€ Ï â€¢ d := by\n  rintro âŸ¨Î³, hÎ³âŸ©\n  exact (cloudRel_iff _ _).2 âŸ¨_, inferInstance, hÎ³, Ï.smul_cloudCode hÎ³âŸ©\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [392, 395], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CloudRel.smul` states that if there is a relation `c â†â‚€ d` between two codes `c` and `d`, then there is also a relation `Ï â€¢ c â†â‚€ Ï â€¢ d` between the codes obtained by multiplying `c` and `d` by a new allowable `Ï`."}
{"full_name": "ConNF.smul_cloudRel", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.smul_cloudRel", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.smul_cloudRel [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {c : ConNF.Code} {d : ConNF.Code} :Ï â€¢ c â†â‚€ Ï â€¢ d â†” c â†â‚€ d", "code": "theorem smul_cloudRel : Ï â€¢ c â†â‚€ Ï â€¢ d â†” c â†â‚€ d := by\n  refine âŸ¨fun h => ?_, CloudRel.smulâŸ©\n  rw [â† inv_smul_smul Ï c, â† inv_smul_smul Ï d]\n  exact h.smul\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [397, 401], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.smul_cloudRel` states that for any `ConNF.NewAllowable` object `Ï` and any two `ConNF.Code` objects `c` and `d`, the relation `Ï â€¢ c â†â‚€ Ï â€¢ d` holds if and only if the relation `c â†â‚€ d` holds. This theorem simplifies the manipulation of the `ConNF.smul` operation on `ConNF.Code` objects."}
{"full_name": "ConNF.Code.isEven_smul_nonempty", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isEven_smul_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven_smul_nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} (c : ConNF.NonemptyCode) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ â†‘c) â†” ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— â†‘c", "code": "theorem isEven_smul_nonempty : âˆ€ c : NonemptyCode, (Ï â€¢ c.val).IsEven â†” c.val.IsEven\n  | âŸ¨c, hcâŸ© => by\n    simp_rw [Code.isEven_iff]\n    constructor <;> intro h d hd\n    Â· have := hd.nonempty_iff.2 hc\n      have _ : âŸ¨d, thisâŸ© â† âŸ¨c, hcâŸ© := cloudRel_coe_coe.1 hd\n      exact Code.not_isEven.1 fun H =>\n        (h _ hd.smul).not_isEven <| (isEven_smul_nonempty âŸ¨d, thisâŸ©).2 H\n    Â· rw [â† smul_inv_smul Ï d] at hd âŠ¢\n      rw [smul_cloudRel] at hd\n      have := hd.nonempty_iff.2 hc\n      have _ : âŸ¨_, thisâŸ© â† âŸ¨c, hcâŸ© := cloudRel_coe_coe.1 hd\n      exact Code.not_isEven.1 fun H =>\n        (h _ hd).not_isEven <| (isEven_smul_nonempty âŸ¨_, thisâŸ©).1 H\ntermination_by c => c\n", "additional_info": "", "used_premises": [1, 165, 165], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [404, 419], "informalization": "The theorem `ConNF.Code.isEven_smul_nonempty` states that for a nonempty code `c` in the context of Constructive Ordinal Notation (ConNF), the code `Ï â€¢ c` is even if and only if `c` is even."}
{"full_name": "ConNF.Code.IsEven", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEven", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Code.IsEven [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code â†’ Prop", "code": "  inductive IsEven : Code â†’ Prop\n    | intro : âˆ€ c, (âˆ€ d, d â†â‚€ c â†’ IsOdd d) â†’ IsEven c\n", "additional_info": "A code is even iff it only leads to odd codes.\n", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [58, 60], "informalization": "Type `ConNF.Code.IsEven` represents a property of codes in the context of Constructive Ordinal Notation (ConNF), where a code is considered even if it only leads to odd codes."}
{"full_name": "ConNF.Code.isEven_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isEven_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ c) â†” ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c", "code": "theorem isEven_smul : (Ï â€¢ c).IsEven â†” c.IsEven := by\n  obtain (h | h) := c.members.eq_empty_or_nonempty\n  Â· rw [IsEmpty.isEven_iff h, IsEmpty.isEven_iff]\n    Â· rfl\n    simpa [Code.IsEmpty]\n  Â· exact isEven_smul_nonempty âŸ¨c, hâŸ©\n", "additional_info": "", "used_premises": [1, 165, 165], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [421, 427], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_smul` states that the property of being an even code is preserved under the operation of multiplying a code by a new allowable term."}
{"full_name": "ConNF.Code.isOdd_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isOdd_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isOdd_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ c) â†” ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c", "code": "theorem isOdd_smul : (Ï â€¢ c).IsOdd â†” c.IsOdd := by simp_rw [â† Code.not_isEven, isEven_smul]\n", "additional_info": "", "used_premises": [1, 168, 168], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [429, 430], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.isOdd_smul` states that for any `ConNF.NewAllowable` `Ï` and `ConNF.Code` `c`, the `ConNF.Code` `Ï â€¢ c` is `IsOdd` if and only if `c` is `IsOdd`."}
{"full_name": "ConNF.Code.IsOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsOdd", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Code.IsOdd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code â†’ Prop", "code": "  inductive IsOdd : Code â†’ Prop\n    | intro : âˆ€ c d, d â†â‚€ c â†’ IsEven d â†’ IsOdd c\n", "additional_info": "A code is odd iff it leads to some even code.\n", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [63, 65], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`."}
{"full_name": "ConNF.Code.isEven.smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isEven.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c â†’ ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ c)", "code": "alias âŸ¨_, isEven.smulâŸ© := isEven_smul\n", "additional_info": "**Alias** of the reverse direction of `ğŸ—ŸConNF.Code.isEven_smulğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.Code.isEven_smulğŸ”—` .", "used_premises": [1, 165, 165], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [431, 432], "informalization": "`ConNF.Code.isEven.smul` is a theorem that states that if a code `c` is even, then the result of applying the `smul` operation (which scales a code by a factor) to `c` with a new allowable `Ï` will also result in an even code. This is derived from the fact that applying `smul` to an even code will not change its parity, as `smul` only scales the code and does not change its property of being even."}
{"full_name": "ConNF.Code.isOdd.smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isOdd.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isOdd.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c â†’ ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ c)", "code": "alias âŸ¨_, isOdd.smulâŸ© := isOdd_smul\n", "additional_info": "**Alias** of the reverse direction of `ğŸ—ŸConNF.Code.isOdd_smulğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewAllowable.html#ConNF.Code.isOdd_smulğŸ”—` .", "used_premises": [1, 168, 168], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [433, 434], "informalization": "The statement represents that if a `ConNF.Code` is `IsOdd`, then when it is scaled by a `ConNF.NewAllowable` (denoted as `Ï â€¢ c`), the resulting code is also `IsOdd`. This is an important property in understanding the behavior of Constructive Ordinal Notation (ConNF) codes under multiplication."}
{"full_name": "ConNF.Code.isEven_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :âˆ€ (a : ConNF.Code), ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— a â†” âˆ€ (d : ConNF.Code), d â†â‚€ a â†’ ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— d", "code": "  @[mk_iff]\n", "additional_info": "", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [57, 58], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_iff` states that a code `a` is even if and only if every code `d` that leads to `a` is odd."}
{"full_name": "ConNF.Code.isOdd_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isOdd_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isOdd_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :âˆ€ (a : ConNF.Code), ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— a â†” âˆƒ (d : ConNF.Code), d â†â‚€ a âˆ§ ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— d", "code": "  @[mk_iff]\n", "additional_info": "", "used_premises": [1, 168, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [62, 63], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This theorem states that a code `a` is odd if and only if there exists an even code `d` such that `d` leads to `a`."}
{"full_name": "ConNF.Code.isEven_of_forall_not", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_of_forall_not", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven_of_forall_not [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (h : âˆ€ (d : ConNF.Code), Â¬ d â†â‚€ c) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c", "code": "theorem isEven_of_forall_not (h : âˆ€ d, Â¬d â†â‚€ c) : IsEven c :=\n  (isEven_iff c).2 fun _ hd => (h _ hd).elim\n", "additional_info": "", "used_premises": [1, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [67, 69], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_of_forall_not` states that if for every code `d`, `d` does not lead to `c`, then `c` is an even code."}
{"full_name": "ConNF.Code.isEven_of_eq_bot", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_of_eq_bot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_of_eq_bot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (c : ConNF.Code) (hc : c.Î² = âŠ¥ ) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c", "code": "theorem isEven_of_eq_bot (c : Code) (hc : c.1 = âŠ¥) : c.IsEven :=\n  isEven_of_forall_not <| by rintro d âŸ¨Î², -âŸ©; exact coe_ne_bot hc\n", "additional_info": "", "used_premises": [1, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [71, 73], "informalization": "The theorem `ConNF.Code.isEven_of_eq_bot` states that if a ConNF code `c` satisfies `c.Î² = âŠ¥`, then `c` is an even code."}
{"full_name": "ConNF.Code.isEven_bot", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_bot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_bot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— âŠ¥ s)", "code": "theorem isEven_bot (s : Set Atom) : IsEven (mk âŠ¥ s : Code) :=\n  isEven_of_eq_bot _ rfl\n", "additional_info": "", "used_premises": [1, 69, 165, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [75, 77], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_bot` states that the code `ConNF.Code.mk âŠ¥ s` is even, where `âŠ¥` represents the bottom element in the ConNF hierarchy and `s` is a set of atoms."}
{"full_name": "ConNF.Code.not_isOdd_bot", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isOdd_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.not_isOdd_bot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom) :Â¬ ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— âŠ¥ s)", "code": "theorem not_isOdd_bot (s : Set Atom) : Â¬IsOdd (mk âŠ¥ s : Code) := by\n  simp_rw [isOdd_iff, cloudRel_iff]\n  rintro âŸ¨d, âŸ¨Î³, _, hâŸ©, _âŸ©\n  exact bot_ne_coe (congr_arg Code.Î² h.2)\n", "additional_info": "", "used_premises": [1, 69, 168, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [78, 82], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.not_isOdd_bot` states that the bottom code `ConNF.Code.mk âŠ¥ s` is not `IsOdd`."}
{"full_name": "ConNF.Code.IsEmpty.isEven_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEmpty.isEven_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.IsEmpty.isEven_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— c) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c â†” c.Î² = âŠ¥", "code": "theorem IsEmpty.isEven_iff (hc : c.IsEmpty) : IsEven c â†” (c.1 : TypeIndex) = âŠ¥ := by\n  refine âŸ¨?_, isEven_of_eq_bot _âŸ©\n  intro h\n  obtain âŸ¨_ | (Î² : Î›), sâŸ© := c\n  Â· rfl\n  Â· simp [Code.IsEmpty] at hc\n    cases hc\n    have := not_isOdd_bot âˆ… ((isEven_iff _).1 h âŸ¨âŠ¥, âˆ…âŸ© ?_)\n    Â· cases this\n    convert CloudRel.intro Î² _\n    Â· aesop\n    Â· simp only [ne_eq, Subtype.mk.injEq, WithBot.bot_ne_coe, not_false_eq_true]\n", "additional_info": "An empty code is even iff its extension is `âŠ¥`.", "used_premises": [1, 107, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [85, 97], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. This theorem states that an empty code is even if and only if its extension is `âŠ¥`."}
{"full_name": "ConNF.Code.IsEmpty.isOdd_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEmpty.isOdd_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.IsEmpty.isOdd_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— c) :ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c â†” c.Î² â‰  âŠ¥", "code": "theorem IsEmpty.isOdd_iff (hc : c.IsEmpty) : IsOdd c â†” (c.1 : TypeIndex) â‰  âŠ¥ := by\n  obtain âŸ¨Î², sâŸ© := c\n  refine' âŸ¨_, fun h => (isOdd_iff _).2 âŸ¨mk âŠ¥ âˆ…, _, isEven_bot _âŸ©âŸ©\n  Â· rintro h (rfl : Î² = _)\n    exact not_isOdd_bot _ h\n  Â· lift Î² to Î› using h\n    refine (cloudRel_iff _ _).2 âŸ¨Î², inferInstance, ?_âŸ©\n    simp only [ne_eq, bot_ne_coe, not_false_eq_true, cloudCode_mk_ne, cloud_empty, mk.injEq,\n      heq_eq_eq, true_and]\n    exact hc\n", "additional_info": "", "used_premises": [1, 107, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [99, 109], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` object is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.IsEmpty.isOdd_iff` states that for an empty `ConNF.Code` object `c`, `c` is `IsOdd` if and only if `c.Î² â‰  âŠ¥`."}
{"full_name": "ConNF.Code.isEven_empty_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_empty_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_empty_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.TypeIndex} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î² âˆ… ) â†” Î² = âŠ¥", "code": "theorem isEven_empty_iff : IsEven (mk Î² âˆ…) â†” (Î² : TypeIndex) = âŠ¥ :=\n  IsEmpty.isEven_iff rfl\n", "additional_info": "", "used_premises": [1, 98, 165, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [111, 113], "informalization": "Function `ConNF.Code.isEven_empty_iff` is a theorem in Lean 4 that states that a code is even (in the context of Constructive Ordinal Notation) if and only if the index type `Î²` is equal to the bottom element `âŠ¥`. The theorem's proof is a direct consequence of the definition of evenness for codes, which depends on the index type `Î²` being less than the current level `Î±`, and the empty set being interpreted in the context of tangles as the smallest possible tangle, which corresponds to the bottom element of the type index. The empty set does not itself contribute to the evenness of the code, hence the condition `Î² = âŠ¥` arises."}
{"full_name": "ConNF.Code.isOdd_empty_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isOdd_empty_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isOdd_empty_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.TypeIndex} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î² âˆ… ) â†” Î² â‰  âŠ¥", "code": "theorem isOdd_empty_iff : IsOdd (mk Î² âˆ…) â†” (Î² : TypeIndex) â‰  âŠ¥ :=\n  IsEmpty.isOdd_iff rfl\n", "additional_info": "", "used_premises": [1, 98, 168, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [115, 117], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.isOdd_empty_iff` states that a `ConNF.Code.mk` with an empty set of tangles is `IsOdd` if and only if its type index `Î²` is not equal to `âŠ¥`."}
{"full_name": "ConNF.Code.not_isOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isOdd", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.not_isOdd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :Â¬ ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c â†” ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c", "code": "theorem not_isOdd : Â¬c.IsOdd â†” c.IsEven := by\n  obtain hc | hc := c.members.eq_empty_or_nonempty\n  Â· rw [IsEmpty.isOdd_iff hc, IsEmpty.isEven_iff hc, Classical.not_not]\n  Â· exact not_isOdd_nonempty âŸ¨c, hcâŸ©\n", "additional_info": "A code is not odd iff it is even.", "used_premises": [1, 168, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [135, 139], "informalization": "A code in the context of Constructive Ordinal Notation (ConNF) is not odd if and only if it is even."}
{"full_name": "ConNF.Code.not_isEven", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isEven", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.not_isEven [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :Â¬ ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c â†” ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c", "code": "theorem not_isEven : Â¬c.IsEven â†” c.IsOdd :=\n  not_isOdd.symm.not_left\n", "additional_info": "A code is not even iff it is odd.", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [142, 144], "informalization": "A code in the context of Constructive Ordinal Notation (ConNF) is not even if and only if it is odd."}
{"full_name": "ConNF.Code.IsEven.not_isOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEven.not_isOdd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEven.not_isOdd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c â†’ Â¬ ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c", "code": "alias âŸ¨_, IsEven.not_isOddâŸ© := not_isOdd\n", "additional_info": "**Alias** of the reverse direction of `ğŸ—ŸConNF.Code.not_isOddğŸ—ŸğŸ”—../.././ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isOddğŸ”—` .\n\nA code is not odd iff it is even.", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [145, 146], "informalization": "The theorem `ConNF.Code.IsEven.not_isOdd` is an alias of the reverse direction of `ConNF.Code.not_isOdd`. It states that if a code is even, then it is not odd."}
{"full_name": "ConNF.Code.IsOdd.not_isEven", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsOdd.not_isEven", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsOdd.not_isEven [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c â†’ Â¬ ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c", "code": "alias âŸ¨_, IsOdd.not_isEvenâŸ© := not_isEven\n", "additional_info": "**Alias** of the reverse direction of `ğŸ—ŸConNF.Code.not_isEvenğŸ—ŸğŸ”—../.././ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isEvenğŸ”—` .\n\nA code is not even iff it is odd.", "used_premises": [1, 168, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [147, 148], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. A code is not even iff it is odd."}
{"full_name": "ConNF.Code.isEven_or_isOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_or_isOdd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven_or_isOdd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (c : ConNF.Code) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c âˆ¨ ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c", "code": "theorem isEven_or_isOdd (c : Code) : c.IsEven âˆ¨ c.IsOdd := by\n  rw [â† not_isEven]\n  exact em _\n", "additional_info": "Any code is even or odd.", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [150, 153], "informalization": "In the context of Constructive Ordinal Notation (ConNF), any code can be classified as either even or odd. This theorem, `ConNF.Code.isEven_or_isOdd`, asserts that for any given `ConNF.Code`, it either satisfies the property of being even or odd, according to the inductive definition provided in the `ConNF.Code.IsEven` and `ConNF.Code.IsOdd` types. This categorization is crucial for understanding the structure of the natural numbers and their representation in the ConNF system."}
{"full_name": "ConNF.CloudRel.isOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.CloudRel.isOdd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CloudRel.isOdd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c) (h : c â†â‚€ d) :ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— d", "code": "protected theorem ConNF.CloudRel.isOdd (hc : c.IsEven) (h : c â†â‚€ d) : d.IsOdd :=\n  (isOdd_iff d).2 âŸ¨_, h, hcâŸ©\n", "additional_info": "", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [154, 156], "informalization": "In the context of Constructive Ordinal Notation (ConNF), if `c` is an even code and `c` leads to `d`, then `d` is an odd code."}
{"full_name": "ConNF.Code.IsEven.cloudCode", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEven.cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEven.cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c) (hcÎ³ : c.Î² â‰  â†‘Î³) :ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ c)", "code": "protected theorem IsEven.cloudCode (hc : c.IsEven) (hcÎ³ : c.1 â‰  Î³) : (cloudCode Î³ c).IsOdd :=\n  (CloudRel.intro _ hcÎ³).isOdd hc\n", "additional_info": "", "used_premises": [1, 98, 165, 168, 101], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [157, 159], "informalization": "The theorem `ConNF.Code.IsEven.cloudCode` is a theorem in the Lean proof assistant that is used in the context of Constructive Ordinal Notation (ConNF). It states that given a code `c` which is even and a type index `Î³`, if `c`'s level does not match `Î³`, then the code `ConNF.cloudCode Î³ c` is odd. This theorem is proved by leveraging the definitions and properties of ConNF, such as the `ConNF.Code.IsEven` and `ConNF.Code.IsOdd` classes, and the `ConNF.cloudCode` function, which is defined to adjust the first component of a `ConNF.Code` object to match a given type index."}
{"full_name": "ConNF.Code.IsOdd.cloudCode", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsOdd.cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsOdd.cloudCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsOddğŸ”—<|PREMISE|>ğŸ”— c) (hc' : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— c.members) (hcÎ³ : c.Î² â‰  â†‘Î³) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ c)", "code": "protected theorem IsOdd.cloudCode (hc : c.IsOdd) (hc' : c.members.Nonempty) (hcÎ³ : c.1 â‰  Î³) :\n    (cloudCode Î³ c).IsEven :=\n  (isEven_iff _).2 fun d hd => by rwa [(cloudRel_cloudCode _ hc' hcÎ³).1 hd]\n", "additional_info": "", "used_premises": [1, 98, 168, 83, 165, 101], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [160, 163], "informalization": "The given Lean 4 object is a theorem named `ConNF.Code.IsOdd.cloudCode`, which is a function defined in the context of Constructive Ordinal Notation (ConNF). This function takes a type index `Î²` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem states that if `c` is an odd `ConNF.Code` object with a nonempty set of members and `c.Î²` is not equal to `Î³`, then the `ConNF.Code` returned by `ConNF.cloudCode Î³ c` is even."}
{"full_name": "ConNF.Code.IsEven.cloudCode_ne", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEven.cloudCode_ne", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEven.cloudCode_ne [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— c) (hd : ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— d) (hcÎ³ : c.Î² â‰  â†‘Î³) :ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ c â‰  d", "code": "protected theorem IsEven.cloudCode_ne (hc : c.IsEven) (hd : d.IsEven) (hcÎ³ : c.1 â‰  Î³) :\n    cloudCode Î³ c â‰  d := by rintro rfl; exact hd.not_isOdd (hc.cloudCode hcÎ³)\n", "additional_info": "", "used_premises": [1, 98, 165, 165, 101], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [164, 166], "informalization": "Given a type index `Î³` and two even codes `c` and `d`, the theorem states that if the level of code `c` does not match `Î³`, then `ConNF.cloudCode Î³ c` (which returns a new code where the `Î²` component is defeq to `Î³`, while leaving the other components unchanged) is not equal to `d`. The `ConNF.Code.IsEven` typeclass ensures that `c` and `d` only lead to odd codes. The `ConNF.Params`, `ConNF.Level`, `ConNF.TangleDataLt`, `ConNF.TypedObjectsLt`, and `ConNF.PositionedTanglesLt` classes provide the necessary type-level and order-theoretic relationships required for the proof."}
{"full_name": "ConNF.Code.cloudCode_ne_bot", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.cloudCode_ne_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.cloudCode_ne_bot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle âŠ¥ )} :ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ c â‰  ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— âŠ¥ s", "code": "theorem cloudCode_ne_bot {s} : cloudCode Î³ c â‰  mk âŠ¥ s :=\n  ne_of_apply_ne Code.Î² coe_ne_bot\n", "additional_info": "", "used_premises": [1, 98, 69, 101, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [167, 169], "informalization": "The theorem `ConNF.Code.cloudCode_ne_bot` asserts that given a type level index Î³ less than the current level Î±, and a Code object c, the operation `ConNF.cloudCode Î³ c` does not result in a Code object that is equal to `ConNF.Code.mk âŠ¥ s`, where `s` is a set of tangles at level âŠ¥. The conclusion is that the operation `ConNF.cloudCode Î³ c` yields a distinct Code object, which has a level of Î³, and its tangles are not all at the lowest level âŠ¥."}
{"full_name": "ConNF.Code.cloudCode_ne_singleton", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.cloudCode_ne_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.cloudCode_ne_singleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.TypeIndex} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {t : ConNF.Tangle Î²} (hcÎ² : c.Î² â‰  Î²) :ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ c â‰  ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î² {t}", "code": "theorem cloudCode_ne_singleton {t} (hcÎ² : c.1 â‰  Î²) : cloudCode Î³ c â‰  mk Î² {t} := by\n  intro h\n  rw [cloudCode, Code.ext_iff] at h\n  simp only [ne_eq] at h\n  obtain âŸ¨rfl, hâŸ© := h\n  refine' (Cardinal.one_lt_aleph0.trans_le\n    (Params.Îº_isRegular.aleph0_le.trans Params.Îº_lt_Î¼.le)).not_le _\n  rw [â† Cardinal.mk_singleton t, â† h.eq]\n  refine' Î¼_le_mk_cloudCode c hcÎ² ((cloudCode_nonempty (Î² := Î³)).1 _)\n  rw [cloudCode, eq_of_heq h]\n  simp only [singleton_nonempty]\n", "additional_info": "The cloud map cannot produce a singleton code.", "used_premises": [1, 98, 98, 101, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [171, 182], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the `ConNF.Code.cloudCode` function takes a type index `Î²` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `Î²`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `Î²`. The theorem `ConNF.Code.cloudCode_ne_singleton` states that if `c.Î²` is not equal to `Î²`, then `ConNF.cloudCode Î³ c` cannot be a singleton code."}
{"full_name": "ConNF.Code.isEven_singleton", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_singleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.TypeIndex} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (t : ConNF.Tangle Î²) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î² {t})", "code": "theorem isEven_singleton (t) : (mk Î² {t}).IsEven := by\n  refine' isEven_of_forall_not fun c hc => _\n  obtain âŸ¨Î³, _, hâŸ© := (cloudRel_iff _ _).1 hc\n  have := congr_arg Code.Î² h.2\n  cases this\n  exact cloudCode_ne_singleton h.1 h.2.symm\n", "additional_info": "Singleton codes are even.", "used_premises": [1, 98, 165, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [185, 191], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. This theorem states that a singleton code, which consists of a single tangle, is an even code."}
{"full_name": "ConNF.Code.Equiv.rfl", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.rfl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.rfl [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :c â‰¡ c", "code": "protected theorem rfl : c â‰¡ c :=\n  refl _\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [214, 216], "informalization": "`ConNF.Code.Equiv.rfl` is a reflexivity theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any `ConNF.Code` object `c`, `c` is equivalent to itself (`c â‰¡ c`)."}
{"full_name": "ConNF.Code.Equiv.of_eq", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.of_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.of_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} :c = d â†’ c â‰¡ d", "code": "theorem of_eq : c = d â†’ c â‰¡ d := by rintro rfl; rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [217, 218], "informalization": "Function `ConNF.Code.Equiv.of_eq` is a theorem in the Constructive Ordinal Notation (ConNF) library in Lean 4. It states that if two ConNF codes `c` and `d` are equal, then they are equivalent, denoted as `c â‰¡ d`."}
{"full_name": "ConNF.Code.Equiv.symm", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.symm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :SymmetricğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : ConNF.Code) => x â‰¡ x_1", "code": "theorem symm : Symmetric ((Â· â‰¡ Â·) : Code â†’ Code â†’ Prop)\n  | _, _, refl _ => refl _\n  | _, _, cloud_left c Î² hc hcÎ² => cloud_right c Î² hc hcÎ²\n  | _, _, cloud_right c Î² hc hcÎ² => cloud_left c Î² hc hcÎ²\n  | _, _, cloud_cloud c hc Î² hcÎ² Î³ hcÎ³ => cloud_cloud c hc Î³ hcÎ³ Î² hcÎ²\n", "additional_info": "", "used_premises": [1, 196], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [219, 224], "informalization": "Function `Symmetric` checks if a given binary relation `r` on a type `Î²` is symmetric, meaning if `r x y` holds, then `r y x` must also hold. The theorem `ConNF.Code.Equiv.symm` states that the equivalence relation `â‰¡` on `ConNF.Code` is symmetric."}
{"full_name": "Symmetric", "url": "Mathlib/Init/Logic.html#Symmetric", "code_src": "mathlib4", "ptype": "def", "header": "def Symmetric {Î² : Sort v} (r : Î² â†’ Î² â†’ Prop ) :Prop", "code": "def Symmetric := âˆ€ â¦ƒx yâ¦„, x â‰º y â†’ y â‰º x\n", "additional_info": "A relation is symmetric if `x â‰º y` implies `y â‰º x`.\nEquations\n* ğŸ—ŸSymmetricğŸ—ŸğŸ”—../.././Mathlib/Init/Logic.html#SymmetricğŸ”—  r ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒx y : Î²â¦„, r x y â†’ r y x\n\n", "used_premises": [], "def_path": "Mathlib/Init/Logic.lean", "pos": [462, 463], "informalization": "Function `Symmetric` is a predicate that checks if a given binary relation `r` on a type `Î²` is symmetric, meaning if `r x y` holds, then `r y x` must also hold."}
{"full_name": "ConNF.Code.Equiv.empty_empty", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.empty_empty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.empty_empty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (Î² : ConNF.TypeIndex) (Î³ : ConNF.TypeIndex) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î³] :ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î² âˆ… â‰¡ ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î³ âˆ…", "code": "theorem empty_empty : âˆ€ (Î² Î³ : TypeIndex), [LtLevel Î²] â†’ [LtLevel Î³] â†’ (âŸ¨Î², âˆ…âŸ© : Code) â‰¡ âŸ¨Î³, âˆ…âŸ©\n  | âŠ¥, âŠ¥, _, _ => Equiv.rfl\n  | âŠ¥, (Î³ : Î›), _, hÎ³ => by\n    convert cloud_right _ (isEven_bot _) Î³ bot_ne_coe\n    simp only [ne_eq, bot_ne_coe, not_false_eq_true, snd_cloudCode, cloud_empty]\n  | (Î² : Î›), âŠ¥, hÎ², _ => by\n    convert cloud_left _ (isEven_bot _) Î² bot_ne_coe\n    simp only [ne_eq, bot_ne_coe, not_false_eq_true, snd_cloudCode, cloud_empty]\n  | (Î² : Î›), (Î³ : Î›), hÎ², hÎ³ => by\n    convert cloud_cloud _ (isEven_bot âˆ…) Î² bot_ne_coe Î³ bot_ne_coe <;>\n    Â· simp only [ne_eq, bot_ne_coe, not_false_eq_true, snd_cloudCode]\n      rw [cloud_empty]\n", "additional_info": "All empty codes are equivalent.", "used_premises": [1, 98, 98, 104, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [229, 241], "informalization": "All empty codes are equivalent in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Code.IsEmpty.equiv", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEmpty.equiv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEmpty.equiv [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— c) (hd : ConNF.Code.IsEmptyğŸ”—<|PREMISE|>ğŸ”— d) :c â‰¡ d", "code": "protected theorem ConNF.Code.IsEmpty.equiv (hc : c.IsEmpty) (hd : d.IsEmpty) : c â‰¡ d := by\n  obtain âŸ¨Î³, câŸ© := c\n  obtain âŸ¨Î´, dâŸ© := d\n  change c = âˆ… at hc\n  change d = âˆ… at hd\n  subst hc\n  subst hd\n  exact empty_empty _ _\n", "additional_info": "", "used_premises": [1, 107, 107], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [242, 250], "informalization": "Function `ConNF.Code.IsEmpty.equiv` proves that if two `ConNF.Code` objects `c` and `d` are both empty (`ConNF.Code.IsEmpty c` and `ConNF.Code.IsEmpty d`), then they are equivalent (`c â‰¡ d`)."}
{"full_name": "ConNF.Code.Equiv.equiv_equivalence", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.equiv_equivalence", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.equiv_equivalence [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :EquivalenceğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : ConNF.Code) => x â‰¡ x_1", "code": "theorem equiv_equivalence : Equivalence ((Â· â‰¡ Â·) : Code â†’ Code â†’ Prop) :=\n  âŸ¨refl, fun {_ _} h => symm h, fun {_ _ _} hâ‚ hâ‚‚ => trans hâ‚ hâ‚‚âŸ©\n", "additional_info": "Code equivalence is an equivalence relation.", "used_premises": [1, 200], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [289, 291], "informalization": "The theorem `ConNF.Code.Equiv.equiv_equivalence` states that the equivalence relation `â‰¡` on `ConNF.Code` is indeed an equivalence relation, meaning it is reflexive, symmetric, and transitive."}
{"full_name": "Equivalence", "url": "Init/Core.html#Equivalence", "code_src": "lean4", "ptype": "structure", "header": "structure Equivalence {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop ) :Prop\n | refl : âˆ€ (x : Î±), r x x\n | symm : âˆ€ {x y : Î±}, r x y â†’ r y x\n | trans : âˆ€ {x y z : Î±}, r x y â†’ r y z â†’ r x z", "code": "structure Equivalence {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) : Prop where\n  /-- An equivalence relation is reflexive: `x ~ x` -/\n  refl  : âˆ€ x, r x x\n  /-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\n  symm  : âˆ€ {x y}, r x y â†’ r y x\n  /-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\n  trans : âˆ€ {x y z}, r x y â†’ r y z â†’ r x z\n", "additional_info": "An equivalence relation `~ : Î± â†’ Î± â†’ Prop` is a relation that is:\n* reflexive: `x ~ x`\n* symmetric: `x ~ y` implies `y ~ x`\n* transitive: `x ~ y` and `y ~ z` implies `x ~ z`\n\nEquality is an equivalence relation, and equivalence relations share many of\nthe properties of equality. In particular, `ğŸ—ŸQuotğŸ—ŸğŸ”—.././Init/Prelude.html#QuotğŸ”—  Î± ğŸ—ŸrğŸ—ŸğŸ”—.././Init/Core.html#Setoid.rğŸ”—`  is most well behaved\nwhen `ğŸ—ŸrğŸ—ŸğŸ”—.././Init/Core.html#Setoid.rğŸ”—`  is an equivalence relation, and in this case we use `ğŸ—ŸQuotientğŸ—ŸğŸ”—.././Init/Core.html#QuotientğŸ”—`  instead.\n- Equivalence.refl: An equivalence relation is reflexive: `x ~ x`\n\n\n- Equivalence.symm: An equivalence relation is symmetric: `x ~ y` implies `y ~ x`\n\n\n- Equivalence.trans: An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z`\n\n\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [1059, 1066], "informalization": "An equivalence relation `~ : Î± â†’ Î± â†’ Prop` is a relation that is reflexive (`x ~ x`), symmetric (`x ~ y` implies `y ~ x`), and transitive (`x ~ y` and `y ~ z` implies `x ~ z`). Equality is an equivalence relation, and equivalence relations share many of the properties of equality. In particular, `Quot  Î± r` is most well behaved when `r` is an equivalence relation, and in this case we use `Quotient` instead."}
{"full_name": "ConNF.Code.extension_eq_of_singleton_equiv_singleton", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.extension_eq_of_singleton_equiv_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.extension_eq_of_singleton_equiv_singleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.TypeIndex} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {Î³ : ConNF.TypeIndex} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î³] {a : ConNF.Tangle Î²} {b : ConNF.Tangle Î³} (h : ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î² {a} â‰¡ ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î³ {b}) :Î² = Î³", "code": "theorem extension_eq_of_singleton_equiv_singleton {Î³ : TypeIndex} [LtLevel Î³]\n    {a : Tangle Î²} {b : Tangle Î³}\n    (h : (âŸ¨Î², {a}âŸ© : Code) â‰¡ âŸ¨Î³, {b}âŸ©) : Î² = Î³ := by\n  obtain h | âŸ¨Îµ, _, hc, hÎ²Îµ, hAâŸ© := Equiv.singleton_iff.1 h\n  Â· exact ((Code.ext_iff _ _).1 h).1\n  Â· exfalso\n    refine cloudCode_ne_singleton ?_ hA.symm\n    cases congr_arg Code.Î² hA\n    exact hÎ²Îµ\n", "additional_info": "", "used_premises": [1, 98, 98, 104, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [361, 370], "informalization": "The theorem states that given two codes `a` and `b` of type indices `Î²` and `Î³` respectively, where `a` is a singleton set and `b` is also a singleton set, and these codes are equivalent under the equivalence relation defined by the `ConNF.Params` class, then the types `Î²` and `Î³` must be equal. This is a key property that underpins the use of ConNF in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.Code.equiv_bot_subsingleton", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.equiv_bot_subsingleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.equiv_bot_subsingleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (d : ConNF.Code) (e : ConNF.Code) (hdc : d â‰¡ c) (hec : e â‰¡ c) (hd : d.Î² = âŠ¥ ) (he : e.Î² = âŠ¥ ) :d = e", "code": "theorem equiv_bot_subsingleton (d e : Code)\n    (hdc : d â‰¡ c) (hec : e â‰¡ c) (hd : d.1 = âŠ¥) (he : e.1 = âŠ¥) : d = e :=\n  (hdc.trans hec.symm).unique (hd.trans he.symm)\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [406, 409], "informalization": "The theorem `ConNF.Code.equiv_bot_subsingleton` states that if two ConNF codes `d` and `e` are equivalent to the same code `c`, and both `d.Î²` and `e.Î²` are equal to `âŠ¥`, then `d` must be equal to `e`."}
{"full_name": "ConNF.Extensions.ext", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Extensions.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Extensions.ext [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] {eâ‚ : ConNF.Extensions} {eâ‚‚ : ConNF.Extensions} (h : âˆ€ (Î² : ConNF.Î›) [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²], eâ‚ Î² = eâ‚‚ Î²) :eâ‚ = eâ‚‚", "code": "theorem Extensions.ext {eâ‚ eâ‚‚ : Extensions} (h : âˆ€ Î² : Î›, [LtLevel Î²] â†’ eâ‚ Î² = eâ‚‚ Î²) : eâ‚ = eâ‚‚ :=\n  funext (fun Î² => funext (fun _ => h Î²))\n", "additional_info": "", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [39, 41], "informalization": "The `ConNF.Extensions.ext` theorem in Lean 4 is a proof that two `ConNF.Extensions` objects are equal if and only if their values are equal for all types `Î²` that are less than the current level `Î±` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Semitangle.Preference.base_heq_base", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.base_heq_base", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.Preference.base_heq_base [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {mâ‚ : ConNF.Extensions} {mâ‚‚ : ConNF.Extensions} {sâ‚ : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle âŠ¥ )} {sâ‚‚ : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle âŠ¥ )} {hâ‚ : âˆ€ (Î³ : ConNF.Î›) [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³], ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— â‹¯ sâ‚ = mâ‚ Î³} {hâ‚‚ : âˆ€ (Î³ : ConNF.Î›) [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³], ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— â‹¯ sâ‚‚ = mâ‚‚ Î³} (hm : mâ‚ = mâ‚‚) (hs : sâ‚ = sâ‚‚) :HEqğŸ”—<|PREMISE|>ğŸ”— (ConNF.Semitangle.Preference.baseğŸ”—<|PREMISE|>ğŸ”— sâ‚ hâ‚) (ConNF.Semitangle.Preference.baseğŸ”—<|PREMISE|>ğŸ”— sâ‚‚ hâ‚‚)", "code": "theorem Preference.base_heq_base {mâ‚ mâ‚‚ : Extensions} {sâ‚ sâ‚‚ hâ‚ hâ‚‚} (hm : mâ‚ = mâ‚‚)\n    (hs : sâ‚ = sâ‚‚) :\n    HEq (Preference.base sâ‚ hâ‚ : Preference mâ‚) (Preference.base sâ‚‚ hâ‚‚ : Preference mâ‚‚) := by\n  cases hm\n  cases hs\n  rfl\n", "additional_info": "", "used_premises": [1, 69, 69, 98, 77, 98, 77, 126, 205, 205], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [64, 70], "informalization": "This theorem states that the Base preference constructor for semitangles is equality-preserving with respect to the set of tangles and the extension function. This means that if two Base preference constructors have the same set of tangles and the same extension function, they are considered equal."}
{"full_name": "ConNF.Semitangle.Preference.base", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference", "code_src": "con-nf", "ptype": "constructor", "header": "constructor ConNF.Semitangle.PreferenceğŸ”—<|PREMISE|>ğŸ”—.base: [inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] â†’\n [inst_1 : ConNF.Level] â†’\n [inst_2 : ConNF.TangleDataLt] â†’\n [inst_3 : ConNF.PositionedTanglesLt] â†’\n [inst_4 : ConNF.TypedObjectsLt] â†’\n {members : ConNF.Extensions} â†’\n (atoms : SetğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Tangle  âŠ¥ )) â†’\n (âˆ€ (Î³ : ConNF.Î›) [inst_5 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³], ConNF.cloudğŸ”—<|PREMISE|>ğŸ”—  â‹¯ atoms =  members Î³) â†’\n ConNF.Semitangle.PreferenceğŸ”—<|PREMISE|>ğŸ”—  members", "code": "inductive Preference (members : Extensions)\n  | base (atoms : Set (Tangle âŠ¥)) :\n    (âˆ€ (Î³ : Î›), [LtLevel Î³] â†’ cloud bot_ne_coe atoms = members Î³) â†’ Preference members\n  | proper (Î² : Î›) [LtLevel Î²] :\n    (mk Î² (members Î²) : Code).IsEven â†’\n    (âˆ€ (Î³ : Î›) [LtLevel Î³] (hÎ²Î³ : (Î² : TypeIndex) â‰  Î³), cloud hÎ²Î³ (members Î²) = members Î³) â†’\n    Preference members\n", "additional_info": "", "used_premises": [206, 1, 69, 98, 77, 206], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [49, 56], "informalization": "Function `ConNF.Semitangle.Preference.base` is a constructor for the type `ConNF.Semitangle.Preference`, which represents the preferred extension of a semitangle, along with coherence conditions relating each extension of the semitangle. Each non-preferred extension can be obtained by applying the `ConNF.cloud` map to the preferred extension. This constructor is used to define the base case of the preference, where the preferred extension is directly given by the `ConNF.cloud` map applied to a set of tangles."}
{"full_name": "ConNF.Semitangle.Preference", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Semitangle.Preference [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (members : ConNF.Extensions) :Type u", "code": "inductive Preference (members : Extensions)\n  | base (atoms : Set (Tangle âŠ¥)) :\n    (âˆ€ (Î³ : Î›), [LtLevel Î³] â†’ cloud bot_ne_coe atoms = members Î³) â†’ Preference members\n  | proper (Î² : Î›) [LtLevel Î²] :\n    (mk Î² (members Î²) : Code).IsEven â†’\n    (âˆ€ (Î³ : Î›) [LtLevel Î³] (hÎ²Î³ : (Î² : TypeIndex) â‰  Î³), cloud hÎ²Î³ (members Î²) = members Î³) â†’\n    Preference members\n", "additional_info": "Keeps track of the preferred extension of a semitangle, along with coherence conditions\nrelating each extension of the semitangle. In particular, each non-preferred extension can be\nobtained by applying the `cloud` map to the preferred extension.\n", "used_premises": [1], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [49, 56], "informalization": "Type `Preference` represents the preferred extension of a semitangle, along with coherence conditions relating each extension of the semitangle. Each non-preferred extension can be obtained by applying the `cloud` map to the preferred extension."}
{"full_name": "ConNF.Semitangle.reprCode_base", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.reprCode_base", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Semitangle.reprCode_base [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (exts : ConNF.Extensions) (atoms : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle âŠ¥ )) (hA : âˆ€ (Î³ : ConNF.Î›) [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³], ConNF.cloudğŸ”—<|PREMISE|>ğŸ”— â‹¯ atoms = exts Î³) :ConNF.Semitangle.reprCodeğŸ”—<|PREMISE|>ğŸ”— { members := exts, pref := ConNF.Semitangle.Preference.baseğŸ”—<|PREMISE|>ğŸ”— atoms hA } = ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— âŠ¥ atoms", "code": "theorem reprCode_base (exts : Extensions) (atoms hA) :\n    reprCode âŸ¨exts, Preference.base atoms hAâŸ© = âŸ¨âŠ¥, atomsâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 69, 98, 77, 208, 205, 104], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [99, 102], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Semitangle.reprCode` computes the even code associated to a semitangle. The theorem `ConNF.Semitangle.reprCode_base` provides a base case for this computation, where the preferred extension of the semitangle is directly given by the `ConNF.cloud` map applied to a set of tangles."}
{"full_name": "ConNF.Semitangle.reprCode", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.reprCode", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Semitangle.reprCode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :ConNF.Semitangle â†’ ConNF.Code", "code": "def reprCode : Semitangle â†’ Code\n  | âŸ¨_, Preference.base atoms _âŸ© => âŸ¨âŠ¥, atomsâŸ©\n  | âŸ¨exts, Preference.proper Î² _ _âŸ© => âŸ¨Î², exts Î²âŸ©\n", "additional_info": "The even code associated to a semitangle.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [94, 97], "informalization": "Function `ConNF.Semitangle.reprCode` computes the even code associated to a semitangle in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Semitangle.reprCodeSpec", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.reprCodeSpec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.reprCodeSpec [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t : ConNF.Semitangle) :ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (ConNF.Semitangle.reprCodeğŸ”—<|PREMISE|>ğŸ”— t)", "code": "theorem reprCodeSpec : âˆ€ t : Semitangle, (reprCode t : Code).IsEven\n  | âŸ¨_, Preference.proper _ rep _âŸ© => rep\n  | âŸ¨_, Preference.base _ _âŸ© => isEven_bot _\n", "additional_info": "", "used_premises": [1, 165, 208], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [108, 111], "informalization": "The theorem `ConNF.Semitangle.reprCodeSpec` states that the even code associated to a semitangle in the context of Constructive Ordinal Notation (ConNF) is indeed even."}
{"full_name": "ConNF.Semitangle.reprCode_members_ne", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.reprCode_members_ne", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.reprCode_members_ne [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t : ConNF.Semitangle) (Î³ : ConNF.Î›) [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] :(ConNF.Semitangle.reprCodeğŸ”—<|PREMISE|>ğŸ”— t).Î² â‰  â†‘Î³ â†’ (ConNF.cloudCodeğŸ”—<|PREMISE|>ğŸ”— Î³ (ConNF.Semitangle.reprCodeğŸ”—<|PREMISE|>ğŸ”— t)).members = t.members Î³", "code": "theorem reprCode_members_ne :\n    âˆ€ (t : Semitangle) (Î³ : Î›) [LtLevel Î³] (_ : (reprCode t : Code).1 â‰  Î³),\n      (cloudCode Î³ (reprCode t)).members = t.members Î³\n  | âŸ¨exts, Preference.proper Î² rep hAâŸ©, Î³, _, hcÎ³ => by\n      rw [snd_cloudCode]\n      exact hA _ hcÎ³\n  | âŸ¨_, Preference.base _ hAâŸ©, Î³, _, _ => hA _\n", "additional_info": "", "used_premises": [1, 98, 208, 101, 208], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [112, 119], "informalization": "Function `ConNF.Semitangle.reprCode_members_ne` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for a semitangle `t` and a type index `Î³` less than the current level, if the first component of the even code `ConNF.Semitangle.reprCode t` is not equal to `Î³`, then the members of the cloud code `ConNF.cloudCode Î³ (ConNF.Semitangle.reprCode t)` are equal to the members of `t` at `Î³`."}
{"full_name": "ConNF.Semitangle.ext_core", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.ext_core", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.ext_core [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (tâ‚ : ConNF.Semitangle) (tâ‚‚ : ConNF.Semitangle) :NonemptyğŸ”—<|PREMISE|>ğŸ”— ((Î³ : ConNF.Î›) Ã—' ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³) â†’ tâ‚.members = tâ‚‚.members â†’ tâ‚ = tâ‚‚", "code": "theorem ext_core (tâ‚ tâ‚‚ : Semitangle) : Nonempty ((Î³ : Î›) Ã—' LtLevel Î³) â†’\n    tâ‚.members = tâ‚‚.members â†’ tâ‚ = tâ‚‚ := by\n  obtain âŸ¨xs, hxsâŸ© := tâ‚\n  obtain âŸ¨ys, hysâŸ© := tâ‚‚\n  rintro âŸ¨Î³, _âŸ© rfl\n  simp only [mk.injEq, heq_eq_eq, true_and]\n  obtain âŸ¨atomsâ‚, hAâ‚âŸ© | âŸ¨Î², evenâ‚, hAâ‚âŸ© := hxs <;>\n  obtain âŸ¨atomsâ‚‚, hAâ‚‚âŸ© | âŸ¨Î³, evenâ‚‚, hAâ‚‚âŸ© := hys\n  Â· simp_rw [cloud_injective ((hAâ‚ Î³).trans (hAâ‚‚ _).symm)]\n  Â· cases (isEven_bot atomsâ‚).cloudCode_ne evenâ‚‚ (bot_ne_coe (a := Î³))\n      (Code.ext _ _ rfl (heq_of_eq (hAâ‚ Î³)))\n  Â· cases (isEven_bot atomsâ‚‚).cloudCode_ne evenâ‚ (bot_ne_coe (a := Î²))\n      (Code.ext _ _ rfl (heq_of_eq (hAâ‚‚ Î²)))\n  Â· simp only [Preference.proper.injEq]\n    refine not_ne_iff.1 fun hÎ²Î³ =>\n      evenâ‚‚.cloudCode_ne evenâ‚ (WithBot.coe_injective.ne hÎ²Î³.symm) <|\n        Code.ext _ _ rfl (heq_of_eq ?_)\n    rw [snd_cloudCode]\n    exact hAâ‚‚ Î² fun h => hÎ²Î³.symm (WithBot.coe_injective h)\n", "additional_info": "One form of extensionality: If there is a proper type index `Î³ < Î±`, then two semitangles\nwith the same elements have the same preference.\nRemark: This formulation of extensionality holds only for types larger than type zero, since\nit doesn't take into account any `âŠ¥`-extension.", "used_premises": [1, 212, 98], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [125, 144], "informalization": "The theorem `ConNF.Semitangle.ext_core` is a form of extensionality for semitangles in the context of Constructive Ordinal Notation (ConNF). It states that if there exists a proper type index `Î³` less than the current level `Î±`, and two semitangles have the same members, then the two semitangles are equal."}
{"full_name": "Nonempty", "url": "Init/Prelude.html#Nonempty", "code_src": "lean4", "ptype": "class inductive", "header": "class inductive Nonempty (Î± : Sort u) :Prop", "code": "class inductive Nonempty (Î± : Sort u) : Prop where\n  /-- If `val : Î±`, then `Î±` is nonempty. -/\n  | intro (val : Î±) : Nonempty Î±\n", "additional_info": "`ğŸ—ŸNonemptyğŸ—ŸğŸ”—.././Init/Prelude.html#NonemptyğŸ”—  Î±` is a typeclass that says that `Î±` is not an empty type,\nthat is, there exists an element in the type. It differs from `ğŸ—ŸInhabitedğŸ—ŸğŸ”—.././Init/Prelude.html#InhabitedğŸ”—  Î±`\nin that `ğŸ—ŸNonemptyğŸ—ŸğŸ”—.././Init/Prelude.html#NonemptyğŸ”—  Î±` is a `Prop`, which means that it does not actually carry\nan element of `Î±`, only a proof that *there exists* such an element.\nGiven `ğŸ—ŸNonemptyğŸ—ŸğŸ”—.././Init/Prelude.html#NonemptyğŸ”—  Î±`, you can construct an element of `Î±` *nonconstructively*\nusing `ğŸ—ŸClassical.choiceğŸ—ŸğŸ”—.././Init/Prelude.html#Classical.choiceğŸ”—` .\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [703, 706], "informalization": "Class `Nonempty` represents the proposition that a type `Î±` is not empty, meaning there exists at least one element of type `Î±`, without providing a specific instance."}
{"full_name": "ConNF.Semitangle.ext", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.ext [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (tâ‚ : ConNF.Semitangle) (tâ‚‚ : ConNF.Semitangle) (h : tâ‚.members Î³ = tâ‚‚.members Î³) :tâ‚ = tâ‚‚", "code": "theorem ext (tâ‚ tâ‚‚ : Semitangle) (h : tâ‚.members Î³ = tâ‚‚.members Î³) : tâ‚ = tâ‚‚ := by\n  obtain âŸ¨xs, hxsâŸ© := tâ‚\n  obtain âŸ¨ys, hysâŸ© := tâ‚‚\n  dsimp only at h\n  refine ext_code ?_\n  obtain âŸ¨atomsâ‚, hAâ‚âŸ© | âŸ¨Î², evenâ‚, hAâ‚âŸ© := hxs <;> obtain âŸ¨atomsâ‚‚, hAâ‚‚âŸ© | âŸ¨Î´, evenâ‚‚, hAâ‚‚âŸ© := hys\n  Â· refine (Code.Equiv.cloud_right _ (Code.isEven_bot _) Î³ bot_ne_coe).trans ?_\n    simp only [ne_eq, bot_ne_coe, not_false_eq_true, cloudCode_mk_ne, reprCode_base,\n      Equiv.bot_right_iff, Code.mk.injEq, coe_ne_bot, false_and, coe_inj, exists_and_left,\n      exists_eq_left', heq_eq_eq, false_or]\n    rw [hAâ‚ Î³, h, â† hAâ‚‚ Î³]\n    exact âŸ¨inferInstance, rflâŸ©\n  Â· simp only [reprCode_base, Subtype.coe_mk, reprCode_proper]\n    obtain rfl | hÎ´Î³ := eq_or_ne Î´ Î³\n    Â· simp only [coe_ne_bot, isEmpty_mk, ne_eq, coe_inj, Equiv.bot_left_iff, Code.mk.injEq,\n        bot_ne_coe, false_and, exists_and_left, exists_eq_left', heq_eq_eq, false_or] at *\n      rw [â† h, â† hAâ‚ Î´]\n      exact âŸ¨inferInstance, rflâŸ©\n    Â· refine (Code.Equiv.cloud_right _ (Code.isEven_bot _) Î³ bot_ne_coe).trans ?_\n      simp only [ne_eq, bot_ne_coe, not_false_eq_true, cloudCode_mk_ne]\n      rw [hAâ‚ Î³, h, â† hAâ‚‚ Î³ (WithBot.coe_injective.ne hÎ´Î³), â† cloudCode_mk_ne]\n      exact Code.Equiv.cloud_left _ evenâ‚‚ Î³ (WithBot.coe_injective.ne hÎ´Î³)\n  Â· simp only [reprCode_proper, Subtype.coe_mk, reprCode_base]\n    obtain rfl | hÎ²Î³ := eq_or_ne Î² Î³\n    Â· dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n      rw [h, â† hAâ‚‚ Î²]\n      exact Code.Equiv.cloud_left _ (Code.isEven_bot _) _ bot_ne_coe\n    Â· refine (Code.Equiv.cloud_right _ evenâ‚ Î³ <| WithBot.coe_injective.ne hÎ²Î³).trans ?_\n      dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n      refine (Code.Equiv.of_eq <| cloudCode_mk_ne _ _ (WithBot.coe_injective.ne hÎ²Î³) (xs Î²)).trans ?_\n      rw [hAâ‚ Î³ (WithBot.coe_injective.ne hÎ²Î³), h, â† hAâ‚‚ Î³]\n      exact Code.Equiv.cloud_left _ (Code.isEven_bot _) Î³ bot_ne_coe\n  Â· simp only [reprCode_proper, Subtype.coe_mk]\n    obtain rfl | hÎ²Î³ := eq_or_ne Î² Î³\n    Â· obtain rfl | hÎ´Î² := eq_or_ne Î´ Î²\n      Â· rw [h]\n      Â· have := cloudCode_ne Î² (Code.mk Î´ (ys Î´)) (WithBot.coe_injective.ne hÎ´Î²)\n        dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n        rw [h, â† hAâ‚‚ _ (WithBot.coe_injective.ne hÎ´Î²), â† this]\n        exact Code.Equiv.cloud_left _ evenâ‚‚ _ (WithBot.coe_injective.ne hÎ´Î²)\n    obtain rfl | hÎ´Î³ := eq_or_ne Î´ Î³\n    Â· have := cloudCode_ne Î´ (Code.mk Î² (xs Î²)) (WithBot.coe_injective.ne hÎ²Î³)\n      dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n      simp_rw [â† h, â† hAâ‚ _ (WithBot.coe_injective.ne hÎ²Î³), â† this]\n      exact Code.Equiv.cloud_right _ evenâ‚ _ (WithBot.coe_injective.ne hÎ²Î³)\n    refine' (Code.Equiv.cloud_right _ evenâ‚ Î³ <| WithBot.coe_injective.ne hÎ²Î³).trans _\n    have := cloudCode_ne Î³ (Code.mk (â†‘Î´) (ys Î´)) (WithBot.coe_injective.ne hÎ´Î³)\n    dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n    rw [cloudCode_ne]\n    rw [hAâ‚ Î³ (WithBot.coe_injective.ne hÎ²Î³), h, â† hAâ‚‚ Î³ (WithBot.coe_injective.ne hÎ´Î³)]\n    rw [â† this]\n    exact Code.Equiv.cloud_left _ evenâ‚‚ Î³ (WithBot.coe_injective.ne hÎ´Î³)\n", "additional_info": "Extensionality in tangled type theory. Two semitangles are equal if their\n`Î²`-extensions are equal for *any* choice of `Î³ < Î±`.\nTODO: This proof can be golfed quite a bit just by cleaning up the `simp` calls.", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [199, 251], "informalization": "The theorem `ConNF.Semitangle.ext` is a proof of extensionality for semitangles in the context of Constructive Ordinal Notation (ConNF). It states that two semitangles are equal if their `Î²`-extensions are equal for any choice of `Î³ < Î±`."}
{"full_name": "ConNF.Semitangle.ext_zero", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.ext_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.ext_zero [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (tâ‚ : ConNF.Semitangle) (tâ‚‚ : ConNF.Semitangle) (Î±_zero : IsMinğŸ”—<|PREMISE|>ğŸ”— ConNF.Î±) (h : ConNF.Semitangle.Preference.atomsğŸ”—<|PREMISE|>ğŸ”— tâ‚.pref = ConNF.Semitangle.Preference.atomsğŸ”—<|PREMISE|>ğŸ”— tâ‚‚.pref) :tâ‚ = tâ‚‚", "code": "theorem ext_zero (tâ‚ tâ‚‚ : Semitangle) (Î±_zero : IsMin Î±) (h : tâ‚.pref.atoms = tâ‚‚.pref.atoms) :\n    tâ‚ = tâ‚‚ := by\n  obtain âŸ¨xs, âŸ¨atomsâ‚, hAâ‚âŸ© | âŸ¨Î³, _, _âŸ©âŸ© := tâ‚\n  swap\n  Â· cases Î±_zero.not_lt (show Î³ < Î± from WithBot.coe_lt_coe.mp LtLevel.elim)\n  obtain âŸ¨ys, âŸ¨atomsâ‚‚, hAâ‚‚âŸ© | âŸ¨Î³, _, _âŸ©âŸ© := tâ‚‚\n  swap\n  Â· cases Î±_zero.not_lt (show Î³ < Î± from WithBot.coe_lt_coe.mp LtLevel.elim)\n  subst h\n  suffices xs = ys by\n    subst this\n    rfl\n  ext Î² : 1\n  cases Î±_zero.not_lt (show Î² < Î± from WithBot.coe_lt_coe.mp LtLevel.elim)\n", "additional_info": "Extensionality at the lowest level of tangled type theory.\nAt type 0, all semitangles have a `âŠ¥`-extension.\nTherefore, the extensionality principle in this case applies to the `âŠ¥`-extensions.", "used_premises": [1, 215, 216, 216], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [255, 269], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Semitangle.ext_zero` establishes an extensionality principle for semitangles at the lowest level of tangled type theory, specifically at type 0. At this level, all semitangles have a `âŠ¥`-extension, and the extensionality principle applies to these `âŠ¥`-extensions."}
{"full_name": "IsMin", "url": "Mathlib/Order/Max.html#IsMin", "code_src": "mathlib4", "ptype": "def", "header": "def IsMin {Î± : Type u_1} [LEğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) :Prop", "code": "def IsMin (a : Î±) : Prop :=\n  âˆ€ â¦ƒbâ¦„, b â‰¤ a â†’ a â‰¤ b\n", "additional_info": "`a` is a minimal element of `Î±` if no element is strictly less than it. We spell it without `<`\nto avoid having to convert between `â‰¤` and `<`. Instead, `ğŸ—ŸisMin_iff_forall_not_ltğŸ—ŸğŸ”—../.././Mathlib/Order/Max.html#isMin_iff_forall_not_ltğŸ”—`  does the\nconversion.\nEquations\n* ğŸ—ŸIsMinğŸ—ŸğŸ”—../.././Mathlib/Order/Max.html#IsMinğŸ”—  a ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒb : Î±â¦„, b ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../.././Init/Prelude.html#LE.leğŸ”—  a â†’ a ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../.././Init/Prelude.html#LE.leğŸ”—  b\n\n", "used_premises": [5], "def_path": "Mathlib/Order/Max.lean", "pos": [201, 203], "informalization": "The function `IsMin` checks if an element `a` of a preordered type `Î±` is a minimal element, meaning there is no element `b` such that `b < a`."}
{"full_name": "ConNF.Semitangle.Preference.atoms", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.atoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Semitangle.Preference.atoms [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {members : ConNF.Extensions} :ConNF.Semitangle.PreferenceğŸ”—<|PREMISE|>ğŸ”— members â†’ SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def Preference.atoms : Preference members â†’ Set Atom\n  | Preference.base atoms _ => (atoms : Set (Tangle âŠ¥))\n  | Preference.proper _ _ _ => âˆ…\n", "additional_info": "The `âŠ¥`-extension associated with a given semitangle extension.\nEquations\n* ğŸ—ŸConNF.Semitangle.Preference.atomsğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.atomsğŸ”—  x ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  match x with\n | ğŸ—ŸConNF.Semitangle.Preference.baseğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.baseğŸ”—  atoms a => atoms\n | ğŸ—ŸConNF.Semitangle.Preference.properğŸ—ŸğŸ”—../.././ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.properğŸ”—  Î² a a_1 => ğŸ—Ÿâˆ…ğŸ—ŸğŸ”—../.././Init/Core.html#EmptyCollection.emptyCollectionğŸ”—\n\n", "used_premises": [1, 206, 69], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [60, 63], "informalization": "Function `ConNF.Semitangle.Preference.atoms` returns the set of `âŠ¥`-extensions associated with a given semitangle extension."}
{"full_name": "ConNF.Semitangle.exts_intro", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.exts_intro", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Semitangle.exts_intro [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] {Î² : ConNF.TypeIndex} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î²)) (heven : ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î² s)) :(ConNF.Semitangle.introğŸ”—<|PREMISE|>ğŸ”— s heven).members = ConNF.extensionğŸ”—<|PREMISE|>ğŸ”— s", "code": "theorem exts_intro (s : Set (Tangle Î²)) (heven : IsEven (Code.mk Î² s)) :\n    (intro s heven).members = extension s :=\n  rfl\n", "additional_info": "", "used_premises": [1, 98, 69, 165, 104, 218, 99], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [287, 290], "informalization": "The `ConNF.Semitangle.exts_intro` theorem in Lean 4 states that the members of a semitangle constructed from an even code are equal to the extension of the set of tangles used to construct the semitangle."}
{"full_name": "ConNF.Semitangle.intro", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.intro", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Semitangle.intro [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Î² : ConNF.TypeIndex} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î²] (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tangle Î²)) (heven : ConNF.Code.IsEvenğŸ”—<|PREMISE|>ğŸ”— (ConNF.Code.mkğŸ”—<|PREMISE|>ğŸ”— Î² s)) :ConNF.Semitangle", "code": "def intro {Î² : TypeIndex} [inst : LtLevel Î²] (s : Set (Tangle Î²))\n    (heven : (Code.mk Î² s).IsEven) : Semitangle :=\n  âŸ¨extension s,\n    match Î², inst, s, heven with\n    | âŠ¥, _, s, _ => Preference.base s fun Î² => rfl\n    | (Î³ : Î›), _, s, heven =>\n      Preference.proper Î³\n        (by\n          convert heven\n          exact extension_self s)\n        fun Î´ _ hÎ´ => by\n          rw [extension_ne s Î´]\n          congr\n          exact congr_arg _ (extension_self s)âŸ©\n", "additional_info": "Construct a semitangle from an even code.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 98, 69, 165, 104], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [271, 285], "informalization": "Function `ConNF.Semitangle.intro` is used to construct a semitangle from an even code in the context of Constructive Ordinal Notation (ConNF). It takes a set of tangles of type `Î²` and a proof that the corresponding code is even, and returns a semitangle."}
{"full_name": "ConNF.NewAllowable.members_smul'", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.members_smul'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.members_smul' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.NewAllowable) (t : ConNF.Semitangle) :(Ï â€¢ t).members = Ï â€¢ t.members", "code": "theorem members_smul' (Ï : NewAllowable) (t : Semitangle) : (Ï â€¢ t).members = Ï â€¢ t.members :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [357, 359], "informalization": "The theorem `ConNF.NewAllowable.members_smul'` states that for any `ConNF.NewAllowable` object `Ï` and any `ConNF.Semitangle` object `t`, the members of the semitangle `(Ï â€¢ t)` is equal to `Ï â€¢ t.members`, where `Ï â€¢ t.members` denotes the scalar multiplication of the members of `t` by `Ï`."}
{"full_name": "ConNF.Code.Equiv.supports", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Code.Equiv.supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.supports [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±)} (hcd : c â‰¡ d) (hS : MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— ConNF.NewAllowable S c) :MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— ConNF.NewAllowable S d", "code": "protected theorem Code.Equiv.supports (hcd : c â‰¡ d) (hS : Supports NewAllowable S c) :\n    Supports NewAllowable S d := fun Ï h => by\n  have hâ‚ := hcd.smul (Ï := Ï)\n  have hâ‚‚ := (Code.Equiv.of_eq <| hS Ï h).trans hcd\n  exact (hâ‚.symm.trans hâ‚‚).unique rfl\n", "additional_info": "If a set of addresses supports a code, it supports all equivalent codes.", "used_premises": [1, 69, 60, 68, 68], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [410, 415], "informalization": "The theorem `ConNF.Code.Equiv.supports` states that if a set of addresses supports a code `c`, then it also supports any code `d` that is equivalent to `c`. In the context of Constructive Ordinal Notation (ConNF), this means that if a set of addresses is sufficient to determine the behavior of one code, it is also sufficient to determine the behavior of any equivalent code."}
{"full_name": "ConNF.Code.Equiv.supports_iff", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Code.Equiv.supports_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.supports_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±)} (hcd : c â‰¡ d) :MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— ConNF.NewAllowable S c â†” MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— ConNF.NewAllowable S d", "code": "theorem Code.Equiv.supports_iff (hcd : c â‰¡ d) :\n    Supports NewAllowable S c â†” Supports NewAllowable S d :=\n  âŸ¨hcd.supports, hcd.symm.supportsâŸ©\n", "additional_info": "", "used_premises": [1, 69, 60, 68, 68], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [416, 419], "informalization": "The theorem `ConNF.Code.Equiv.supports_iff` states that if two ConNF codes `c` and `d` are equivalent (denoted by `c â‰¡ d`), then the set `S` supports `c` under the action of `ConNF.NewAllowable` if and only if `S` supports `d` under the same action."}
{"full_name": "ConNF.Code.Equiv.supported_iff", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Code.Equiv.supported_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.supported_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} (hcd : c â‰¡ d) :(âˆƒ (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±), MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— ConNF.NewAllowable (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) c) â†” âˆƒ (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±), MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— ConNF.NewAllowable (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) d", "code": "theorem Code.Equiv.supported_iff (hcd : c â‰¡ d) :\n    (âˆƒ S : Support Î±, MulAction.Supports NewAllowable (S : Set (Address Î±)) c) â†”\n    âˆƒ S : Support Î±, MulAction.Supports NewAllowable (S : Set (Address Î±)) d := by\n  constructor <;> rintro âŸ¨S, hSâŸ©\n  Â· exact âŸ¨S, hcd.supports hSâŸ©\n  Â· exact âŸ¨S, hcd.symm.supports hSâŸ©\n", "additional_info": "If two codes are equivalent, one is supported if and only if the other is.", "used_premises": [1, 58, 68, 70, 58, 68, 70], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [421, 427], "informalization": "The theorem `ConNF.Code.Equiv.supported_iff` states that if two codes `c` and `d` are equivalent (denoted by `c â‰¡ d`), then there exists a support for `c` if and only if there exists a support for `d`. This means that the property of being supported is preserved under equivalence of codes."}
{"full_name": "ConNF.NewAllowable.smul_address", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.smul_address", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NewAllowable.smul_address [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±} :Ï â€¢ c = { path := c.path, value := ConNF.NewAllowable.toStructPerm Ï c.path â€¢ c.value }", "code": "theorem NewAllowable.smul_address {Ï : NewAllowable} {c : Address Î±} :\n    Ï â€¢ c = âŸ¨c.path, NewAllowable.toStructPerm Ï c.path â€¢ c.valueâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [441, 444], "informalization": "In the context of Constructive Ordinal Notation (ConNF), `ConNF.NewAllowable.smul_address` is a theorem that defines the action of a `ConNF.NewAllowable` object on a `ConNF.Address` object. Specifically, it states that when a `ConNF.NewAllowable` object `Ï` acts on a `ConNF.Address` object `c`, the resulting `ConNF.Address` object has the same path as `c`, but its value is obtained by applying the permutation `ConNF.NewAllowable.toStructPerm Ï c.path` to the value of `c`."}
{"full_name": "ConNF.NewAllowable.smul_address_eq_iff", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.smul_address_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.smul_address_eq_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±} :Ï â€¢ c = c â†” ConNF.NewAllowable.toStructPerm Ï c.path â€¢ c.value = c.value", "code": "theorem NewAllowable.smul_address_eq_iff {Ï : NewAllowable} {c : Address Î±} :\n    Ï â€¢ c = c â†” NewAllowable.toStructPerm Ï c.path â€¢ c.value = c.value :=\n  StructPerm.smul_address_eq_iff\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [446, 449], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.smul_address_eq_iff` states that for an element `Ï` of the type `ConNF.NewAllowable` and an element `c` of the type `ConNF.Address â†‘ConNF.Î±`, the condition `Ï â€¢ c = c` is equivalent to the condition `ConNF.NewAllowable.toStructPerm Ï c.path â€¢ c.value = c.value`. This theorem is marked as `@[simp]`, indicating that it should be used as a simplification rule in further proofs."}
{"full_name": "ConNF.NewAllowable.smul_address_eq_smul_iff", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.smul_address_eq_smul_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.smul_address_eq_smul_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {Ï : ConNF.NewAllowable} {Ï' : ConNF.NewAllowable} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘ConNF.Î±} :Ï â€¢ c = Ï' â€¢ c â†” ConNF.NewAllowable.toStructPerm Ï c.path â€¢ c.value = ConNF.NewAllowable.toStructPerm Ï' c.path â€¢ c.value", "code": "theorem NewAllowable.smul_address_eq_smul_iff\n    {Ï Ï' : NewAllowable} {c : Address Î±} :\n    Ï â€¢ c = Ï' â€¢ c â†”\n    NewAllowable.toStructPerm Ï c.path â€¢ c.value =\n      NewAllowable.toStructPerm Ï' c.path â€¢ c.value :=\n  StructPerm.smul_address_eq_smul_iff\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [451, 457], "informalization": "The theorem `ConNF.NewAllowable.smul_address_eq_smul_iff` states that for two `ConNF.NewAllowable` objects `Ï` and `Ï'` and a `ConNF.Address` object `c`, the equation `Ï â€¢ c = Ï' â€¢ c` holds if and only if the permutation of `c`'s value by `Ï` is equal to the permutation of `c`'s value by `Ï'`."}
{"full_name": "ConNF.NewAllowable.coe_smul_newTangle", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.coe_smul_newTangle", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_smul_newTangle [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (Ï : ConNF.NewAllowable) (t : ConNF.NewTangle) :Ï â€¢ â†‘t = Ï â€¢ â†‘t", "code": "theorem coe_smul_newTangle (Ï : NewAllowable) (t : NewTangle) :\n    ((Ï â€¢ t) : Semitangle) = Ï â€¢ (t : Semitangle) :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [506, 509], "informalization": "The theorem `ConNF.NewAllowable.coe_smul_newTangle` states that the scalar multiplication of a `ConNF.NewAllowable` object `Ï` with a `ConNF.NewTangle` object `t` is equal to the scalar multiplication of `Ï` with the underlying `ConNF.Tangle` object of `t`."}
{"full_name": "ConNF.Enumeration.ext", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.ext :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } {Î± : Type u_1} (x y : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±), x.max = y.max â†’ HEqğŸ”—<|PREMISE|>ğŸ”— x.f y.f â†’ x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 59, 126], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [15, 16], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-enumeration is a function from an initial segment of `Îº` to `Î±`. The theorem `ConNF.Enumeration.ext` states that two `Î±`-enumerations `x` and `y` are equal if their maximum values (`x.max` and `y.max`) are equal and their functions (`x.f` and `y.f`) are heterogeneously equal (`HEq`)."}
{"full_name": "ConNF.Enumeration.ext_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.ext_iff :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } {Î± : Type u_1} (x y : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±), x = y â†” x.max = y.max âˆ§ HEqğŸ”—<|PREMISE|>ğŸ”— x.f y.f", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 59, 126], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [15, 16], "informalization": "The theorem `ConNF.Enumeration.ext_iff` states that two `Î±`-enumerations `x` and `y` are equal if and only if their maximum values `x.max` and `y.max` are equal and the functions `x.f` and `y.f` are heterogeneously equal (`HEq`)."}
{"full_name": "ConNF.Enumeration.mem_carrier_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.mem_carrier_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.mem_carrier_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (x : Î±) (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :x âˆˆ ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— E â†” âˆƒ (i : ConNF.Îº) (h : i < E.max), x = E.f i h", "code": "theorem Enumeration.mem_carrier_iff (x : Î±) (E : Enumeration Î±) :\n    x âˆˆ E.carrier â†” âˆƒ i, âˆƒ (h : i < E.max), x = E.f i h :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 59, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [29, 32], "informalization": "The theorem `ConNF.Enumeration.mem_carrier_iff` states that an element `x` is in the carrier set of an `Î±`-enumeration `E` if and only if there exists an index `i` less than `E.max` such that `x` is equal to `E.f i h`, where `h` is a proof that `i` is less than `E.max`."}
{"full_name": "ConNF.Enumeration.mem_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.mem_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (c : Î±) (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :c âˆˆ E â†” âˆƒ (i : ConNF.Îº) (h : i < E.max), c = E.f i h", "code": "theorem Enumeration.mem_iff (c : Î±) (E : Enumeration Î±) :\n    c âˆˆ E â†” âˆƒ i, âˆƒ (h : i < E.max), c = E.f i h :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [33, 36], "informalization": "The theorem `ConNF.Enumeration.mem_iff` states that an element `c` is a member of an enumeration `E` if and only if there exists an index `i` less than the maximum index of `E` such that `c` is equal to the value of `E` at `i`."}
{"full_name": "ConNF.Enumeration.f_mem", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.f_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.f_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (i : ConNF.Îº) (hi : i < E.max) :E.f i hi âˆˆ E", "code": "theorem Enumeration.f_mem (E : Enumeration Î±) (i : Îº) (hi : i < E.max) :\n    E.f i hi âˆˆ E :=\n  âŸ¨i, hi, rflâŸ©\n", "additional_info": "", "used_premises": [1, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [37, 40], "informalization": "The theorem `ConNF.Enumeration.f_mem` states that for any `Î±`-enumeration `E` and any `i` less than `E.max`, the value `E.f i hi` (where `hi` is a proof that `i < E.max`) is an element of `E`."}
{"full_name": "ConNF.Enumeration.carrier_small", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.carrier_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.carrier_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— E)", "code": "theorem Enumeration.carrier_small (E : Enumeration Î±) : Small E.carrier := by\n  refine lt_of_le_of_lt (b := #(Set.Iio E.max)) ?_ (card_typein_lt (Â· < Â·) E.max Params.Îº_ord.symm)\n  refine mk_le_of_surjective (f := fun x => âŸ¨E.f x x.prop, x, x.prop, rflâŸ©) ?_\n  rintro âŸ¨_, i, h, rflâŸ©\n  exact âŸ¨âŸ¨i, hâŸ©, rflâŸ©\n", "additional_info": "", "used_premises": [1, 59, 233, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [41, 46], "informalization": "The theorem `ConNF.Enumeration.carrier_small` states that the carrier set of an `Î±`-enumeration `E`, which consists of all elements `c` of type `Î±` that can be expressed as `E.f i h` for some `i < E.max`, has a cardinality strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Small", "url": "ConNF/BaseType/Small.html#ConNF.Small", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "def Small (s : Set Î±) : Prop :=\n  #s < #Îº\n", "additional_info": "A set is small if its cardinality is strictly less than `Îº`.\nEquations\n* ğŸ—ŸConNF.SmallğŸ—ŸğŸ”—../.././ConNF/BaseType/Small.html#ConNF.SmallğŸ”—  s ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸCardinal.mkğŸ—ŸğŸ”—../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mkğŸ”—  â†‘s ğŸ—Ÿ<ğŸ—ŸğŸ”—../.././Init/Prelude.html#LT.ltğŸ”—  ğŸ—ŸCardinal.mkğŸ—ŸğŸ”—../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mkğŸ”—  ConNF.Îº)\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/Small.lean", "pos": [25, 27], "informalization": "Function `ConNF.Small` is a predicate that checks if the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Enumeration.small", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— E)", "code": "theorem Enumeration.small (E : Enumeration Î±) : Small (E : Set Î±) :=\n  E.carrier_small\n", "additional_info": "", "used_premises": [1, 59, 233, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [47, 49], "informalization": "Function `ConNF.Enumeration.small` proves that the carrier set of an `Î±`-enumeration `E` is strictly smaller than the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.funMap_injective", "url": "ConNF/Structural/Enumeration.html#ConNF.funMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.funMap_injective {Î± : Type u_1} {Î² : Type u_1} [LinearOrderğŸ”—<|PREMISE|>ğŸ”— Î²] [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î² fun (x x_1 : Î²) => x < x_1] :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.funMapğŸ”—<|PREMISE|>ğŸ”— Î± Î²)", "code": "theorem funMap_injective {Î± Î² : Type _} [LinearOrder Î²] [IsWellOrder Î² (Â· < Â·)] :\n    Function.Injective (funMap Î± Î²) := by\n  intro f g h\n  simp only [funMap, Prod.mk.injEq, Subtype.mk.injEq] at h\n  suffices : âˆ€ y : Î², âˆ€ x : Î±, f x = y â†’ g x = y\n  Â· ext x : 1\n    rw [this]\n    rfl\n  intro y\n  refine IsWellFounded.induction (Â· < Â·) (C := fun y => âˆ€ x : Î±, f x = y â†’ g x = y) y ?_\n  clear y\n  rintro y ih x rfl\n  obtain âŸ¨y, hâ‚âŸ© : f x âˆˆ Set.range g\n  Â· rw [â† h.1]\n    exact âŸ¨x, rflâŸ©\n  rw [â† hâ‚]\n  obtain (hâ‚‚ | hâ‚‚ | hâ‚‚) := lt_trichotomy (g x) (g y)\n  Â· obtain âŸ¨z, hâ‚ƒâŸ© : g x âˆˆ Set.range f\n    Â· rw [h.1]\n      exact âŸ¨x, rflâŸ©\n    rw [hâ‚, â† hâ‚ƒ] at hâ‚‚\n    have hâ‚„ := ih (f z) hâ‚‚ z rfl\n    have := congr_funâ‚‚ h.2 z x\n    simp only [InvImage, hâ‚‚, eq_iff_iff, true_iff] at this\n    rw [hâ‚„, hâ‚ƒ] at this\n    cases lt_irrefl _ this\n  Â· exact hâ‚‚\n  Â· have := congr_funâ‚‚ h.2 y x\n    simp only [InvImage, eq_iff_iff] at this\n    rw [â† this] at hâ‚‚\n    have := ih (f y) hâ‚‚ y rfl\n    have := hâ‚‚.trans_eq (hâ‚.symm.trans this)\n    cases lt_irrefl _ this\n", "additional_info": "", "used_premises": [2, 15, 89, 236], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [60, 93], "informalization": "The theorem `ConNF.funMap_injective` states that the function `ConNF.funMap`, which maps a function `f` from `Î±` to `Î²` to a pair consisting of the range of `f` and the inverse image of the less-than relation on `Î²` under `f`, is injective."}
{"full_name": "ConNF.funMap", "url": "ConNF/Structural/Enumeration.html#ConNF.funMap", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.funMap (Î± : Type u_1) (Î² : Type u_1) [LTğŸ”—<|PREMISE|>ğŸ”— Î²] (f : Î± â†’ Î²) :{ E : SetğŸ”—<|PREMISE|>ğŸ”— Î² // Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘E â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î± } Ã— (Î± â†’ Î± â†’ Prop )", "code": "def funMap (Î± Î² : Type _) [LT Î²] (f : Î± â†’ Î²) :\n    { E : Set Î² // #E â‰¤ #Î± } Ã— (Î± â†’ Î± â†’ Prop) :=\n  âŸ¨âŸ¨Set.range f, mk_range_leâŸ©, InvImage (Â· < Â·) fâŸ©\n", "additional_info": "Equations\n* ğŸ—ŸConNF.funMapğŸ—ŸğŸ”—../.././ConNF/Structural/Enumeration.html#ConNF.funMapğŸ”—  Î± Î² f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ({ val := ğŸ—ŸSet.rangeğŸ—ŸğŸ”—../.././Mathlib/Data/Set/Defs.html#Set.rangeğŸ”—  f, property := â‹¯ }, ğŸ—ŸInvImageğŸ—ŸğŸ”—../.././Init/Core.html#InvImageğŸ”—  (fun (x x_1 : Î²) => x ğŸ—Ÿ<ğŸ—ŸğŸ”—../.././Init/Prelude.html#LT.ltğŸ”—  x_1) f)\n\n", "used_premises": [6, 69, 29, 29], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [56, 59], "informalization": "Function `ConNF.funMap` takes a type `Î±`, a type `Î²` with a less-than relation, and a function `f` from `Î±` to `Î²`. It returns a pair consisting of a subset of `Î²` (the range of `f`) and a relation on `Î±` (the inverse image of the less-than relation on `Î²` under `f`)."}
{"full_name": "ConNF.mk_fun_le", "url": "ConNF/Structural/Enumeration.html#ConNF.mk_fun_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_fun_le {Î± : Type u} {Î² : Type u} :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (Î± â†’ Î²) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ({ E : SetğŸ”—<|PREMISE|>ğŸ”— Î² // Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘E â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î± } Ã— (Î± â†’ Î± â†’ Prop ))", "code": "theorem mk_fun_le {Î± Î² : Type u} :\n    #(Î± â†’ Î²) â‰¤ #({ E : Set Î² // #E â‰¤ #Î± } Ã— (Î± â†’ Î± â†’ Prop)) := by\n  classical\n  obtain âŸ¨r, hrâŸ© := IsWellOrder.subtype_nonempty (Ïƒ := Î²)\n  let _ := linearOrderOfSTO r\n  exact âŸ¨âŸ¨funMap Î± Î², funMap_injectiveâŸ©âŸ©\n", "additional_info": "", "used_premises": [29, 29, 69, 29, 29], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [94, 100], "informalization": "The cardinality of the set of functions from Î± to Î² is less than or equal to the product of the cardinality of the set of subsets of Î² whose cardinality is less than or equal to the cardinality of Î±, and the set of binary relations on Î±."}
{"full_name": "ConNF.pow_le_of_isStrongLimit'", "url": "ConNF/Structural/Enumeration.html#ConNF.pow_le_of_isStrongLimit'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pow_le_of_isStrongLimit' {Î± : Type u} {Î² : Type u} [InfiniteğŸ”—<|PREMISE|>ğŸ”— Î±] [InfiniteğŸ”—<|PREMISE|>ğŸ”— Î²] (hâ‚ : Cardinal.IsStrongLimitğŸ”—<|PREMISE|>ğŸ”— (Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²)) (hâ‚‚ : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î± < Ordinal.cofğŸ”—<|PREMISE|>ğŸ”— (Cardinal.ordğŸ”—<|PREMISE|>ğŸ”— (Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²))) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î² ^ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î± â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²", "code": "theorem pow_le_of_isStrongLimit' {Î± Î² : Type u} [Infinite Î±] [Infinite Î²]\n    (hâ‚ : IsStrongLimit #Î²) (hâ‚‚ : #Î± < (#Î²).ord.cof) : #Î² ^ #Î± â‰¤ #Î² := by\n  refine le_trans mk_fun_le ?_\n  simp only [mk_prod, Cardinal.lift_id, mk_pi, mk_fintype, Fintype.card_prop, Nat.cast_ofNat,\n    prod_const, Cardinal.lift_id', lift_two]\n  have hâ‚ƒ : #{ E : Set Î² // #E â‰¤ #Î± } â‰¤ #Î²\n  Â· rw [â† mk_subset_mk_lt_cof hâ‚.2]\n    refine âŸ¨âŸ¨fun E => âŸ¨E, E.prop.trans_lt hâ‚‚âŸ©, ?_âŸ©âŸ©\n    intro E F h\n    simp only [Subtype.mk.injEq] at h\n    exact Subtype.coe_injective h\n  have hâ‚„ : (2 ^ #Î±) ^ #Î± â‰¤ #Î²\n  Â· rw [â† power_mul, mul_eq_self (Cardinal.infinite_iff.mp inferInstance)]\n    refine (hâ‚.2 _ ?_).le\n    exact hâ‚‚.trans_le (cof_ord_le #Î²)\n  refine le_trans (mul_le_max _ _) ?_\n  simp only [ge_iff_le, le_max_iff, max_le_iff, le_aleph0_iff_subtype_countable, hâ‚ƒ, hâ‚„, and_self,\n    aleph0_le_mk]\n", "additional_info": "", "used_premises": [239, 239, 37, 29, 29, 38, 27, 29, 29, 29, 29], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [101, 119], "informalization": "The theorem `ConNF.pow_le_of_isStrongLimit'` states that for any two infinite types `Î±` and `Î²`, if `Î²` is a strong limit cardinal and the cardinality of `Î±` is less than the cofinality of the ordinal corresponding to the cardinality of `Î²`, then the cardinality of `Î²` raised to the power of the cardinality of `Î±` is less than or equal to the cardinality of `Î²`."}
{"full_name": "Infinite", "url": "Mathlib/Data/Finite/Defs.html#Infinite", "code_src": "mathlib4", "ptype": "class", "header": "class Infinite (Î± : Sort u_3) :Prop\n | not_finite : Â¬ FiniteğŸ”—<|PREMISE|>ğŸ”—  Î±", "code": "class Infinite (Î± : Sort*) : Prop where\n  /-- assertion that `Î±` is `Â¬Finite`-/\n  not_finite : Â¬Finite Î±\n", "additional_info": "A type is said to be infinite if it is not finite. Note that `ğŸ—ŸInfiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#InfiniteğŸ”—  Î±` is equivalent to\n`ğŸ—ŸIsEmptyğŸ—ŸğŸ”—../../.././Mathlib/Logic/IsEmpty.html#IsEmptyğŸ”—  (Fintype Î±)` or `ğŸ—ŸIsEmptyğŸ—ŸğŸ”—../../.././Mathlib/Logic/IsEmpty.html#IsEmptyğŸ”—  (Finite Î±)`.\n- Infinite.not_finite: assertion that `Î±` is `Â¬Finite`\n\n\n", "used_premises": [240], "def_path": "Mathlib/Data/Finite/Defs.lean", "pos": [116, 119], "informalization": "Class `Infinite` represents the proposition that a type `Î±` is infinite, meaning it does not have a finite number of elements and cannot be bijectively mapped to any finite set `Fin n`."}
{"full_name": "Finite", "url": "Mathlib/Data/Finite/Defs.html#Finite", "code_src": "mathlib4", "ptype": "class inductive", "header": "class inductive Finite (Î± : Sort u_1) :Prop", "code": "class inductive Finite (Î± : Sort*) : Prop\n  | intro {n : â„•} : Î± â‰ƒ Fin n â†’ Finite _\n", "additional_info": "A type is `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  if it is in bijective correspondence to some `ğŸ—ŸFinğŸ—ŸğŸ”—../../.././Init/Prelude.html#FinğŸ”—  n`.\nThis is similar to `Fintype`, but `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  is a proposition rather than data.\nA particular benefit to this is that `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  instances are definitionally equal to one another\n(due to proof irrelevance) rather than being merely propositionally equal,\nand, furthermore, `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  instances generally avoid the need for `ğŸ—ŸDecidableğŸ—ŸğŸ”—../../.././Init/Prelude.html#DecidableğŸ”—`  instances.\nOne other notable difference is that `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  allows there to be `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—  p` instances\nfor all `p : Prop`, which is not allowed by `Fintype` due to universe constraints.\nAn application of this is that `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—  (x âˆˆ s â†’ Î² x)` follows from the general instance for pi\ntypes, assuming `[âˆ€ x, ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—  (Î² x)]`.\nImplementation note: this is a reason `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—  Î±` is not defined as `ğŸ—ŸNonemptyğŸ—ŸğŸ”—../../.././Init/Prelude.html#NonemptyğŸ”—  (Fintype Î±)`.\nEvery `Fintype` instance provides a `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  instance via `Finite.of_fintype`.\nConversely, one can noncomputably create a `Fintype` instance from a `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  instance\nvia `Fintype.ofFinite`. In a proof one might write\n  have := Fintype.ofFinite Î±\n\nto obtain such an instance.\nDo not write noncomputable `Fintype` instances; instead write `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  instances\nand use this `Fintype.ofFinite` interface.\nThe `Fintype` instances should be relied upon to be computable for evaluation purposes.\nTheorems should use `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  instead of `Fintype`, unless definitions in the theorem statement\nrequire `Fintype`.\nDefinitions should prefer `ğŸ—ŸFiniteğŸ—ŸğŸ”—../../.././Mathlib/Data/Finite/Defs.html#FiniteğŸ”—`  as well, unless it is important that the definitions\nare meant to be computable in the reduction or `#eval` sense.\n", "used_premises": [], "def_path": "Mathlib/Data/Finite/Defs.lean", "pos": [80, 82], "informalization": "Class `Finite` represents the proposition that a type `Î±` is finite, meaning it has a finite number of elements, and can be bijectively mapped to a finite set `Fin n` for some natural number `n`."}
{"full_name": "ConNF.pow_le_of_isStrongLimit", "url": "ConNF/Structural/Enumeration.html#ConNF.pow_le_of_isStrongLimit", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pow_le_of_isStrongLimit {Îº : CardinalğŸ”—<|PREMISE|>ğŸ”— } {Î¼ : CardinalğŸ”—<|PREMISE|>ğŸ”— } (hâ‚ : Cardinal.IsStrongLimitğŸ”—<|PREMISE|>ğŸ”— Î¼) (hâ‚‚ : Îº < Ordinal.cofğŸ”—<|PREMISE|>ğŸ”— (Cardinal.ordğŸ”—<|PREMISE|>ğŸ”— Î¼)) :Î¼ ^ Îº â‰¤ Î¼", "code": "theorem pow_le_of_isStrongLimit {Îº Î¼ : Cardinal.{u}} (hâ‚ : IsStrongLimit Î¼) (hâ‚‚ : Îº < Î¼.ord.cof) :\n    Î¼ ^ Îº â‰¤ Î¼ := by\n  by_cases h : Îº < â„µâ‚€\n  Â· exact pow_le hâ‚.isLimit.aleph0_le h\n  Â· revert hâ‚ hâ‚‚ h\n    refine inductionOnâ‚‚ Îº Î¼ ?_\n    intro Î± Î² hâ‚ hâ‚‚ h\n    have := Cardinal.infinite_iff.mpr (le_of_not_lt h)\n    have := Cardinal.infinite_iff.mpr hâ‚.isLimit.aleph0_le\n    exact pow_le_of_isStrongLimit' hâ‚ hâ‚‚\n", "additional_info": "", "used_premises": [28, 28, 37, 38, 27], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [120, 130], "informalization": "If `Î¼` is a strong limit cardinal and `Îº` is less than the cofinality of `Î¼`, then `Î¼ ^ Îº â‰¤ Î¼`."}
{"full_name": "ConNF.mk_enumeration", "url": "ConNF/Structural/Enumeration.html#ConNF.mk_enumeration", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_enumeration [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (mk_Î± : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î± = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_enumeration (mk_Î± : #Î± = #Î¼) : #(Enumeration Î±) = #Î¼ := by\n  refine le_antisymm ?_ ?_\n  Â· rw [Cardinal.mk_congr enumerationEquiv]\n    simp only [mk_sigma, mk_pi, mk_Î±, prod_const, Cardinal.lift_id]\n    refine le_trans (sum_le_sum _ (fun _ => #Î¼) ?_) ?_\n    Â· intro i\n      refine pow_le_of_isStrongLimit Params.Î¼_isStrongLimit ?_\n      refine lt_of_lt_of_le ?_ Params.Îº_le_Î¼_ord_cof\n      exact card_typein_lt (Â· < Â·) i Params.Îº_ord.symm\n    Â· simp only [sum_const, Cardinal.lift_id, mul_mk_eq_max, ge_iff_le, max_le_iff, le_refl,\n        and_true]\n      exact Params.Îº_lt_Î¼.le\n  Â· rw [â† mk_Î±]\n    refine âŸ¨âŸ¨fun x => âŸ¨1, fun _ _ => xâŸ©, ?_âŸ©âŸ©\n    intro aâ‚ aâ‚‚ h\n    simp only [Enumeration.mk.injEq, heq_eq_eq, true_and] at h\n    exact congr_funâ‚‚ h 0 Îº_zero_lt_one\n", "additional_info": "Given that `#Î± = #Î¼`, there are exactly `Î¼` Enumerations.", "used_premises": [1, 29, 29, 29, 59, 29], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [133, 150], "informalization": "The theorem `ConNF.mk_enumeration` states that if the cardinality of a type `Î±` is equal to the cardinality of `Î¼`, then the number of `Î±`-enumerations, which are functions from an initial segment of `Îº` to `Î±`, is also equal to the cardinality of `Î¼`."}
{"full_name": "ConNF.Enumeration.image_max", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.image_max [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {Î² : Type u_2} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î²) :(ConNF.Enumeration.imageğŸ”—<|PREMISE|>ğŸ”— E f).max = E.max", "code": "theorem image_max (E : Enumeration Î±) (f : Î± â†’ Î²) :\n    (E.image f).max = E.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 59, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [158, 161], "informalization": "The function `ConNF.Enumeration.image` transforms an `Î±`-enumeration `E` into a `Î²`-enumeration by applying a function `f : Î± â†’ Î²` to each element in the range of `E`. The maximum value of the resulting `Î²`-enumeration is equal to the maximum value of the original `Î±`-enumeration."}
{"full_name": "ConNF.Enumeration.image", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.image [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {Î² : Type u_2} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î²) :ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î²", "code": "def image (E : Enumeration Î±) (f : Î± â†’ Î²) : Enumeration Î² where\n  max := E.max\n  f i hi := f (E.f i hi)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Enumeration.imageğŸ—ŸğŸ”—../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.imageğŸ”—  E f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  { max := E.max, f := fun (i : ConNF.Îº) (hi : i ğŸ—Ÿ<ğŸ—ŸğŸ”—../.././Init/Prelude.html#LT.ltğŸ”—  E.max) => f (E.f i hi) }\n\n", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [153, 156], "informalization": "Function `ConNF.Enumeration.image` transforms an `Î±`-enumeration `E` into a `Î²`-enumeration by applying a function `f : Î± â†’ Î²` to each element in the range of `E`."}
{"full_name": "ConNF.Enumeration.image_f", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_f", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.image_f [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {Î² : Type u_2} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î²) (i : ConNF.Îº) (hi : i < E.max) :(ConNF.Enumeration.imageğŸ”—<|PREMISE|>ğŸ”— E f).f i hi = f (E.f i hi)", "code": "theorem image_f (E : Enumeration Î±) (f : Î± â†’ Î²) (i : Îº) (hi : i < E.max) :\n    (E.image f).f i hi = f (E.f i hi) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 59, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [163, 166], "informalization": "The function `ConNF.Enumeration.image` transforms an `Î±`-enumeration `E` into a `Î²`-enumeration by applying a function `f : Î± â†’ Î²` to each element in the range of `E`. The theorem `ConNF.Enumeration.image_f` states that for any `Î±`-enumeration `E`, any function `f : Î± â†’ Î²`, and any `i < E.max`, the `i`-th element of the `Î²`-enumeration `ConNF.Enumeration.image E f` is equal to `f` applied to the `i`-th element of `E`."}
{"full_name": "ConNF.Enumeration.image_carrier", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_carrier", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.image_carrier [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {Î² : Type u_2} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î²) :ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.imageğŸ”—<|PREMISE|>ğŸ”— E f) = f '' ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— E", "code": "theorem image_carrier (E : Enumeration Î±) (f : Î± â†’ Î²) :\n    (E.image f).carrier = f '' E.carrier := by\n  ext x : 1\n  constructor\n  Â· rintro âŸ¨i, hi, hâŸ©\n    exact âŸ¨_, âŸ¨i, hi, rflâŸ©, h.symmâŸ©\n  Â· rintro âŸ¨_, âŸ¨i, hi, rflâŸ©, hâŸ©\n    exact âŸ¨i, hi, h.symmâŸ©\n", "additional_info": "", "used_premises": [1, 59, 70, 244, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [168, 176], "informalization": "Function `ConNF.Enumeration.image_carrier` states that the carrier set of the image of an `Î±`-enumeration `E` under a function `f : Î± â†’ Î²` is equal to the image of the carrier set of `E` under `f`."}
{"full_name": "ConNF.Enumeration.image_coe", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.image_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {Î² : Type u_2} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î²) :ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.imageğŸ”—<|PREMISE|>ğŸ”— E f) = f '' ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— E", "code": "theorem image_coe (E : Enumeration Î±) (f : Î± â†’ Î²) :\n    (E.image f : Enumeration Î²) = f '' (E : Set Î±) :=\n  image_carrier E f\n", "additional_info": "", "used_premises": [1, 59, 70, 244, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [178, 181], "informalization": "The theorem `ConNF.Enumeration.image_coe` states that the carrier set of the image of an `Î±`-enumeration `E` under a function `f : Î± â†’ Î²` is equal to the image of the carrier set of `E` under `f`."}
{"full_name": "ConNF.Enumeration.apply_mem_image", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.apply_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.apply_mem_image [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {Î² : Type u_2} {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} {x : Î±} (h : x âˆˆ E) (f : Î± â†’ Î²) :f x âˆˆ ConNF.Enumeration.imageğŸ”—<|PREMISE|>ğŸ”— E f", "code": "theorem apply_mem_image {E : Enumeration Î±} {x : Î±} (h : x âˆˆ E) (f : Î± â†’ Î²) : f x âˆˆ E.image f := by\n  obtain âŸ¨i, hi, rflâŸ© := h\n  exact âŸ¨i, hi, rflâŸ©\n", "additional_info": "", "used_premises": [1, 59, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [182, 185], "informalization": "The theorem `ConNF.Enumeration.apply_mem_image` states that if `x` is an element of an `Î±`-enumeration `E` and `f` is a function from `Î±` to `Î²`, then `f x` is an element of the `Î²`-enumeration obtained by applying `f` to each element in the range of `E`."}
{"full_name": "ConNF.Enumeration.apply_eq_of_image_eq", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.apply_eq_of_image_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.apply_eq_of_image_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} (f : Î± â†’ Î±) (hE : ConNF.Enumeration.imageğŸ”—<|PREMISE|>ğŸ”— E f = E) {x : Î±} (hx : x âˆˆ E) :f x = x", "code": "theorem apply_eq_of_image_eq {E : Enumeration Î±} (f : Î± â†’ Î±)\n    (hE : E.image f = E) {x : Î±} (hx : x âˆˆ E) : f x = x := by\n  obtain âŸ¨i, hi, rflâŸ© := hx\n  have := image_f E f i hi\n  conv at this => lhs; simp only [hE]\n  exact this.symm\n", "additional_info": "", "used_premises": [1, 59, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [186, 192], "informalization": "Given an `Î±`-enumeration `E` and a function `f : Î± â†’ Î±`, if the image of `E` under `f` is equal to `E`, and `x` is an element of `E`, then `f x = x`."}
{"full_name": "ConNF.Enumeration.smul_max", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.smul_max [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_2} {G : Type u_1} [SMulğŸ”—<|PREMISE|>ğŸ”— G Î±] (g : G) (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :(g â€¢ E).max = E.max", "code": "theorem smul_max {G : Type _} [SMul G Î±] (g : G) (E : Enumeration Î±) :\n    (g â€¢ E).max = E.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 57, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [197, 200], "informalization": "The theorem `ConNF.Enumeration.smul_max` states that for an enumeration `E` of type `Î±` and a scalar `g` of type `G`, the maximum value of the enumeration `g â€¢ E` is equal to the maximum value of the original enumeration `E`."}
{"full_name": "ConNF.Enumeration.smul_f", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_f", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.smul_f [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_2} {G : Type u_1} [SMulğŸ”—<|PREMISE|>ğŸ”— G Î±] (g : G) (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (i : ConNF.Îº) (hi : i < E.max) :(g â€¢ E).f i hi = g â€¢ E.f i hi", "code": "theorem smul_f {G : Type _} [SMul G Î±]\n    (g : G) (E : Enumeration Î±) (i : Îº) (hi : i < E.max) :\n    (g â€¢ E).f i hi = g â€¢ E.f i hi :=\n  rfl\n", "additional_info": "", "used_premises": [1, 57, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [202, 206], "informalization": "The theorem `ConNF.Enumeration.smul_f` states that for an `Î±`-enumeration `E` and an element `g` of a group `G` that acts on `Î±`, the `i`-th element of the enumeration `g â€¢ E` is equal to `g` acting on the `i`-th element of `E`."}
{"full_name": "ConNF.Enumeration.smul_mem_smul", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_mem_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.smul_mem_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_2} {G : Type u_1} [SMulğŸ”—<|PREMISE|>ğŸ”— G Î±] {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} {x : Î±} (h : x âˆˆ E) (g : G) :g â€¢ x âˆˆ g â€¢ E", "code": "theorem smul_mem_smul {G : Type _} [SMul G Î±]\n    {E : Enumeration Î±} {x : Î±} (h : x âˆˆ E) (g : G) : g â€¢ x âˆˆ g â€¢ E :=\n  apply_mem_image h _\n", "additional_info": "", "used_premises": [1, 57, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [217, 220], "informalization": "The theorem `ConNF.Enumeration.smul_mem_smul` is a member of the `ConNF.Enumeration` class in Lean 4. The `ConNF Params` class defines a set of parameters that are used in the context of Constructive Ordinal Notation (ConNF) for constructing natural numbers. The `SMul` class represents the concept of scalar multiplication, and an `Î±`-enumeration is a function from an initial segment of `Îº` to `Î±`. This theorem states that if `x` is a member of the enumeration `E` and `g` is an element of a group `G` that acts on `Î±`, then `g â€¢ x` is a member of `g â€¢ E`."}
{"full_name": "ConNF.Enumeration.smul_eq_of_smul_eq", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_eq_of_smul_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.smul_eq_of_smul_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_2} {G : Type u_1} [SMulğŸ”—<|PREMISE|>ğŸ”— G Î±] {g : G} {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} (hE : g â€¢ E = E) {x : Î±} (hx : x âˆˆ E) :g â€¢ x = x", "code": "theorem smul_eq_of_smul_eq {G : Type _} [SMul G Î±] {g : G} {E : Enumeration Î±}\n    (hE : g â€¢ E = E) {x : Î±} (hx : x âˆˆ E) : g â€¢ x = x :=\n  apply_eq_of_image_eq _ hE hx\n", "additional_info": "", "used_premises": [1, 57, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [221, 224], "informalization": "The theorem `ConNF.Enumeration.smul_eq_of_smul_eq` states that if `E` is an `Î±`-enumeration and `g â€¢ E = E`, then for any `x` in the range of `E`, `g â€¢ x = x`."}
{"full_name": "ConNF.Enumeration.add_max", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.add_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.add_max [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} {F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} :(E + F).max = E.max + F.max", "code": "theorem add_max {E F : Enumeration Î±} : (E + F).max = E.max + F.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [257, 259], "informalization": "Function `ConNF.Enumeration.add_max` states that the maximum value of the sum of two enumerations `E` and `F` is equal to the sum of their maximum values."}
{"full_name": "ConNF.Enumeration.add_coe", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.add_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.add_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (E + F) = ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— E âˆª ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— F", "code": "theorem add_coe (E F : Enumeration Î±) :\n    (E + F : Set Î±) = (E : Set _) âˆª F := by\n  ext c\n  simp only [mem_carrier_iff, Set.mem_union]\n  constructor\n  Â· rintro âŸ¨i, hi, rflâŸ©\n    by_cases hi' : i < E.max\n    Â· refine Or.inl âŸ¨i, hi', ?_âŸ©\n      rw [add_f_left]\n    Â· refine Or.inr âŸ¨i - E.max, Îº_sub_lt hi (not_lt.mp hi'), ?_âŸ©\n      rw [add_f_right]\n      exact not_lt.mp hi'\n  Â· rintro (âŸ¨i, hi, rflâŸ© | âŸ¨i, hi, rflâŸ©)\n    Â· refine âŸ¨i, hi.trans_le (Îº_le_self_add _ _), ?_âŸ©\n      rw [add_f_left]\n    Â· refine âŸ¨E.max + i, add_lt_add_left hi E.max, ?_âŸ©\n      rw [add_f_right_add]\n", "additional_info": "", "used_premises": [1, 59, 59, 70, 70, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [274, 291], "informalization": "The theorem `ConNF.Enumeration.add_coe` states that the carrier set of the sum of two `Î±`-enumerations `E` and `F` is the union of the carrier sets of `E` and `F`."}
{"full_name": "ConNF.Enumeration.mem_add_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.mem_add_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.mem_add_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (x : Î±) :x âˆˆ E + F â†” x âˆˆ E âˆ¨ x âˆˆ F", "code": "theorem mem_add_iff (E F : Enumeration Î±) (x : Î±) :\n    x âˆˆ E + F â†” x âˆˆ E âˆ¨ x âˆˆ F := by\n  change x âˆˆ (E + F : Set Î±) â†” _\n  rw [add_coe]\n  rfl\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [293, 298], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-enumeration is a function from an initial segment of `Îº` to `Î±`. The theorem `ConNF.Enumeration.mem_add_iff` states that for two `Î±`-enumerations `E` and `F`, an element `x` is in the sum of `E` and `F` if and only if `x` is in `E` or `x` is in `F`."}
{"full_name": "ConNF.Enumeration.smul_add", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_add", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.smul_add [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_2} {G : Type u_1} [SMulğŸ”—<|PREMISE|>ğŸ”— G Î±] {g : G} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :g â€¢ (E + F) = g â€¢ E + g â€¢ F", "code": "theorem smul_add {G : Type _} [SMul G Î±] {g : G} (E F : Enumeration Î±) :\n    g â€¢ (E + F) = g â€¢ E + g â€¢ F := by\n  ext\n  Â· rfl\n  rw [heq_iff_eq]\n  ext i hi : 2\n  by_cases hi' : i < E.max\n  Â· rw [smul_f, add_f_left (show i < (g â€¢ E).max from hi'), add_f_left hi', smul_f]\n  Â· rw [smul_f, add_f_right hi (show (g â€¢ E).max â‰¤ i from le_of_not_lt hi'),\n      add_f_right (show i < (g â€¢ E + g â€¢ F).max from hi)\n        (show (g â€¢ E).max â‰¤ i from le_of_not_lt hi'), smul_f]\n    rfl\n", "additional_info": "", "used_premises": [1, 57, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [300, 312], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-enumeration is a function from an initial segment of `Îº` to `Î±`. Given two `Î±`-enumerations `E` and `F`, and a scalar `g`, the theorem `smul_add` states that the scalar multiplication of the sum of `E` and `F` by `g` is equal to the sum of the scalar multiplication of `E` by `g` and the scalar multiplication of `F` by `g`."}
{"full_name": "ConNF.Enumeration.le_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.le_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.le_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :E â‰¤ F â†” E.max â‰¤ F.max âˆ§ âˆ€ (i : ConNF.Îº) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF", "code": "theorem le_iff (E F : Enumeration Î±) :\n    E â‰¤ F â†” E.max â‰¤ F.max âˆ§ âˆ€ (i : Îº) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [319, 322], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-enumeration is a function from an initial segment of `Îº` to `Î±`. The theorem `ConNF.Enumeration.le_iff` states that for two `Î±`-enumerations `E` and `F`, `E â‰¤ F` if and only if `E.max â‰¤ F.max` and for all `i < E.max` and `i < F.max`, `E.f i = F.f i`."}
{"full_name": "ConNF.Enumeration.lt_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.lt_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.lt_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :E < F â†” E.max < F.max âˆ§ âˆ€ (i : ConNF.Îº) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF", "code": "theorem lt_iff (E F : Enumeration Î±) :\n    E < F â†” E.max < F.max âˆ§ âˆ€ (i : Îº) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [323, 326], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-enumeration is a function from an initial segment of `Îº` to `Î±`. Given two `Î±`-enumerations `E` and `F`, `E < F` if and only if `E.max < F.max` and for all `i` less than both `E.max` and `F.max`, `E.f i = F.f i`."}
{"full_name": "ConNF.Enumeration.image_le_image", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_le_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.image_le_image [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {Î² : Type u_2} {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} {F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} (h : E â‰¤ F) (f : Î± â†’ Î²) :ConNF.Enumeration.imageğŸ”—<|PREMISE|>ğŸ”— E f â‰¤ ConNF.Enumeration.imageğŸ”—<|PREMISE|>ğŸ”— F f", "code": "theorem image_le_image {E F : Enumeration Î±} (h : E â‰¤ F) (f : Î± â†’ Î²) : E.image f â‰¤ F.image f := by\n  constructor\n  Â· exact h.1\n  Â· intro i hE hF\n    rw [image_f, image_f, h.2]\n", "additional_info": "", "used_premises": [1, 59, 59, 244, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [346, 351], "informalization": "Function `ConNF.Enumeration.image` transforms an `Î±`-enumeration `E` into a `Î²`-enumeration by applying a function `f : Î± â†’ Î²` to each element in the range of `E`. The theorem `ConNF.Enumeration.image_le_image` states that if an `Î±`-enumeration `E` is less than or equal to another `Î±`-enumeration `F`, then the `Î²`-enumeration obtained by applying `f` to `E` is also less than or equal to the `Î²`-enumeration obtained by applying `f` to `F`."}
{"full_name": "ConNF.Enumeration.smul_le_smul", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_le_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.smul_le_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_2} {G : Type u_1} [SMulğŸ”—<|PREMISE|>ğŸ”— G Î±] {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} {F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} (h : E â‰¤ F) (g : G) :g â€¢ E â‰¤ g â€¢ F", "code": "theorem smul_le_smul {G : Type _} [SMul G Î±] {E F : Enumeration Î±} (h : E â‰¤ F) (g : G) :\n    g â€¢ E â‰¤ g â€¢ F :=\n  image_le_image h (g â€¢ Â·)\n", "additional_info": "", "used_premises": [1, 57, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [352, 355], "informalization": "The theorem `ConNF.Enumeration.smul_le_smul` states that if `E` and `F` are `Î±`-enumerations and `E â‰¤ F`, then for any scalar `g`, the scalar multiplication of `E` by `g` is less than or equal to the scalar multiplication of `F` by `g`."}
{"full_name": "ConNF.Enumeration.le_add", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.le_add", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.le_add [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (F : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) :E â‰¤ E + F", "code": "theorem le_add (E F : Enumeration Î±) : E â‰¤ E + F := by\n  constructor\n  Â· simp only [add_max, le_add_iff_nonneg_right]\n    exact Îº_pos _\n  Â· intro i hE hF\n    rw [add_f_left]\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [356, 362], "informalization": "The theorem `ConNF.Enumeration.le_add` states that for any two `Î±`-enumerations `E` and `F`, the enumeration `E` is less than or equal to the sum of `E` and `F`."}
{"full_name": "ConNF.Enumeration.ord_lt_of_small", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ord_lt_of_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.ord_lt_of_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) [LinearOrderğŸ”—<|PREMISE|>ğŸ”— â†‘s] [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— â†‘s fun (x x_1 : â†‘s) => x < x_1] :(Ordinal.typeğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : â†‘s) => x < x_1) < Ordinal.typeğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : ConNF.Îº) => x < x_1", "code": "theorem ord_lt_of_small {s : Set Î±} (hs : Small s) [LinearOrder s] [IsWellOrder s (Â· < Â·)] :\n    type ((Â· < Â·) : s â†’ s â†’ Prop) < type ((Â· < Â·) : Îº â†’ Îº â†’ Prop) := by\n  by_contra! h\n  have := card_le_card h\n  simp only [card_type] at this\n  exact hs.not_le this\n", "additional_info": "", "used_premises": [1, 69, 233, 2, 15, 26, 26], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [366, 372], "informalization": "The theorem states that, given a set `s` that is strictly smaller than the cardinality of `ConNF.Îº` (the type that represents the ordinal numbers in Constructive Ordinal Notation), and `s` is endowed with a linear order and a well-order, the ordinal number corresponding to this well-ordered set is strictly less than the ordinal type of `ConNF.Îº`. This theorem is crucial for establishing the well-ordered structure of the natural numbers within the ConNF framework."}
{"full_name": "ConNF.Enumeration.ofSet'_coe", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet'_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.ofSet'_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) [LinearOrderğŸ”—<|PREMISE|>ğŸ”— â†‘s] [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— â†‘s fun (x x_1 : â†‘s) => x < x_1] :ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.ofSet'ğŸ”—<|PREMISE|>ğŸ”— s hs) = s", "code": "theorem ofSet'_coe (s : Set Î±) (hs : Small s) [LinearOrder s] [IsWellOrder s (Â· < Â·)] :\n    (ofSet' s hs : Set Î±) = s := by\n  ext x\n  rw [ofSet', mem_carrier_iff]\n  constructor\n  Â· rintro âŸ¨i, hi, rflâŸ©\n    exact Subtype.coe_prop _\n  Â· rintro hx\n    refine âŸ¨enum ((Â· < Â·) : Îº â†’ Îº â†’ Prop) (typein ((Â· < Â·) : s â†’ s â†’ Prop) âŸ¨x, hxâŸ©) ?_, ?_, ?_âŸ©\n    Â· exact (typein_lt_type _ _).trans (ord_lt_of_small hs)\n    Â· rw [enum_lt_enum (r := ((Â· < Â·) : Îº â†’ Îº â†’ Prop))]\n      exact typein_lt_type _ _\n    Â· simp only [typein_enum, enum_typein]\n", "additional_info": "", "used_premises": [1, 69, 233, 2, 15, 70, 265], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [385, 398], "informalization": "Function `ConNF.Enumeration.ofSet'` constructs an `Î±`-enumeration from a given set `s` of elements of type `Î±`, provided that `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)), and that `s` is linearly ordered and well-ordered. The `Î±`-enumeration is represented by a function that maps an initial segment of `ConNF.Îº` to `Î±`. The theorem `ConNF.Enumeration.ofSet'_coe` states that the carrier set of the `Î±`-enumeration constructed by `ConNF.Enumeration.ofSet'` is equal to the original set `s`."}
{"full_name": "ConNF.Enumeration.ofSet'", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet'", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.ofSet' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) [LinearOrderğŸ”—<|PREMISE|>ğŸ”— â†‘s] [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— â†‘s fun (x x_1 : â†‘s) => x < x_1] :ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def ofSet' (s : Set Î±) (hs : Small s) [LinearOrder s] [IsWellOrder s (Â· < Â·)] : Enumeration Î± where\n  max := enum (Â· < Â·) (type ((Â· < Â·) : s â†’ s â†’ Prop)) (ord_lt_of_small hs)\n  f i hi := (enum ((Â· < Â·) : s â†’ s â†’ Prop) (typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop) i)\n    (typein_lt_type_of_small hs hi) : s)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 69, 233, 2, 15, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [379, 383], "informalization": "Function `ConNF.Enumeration.ofSet'` constructs an `Î±`-enumeration from a given set `s` of elements of type `Î±`, provided that `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)), and that `s` is linearly ordered and well-ordered. The `Î±`-enumeration is represented by a function that maps an initial segment of `ConNF.Îº` to `Î±`."}
{"full_name": "ConNF.Enumeration.ofSet_coe", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.ofSet_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.ofSetğŸ”—<|PREMISE|>ğŸ”— s hs) = s", "code": "theorem ofSet_coe (s : Set Î±) (hs : Small s) :\n    (ofSet s hs : Set Î±) = s :=\n  letI := (IsWellOrder.subtype_nonempty (Ïƒ := s)).some.prop\n  letI := linearOrderOfSTO (IsWellOrder.subtype_nonempty (Ïƒ := s)).some.val\n  ofSet'_coe s hs\n", "additional_info": "", "used_premises": [1, 69, 233, 70, 267], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [405, 410], "informalization": "The theorem `ConNF.Enumeration.ofSet_coe` states that for any set `s` whose cardinality is strictly less than the cardinality of `ConNF.Îº`, the carrier set of the `Î±`-enumeration `ConNF.Enumeration.ofSet s hs` is equal to `s`."}
{"full_name": "ConNF.Enumeration.ofSet", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.ofSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def ofSet (s : Set Î±) (hs : Small s) : Enumeration Î± :=\n  letI := (IsWellOrder.subtype_nonempty (Ïƒ := s)).some.prop\n  letI := linearOrderOfSTO (IsWellOrder.subtype_nonempty (Ïƒ := s)).some.val\n  ofSet' s hs\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Enumeration.ofSetğŸ—ŸğŸ”—../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSetğŸ”—  s hs ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.Enumeration.ofSet'ğŸ—ŸğŸ”—../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet'ğŸ”—  s hs\n\n", "used_premises": [1, 69, 233, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [399, 403], "informalization": "Function `ConNF.Enumeration.ofSet` takes a set `s` and a proof that the cardinality of `s` is strictly less than the cardinality of `ConNF.Îº`, and returns an `Î±`-enumeration, which is a function from an initial segment of `ConNF.Îº` to `Î±`."}
{"full_name": "ConNF.Enumeration.mem_ofSet_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.mem_ofSet_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.mem_ofSet_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (x : Î±) :x âˆˆ ConNF.Enumeration.ofSetğŸ”—<|PREMISE|>ğŸ”— s hs â†” x âˆˆ s", "code": "theorem mem_ofSet_iff (s : Set Î±) (hs : Small s) (x : Î±) :\n    x âˆˆ ofSet s hs â†” x âˆˆ s := by\n  change x âˆˆ (ofSet s hs : Set Î±) â†” x âˆˆ s\n  rw [ofSet_coe]\n", "additional_info": "", "used_premises": [1, 69, 233, 267], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [412, 416], "informalization": "The theorem `ConNF.Enumeration.mem_ofSet_iff` states that for any set `s` whose cardinality is strictly less than the cardinality of `ConNF.Îº`, and any element `x` of type `Î±`, `x` belongs to the enumeration of `s` if and only if `x` belongs to `s`."}
{"full_name": "ConNF.Enumeration.chooseIndex_lt", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.chooseIndex_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.chooseIndex_lt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±} {p : Î± â†’ Prop } (h : âˆƒ (i : ConNF.Îº) (h : i < E.max), p (E.f i h)) :ConNF.Enumeration.chooseIndexğŸ”—<|PREMISE|>ğŸ”— E p h < E.max", "code": "theorem chooseIndex_lt {E : Enumeration Î±} {p : Î± â†’ Prop}\n    (h : âˆƒ i : Îº, âˆƒ h : i < E.max, p (E.f i h)) : E.chooseIndex p h < E.max :=\n  h.choose_spec.choose\n", "additional_info": "", "used_premises": [1, 59, 270], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [421, 424], "informalization": "Function `ConNF.Enumeration.chooseIndex` takes an enumeration `E` of type `Î±`, a predicate `p` on `Î±`, and a proof `h` that there exists an index `i < E.max` such that `p (E.f i h)`. It returns the smallest such index `i`. The theorem `ConNF.Enumeration.chooseIndex_lt` proves that this index `i` is indeed less than `E.max`."}
{"full_name": "ConNF.Enumeration.chooseIndex", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.chooseIndex", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.chooseIndex [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u_1} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— Î±) (p : Î± â†’ Prop ) (h : âˆƒ (i : ConNF.Îº) (h : i < E.max), p (E.f i h)) :ConNF.Îº", "code": "def chooseIndex (E : Enumeration Î±) (p : Î± â†’ Prop)\n    (h : âˆƒ i : Îº, âˆƒ h : i < E.max, p (E.f i h)) : Îº :=\n  h.choose\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Enumeration.chooseIndexğŸ—ŸğŸ”—../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.chooseIndexğŸ”—  E p h ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸExists.chooseğŸ—ŸğŸ”—../.././Init/Classical.html#Exists.chooseğŸ”—  h\n\n", "used_premises": [1, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [417, 420], "informalization": "Function `ConNF.Enumeration.chooseIndex` takes an enumeration `E` of type `Î±`, a predicate `p` on `Î±`, and a proof `h` that there exists an index `i < E.max` such that `p (E.f i h)`. It returns the smallest such index `i`."}
{"full_name": "ConNF.le_of_path", "url": "ConNF/Structural/Index.html#ConNF.le_of_path", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.le_of_path [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} {Î² : ConNF.TypeIndex} :Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î² â†’ Î² â‰¤ Î±", "code": "theorem le_of_path : âˆ€ {Î² : TypeIndex}, Path Î± Î² â†’ Î² â‰¤ Î±\n  | _, nil => le_rfl\n  | _, cons p f => (le_of_lt f).trans <| le_of_path p\n", "additional_info": "If there is a path between `ğŸ—ŸÎ±ğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.Level.Î±ğŸ”—`  and `Î²`, we must have `Î² â‰¤ ğŸ—ŸÎ±ğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.Level.Î±ğŸ”—` .\nThe case `Î² = ğŸ—ŸÎ±ğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.Level.Î±ğŸ”—`  can occur with the nil path.", "used_premises": [1, 76], "def_path": "ConNF/Structural/Index.lean", "pos": [64, 67], "informalization": "The theorem `ConNF.le_of_path` states that if there is a path between two types `Î±` and `Î²` in the context of Constructive Ordinal Notation (ConNF), then `Î²` must be less than or equal to `Î±`. The case where `Î² = Î±` can occur with the nil path."}
{"full_name": "ConNF.path_eq_nil", "url": "ConNF/Structural/Index.html#ConNF.path_eq_nil", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.path_eq_nil [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î±) :p = Quiver.Path.nil", "code": "theorem path_eq_nil : âˆ€ p : Path Î± Î±, p = nil\n  | nil => rfl\n  | cons p f => ((le_of_path p).not_lt f).elim\n", "additional_info": "", "used_premises": [1, 76], "def_path": "ConNF/Structural/Index.lean", "pos": [68, 71], "informalization": "The theorem `ConNF.path_eq_nil` states that in the context of Constructive Ordinal Notation (ConNF), the only path from a vertex to itself is the trivial path."}
{"full_name": "ConNF.ExtendedIndex.length_ne_zero", "url": "ConNF/Structural/Index.html#ConNF.ExtendedIndex.length_ne_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.ExtendedIndex.length_ne_zero [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.Î›} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î±) :Quiver.Path.lengthğŸ”—<|PREMISE|>ğŸ”— A â‰  0", "code": "theorem ExtendedIndex.length_ne_zero {Î± : Î›} (A : ExtendedIndex Î±) : A.length â‰  0 := by\n  intro h\n  cases Quiver.Path.eq_of_length_zero A h\n", "additional_info": "", "used_premises": [1, 61, 137], "def_path": "ConNF/Structural/Index.lean", "pos": [72, 75], "informalization": "Function `ConNF.ExtendedIndex` defines a finite path from a type `Î±` to the base type `âŠ¥` in the context of Constructive Ordinal Notation (ConNF). This path represents a way to understand extensionality by iteratively descending to lower types in the hierarchy until reaching the base type. Since `Î›` is well-ordered, there are no infinite descending paths. Function `Quiver.Path.length` calculates the length of a path in a quiver, which is defined as the number of arrows in the path. For a trivial path (`nil`), the length is 0, and for a path extended by an arrow (`cons`), the length is the length of the previous path plus 1. The theorem `ConNF.ExtendedIndex.length_ne_zero` states that the length of any non-trivial `ConNF.ExtendedIndex` path is not zero."}
{"full_name": "ConNF.mk_extendedIndex", "url": "ConNF/Structural/Index.html#ConNF.mk_extendedIndex", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_extendedIndex [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î›", "code": "theorem mk_extendedIndex (Î± : TypeIndex) : #(ExtendedIndex Î±) â‰¤ #Î› := by\n  refine le_trans ((Cardinal.le_def _ _).2 âŸ¨âŸ¨toList, toList_injective (Î± : TypeIndex) âŠ¥âŸ©âŸ©) ?_\n  convert mk_list_le_max _ using 1\n  simp only [mk_typeIndex, max_eq_right, aleph0_le_mk]\n", "additional_info": "There are at most `Î›` `ğŸ—ŸÎ±ğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.Level.Î±ğŸ”—` -extended type indices.", "used_premises": [1, 29, 61, 29], "def_path": "ConNF/Structural/Index.lean", "pos": [78, 82], "informalization": "Function `ConNF.mk_extendedIndex` proves that the cardinality of the set of `Î±`-extended type indices is less than or equal to the cardinality of `Î›`."}
{"full_name": "ConNF.mk_extendedIndex_ne_zero", "url": "ConNF/Structural/Index.html#ConNF.mk_extendedIndex_ne_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_extendedIndex_ne_zero [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) â‰  0", "code": "theorem mk_extendedIndex_ne_zero (Î± : TypeIndex) : #(ExtendedIndex Î±) â‰  0 :=\n  Cardinal.mk_ne_zero _\n", "additional_info": "There exists an `ğŸ—ŸÎ±ğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.Level.Î±ğŸ”—` -extended type index. -", "used_premises": [1, 29, 61], "def_path": "ConNF/Structural/Index.lean", "pos": [94, 96], "informalization": "There exists an `Î±` -extended type index."}
{"full_name": "ConNF.Pretangle.toBot_symm", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toBot_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toBot_symm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :ConNF.Pretangle.toBot.symm = ConNF.Pretangle.ofBot", "code": "theorem toBot_symm : toBot.symm = ofBot :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [45, 47], "informalization": "The theorem `ConNF.Pretangle.toBot_symm` states that the inverse of the function `ConNF.Pretangle.toBot` is equal to the function `ConNF.Pretangle.ofBot` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Pretangle.ofBot_symm", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofBot_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofBot_symm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :ConNF.Pretangle.ofBot.symm = ConNF.Pretangle.toBot", "code": "theorem ofBot_symm : ofBot.symm = toBot :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [49, 51], "informalization": "The theorem `ConNF.Pretangle.ofBot_symm` states that the inverse of the function `ConNF.Pretangle.ofBot` is equal to `ConNF.Pretangle.toBot` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Pretangle.toBot_ofBot", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toBot_ofBot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toBot_ofBot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (a : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— âŠ¥ ) :ConNF.Pretangle.toBot (ConNF.Pretangle.ofBot a) = a", "code": "theorem toBot_ofBot (a) : toBot (ofBot a) = a := by aesop\n", "additional_info": "", "used_premises": [1, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [61, 62], "informalization": "The theorem `ConNF.Pretangle.toBot_ofBot` states that for any pretangle `a` in the context of Constructive Ordinal Notation (ConNF), the operation `ConNF.Pretangle.ofBot` followed by `ConNF.Pretangle.toBot` returns the original pretangle `a`."}
{"full_name": "ConNF.Pretangle", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Pretangle [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :ConNF.TypeIndex â†’ Type u", "code": "def Pretangle : TypeIndex â†’ Type u\n  | âŠ¥ => Atom\n  | (Î± : Î›) => âˆ€ Î² : TypeIndex, Î² < Î± â†’ Set (Pretangle Î²)\ntermination_by x => x\n", "additional_info": "A *pretangle* is an object that may become a *tangle*, an element of the model.\nThe type of pretangles forms a model of TTT without extensionality.\nEquations\n* ğŸ—ŸConNF.PretangleğŸ—ŸğŸ”—../.././ConNF/Structural/Pretangle.html#ConNF.PretangleğŸ”—  none ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ConNF.Atom\n* ğŸ—ŸConNF.PretangleğŸ—ŸğŸ”—../.././ConNF/Structural/Pretangle.html#ConNF.PretangleğŸ”—  (ğŸ—ŸsomeğŸ—ŸğŸ”—../.././Init/Prelude.html#Option.someğŸ”—  Î±) ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ((Î² : ConNF.TypeIndex) â†’ Î² ğŸ—Ÿ<ğŸ—ŸğŸ”—../.././Init/Prelude.html#LT.ltğŸ”—  â†‘Î± â†’ ğŸ—ŸSetğŸ—ŸğŸ”—../.././Mathlib/Init/Set.html#SetğŸ”—  (ğŸ—ŸConNF.PretangleğŸ—ŸğŸ”—../.././ConNF/Structural/Pretangle.html#ConNF.PretangleğŸ”—  Î²))\n\n", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [21, 25], "informalization": "Function `ConNF.Pretangle` defines a pretangle in the context of Constructive Ordinal Notation (ConNF), which is an object that may become a tangle, an element of the model. The type of pretangles forms a model of TTT without extensionality."}
{"full_name": "ConNF.Pretangle.ofBot_toBot", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofBot_toBot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofBot_toBot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (a : ConNF.Atom) :ConNF.Pretangle.ofBot (ConNF.Pretangle.toBot a) = a", "code": "theorem ofBot_toBot (a) : ofBot (toBot a) = a := by aesop\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [64, 65], "informalization": "The theorem `ConNF.Pretangle.ofBot_toBot` states that for any `ConNF.Atom` `a`, converting `a` to a `ConNF.Pretangle` using `ConNF.Pretangle.toBot` and then back to an `ConNF.Atom` using `ConNF.Pretangle.ofBot` results in the original `ConNF.Atom` `a`."}
{"full_name": "ConNF.Pretangle.toCoe_ofCoe", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toCoe_ofCoe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toCoe_ofCoe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.Î›} (a : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— â†‘Î±) :ConNF.Pretangle.toCoe (ConNF.Pretangle.ofCoe a) = a", "code": "theorem toCoe_ofCoe (a : Pretangle Î±) : toCoe (ofCoe a) = a := by simp [toCoe, ofCoe]\n", "additional_info": "", "used_premises": [1, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [67, 68], "informalization": "The theorem `ConNF.Pretangle.toCoe_ofCoe` states that the function `ConNF.Pretangle.toCoe` is the left inverse of the function `ConNF.Pretangle.ofCoe`. This means that applying `ConNF.Pretangle.ofCoe` to a pretangle and then applying `ConNF.Pretangle.toCoe` to the result will return the original pretangle."}
{"full_name": "ConNF.Pretangle.ofCoe_toCoe", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofCoe_toCoe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofCoe_toCoe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.Î›} (a : (Î² : ConNF.TypeIndex) â†’ Î² < â†‘Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î²)) :ConNF.Pretangle.ofCoe (ConNF.Pretangle.toCoe a) = a", "code": "theorem ofCoe_toCoe (a) : ofCoe (toCoe a : Pretangle Î±) = a := by simp [toCoe, ofCoe]\n", "additional_info": "", "used_premises": [1, 69, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [70, 71], "informalization": "The theorem `ConNF.Pretangle.ofCoe_toCoe` states that the function `ConNF.Pretangle.ofCoe` is the left inverse of the function `ConNF.Pretangle.toCoe`. This means that applying `ConNF.Pretangle.ofCoe` to the result of `ConNF.Pretangle.toCoe` returns the original argument."}
{"full_name": "ConNF.Pretangle.toBot_inj", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toBot_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toBot_inj [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {a : ConNF.Atom} {b : ConNF.Atom} :ConNF.Pretangle.toBot a = ConNF.Pretangle.toBot b â†” a = b", "code": "theorem toBot_inj {a b} : toBot a = toBot b â†” a = b :=\n  toBot.injective.eq_iff\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [73, 75], "informalization": "Function `ConNF.Pretangle.toBot_inj` is a theorem in Lean 4 that states the injectivity of the function `ConNF.Pretangle.toBot` in the context of Constructive Ordinal Notation (ConNF). It asserts that two `ConNF.Atom`s are equal if and only if their images under the function `ConNF.Pretangle.toBot` are equal."}
{"full_name": "ConNF.Pretangle.ofBot_inj", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofBot_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofBot_inj [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {a : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— âŠ¥ } {b : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— âŠ¥ } :ConNF.Pretangle.ofBot a = ConNF.Pretangle.ofBot b â†” a = b", "code": "theorem ofBot_inj {a b} : ofBot a = ofBot b â†” a = b :=\n  ofBot.injective.eq_iff\n", "additional_info": "", "used_premises": [1, 279, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [77, 79], "informalization": "The theorem `ConNF.Pretangle.ofBot_inj` states that the function `ConNF.Pretangle.ofBot` is injective, meaning that it maps distinct pretangles to distinct tangles."}
{"full_name": "ConNF.Pretangle.toCoe_inj", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toCoe_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toCoe_inj [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.Î›} {a : (Î² : ConNF.TypeIndex) â†’ Î² < â†‘Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î²)} {b : (Î² : ConNF.TypeIndex) â†’ Î² < â†‘Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î²)} :ConNF.Pretangle.toCoe a = ConNF.Pretangle.toCoe b â†” a = b", "code": "theorem toCoe_inj {a b} : (toCoe a : Pretangle Î±) = toCoe b â†” a = b :=\n  toCoe.injective.eq_iff\n", "additional_info": "", "used_premises": [1, 69, 279, 69, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [81, 83], "informalization": "The theorem `ConNF.Pretangle.toCoe_inj` states that the function `ConNF.Pretangle.toCoe` is injective. This means that if two pretangles `a` and `b` have the same image under the function `ConNF.Pretangle.toCoe`, then `a` must be equal to `b`."}
{"full_name": "ConNF.Pretangle.ofCoe_inj", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofCoe_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofCoe_inj [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.Î›} {a : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— â†‘Î±} {b : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— â†‘Î±} :ConNF.Pretangle.ofCoe a = ConNF.Pretangle.ofCoe b â†” a = b", "code": "theorem ofCoe_inj {a b : Pretangle Î±} : ofCoe a = ofCoe b â†” a = b :=\n  ofCoe.injective.eq_iff\n", "additional_info": "", "used_premises": [1, 279, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [85, 87], "informalization": "`ConNF.Pretangle.ofCoe_inj` is a theorem in Lean 4 that states the injectivity of the `ConNF.Pretangle.ofCoe` function in the context of Constructive Ordinal Notation (ConNF). This theorem asserts that two pretangles `a` and `b` are equal if and only if their images under the `ConNF.Pretangle.ofCoe` function are equal."}
{"full_name": "ConNF.Pretangle.coe_ext", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.coe_ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Pretangle.coe_ext [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.Î›} {a : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— â†‘Î±} {b : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— â†‘Î±} :a = b â†” âˆ€ (Î² : ConNF.TypeIndex) (hÎ² : Î² < â†‘Î±) (t : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î²), t âˆˆ ConNF.Pretangle.ofCoe a Î² hÎ² â†” t âˆˆ ConNF.Pretangle.ofCoe b Î² hÎ²", "code": "theorem coe_ext {Î± : Î›} {a b : Pretangle Î±} :\n    a = b â†” âˆ€ Î² hÎ² t, t âˆˆ ofCoe a Î² hÎ² â†” t âˆˆ ofCoe b Î² hÎ² := by\n  constructor\n  Â· rintro rfl\n    simp only [implies_true, forall_const]\n  intro h\n  rw [â† ofCoe_inj]\n  ext Î² hÎ² t\n  exact h Î² hÎ² t\n", "additional_info": "", "used_premises": [1, 279, 279, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [88, 97], "informalization": "The theorem `ConNF.Pretangle.coe_ext` states that two pretangles are equal if and only if they have the same members at each type level, corresponding to restrictions of the pretangles to each type level. This theorem is crucial for proving the extensionality axiom in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.Tree.toBot_ofBot", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_ofBot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_ofBot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ âŠ¥ ) :ConNF.Tree.toBot (ConNF.Tree.ofBot a) = a", "code": "theorem toBot_ofBot (a : Tree Ï„ âŠ¥) : toBot (ofBot a) = a := by\n  funext A\n  cases path_eq_nil A\n  rfl\n", "additional_info": "", "used_premises": [1, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [60, 64], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Tree.toBot_ofBot` states that the function `ConNF.Tree.toBot`, which maps an `Î±`-tree of `Ï„` to a `âŠ¥`-tree of `Ï„`, is the left inverse of the function `ConNF.Tree.ofBot`, which maps a `âŠ¥`-tree of `Ï„` to an `Î±`-tree of `Ï„`."}
{"full_name": "ConNF.Tree", "url": "ConNF/Structural/Tree.html#ConNF.Tree", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Tree [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï„ : Type u) (Î± : ConNF.TypeIndex) :Type u", "code": "def Tree (Ï„ : Type u) (Î± : TypeIndex) : Type u :=\n  ExtendedIndex Î± â†’ Ï„\n", "additional_info": "For each type index `Î±`, an `Î±`-tree of `Ï„` is a function from `Î±`-extended type indices to\n`Ï„`.\nEquations\n* ğŸ—ŸConNF.TreeğŸ—ŸğŸ”—../.././ConNF/Structural/Tree.html#ConNF.TreeğŸ”—  Ï„ Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  Î± â†’ Ï„)\n\n", "used_premises": [1], "def_path": "ConNF/Structural/Tree.lean", "pos": [28, 30], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-tree of `Ï„` is defined as a function from `Î±`-extended type indices to `Ï„`. This function maps each `Î±`-extended type index to a value of type `Ï„`."}
{"full_name": "ConNF.Tree.ofBot_toBot", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_toBot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_toBot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} (a : Ï„) :ConNF.Tree.ofBot (ConNF.Tree.toBot a) = a", "code": "theorem ofBot_toBot (a : Ï„) : ofBot (toBot a) = a := rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Tree.lean", "pos": [66, 67], "informalization": "The theorem `ConNF.Tree.ofBot_toBot` states that the function `ConNF.Tree.ofBot` is the left inverse of the function `ConNF.Tree.toBot`. This means that for any element `a` of type `Ï„`, applying `ConNF.Tree.toBot` to `a` and then applying `ConNF.Tree.ofBot` to the result will return the original element `a`."}
{"full_name": "ConNF.Tree.toBot_inj", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_inj [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {a : Ï„} {b : Ï„} :ConNF.Tree.toBot a = ConNF.Tree.toBot b â†” a = b", "code": "theorem toBot_inj {a b : Ï„} : toBot a = toBot b â†” a = b :=\n  toBot.injective.eq_iff\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Tree.lean", "pos": [69, 71], "informalization": "`ConNF.Tree.toBot_inj` is a theorem in Lean 4 that states the injectivity of the function `ConNF.Tree.toBot` in the context of Constructive Ordinal Notation (ConNF). Specifically, it asserts that for any two elements `a` and `b` of the same type `Ï„`, the equation `ConNF.Tree.toBot a = ConNF.Tree.toBot b` holds if and only if `a = b`."}
{"full_name": "ConNF.Tree.ofBot_inj", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_inj [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ âŠ¥ } {b : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ âŠ¥ } :ConNF.Tree.ofBot a = ConNF.Tree.ofBot b â†” a = b", "code": "theorem ofBot_inj {a b : Tree Ï„ âŠ¥} : ofBot a = ofBot b â†” a = b :=\n  ofBot.injective.eq_iff\n", "additional_info": "", "used_premises": [1, 289, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [73, 75], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-tree of `Ï„` is defined as a function from `Î±`-extended type indices to `Ï„`. This function maps each `Î±`-extended type index to a value of type `Ï„`. The theorem `ConNF.Tree.ofBot_inj` states that for any two `âŠ¥`-trees `a` and `b` of type `Ï„`, the equation `ConNF.Tree.ofBot a = ConNF.Tree.ofBot b` holds if and only if `a = b`."}
{"full_name": "ConNF.Tree.ext", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.ext [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {Î± : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (b : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (h : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±), a A = b A) :a = b", "code": "theorem ext {Î± : TypeIndex} (a b : Tree Ï„ Î±) (h : âˆ€ A, a A = b A) : a = b :=\n  funext h\n", "additional_info": "", "used_premises": [1, 289, 289, 61], "def_path": "ConNF/Structural/Tree.lean", "pos": [77, 79], "informalization": "Function `ConNF.Tree.ext` is an extensionality theorem for trees in the context of Constructive Ordinal Notation (ConNF). It states that if two trees `a` and `b` of type `Ï„` and index `Î±` are equal at every extended index `A`, then the trees themselves are equal."}
{"full_name": "ConNF.Tree.mul_apply", "url": "ConNF/Structural/Tree.html#ConNF.Tree.mul_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.mul_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] {Î± : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (a' : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) :(a * a') A = a A * a' A", "code": "theorem mul_apply (a a' : Tree Ï„ Î±) (A : ExtendedIndex Î±) :\n    (a * a') A = a A * a' A :=\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 289, 289, 61], "def_path": "ConNF/Structural/Tree.lean", "pos": [91, 94], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-tree of `Ï„` is defined as a function from `Î±`-extended type indices to `Ï„`. This function maps each `Î±`-extended type index to a value of type `Ï„`. Given two `Î±`-trees `a` and `a'` of type `Ï„`, and an `Î±`-extended type index `A`, the multiplication of `a` and `a'` at `A` is equal to the product of `a A` and `a' A`."}
{"full_name": "ConNF.Tree.inv_apply", "url": "ConNF/Structural/Tree.html#ConNF.Tree.inv_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.inv_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] {Î± : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) :aâ»Â¹ A = (a A)â»Â¹", "code": "theorem inv_apply (a : Tree Ï„ Î±) (A : ExtendedIndex Î±) :\n    aâ»Â¹ A = (a A)â»Â¹ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 289, 61], "def_path": "ConNF/Structural/Tree.lean", "pos": [96, 99], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the inverse of a `Ï„`-tree `a` at an `Î±`-extended type index `A` is equal to the inverse of the value of `a` at `A`."}
{"full_name": "ConNF.Tree.toBot_mul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_mul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_mul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] (a : Ï„) (a' : Ï„) :ConNF.Tree.toBot (a * a') = ConNF.Tree.toBot a * ConNF.Tree.toBot a'", "code": "theorem toBot_mul (a a' : Ï„) : toBot (a * a') = toBot a * toBot a' :=\n  toBotIso.map_mul _ _\n", "additional_info": "", "used_premises": [1, 40], "def_path": "ConNF/Structural/Tree.lean", "pos": [123, 125], "informalization": "The theorem `ConNF.Tree.toBot_mul` states that in the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Tree.toBot` applied to the product of two elements `a` and `a'` of a group `Ï„` is equal to the product of `ConNF.Tree.toBot` applied to `a` and `ConNF.Tree.toBot` applied to `a'`."}
{"full_name": "ConNF.Tree.ofBot_mul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_mul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_mul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ âŠ¥ ) (a' : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ âŠ¥ ) :ConNF.Tree.ofBot (a * a') = ConNF.Tree.ofBot a * ConNF.Tree.ofBot a'", "code": "theorem ofBot_mul (a a' : Tree Ï„ âŠ¥) : ofBot (a * a') = ofBot a * ofBot a' :=\n  toBotIso.symm.map_mul _ _\n", "additional_info": "", "used_premises": [1, 40, 289, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [127, 129], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `Î±`-tree of `Ï„` is defined as a function from `Î±`-extended type indices to `Ï„`. This function maps each `Î±`-extended type index to a value of type `Ï„`. Given two `âŠ¥`-trees `a` and `a'` of type `Ï„`, where `Ï„` is a group, the theorem `ConNF.Tree.ofBot_mul` states that the `âŠ¥`-tree of the product of `a` and `a'` is equal to the product of the `âŠ¥`-trees of `a` and `a'`."}
{"full_name": "ConNF.Tree.toBot_inv", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_inv [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] (a : Ï„) :ConNF.Tree.toBot aâ»Â¹ = (ConNF.Tree.toBot a)â»Â¹", "code": "theorem toBot_inv (a : Ï„) : toBot aâ»Â¹ = (toBot a)â»Â¹ :=\n  id toBotIso.map_inv a\n", "additional_info": "", "used_premises": [1, 40], "def_path": "ConNF/Structural/Tree.lean", "pos": [131, 133], "informalization": "The theorem `ConNF.Tree.toBot_inv` states that for any group element `a`, the inverse of `ConNF.Tree.toBot a` is equal to `ConNF.Tree.toBot` of the inverse of `a`."}
{"full_name": "ConNF.Tree.ofBot_inv", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_inv [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ âŠ¥ ) :ConNF.Tree.ofBot aâ»Â¹ = (ConNF.Tree.ofBot a)â»Â¹", "code": "theorem ofBot_inv (a : Tree Ï„ âŠ¥) : ofBot aâ»Â¹ = (ofBot a)â»Â¹ :=\n  (toBotIso (Ï„ := Ï„)).symm.map_inv a\n", "additional_info": "", "used_premises": [1, 40, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [135, 137], "informalization": "The theorem `ConNF.Tree.ofBot_inv` states that in the context of Constructive Ordinal Notation (ConNF), the inverse of an `Î±`-tree of `Ï„` (where `Ï„` is a group) evaluated at `âŠ¥` is equal to the inverse of the `Î±`-tree evaluated at `âŠ¥`."}
{"full_name": "Quiver.Hom.comp_toPath", "url": "ConNF/Structural/Tree.html#Quiver.Hom.comp_toPath", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Quiver.Hom.comp_toPath {V : Type u_1} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {a : V} {b : V} {c : V} {p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— a b} {e : b âŸ¶ c} :Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— p (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”— e) = Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— p e", "code": "theorem Quiver.Hom.comp_toPath {V : Type _} [Quiver V] {a b c : V}\n    {p : Path a b} {e : b âŸ¶ c} :\n    p.comp e.toPath = p.cons e := rfl\n", "additional_info": "", "used_premises": [75, 76, 135, 74, 301], "def_path": "ConNF/Structural/Tree.lean", "pos": [141, 144], "informalization": "Function `Quiver.Hom.toPath` converts a single arrow in a quiver into a path of length one. Function `Quiver.Path.comp` composes two paths in a quiver. Given a path from vertex `a` to vertex `b` and a path from vertex `b` to vertex `c`, it returns a path from vertex `a` to vertex `c`. Function `Quiver.Path.cons` takes a path from `a` to `b` and an arrow from `b` to `c`, and returns a path from `a` to `c`. The theorem `Quiver.Hom.comp_toPath` states that the composition of a path `p` from `a` to `b` and an arrow `e` from `b` to `c` is equal to the path obtained by extending `p` with `e`."}
{"full_name": "Quiver.Path.cons", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path", "code_src": "mathlib4", "ptype": "constructor", "header": "constructor Quiver.PathğŸ”—<|PREMISE|>ğŸ”—.cons: {V : Type  u} â†’ [inst : QuiverğŸ”—<|PREMISE|>ğŸ”—  V] â†’ {a b c : V} â†’ Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  a b â†’ (b âŸ¶  c) â†’ Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  a c", "code": "inductive Path {V : Type u} [Quiver.{v} V] (a : V) : V â†’ Sort max (u + 1) v\n  | nil : Path a a\n  | cons : âˆ€ {b c : V}, Path a b â†’ (b âŸ¶ c) â†’ Path a c\n", "additional_info": "", "used_premises": [76, 75, 76, 76], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [24, 27], "informalization": "Function `Quiver.Path.cons` takes a path from `a` to `b` and an arrow from `b` to `c`, and returns a path from `a` to `c`."}
{"full_name": "Quiver.Hom.comp_toPath_comp", "url": "ConNF/Structural/Tree.html#Quiver.Hom.comp_toPath_comp", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Quiver.Hom.comp_toPath_comp {V : Type u_1} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {a : V} {b : V} {c : V} {d : V} {p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— a b} {e : b âŸ¶ c} {q : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— c d} :Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— p (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”— e) q) = Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— p e) q", "code": "theorem Quiver.Hom.comp_toPath_comp {V : Type _} [Quiver V] {a b c d : V}\n    {p : Path a b} {e : b âŸ¶ c} {q : Path c d} :\n    p.comp (e.toPath.comp q) = (p.cons e).comp q := by\n  rw [Hom.toPath, â† comp_assoc, comp_cons, comp_nil]\n", "additional_info": "", "used_premises": [75, 76, 76, 135, 135, 74, 135, 301], "def_path": "ConNF/Structural/Tree.lean", "pos": [146, 150], "informalization": "Function `Quiver.Hom.comp_toPath_comp` states that for any path `p` from vertex `a` to vertex `b`, any arrow `e` from vertex `b` to vertex `c`, and any path `q` from vertex `c` to vertex `d`, the composition of `p` with the composition of `e` and `q` is equal to the composition of the path obtained by extending `p` with `e` and `q`."}
{"full_name": "ConNF.Tree.comp_def", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_def", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_def [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {Î± : ConNF.TypeIndex} {Î² : ConNF.TypeIndex} (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î²) (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A a = fun (B : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² âŠ¥ ) => a (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B)", "code": "theorem comp_def (A : Path Î± Î²) (a : Tree Ï„ Î±) :\n    comp A a = fun B => a (A.comp B) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 76, 289, 304, 76, 135], "def_path": "ConNF/Structural/Tree.lean", "pos": [164, 167], "informalization": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `Î±` to type index `Î²` and an `Î±`-tree `a` of type `Ï„`, it returns a `Î²`-tree of type `Ï„` by applying `a` to the composition of `A` with any `Î²`-extended type index `B`."}
{"full_name": "ConNF.Tree.comp", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Tree.comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {Î± : ConNF.TypeIndex} {Î² : ConNF.TypeIndex} (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î²) (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) :ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î²", "code": "def comp (A : Path Î± Î²) (a : Tree Ï„ Î±) : Tree Ï„ Î² :=\n  fun B => a (A.comp B)\n", "additional_info": "The *derivative* functor.\nFor a path from `Î±` to `Î²`, this is a map from `Î±`-trees of `Ï„` to `Î²`-trees of `Ï„`.\nThis is a functor from the category of type indices where\nthe morphisms are the decreasing paths (i.e. the category where morphisms are elements of `Path Î± Î²`\nfor `Î±, Î² : TypeIndex`) to the category of all trees of a fixed type `Ï„`, where the morphisms are\nfunctions.\nIf `Ï„` has a group structure, this map preserves multiplication. This means that we can treat this\nas a functor to the category of all trees on `Ï„` where the morphisms are group homomorphisms.\nEquations\n* ğŸ—ŸConNF.Tree.compğŸ—ŸğŸ”—../.././ConNF/Structural/Tree.html#ConNF.Tree.compğŸ”—  A a B ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  a (ğŸ—ŸQuiver.Path.compğŸ—ŸğŸ”—../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.compğŸ”—  A B)\n\n", "used_premises": [1, 76, 289, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [161, 163], "informalization": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `Î±` to type index `Î²` and an `Î±`-tree `a` of type `Ï„`, it returns a `Î²`-tree of type `Ï„` by applying `a` to the composition of `A` with any `Î²`-extended type index `B`."}
{"full_name": "ConNF.Tree.comp_apply", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.comp_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {Î± : ConNF.TypeIndex} {Î² : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î²) (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A a B = a (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B)", "code": "theorem comp_apply (a : Tree Ï„ Î±) (A : Path Î± Î²) (B : ExtendedIndex Î²) :\n    comp A a B = a (A.comp B) :=\n  rfl\n", "additional_info": "Evaluating the derivative of a structural group element along a path is the same as evaluating\nthe original element along the composition of the paths.", "used_premises": [1, 289, 76, 61, 304, 135], "def_path": "ConNF/Structural/Tree.lean", "pos": [171, 174], "informalization": "Evaluating the derivative of a structural group element along a path is the same as evaluating the original element along the composition of the paths."}
{"full_name": "ConNF.Tree.comp_nil", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_nil", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.comp_nil [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {Î± : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— Quiver.Path.nil a = a", "code": "theorem comp_nil (a : Tree Ï„ Î±) : comp nil a = a := by\n  simp only [comp_def, nil_comp, MonoidHom.coe_mk, OneHom.coe_mk]\n", "additional_info": "The derivative along the empty path does nothing.", "used_premises": [1, 289, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [177, 179], "informalization": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `Î±` to type index `Î²` and an `Î±`-tree `a` of type `Ï„`, it returns a `Î²`-tree of type `Ï„` by applying `a` to the composition of `A` with any `Î²`-extended type index `B`. The theorem `ConNF.Tree.comp_nil` states that the derivative along the empty path `Quiver.Path.nil` does nothing, meaning it returns the original tree `a`."}
{"full_name": "ConNF.Tree.comp_cons", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_cons", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_cons [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {Î± : ConNF.TypeIndex} {Î² : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î²) {Î³ : ConNF.TypeIndex} (h : Î³ < Î²) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— p h) a = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”— h) (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— p a)", "code": "theorem comp_cons (a : Tree Ï„ Î±) (p : Path Î± Î²) {Î³ : TypeIndex} (h : Î³ < Î²) :\n    comp (p.cons h) a = (comp (Hom.toPath h)) (comp p a) := by\n  simp only [comp_def, MonoidHom.coe_mk, OneHom.coe_mk, Hom.comp_toPath_comp]\n", "additional_info": "", "used_premises": [1, 289, 76, 304, 301, 304, 74, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [180, 183], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given an `Î±`-tree `a` of type `Ï„`, a path `p` from `Î±` to `Î²`, and an arrow `h` from `Î²` to `Î³`, the derivative functor `ConNF.Tree.comp` applied to the composition of `p` and `h` is equal to the derivative functor applied to `h` followed by the derivative functor applied to `p` and `a`."}
{"full_name": "ConNF.Tree.comp_comp", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {Î± : ConNF.TypeIndex} {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î²) (q : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— q (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— p a) = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— p q) a", "code": "theorem comp_comp (a : Tree Ï„ Î±) (p : Path Î± Î²) (q : Path Î² Î³) :\n    comp q (comp p a) = comp (p.comp q) a := by\n  simp only [comp_def, MonoidHom.coe_mk, OneHom.coe_mk, comp_assoc]\n", "additional_info": "The derivative map is functorial.", "used_premises": [1, 289, 76, 76, 304, 304, 304, 135], "def_path": "ConNF/Structural/Tree.lean", "pos": [185, 188], "informalization": "The theorem `ConNF.Tree.comp_comp` establishes the functoriality of the derivative map in the context of Constructive Ordinal Notation (ConNF). It states that for any path `p` from type index `Î±` to type index `Î²`, and any path `q` from type index `Î²` to type index `Î³`, the composition of the derivative maps corresponding to `p` and `q` is equal to the derivative map corresponding to the composition of `p` and `q`."}
{"full_name": "ConNF.Tree.comp_mul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_mul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_mul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] {Î± : ConNF.TypeIndex} {Î² : ConNF.TypeIndex} (aâ‚ : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (aâ‚‚ : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î²) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (aâ‚ * aâ‚‚) = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A aâ‚ * ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A aâ‚‚", "code": "theorem comp_mul {Î² : TypeIndex} (aâ‚ aâ‚‚ : Tree Ï„ Î±) (A : Path (Î± : TypeIndex) Î²) :\n    comp A (aâ‚ * aâ‚‚) = comp A aâ‚ * comp A aâ‚‚ :=\n  rfl\n", "additional_info": "The derivative map preserves multiplication.", "used_premises": [1, 40, 289, 289, 76, 304, 304, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [196, 199], "informalization": "The theorem `ConNF.Tree.comp_mul` states that in the context of Constructive Ordinal Notation (ConNF), the derivative functor preserves multiplication. Specifically, given two trees `aâ‚` and `aâ‚‚` of the same type index `Î±` and a path `A` from `Î±` to another type index `Î²`, the derivative of the product `aâ‚ * aâ‚‚` along `A` is equal to the product of the derivatives of `aâ‚` and `aâ‚‚` along `A`."}
{"full_name": "ConNF.Tree.comp_inv", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_inv [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] {Î± : ConNF.TypeIndex} {Î² : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± Î²) :(ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A a)â»Â¹ = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A aâ»Â¹", "code": "theorem comp_inv {Î² : TypeIndex} (a : Tree Ï„ Î±) (A : Path (Î± : TypeIndex) Î²) :\n    (comp A a)â»Â¹ = comp A aâ»Â¹ :=\n  rfl\n", "additional_info": "The derivative map preserves inverses.", "used_premises": [1, 40, 289, 76, 304, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [201, 204], "informalization": "The theorem `ConNF.Tree.comp_inv` states that in the context of Constructive Ordinal Notation (ConNF), the derivative map preserves inverses. Specifically, if `a` is an `Î±`-tree of type `Ï„` and `A` is a path from type index `Î±` to type index `Î²`, then the inverse of the `Î²`-tree obtained by composing `a` with `A` is equal to the `Î²`-tree obtained by composing the inverse of `a` with `A`."}
{"full_name": "ConNF.Tree.comp_bot", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_bot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.comp_bot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} {Î± : ConNF.TypeIndex} (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ Î±) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î± âŠ¥ ) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A a = ConNF.Tree.toBot (a A)", "code": "theorem comp_bot (a : Tree Ï„ Î±) (A : Path (Î± : TypeIndex) âŠ¥) :\n    comp A a = toBot (a A) := by\n  funext B\n  cases path_eq_nil B\n  rfl\n", "additional_info": "", "used_premises": [1, 289, 76, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [206, 211], "informalization": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `Î±` to type index `âŠ¥` and an `Î±`-tree `a` of type `Ï„`, it returns a `âŠ¥`-tree of type `Ï„` by applying `a` to the composition of `A` with any `âŠ¥`-extended type index `B`."}
{"full_name": "ConNF.Tree.toBot_smul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— Ï„ X] (a : Ï„) (x : X) :ConNF.Tree.toBot a â€¢ x = a â€¢ x", "code": "theorem toBot_smul (a : Ï„) (x : X) : toBot a â€¢ x = a â€¢ x := by\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 56], "def_path": "ConNF/Structural/Tree.lean", "pos": [221, 223], "informalization": "Function `ConNF.Tree.toBot_smul` simplifies the expression `ConNF.Tree.toBot a â€¢ x` to `a â€¢ x`, where `a` is an element of a group `Ï„` and `x` is an element of a type `X` with a multiplicative action of `Ï„`."}
{"full_name": "ConNF.Tree.ofBot_smul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— Ï„ X] (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ âŠ¥ ) (x : X) :ConNF.Tree.ofBot a â€¢ x = a â€¢ x", "code": "theorem ofBot_smul (a : Tree Ï„ âŠ¥) (x : X) : ofBot a â€¢ x = a â€¢ x := by\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 56, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [225, 227], "informalization": "`ConNF.Tree.ofBot_smul` is a theorem in Lean 4 that states that for a ConNF Params structure with a `Ï„` which is a group and a `X` which is a type with a `Ï„`-multiplication action, the `ConNF.Tree.ofBot` function applied to `a : ConNF.Tree Ï„ âŠ¥` and then multiplied by `x : X` yields the same result as `a â€¢ x`. In other words, the `ConNF.Tree.ofBot` function applied to an empty tree returns the tree itself when applied to a group action."}
{"full_name": "ConNF.Tree.toBot_inv_smul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_inv_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_inv_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— Ï„ X] (a : Ï„) (x : X) :(ConNF.Tree.toBot a)â»Â¹ â€¢ x = aâ»Â¹ â€¢ x", "code": "theorem toBot_inv_smul (a : Ï„) (x : X) : (toBot a)â»Â¹ â€¢ x = aâ»Â¹ â€¢ x := by\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 56], "def_path": "ConNF/Structural/Tree.lean", "pos": [229, 231], "informalization": "The theorem `ConNF.Tree.toBot_inv_smul` states that for a group `Ï„` acting on a type `X`, the inverse of the action of `ConNF.Tree.toBot a` on `x` is equal to the action of the inverse of `a` on `x`."}
{"full_name": "ConNF.Tree.ofBot_inv_smul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_inv_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_inv_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï„ : Type u} [GroupğŸ”—<|PREMISE|>ğŸ”— Ï„] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— Ï„ X] (a : ConNF.TreeğŸ”—<|PREMISE|>ğŸ”— Ï„ âŠ¥ ) (x : X) :(ConNF.Tree.ofBot a)â»Â¹ â€¢ x = aâ»Â¹ â€¢ x", "code": "theorem ofBot_inv_smul (a : Tree Ï„ âŠ¥) (x : X) : (ofBot a)â»Â¹ â€¢ x = aâ»Â¹ â€¢ x := by\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 56, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [233, 235], "informalization": "The theorem `ConNF.Tree.ofBot_inv_smul` states that in the context of Constructive Ordinal Notation (ConNF), given a tree `a` of type `âŠ¥` and an element `x` of a type `X` with a multiplicative action by a group `Ï„`, the action of the inverse of the tree `a` on `x` is equal to the action of the inverse of `a` on `x`."}
{"full_name": "ConNF.StructPerm.smul_nearLitter_fst", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.smul_nearLitter_fst", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.smul_nearLitter_fst [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— âŠ¥ ) (N : ConNF.NearLitter) :(Ï€ â€¢ N).fst = Ï€ â€¢ N.fst", "code": "theorem smul_nearLitter_fst (Ï€ : StructPerm âŠ¥) (N : NearLitter) : (Ï€ â€¢ N).fst = Ï€ â€¢ N.fst :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [45, 47], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `Î±` is a near-litter permutation for each `Î±`-extended index. This represents how the permutation acts along each path down the type levels in the model. The theorem `ConNF.StructPerm.smul_nearLitter_fst` states that when a structural permutation `Ï€` acts on a near-litter `N`, the first component of the resulting near-litter is equal to `Ï€` acting on the first component of `N`."}
{"full_name": "ConNF.StructPerm.smul_nearLitter_coe", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.smul_nearLitter_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.smul_nearLitter_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— âŠ¥ ) (N : ConNF.NearLitter) :â†‘(Ï€ â€¢ N) = Ï€ â€¢ â†‘N", "code": "theorem smul_nearLitter_coe (Ï€ : StructPerm âŠ¥) (N : NearLitter) :\n    (Ï€ â€¢ N : NearLitter) = Ï€ â€¢ (N : Set Atom) :=\n  NearLitterPerm.smul_nearLitter_coe (Tree.ofBot Ï€) N\n", "additional_info": "", "used_premises": [1, 55], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [48, 51], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `Î±` is a near-litter permutation for each `Î±`-extended index. This represents how the permutation acts along each path down the type levels in the model. Note that we define structural permutations as trees of near-litter permutations. The theorem `ConNF.StructPerm.smul_nearLitter_coe` states that for a structural permutation `Ï€` and a near-litter `N`, the action of `Ï€` on `N` (denoted as `Ï€ â€¢ N`) is equal to the action of `Ï€` on the underlying set of `N` (denoted as `Ï€ â€¢ â†‘N`)."}
{"full_name": "ConNF.StructPerm.comp_bot_smul_atom", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.comp_bot_smul_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.comp_bot_smul_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) (a : ConNF.Atom) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï€ â€¢ a = Ï€ A â€¢ a", "code": "theorem comp_bot_smul_atom {Î± : TypeIndex} (Ï€ : StructPerm Î±)\n    (A : ExtendedIndex Î±) (a : Atom) :\n    Tree.comp A Ï€ â€¢ a = Ï€ A â€¢ a :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 61, 304], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [57, 61], "informalization": "`ConNF.StructPerm.comp_bot_smul_atom` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any structural permutation `Ï€` on a proper type index `Î±`, any extended index `A` from `Î±` to the base type `âŠ¥`, and any atom `a`, the derivative functor `ConNF.Tree.comp A Ï€` applied to `a` is equal to `Ï€ A` applied to `a`."}
{"full_name": "ConNF.StructPerm.comp_bot_smul_litter", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.comp_bot_smul_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.comp_bot_smul_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) (L : ConNF.Litter) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï€ â€¢ L = Ï€ A â€¢ L", "code": "theorem comp_bot_smul_litter {Î± : TypeIndex} (Ï€ : StructPerm Î±)\n    (A : ExtendedIndex Î±) (L : Litter) :\n    Tree.comp A Ï€ â€¢ L = Ï€ A â€¢ L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 61, 304], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [63, 67], "informalization": "The theorem `ConNF.StructPerm.comp_bot_smul_litter` states that for any structural permutation `Ï€` on a proper type index `Î±`, any extended index `A` from `Î±` to the base type `âŠ¥`, and any litter `L`, the derivative functor `ConNF.Tree.comp A Ï€` applied to `L` is equal to `Ï€ A` applied to `L`."}
{"full_name": "ConNF.StructPerm.comp_bot_smul_nearLitter", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.comp_bot_smul_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.comp_bot_smul_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) (N : ConNF.NearLitter) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï€ â€¢ N = Ï€ A â€¢ N", "code": "theorem comp_bot_smul_nearLitter {Î± : TypeIndex} (Ï€ : StructPerm Î±)\n    (A : ExtendedIndex Î±) (N : NearLitter) :\n    Tree.comp A Ï€ â€¢ N = Ï€ A â€¢ N :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 61, 304], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [69, 73], "informalization": "The theorem `ConNF.StructPerm.comp_bot_smul_nearLitter` states that for any structural permutation `Ï€` on a proper type index `Î±`, any extended index `A` from `Î±` to the base type `âŠ¥`, and any near-litter permutation `N`, the derivative functor `ConNF.Tree.comp A Ï€` applied to `N` is equal to `Ï€ A` applied to `N`."}
{"full_name": "ConNF.StructPerm.one_pretangleAction", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.one_pretangleAction", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.one_pretangleAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (t : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.StructPerm.pretangleActionğŸ”—<|PREMISE|>ğŸ”— 1 t = t", "code": "theorem one_pretangleAction {Î± : TypeIndex} (t : Pretangle Î±) : pretangleAction 1 t = t := by\n  have : WellFoundedLT TypeIndex := inferInstance\n  revert t\n  refine this.induction Î± (C := fun Î± => âˆ€ t : Pretangle Î±, pretangleAction 1 t = t) ?_\n  intro Î± ih t\n  induction Î± using WithBot.recBotCoe with\n  | bot =>\n      unfold pretangleAction\n      rfl\n  | coe Î± =>\n      unfold pretangleAction\n      rw [Pretangle.coe_ext]\n      intro Î² hÎ² u\n      simp only [Tree.comp_one, Pretangle.ofCoe_toCoe, ih Î² hÎ², image_id']\n", "additional_info": "", "used_premises": [1, 279, 322], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [80, 94], "informalization": "The theorem `ConNF.StructPerm.one_pretangleAction` states that the action of the identity permutation on a pretangle in the context of Constructive Ordinal Notation (ConNF) results in the same pretangle."}
{"full_name": "ConNF.StructPerm.pretangleAction", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.pretangleAction", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructPerm.pretangleAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} :ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î± â†’ ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î± â†’ ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def pretangleAction : {Î± : TypeIndex} â†’ StructPerm Î± â†’ Pretangle Î± â†’ Pretangle Î±\n  | âŠ¥, Ï€, t => Tree.ofBot Ï€ â€¢ (Pretangle.ofBot t)\n  | (Î± : Î›), Ï€, t => Pretangle.toCoe\n      (fun Î² hÎ² => pretangleAction (Tree.comp (Hom.toPath hÎ²) Ï€) '' Pretangle.ofCoe t Î² hÎ²)\ntermination_by Î± Ï€ t => Î±\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n* ğŸ—ŸConNF.StructPerm.pretangleActionğŸ—ŸğŸ”—../.././ConNF/Structural/StructPerm.html#ConNF.StructPerm.pretangleActionğŸ”—  Ï€ t ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ConNF.Tree.ofBot Ï€ ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  ConNF.Pretangle.ofBot t\n\n", "used_premises": [1, 55, 279, 279], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [74, 79], "informalization": "Function `ConNF.StructPerm.pretangleAction` defines the action of a *structural permutation* on a *pretangle* in the context of Constructive Ordinal Notation (ConNF). A pretangle is an object that may become a tangle, an element of the model. The type of pretangles forms a model of TTT without extensionality. A structural permutation on a proper type index `Î±` is a near-litter permutation for each `Î±`-extended index. This represents how the permutation acts along each path down the type levels in the model."}
{"full_name": "ConNF.StructPerm.mul_pretangleAction", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.mul_pretangleAction", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.mul_pretangleAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (Ï€â‚ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) (Ï€â‚‚ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) (t : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.StructPerm.pretangleActionğŸ”—<|PREMISE|>ğŸ”— (Ï€â‚ * Ï€â‚‚) t = ConNF.StructPerm.pretangleActionğŸ”—<|PREMISE|>ğŸ”— Ï€â‚ (ConNF.StructPerm.pretangleActionğŸ”—<|PREMISE|>ğŸ”— Ï€â‚‚ t)", "code": "theorem mul_pretangleAction {Î± : TypeIndex} (Ï€â‚ Ï€â‚‚ : StructPerm Î±) (t : Pretangle Î±) :\n    pretangleAction (Ï€â‚ * Ï€â‚‚) t = pretangleAction Ï€â‚ (pretangleAction Ï€â‚‚ t) := by\n  have : WellFoundedLT TypeIndex := inferInstance\n  revert Ï€â‚ Ï€â‚‚ t\n  refine this.induction Î±\n    (C := fun Î± => âˆ€ Ï€â‚ Ï€â‚‚ : StructPerm Î±, âˆ€ t : Pretangle Î±,\n      pretangleAction (Ï€â‚ * Ï€â‚‚) t = pretangleAction Ï€â‚ (pretangleAction Ï€â‚‚ t)) ?_\n  intro Î± ih Ï€â‚ Ï€â‚‚ t\n  induction Î± using WithBot.recBotCoe with\n  | bot =>\n      unfold pretangleAction\n      rfl\n  | coe Î± =>\n      rw [pretangleAction, pretangleAction, pretangleAction]\n      simp only [Tree.comp_mul, Pretangle.ofCoe_toCoe, EmbeddingLike.apply_eq_iff_eq]\n      ext Î² hÎ² u\n      simp only [ih Î² hÎ², mem_image, exists_exists_and_eq_and]\n", "additional_info": "", "used_premises": [1, 55, 55, 279, 322, 322, 322], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [95, 112], "informalization": "The theorem `ConNF.StructPerm.mul_pretangleAction` states that the action of the product of two structural permutations on a pretangle is equal to the action of the first permutation on the action of the second permutation on the pretangle."}
{"full_name": "ConNF.StructPerm.smul_eq", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.smul_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.smul_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) (t : ConNF.PretangleğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€ â€¢ t = ConNF.StructPerm.pretangleActionğŸ”—<|PREMISE|>ğŸ”— Ï€ t", "code": "theorem smul_eq {Î± : TypeIndex} (Ï€ : StructPerm Î±) (t : Pretangle Î±) :\n    Ï€ â€¢ t = pretangleAction Ï€ t :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 279, 322], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [118, 121], "informalization": "The theorem `ConNF.StructPerm.smul_eq` states that the action of a *structural permutation* on a *pretangle* in the context of Constructive Ordinal Notation (ConNF) is equivalent to the specific function `ConNF.StructPerm.pretangleAction`. This theorem is crucial for establishing the equivalence between the actions of *structural permutations* and the model of the theory of types without extensionality."}
{"full_name": "ConNF.Address.ext_iff", "url": "ConNF/Structural/Support.html#ConNF.Address.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Address.ext_iff :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } {Î± : ConNF.TypeIndex} (x y : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±), x = y â†” x.path = y.path âˆ§ x.value = y.value", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [30, 31], "informalization": "The theorem `ConNF.Address.ext_iff` states that two `ConNF.Address` objects are equal if and only if their paths and values are equal."}
{"full_name": "ConNF.Address.ext", "url": "ConNF/Structural/Support.html#ConNF.Address.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Address.ext :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } {Î± : ConNF.TypeIndex} (x y : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±), x.path = y.path â†’ x.value = y.value â†’ x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [30, 31], "informalization": "The theorem `ConNF.Address.ext` states that two `ConNF.Address` objects are equal if and only if their `path` and `value` components are equal. This is a property of extensionality for the `ConNF.Address` structure."}
{"full_name": "ConNF.mk_address", "url": "ConNF/Structural/Support.html#ConNF.mk_address", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_address [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_address (Î± : TypeIndex) : #(Address Î±) = #Î¼ := by\n  rw [mk_congr Address_equiv]\n  simp only [Address, mk_prod, mk_sum, mk_atom, lift_id, mk_nearLitter]\n  rw [add_eq_left (Params.Îº_isRegular.aleph0_le.trans Params.Îº_lt_Î¼.le) le_rfl]\n  exact mul_eq_right\n    (Params.Îº_isRegular.aleph0_le.trans Params.Îº_lt_Î¼.le)\n    (le_trans (mk_extendedIndex Î±) <| le_of_lt <| lt_trans Params.Î›_lt_Îº Params.Îº_lt_Î¼)\n    (mk_ne_zero _)\n", "additional_info": "There are `Î¼` addresses.", "used_premises": [1, 29, 60, 29], "def_path": "ConNF/Structural/Support.lean", "pos": [45, 53], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_address` states that the cardinality of the set of addresses for a given type `Î±` is equal to the cardinality of the type `Î¼`. This means that there are as many addresses as there are elements in the type `Î¼`."}
{"full_name": "ConNF.StructPerm.smul_address", "url": "ConNF/Structural/Support.html#ConNF.StructPerm.smul_address", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.smul_address [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï€ â€¢ c = { path := c.path, value := Ï€ c.path â€¢ c.value }", "code": "theorem smul_address :\n    Ï€ â€¢ c = âŸ¨c.path, Ï€ c.path â€¢ c.valueâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [71, 74], "informalization": "Function `ConNF.StructPerm.smul_address` defines the action of a *structural permutation* on an *address* in the context of Constructive Ordinal Notation (ConNF). A *structural permutation* on a proper type index `Î±` is a near-litter permutation for each `Î±`-extended index, representing how the permutation acts along each path down the type levels in the model. An *address* represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `Î±` to type `âŠ¥` by looking at elements of elements and so on in the model."}
{"full_name": "ConNF.StructPerm.smul_address_eq_iff", "url": "ConNF/Structural/Support.html#ConNF.StructPerm.smul_address_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.smul_address_eq_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï€ â€¢ c = c â†” Ï€ c.path â€¢ c.value = c.value", "code": "theorem smul_address_eq_iff :\n    Ï€ â€¢ c = c â†” Ï€ c.path â€¢ c.value = c.value := by\n  obtain âŸ¨A, xâŸ© := c\n  simp only [smul_address, Address.mk.injEq, true_and]\n", "additional_info": "", "used_premises": [1, 55, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [76, 80], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `Î±` is a near-litter permutation for each `Î±`-extended index. This represents how the permutation acts along each path down the type levels in the model. Note that we define structural permutations as trees of near-litter permutations. Structure `ConNF.Address` represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `Î±` to type `âŠ¥` by looking at elements of elements and so on in the model. The theorem `ConNF.StructPerm.smul_address_eq_iff` states that for a structural permutation `Ï€` on a proper type index `Î±` and an address `c` of type `Î±`, `Ï€ â€¢ c = c` if and only if `Ï€ c.path â€¢ c.value = c.value`."}
{"full_name": "ConNF.StructPerm.smul_address_eq_smul_iff", "url": "ConNF/Structural/Support.html#ConNF.StructPerm.smul_address_eq_smul_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.smul_address_eq_smul_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï€ â€¢ c = Ï€' â€¢ c â†” Ï€ c.path â€¢ c.value = Ï€' c.path â€¢ c.value", "code": "theorem smul_address_eq_smul_iff :\n    Ï€ â€¢ c = Ï€' â€¢ c â†” Ï€ c.path â€¢ c.value = Ï€' c.path â€¢ c.value := by\n  obtain âŸ¨A, xâŸ© := c\n  simp only [smul_address, Address.mk.injEq, true_and]\n", "additional_info": "", "used_premises": [1, 55, 55, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [82, 86], "informalization": "The theorem `ConNF.StructPerm.smul_address_eq_smul_iff` states that for any two structural permutations `Ï€` and `Ï€'` of the same type index `Î±`, and any address `c` of type `Î±`, the equation `Ï€ â€¢ c = Ï€' â€¢ c` holds if and only if `Ï€ c.path â€¢ c.value = Ï€' c.path â€¢ c.value`, where `c.path` and `c.value` are the path and value components of the address `c`, respectively."}
{"full_name": "ConNF.NearLitterPerm.smul_address", "url": "ConNF/Structural/Support.html#ConNF.NearLitterPerm.smul_address", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.smul_address [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€ : ConNF.NearLitterPerm} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— âŠ¥ } :Ï€ â€¢ c = { path := c.path, value := Ï€ â€¢ c.value }", "code": "theorem smul_address :\n    Ï€ â€¢ c = âŸ¨c.path, Ï€ â€¢ c.valueâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [99, 102], "informalization": "The theorem `ConNF.NearLitterPerm.smul_address` states that for any near-litter permutation `Ï€` and an address `c` in the base type `âŠ¥`, the action of `Ï€` on `c` results in a new address with the same path as `c` but with the value component transformed by `Ï€`."}
{"full_name": "ConNF.NearLitterPerm.smul_address_eq_iff", "url": "ConNF/Structural/Support.html#ConNF.NearLitterPerm.smul_address_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.smul_address_eq_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€ : ConNF.NearLitterPerm} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— âŠ¥ } :Ï€ â€¢ c = c â†” Ï€ â€¢ c.value = c.value", "code": "theorem smul_address_eq_iff :\n    Ï€ â€¢ c = c â†” Ï€ â€¢ c.value = c.value := by\n  obtain âŸ¨A, xâŸ© := c\n  simp only [smul_address, Address.mk.injEq, true_and]\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [104, 108], "informalization": "The theorem `ConNF.NearLitterPerm.smul_address_eq_iff` states that for a near-litter permutation `Ï€` and an address `c`, the action of `Ï€` on `c` is equal to `c` if and only if the action of `Ï€` on the value of `c` is equal to the value of `c`."}
{"full_name": "ConNF.NearLitterPerm.smul_address_eq_smul_iff", "url": "ConNF/Structural/Support.html#ConNF.NearLitterPerm.smul_address_eq_smul_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.smul_address_eq_smul_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€ : ConNF.NearLitterPerm} {Ï€' : ConNF.NearLitterPerm} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— âŠ¥ } :Ï€ â€¢ c = Ï€' â€¢ c â†” Ï€ â€¢ c.value = Ï€' â€¢ c.value", "code": "theorem smul_address_eq_smul_iff :\n    Ï€ â€¢ c = Ï€' â€¢ c â†” Ï€ â€¢ c.value = Ï€' â€¢ c.value := by\n  obtain âŸ¨A, xâŸ© := c\n  simp only [smul_address, Address.mk.injEq, true_and]\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [110, 114], "informalization": "The theorem `ConNF.NearLitterPerm.smul_address_eq_smul_iff` states that for two near-litter permutations `Ï€` and `Ï€'` and an address `c`, the equation `Ï€ â€¢ c = Ï€' â€¢ c` holds if and only if `Ï€ â€¢ c.value = Ï€' â€¢ c.value`, where `c.value` is the value of the address `c`."}
{"full_name": "ConNF.Support.ext_iff", "url": "ConNF/Structural/Support.html#ConNF.Support.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.ext_iff :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } {Î± : ConNF.TypeIndex} (x y : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±), x = y â†” x.enum = y.enum", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [120, 121], "informalization": "Structure `ConNF.Support` represents a function from an initial segment of `Îº` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. The theorem `ConNF.Support.ext_iff` states that two instances of `ConNF.Support` are equal if and only if their enumerations are equal."}
{"full_name": "ConNF.Support.ext", "url": "ConNF/Structural/Support.html#ConNF.Support.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.ext :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } {Î± : ConNF.TypeIndex} (x y : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±), x.enum = y.enum â†’ x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [120, 121], "informalization": "Function `ConNF.Support.ext` is an extensionality theorem for the `ConNF.Support` structure in the context of Constructive Ordinal Notation (ConNF). It states that if two `ConNF.Support` structures have the same enumeration, then they are equal."}
{"full_name": "ConNF.Support.small", "url": "ConNF/Structural/Support.html#ConNF.Support.small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum)", "code": "theorem Support.small (S : Support Î±) : Small (S : Set (Address Î±)) :=\n  S.enum.small\n", "additional_info": "", "used_premises": [1, 58, 233, 70], "def_path": "ConNF/Structural/Support.lean", "pos": [145, 147], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Support` structure represents a function from an initial segment of `Îº` to the type of addresses, ensuring that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. The theorem `ConNF.Support.small` asserts that the cardinality of the carrier set of an `Î±`-enumeration `E`, which consists of all elements `c` of type `Î±` that can be expressed as `E.f i h` for some `i < E.max`, is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.Support.mem_iff", "url": "ConNF/Structural/Support.html#ConNF.Support.mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.mem_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±) (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) :c âˆˆ S â†” âˆƒ (i : ConNF.Îº) (h : i < ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”— S), c = ConNF.Support.fğŸ”—<|PREMISE|>ğŸ”— S i h", "code": "theorem Support.mem_iff (c : Address Î±) (S : Support Î±) :\n    c âˆˆ S â†” âˆƒ i, âˆƒ (h : i < S.max), c = S.f i h :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 60, 58, 338, 339], "def_path": "ConNF/Structural/Support.lean", "pos": [158, 161], "informalization": "The theorem `ConNF.Support.mem_iff` states that an element `c` of type `ConNF.Address Î±` is a member of a `ConNF.Support` structure `S` if and only if there exists an element `i` of type `ConNF.Îº` that is less than the maximum element of `S`, and `c` is equal to the function `ConNF.Support.f` applied to `S`, `i`, and a proof that `i` is less than the maximum element of `S`."}
{"full_name": "ConNF.Support.max", "url": "ConNF/Structural/Support.html#ConNF.Support.max", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Support.max [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.Îº", "code": "def Support.max (S : Support Î±) : Îº :=\n  S.enum.max\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Support.maxğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.Support.maxğŸ”—  S ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  S.enum.max\n\n", "used_premises": [1, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [127, 129], "informalization": "Function `ConNF.Support.max` returns the maximum element of a `ConNF.Support` structure, which represents a function from an initial segment of `Îº` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). This function ensures that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.Support.f", "url": "ConNF/Structural/Support.html#ConNF.Support.f", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Support.f [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) (i : ConNF.Îº) :i < ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”— S â†’ ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def Support.f (S : Support Î±) : (i : Îº) â†’ i < S.max â†’ Address Î± :=\n  S.enum.f\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Support.fğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.Support.fğŸ”—  S ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  S.enum.f\n\n", "used_premises": [1, 58, 338, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [130, 132], "informalization": "Function `ConNF.Support.f` takes a `ConNF.Support` structure `S`, an element `i` of type `ConNF.Îº`, and a proof that `i` is less than the maximum element of `S`. It returns an element of type `ConNF.Address Î±`, which represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `Î±` to type `âŠ¥` by looking at elements of elements and so on in the model."}
{"full_name": "ConNF.Support.smul_max", "url": "ConNF/Structural/Support.html#ConNF.Support.smul_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Support.smul_max [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”— (Ï€ â€¢ S) = ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”— S", "code": "theorem Support.smul_max (Ï€ : StructPerm Î±) (S : Support Î±) :\n    (Ï€ â€¢ S).max = S.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 58, 338, 338], "def_path": "ConNF/Structural/Support.lean", "pos": [196, 199], "informalization": "The theorem `ConNF.Support.smul_max` states that the maximum element of a `ConNF.Support` structure, which represents a function from an initial segment of `Îº` to the type of addresses in the context of Constructive Ordinal Notation (ConNF), is invariant under the action of a structural permutation."}
{"full_name": "ConNF.Support.smul_f", "url": "ConNF/Structural/Support.html#ConNF.Support.smul_f", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Support.smul_f [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) (i : ConNF.Îº) (hi : i < ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”— S) :ConNF.Support.fğŸ”—<|PREMISE|>ğŸ”— (Ï€ â€¢ S) i hi = Ï€ â€¢ ConNF.Support.fğŸ”—<|PREMISE|>ğŸ”— S i hi", "code": "theorem Support.smul_f (Ï€ : StructPerm Î±) (S : Support Î±) (i : Îº) (hi : i < S.max) :\n    (Ï€ â€¢ S).f i hi = Ï€ â€¢ S.f i hi :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 58, 338, 339, 339], "def_path": "ConNF/Structural/Support.lean", "pos": [201, 204], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Support.f` takes a `ConNF.Support` structure `S`, an element `i` of type `ConNF.Îº`, and a proof that `i` is less than the maximum element of `S`. It returns an element of type `ConNF.Address Î±`, which represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `Î±` to type `âŠ¥` by looking at elements of elements and so on in the model. The theorem `ConNF.Support.smul_f` states that applying a structural permutation `Ï€` to a `ConNF.Support` structure `S` and then applying `ConNF.Support.f` to the result is equivalent to first applying `ConNF.Support.f` to `S` and then applying the permutation `Ï€` to the result."}
{"full_name": "ConNF.Support.smul_mem_smul", "url": "ConNF/Structural/Support.html#ConNF.Support.smul_mem_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.smul_mem_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} (h : c âˆˆ S) (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€ â€¢ c âˆˆ Ï€ â€¢ S", "code": "theorem Support.smul_mem_smul {S : Support Î±} {c : Address Î±}\n    (h : c âˆˆ S) (Ï€ : StructPerm Î±) : Ï€ â€¢ c âˆˆ Ï€ â€¢ S :=\n  Enumeration.smul_mem_smul h Ï€\n", "additional_info": "", "used_premises": [1, 58, 60, 55], "def_path": "ConNF/Structural/Support.lean", "pos": [210, 213], "informalization": "The theorem `ConNF.Support.smul_mem_smul` states that for any initial segment `Î±` of the type `Îº`, any support function `S` defined on `Î±`, any address `c` that is in the support of `S`, and any structural permutation `Ï€`, the address `Ï€ â€¢ c` is also in the support of the support function `Ï€ â€¢ S`. This is a crucial result in the proof of the main theorem of Constructive Ordinal Notation (ConNF), which states that the natural numbers are well-ordered."}
{"full_name": "ConNF.Support.smul_eq_of_smul_eq", "url": "ConNF/Structural/Support.html#ConNF.Support.smul_eq_of_smul_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.smul_eq_of_smul_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±} (hS : Ï€ â€¢ S = S) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} (hc : c âˆˆ S) :Ï€ â€¢ c = c", "code": "theorem Support.smul_eq_of_smul_eq {S : Support Î±} {Ï€ : StructPerm Î±}\n    (hS : Ï€ â€¢ S = S) {c : Address Î±} (hc : c âˆˆ S) : Ï€ â€¢ c = c :=\n  Enumeration.smul_eq_of_smul_eq (congr_arg Support.enum hS) hc\n", "additional_info": "", "used_premises": [1, 58, 55, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [214, 217], "informalization": "The theorem `ConNF.Support.smul_eq_of_smul_eq` states that if a structural permutation `Ï€` leaves a support `S` invariant (i.e., `Ï€ â€¢ S = S`), then `Ï€` also leaves any address `c` in `S` invariant (i.e., `Ï€ â€¢ c = c`)."}
{"full_name": "ConNF.Support.singleton_enum", "url": "ConNF/Structural/Support.html#ConNF.Support.singleton_enum", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Support.singleton_enum [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±) :(ConNF.Support.singletonğŸ”—<|PREMISE|>ğŸ”— c).enum = { max := 1, f := fun (x : ConNF.Îº) (x : x < 1) => c }", "code": "theorem Support.singleton_enum (c : Address Î±) :\n    (Support.singleton c).enum = âŸ¨1, fun _ _ => câŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60, 345], "def_path": "ConNF/Structural/Support.lean", "pos": [231, 234], "informalization": "Function `ConNF.Support.singleton` is a constructor for the `ConNF.Support` structure, which represents a function from an initial segment of `Îº` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. Given an address `c` of type `ConNF.Address Î±`, `ConNF.Support.singleton c` returns a `ConNF.Support Î±` structure where the enumeration `enum` is defined as `âŸ¨1, fun _ _ => câŸ©`, meaning it maps all elements of `Îº` less than `1` to the address `c`."}
{"full_name": "ConNF.Support.singleton", "url": "ConNF/Structural/Support.html#ConNF.Support.singleton", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Support.singleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def Support.singleton (c : Address Î±) : Support Î± where\n  enum := âŸ¨1, fun _ _ => câŸ©\n  mem_of_mem_symmDiff' := by\n    intro _ Nâ‚ Nâ‚‚ b _ hb hNâ‚ hNâ‚‚\n    simp only [Enumeration.mem_iff, Îº_lt_one_iff, exists_prop, exists_eq_left] at hNâ‚ hNâ‚‚\n    rw [â† hNâ‚‚] at hNâ‚\n    simp only [Address.mk.injEq, inr.injEq, true_and] at hNâ‚\n    subst hNâ‚\n    cases hb with\n    | inl hb => cases hb.2 hb.1\n    | inr hb => cases hb.2 hb.1\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Support.singletonğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.Support.singletonğŸ”—  c ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  { enum := { max := 1, f := fun (x : ConNF.Îº) (x : x ğŸ—Ÿ<ğŸ—ŸğŸ”—../.././Init/Prelude.html#LT.ltğŸ”—  1) => c }, mem_of_mem_symmDiff' := â‹¯ }\n\n", "used_premises": [1, 60, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [218, 229], "informalization": "Function `ConNF.Support.singleton` is a constructor for the `ConNF.Support` structure, which represents a function from an initial segment of `Îº` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. Given an address `c` of type `ConNF.Address Î±`, `ConNF.Support.singleton c` returns a `ConNF.Support Î±` structure where the enumeration `enum` is defined as `âŸ¨1, fun _ _ => câŸ©`, meaning it maps all elements of `Îº` less than `1` to the address `c`."}
{"full_name": "ConNF.Support.mem_singleton_iff", "url": "ConNF/Structural/Support.html#ConNF.Support.mem_singleton_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Support.mem_singleton_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±) :c âˆˆ ConNF.Support.singletonğŸ”—<|PREMISE|>ğŸ”— d â†” c = d", "code": "theorem Support.mem_singleton_iff (c d : Address Î±) : c âˆˆ Support.singleton d â†” c = d := by\n  unfold singleton\n  simp only [mem_mk, Enumeration.mem_iff, Îº_lt_one_iff, exists_prop, exists_eq_left]\n", "additional_info": "", "used_premises": [1, 60, 60, 345], "def_path": "ConNF/Structural/Support.lean", "pos": [236, 239], "informalization": "The theorem `ConNF.Support.mem_singleton_iff` states that for any two addresses `c` and `d` of the same type `Î±` in the context of Constructive Ordinal Notation (ConNF), `c` is an element of the singleton support structure `ConNF.Support.singleton d` if and only if `c` is equal to `d`."}
{"full_name": "ConNF.mk_support", "url": "ConNF/Structural/Support.html#ConNF.mk_support", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_support [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_support : #(Support Î±) = #Î¼ := by\n  refine le_antisymm ?_ ?_\n  Â· rw [â† mk_enumeration (mk_address Î±)]\n    refine âŸ¨âŸ¨Support.enum, ?_âŸ©âŸ©\n    intro Sâ‚ Sâ‚‚ h\n    ext : 1\n    exact h\n  Â· rw [â† mk_atom]\n    refine âŸ¨âŸ¨fun a => Support.singleton âŸ¨default, inl aâŸ©, ?_âŸ©âŸ©\n    intro aâ‚ aâ‚‚ h\n    have := Support.singleton_injective h\n    simp only [Address.mk.injEq, inl.injEq, true_and] at this\n    exact this\n", "additional_info": "There are exactly `Î¼` supports.", "used_premises": [1, 29, 58, 29], "def_path": "ConNF/Structural/Support.lean", "pos": [250, 263], "informalization": "The theorem `ConNF.mk_support` states that the cardinality of the set of supports for a given type index `Î±` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `Î¼`. This means that there are exactly as many supports as there are elements in the type `Î¼`."}
{"full_name": "ConNF.Support.IsCompletion.smul", "url": "ConNF/Structural/Support.html#ConNF.Support.IsCompletion.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.IsCompletion.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)} (h : ConNF.Support.IsCompletionğŸ”—<|PREMISE|>ğŸ”— S E) (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.Support.IsCompletionğŸ”—<|PREMISE|>ğŸ”— (Ï€ â€¢ S) (Ï€ â€¢ E)", "code": "theorem Support.IsCompletion.smul {S : Support Î±} {E : Enumeration (Address Î±)}\n    (h : S.IsCompletion E) (Ï€ : StructPerm Î±) : (Ï€ â€¢ S).IsCompletion (Ï€ â€¢ E) := by\n  constructor\n  Â· exact Enumeration.smul_le_smul h.le Ï€\n  Â· intro i hiâ‚ hiâ‚‚\n    obtain âŸ¨A, a, Nâ‚, Nâ‚‚, hN, ha, hNâ‚, hNâ‚‚, hâŸ© := h.eq_atom i hiâ‚ hiâ‚‚\n    refine âŸ¨A, Ï€ A â€¢ a, Ï€ A â€¢ Nâ‚, Ï€ A â€¢ Nâ‚‚, ?_, ?_, ?_, ?_, ?_âŸ©\n    Â· simp only [NearLitterPerm.smul_nearLitter_fst, smul_left_cancel_iff]\n      exact hN\n    Â· rw [NearLitterPerm.smul_nearLitter_coe, NearLitterPerm.smul_nearLitter_coe,\n        â† Set.smul_set_symmDiff, Set.smul_mem_smul_set_iff]\n      exact ha\n    Â· obtain âŸ¨i, hi, hâŸ© := hNâ‚\n      refine âŸ¨i, hi, ?_âŸ©\n      rw [Enumeration.smul_f, â† h]\n      rfl\n    Â· obtain âŸ¨i, hi, hâŸ© := hNâ‚‚\n      refine âŸ¨i, hi, ?_âŸ©\n      rw [Enumeration.smul_f, â† h]\n      rfl\n    Â· rw [smul_f, h]\n      rfl\n", "additional_info": "", "used_premises": [1, 58, 59, 60, 349, 55, 349], "def_path": "ConNF/Structural/Support.lean", "pos": [274, 296], "informalization": "The theorem `ConNF.Support.IsCompletion.smul` states that if `S` is a completion of an enumeration of addresses `E`, and `Ï€` is a structural permutation, then `Ï€ â€¢ S` is a completion of `Ï€ â€¢ E`."}
{"full_name": "ConNF.Support.IsCompletion", "url": "ConNF/Structural/Support.html#ConNF.Support.IsCompletion", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Support.IsCompletion [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) :Prop\n | le : E â‰¤  S.enum\n | eq_atom : âˆ€ (i : ConNF.Îº) (hiâ‚ : i <  ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”—  S),\n E.max â‰¤  i â†’\n âˆƒ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  Î±) (a : ConNF.Atom) (Nâ‚ : ConNF.NearLitter) (Nâ‚‚ : ConNF.NearLitter),\n Nâ‚.fst =  Nâ‚‚.fst âˆ§  a âˆˆ  symmDiffğŸ”—<|PREMISE|>ğŸ”—  â†‘Nâ‚ â†‘Nâ‚‚ âˆ§  { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  Nâ‚ } âˆˆ  E âˆ§  { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  Nâ‚‚ } âˆˆ  E âˆ§  ConNF.Support.fğŸ”—<|PREMISE|>ğŸ”—  S i hiâ‚ =  { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a }", "code": "structure Support.IsCompletion (S : Support Î±) (E : Enumeration (Address Î±)) : Prop where\n  le : E â‰¤ S.enum\n  eq_atom (i : Îº) (hiâ‚ : i < S.max) (hiâ‚‚ : E.max â‰¤ i) :\n    âˆƒ A : ExtendedIndex Î±, âˆƒ a : Atom, âˆƒ Nâ‚ Nâ‚‚ : NearLitter,\n    Nâ‚.1 = Nâ‚‚.1 âˆ§ a âˆˆ (Nâ‚ : Set Atom) âˆ† Nâ‚‚ âˆ§\n    âŸ¨A, inr Nâ‚âŸ© âˆˆ E âˆ§ âŸ¨A, inr Nâ‚‚âŸ© âˆˆ E âˆ§ S.f i hiâ‚ = âŸ¨A, inl aâŸ©\n", "additional_info": "`S` is a *completion* of an enumeration of addresses `E` if it extends `E`,\nand every address in the extension is an atom contained in the symmetric difference of\ntwo near-litters in `E`.\n", "used_premises": [1, 58, 59, 60, 338, 61, 62, 65, 65, 339, 67], "def_path": "ConNF/Structural/Support.lean", "pos": [267, 273], "informalization": "`S` is a *completion* of an enumeration of addresses `E` if it extends `E`, and every address in the extension is an atom contained in the symmetric difference of two near-litters in `E`."}
{"full_name": "ConNF.nearLitter_not_mem_completionToAdd", "url": "ConNF/Structural/Support.html#ConNF.nearLitter_not_mem_completionToAdd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.nearLitter_not_mem_completionToAdd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) (N : ConNF.NearLitter) (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } âˆ‰ ConNF.completionToAddğŸ”—<|PREMISE|>ğŸ”— s", "code": "theorem nearLitter_not_mem_completionToAdd (A : ExtendedIndex Î±) (N : NearLitter)\n    (s : Set (Address Î±)) : âŸ¨A, inr NâŸ© âˆ‰ completionToAdd s := by\n  rintro âŸ¨_, _, _, a, h, _âŸ©\n  cases h\n", "additional_info": "", "used_premises": [1, 61, 69, 60, 65, 351], "def_path": "ConNF/Structural/Support.lean", "pos": [302, 306], "informalization": "The theorem `ConNF.nearLitter_not_mem_completionToAdd` states that a near-litter address does not belong to the completion of a set `s` of addresses. This is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). The completion of a set `s` is the set of addresses that need to be added to `s` to make it a \"support\" in the ConNF model. A \"support\" is a set of addresses that satisfies certain properties related to the structure of the ConNF model. The theorem shows that near-litter addresses are not added to the completion of a set `s` to make it a support, which is a key step in the proof of the natural number representation in ConNF."}
{"full_name": "ConNF.completionToAdd", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.completionToAdd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)", "code": "def completionToAdd (s : Set (Address Î±)) : Set (Address Î±) :=\n  {x | âˆƒ Nâ‚ Nâ‚‚ : NearLitter, Nâ‚.1 = Nâ‚‚.1 âˆ§ âˆƒ a : Atom, x.2 = inl a âˆ§ a âˆˆ (Nâ‚ : Set Atom) âˆ† Nâ‚‚ âˆ§\n    âŸ¨x.1, inr Nâ‚âŸ© âˆˆ s âˆ§ âŸ¨x.1, inr Nâ‚‚âŸ© âˆˆ s}\n", "additional_info": "The set of addresses that we need to add to `s` to make it a support.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [298, 301], "informalization": "Function `ConNF.completionToAdd` defines the set of addresses that need to be added to a given set `s` of addresses to make it a \"support\" in the context of Constructive Ordinal Notation (ConNF). A \"support\" is a set of addresses that satisfies certain properties related to the structure of the ConNF model. The function looks for pairs of near-litters `Nâ‚` and `Nâ‚‚` with the same base type, an atom `a` that belongs to the symmetric difference of `Nâ‚` and `Nâ‚‚`, and addresses `âŸ¨x.1, inr Nâ‚âŸ©` and `âŸ¨x.1, inr Nâ‚‚âŸ©` that are already in `s`. The function then adds the address `âŸ¨x.1, inl aâŸ©` to the set `s` to ensure it becomes a support."}
{"full_name": "ConNF.completionToAdd'_small", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd'_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.completionToAdd'_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.completionToAdd'ğŸ”—<|PREMISE|>ğŸ”— s A)", "code": "theorem completionToAdd'_small (s : Set (Address Î±)) (hs : Small s) (A : ExtendedIndex Î±) :\n    Small (completionToAdd' s A) := by\n  have : Function.Injective (fun N => (âŸ¨A, inr NâŸ© : Address Î±))\n  Â· intro Nâ‚ Nâ‚‚ h\n    simp only [Address.mk.injEq, inr.injEq, true_and] at h\n    exact h\n  refine Small.bUnion (Small.preimage this hs) (fun Nâ‚ _ => ?_)\n  refine Small.bUnion (Small.preimage this hs) (fun Nâ‚‚ _ => ?_)\n  refine small_iUnion_Prop (fun h => ?_)\n  refine Nâ‚.2.prop.symm.trans ?_\n  rw [h]\n  exact Nâ‚‚.2.prop\n", "additional_info": "", "used_premises": [1, 69, 60, 233, 61, 233, 353], "def_path": "ConNF/Structural/Support.lean", "pos": [313, 325], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.completionToAdd'` is used to define the addition operation on natural numbers. This function takes a set `s` of `ConNF.Address` objects and an `ConNF.ExtendedIndex` object `A`, and returns a set of `ConNF.Atom` objects. The theorem `ConNF.completionToAdd'_small` states that if the set `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.Îº`), then the set returned by `ConNF.completionToAdd'` is also small."}
{"full_name": "ConNF.completionToAdd'", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd'", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.completionToAdd' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def completionToAdd' (s : Set (Address Î±)) (A : ExtendedIndex Î±) : Set Atom :=\n  â‹ƒ (Nâ‚ : NearLitter) (_ : Nâ‚ âˆˆ (fun N => âŸ¨A, inr NâŸ©) â»Â¹' s)\n    (Nâ‚‚ : NearLitter) (_ : Nâ‚‚ âˆˆ (fun N => âŸ¨A, inr NâŸ©) â»Â¹' s)\n    (_ : Nâ‚.1 = Nâ‚‚.1),\n  (Nâ‚ : Set Atom) âˆ† Nâ‚‚\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 69, 60, 61, 69], "def_path": "ConNF/Structural/Support.lean", "pos": [307, 312], "informalization": "Function `ConNF.completionToAdd'` takes a set `s` of `ConNF.Address` objects and an `ConNF.ExtendedIndex` object `A`, and returns a set of `ConNF.Atom` objects. This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), and is used to define the addition operation on natural numbers."}
{"full_name": "ConNF.completionToAdd_eq_completionToAdd'", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd_eq_completionToAdd'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.completionToAdd_eq_completionToAdd' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) :ConNF.completionToAddğŸ”—<|PREMISE|>ğŸ”— s = â‹ƒ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î±), (fun (x : ConNF.Atom) => { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— x }) '' ConNF.completionToAdd'ğŸ”—<|PREMISE|>ğŸ”— s A", "code": "theorem completionToAdd_eq_completionToAdd' (s : Set (Address Î±)) :\n    completionToAdd s = â‹ƒ (A : ExtendedIndex Î±), (âŸ¨A, inl Â·âŸ©) '' completionToAdd' s A := by\n  simp only [completionToAdd, completionToAdd']\n  aesop\n", "additional_info": "", "used_premises": [1, 69, 60, 351, 61, 67, 353], "def_path": "ConNF/Structural/Support.lean", "pos": [326, 330], "informalization": "The theorem `ConNF.completionToAdd_eq_completionToAdd'` establishes an equality between two sets of addresses. Specifically, it relates the set of addresses `ConNF.completionToAdd s` (which adds new addresses to a set `s` to make it a \"support\") with the union of sets obtained by applying the function `ConNF.completionToAdd'` to `s` for each `ConNF.ExtendedIndex Î±`. The function `ConNF.completionToAdd'` takes a set `s` and an `ConNF.ExtendedIndex Î±` object `A`, and returns a set of `ConNF.Atom` objects, which are used to define the addition operation on natural numbers in the context of Constructive Ordinal Notation (ConNF). The equality established by the theorem means that the set obtained by adding new addresses to `s` to make it a \"support\" can be equivalently described by taking the union of sets generated by applying `ConNF.completionToAdd'` to `s` for each possible `ConNF.ExtendedIndex Î±`."}
{"full_name": "ConNF.completionToAdd_small", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.completionToAdd_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.completionToAddğŸ”—<|PREMISE|>ğŸ”— s)", "code": "theorem completionToAdd_small (s : Set (Address Î±)) (hs : Small s) :\n    Small (completionToAdd s) := by\n  rw [completionToAdd_eq_completionToAdd']\n  refine small_iUnion ?_ ?_\n  Â· exact (mk_extendedIndex Î±).trans_lt Params.Î›_lt_Îº\n  Â· intro A\n    exact Small.image (completionToAdd'_small s hs A)\n", "additional_info": "", "used_premises": [1, 69, 60, 233, 233, 351], "def_path": "ConNF/Structural/Support.lean", "pos": [331, 338], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.completionToAdd_small` states that the set of addresses that need to be added to a given set `s` of addresses to make it a \"support\" (a set of addresses that satisfies certain properties related to the structure of the ConNF model) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.mem_completeEnum", "url": "ConNF/Structural/Support.html#ConNF.mem_completeEnum", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mem_completeEnum [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±) :c âˆˆ ConNF.completeEnumğŸ”—<|PREMISE|>ğŸ”— E â†” c âˆˆ E âˆ¨ c âˆˆ ConNF.completionToAddğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— E)", "code": "theorem mem_completeEnum (E : Enumeration (Address Î±)) (c : Address Î±) :\n    c âˆˆ completeEnum E â†” c âˆˆ E âˆ¨ c âˆˆ completionToAdd E :=\n  by rw [completeEnum, Enumeration.mem_add_iff, Enumeration.mem_ofSet_iff]\n", "additional_info": "", "used_premises": [1, 59, 60, 60, 357, 351, 70], "def_path": "ConNF/Structural/Support.lean", "pos": [344, 347], "informalization": "The theorem `ConNF.mem_completeEnum` states that an address `c` belongs to the complete enumeration of an `Î±`-enumeration `E` if and only if `c` belongs to `E` or `c` belongs to the completion of `E` with respect to the addition operation defined in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.completeEnum", "url": "ConNF/Structural/Support.html#ConNF.completeEnum", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.completeEnum [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) :ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)", "code": "noncomputable def completeEnum (E : Enumeration (Address Î±)) :\n    Enumeration (Address Î±) :=\n  E + Enumeration.ofSet (completionToAdd E) (completionToAdd_small _ E.small)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.completeEnumğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.completeEnumğŸ”—  E ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  E ğŸ—Ÿ+ğŸ—ŸğŸ”—../.././Init/Prelude.html#HAdd.hAddğŸ”—  ğŸ—ŸConNF.Enumeration.ofSetğŸ—ŸğŸ”—../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSetğŸ”—  (ğŸ—ŸConNF.completionToAddğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.completionToAddğŸ”—  (ğŸ—ŸConNF.Enumeration.carrierğŸ—ŸğŸ”—../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.carrierğŸ”—  E)) â‹¯\n\n", "used_premises": [1, 59, 60, 59, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [339, 342], "informalization": "Function `ConNF.completeEnum` takes an `Î±`-enumeration `E` (a function from an initial segment of `Îº` to `Î±`) and returns a new `Î±`-enumeration, which is the sum of the original enumeration `E` and the enumeration of the completion of `E` with respect to the addition operation defined in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Support.complete_isCompletion", "url": "ConNF/Structural/Support.html#ConNF.Support.complete_isCompletion", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.complete_isCompletion [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) :ConNF.Support.IsCompletionğŸ”—<|PREMISE|>ğŸ”— (ConNF.Support.completeğŸ”—<|PREMISE|>ğŸ”— E) E", "code": "theorem Support.complete_isCompletion (E : Enumeration (Address Î±)) :\n    (complete E).IsCompletion E := by\n  constructor\n  Â· exact Enumeration.le_add _ _\n  Â· intro i hiâ‚ hiâ‚‚\n    have := Enumeration.f_mem _ (i - E.max) (Îº_sub_lt hiâ‚ hiâ‚‚)\n    rw [â† Enumeration.add_f_right hiâ‚ hiâ‚‚, Enumeration.mem_ofSet_iff] at this\n    obtain âŸ¨Nâ‚, Nâ‚‚, hN, a, haâ‚, haâ‚‚, hNâ‚, hNâ‚‚âŸ© := this\n    refine âŸ¨_, a, Nâ‚, Nâ‚‚, hN, haâ‚‚, hNâ‚, hNâ‚‚, ?_âŸ©\n    rw [â† haâ‚]\n    rfl\n", "additional_info": "", "used_premises": [1, 59, 60, 349, 359], "def_path": "ConNF/Structural/Support.lean", "pos": [365, 376], "informalization": "The theorem `ConNF.Support.complete_isCompletion` states that the function `ConNF.Support.complete`, which extends an enumeration to a support in the context of Constructive Ordinal Notation (ConNF), ensures that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.Support.complete", "url": "ConNF/Structural/Support.html#ConNF.Support.complete", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.Support.complete [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)) :ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "noncomputable def Support.complete (E : Enumeration (Address Î±)) : Support Î± where\n  enum := completeEnum E\n  mem_of_mem_symmDiff' := completeEnum_mem_of_mem_symmDiff E\n", "additional_info": "Extend an enumeration to a support.\nEquations\n* ğŸ—ŸConNF.Support.completeğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.Support.completeğŸ”—  E ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  { enum := ğŸ—ŸConNF.completeEnumğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.completeEnumğŸ”—  E, mem_of_mem_symmDiff' := â‹¯ }\n\n", "used_premises": [1, 59, 60, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [361, 364], "informalization": "Function `ConNF.Support.complete` extends an enumeration to a support in the context of Constructive Ordinal Notation (ConNF), ensuring that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.Support.IsSum.smul", "url": "ConNF/Structural/Support.html#ConNF.Support.IsSum.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.IsSum.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {Sâ‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {Sâ‚‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} (h : ConNF.Support.IsSumğŸ”—<|PREMISE|>ğŸ”— S Sâ‚ Sâ‚‚) (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.Support.IsSumğŸ”—<|PREMISE|>ğŸ”— (Ï€ â€¢ S) (Ï€ â€¢ Sâ‚) (Ï€ â€¢ Sâ‚‚)", "code": "theorem Support.IsSum.smul {S Sâ‚ Sâ‚‚ : Support Î±} (h : S.IsSum Sâ‚ Sâ‚‚) (Ï€ : StructPerm Î±) :\n    (Ï€ â€¢ S).IsSum (Ï€ â€¢ Sâ‚) (Ï€ â€¢ Sâ‚‚) := by\n  have := IsCompletion.smul h Ï€\n  rw [Enumeration.smul_add] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 58, 58, 58, 361, 55, 361], "def_path": "ConNF/Structural/Support.lean", "pos": [380, 385], "informalization": "Function `ConNF.Support.IsSum.smul` proves that if `S` is a sum of `Sâ‚` and `Sâ‚‚`, and `Ï€` is a structural permutation, then `Ï€ â€¢ S` is a sum of `Ï€ â€¢ Sâ‚` and `Ï€ â€¢ Sâ‚‚`."}
{"full_name": "ConNF.Support.IsSum", "url": "ConNF/Structural/Support.html#ConNF.Support.IsSum", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Support.IsSum [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) (Sâ‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) (Sâ‚‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "def Support.IsSum (S Sâ‚ Sâ‚‚ : Support Î±) : Prop := S.IsCompletion (Sâ‚.enum + Sâ‚‚.enum)\n", "additional_info": "`S` is a *sum* of `Sâ‚` and `Sâ‚‚` if it is a completion of `Sâ‚ + Sâ‚‚`.\nEquations\n* ğŸ—ŸConNF.Support.IsSumğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.Support.IsSumğŸ”—  S Sâ‚ Sâ‚‚ ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.Support.IsCompletionğŸ—ŸğŸ”—../.././ConNF/Structural/Support.html#ConNF.Support.IsCompletionğŸ”—  S (Sâ‚.enum ğŸ—Ÿ+ğŸ—ŸğŸ”—../.././Init/Prelude.html#HAdd.hAddğŸ”—  Sâ‚‚.enum)\n\n", "used_premises": [1, 58, 58, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [378, 379], "informalization": "Function `ConNF.Support.IsSum` checks if a `ConNF.Support` object `S` is a sum of two other `ConNF.Support` objects `Sâ‚` and `Sâ‚‚`. This is determined by checking if `S` is a completion of the sum of the enumerations of `Sâ‚` and `Sâ‚‚`."}
{"full_name": "ConNF.Support.exists_isSum", "url": "ConNF/Structural/Support.html#ConNF.Support.exists_isSum", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.exists_isSum [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} (Sâ‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) (Sâ‚‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) :âˆƒ (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±), ConNF.Support.IsSumğŸ”—<|PREMISE|>ğŸ”— S Sâ‚ Sâ‚‚", "code": "theorem Support.exists_isSum (Sâ‚ Sâ‚‚ : Support Î±) : âˆƒ S : Support Î±, S.IsSum Sâ‚ Sâ‚‚ :=\n  âŸ¨_, Support.complete_isCompletion _âŸ©\n", "additional_info": "", "used_premises": [1, 58, 58, 58, 361], "def_path": "ConNF/Structural/Support.lean", "pos": [386, 388], "informalization": "Given two `ConNF.Support` objects `Sâ‚` and `Sâ‚‚`, there exists a `ConNF.Support` object `S` such that `S` is the sum of `Sâ‚` and `Sâ‚‚`."}
{"full_name": "ConNF.someOfMkLt_spec", "url": "ConNF/Fuzz/Construction.html#ConNF.someOfMkLt_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.someOfMkLt_spec {Î² : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î²} {h : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘s < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²} :ConNF.someOfMkLtğŸ”—<|PREMISE|>ğŸ”— s h âˆ‰ s", "code": "theorem someOfMkLt_spec {s : Set Î²} {h : #s < #Î²} : someOfMkLt s h âˆ‰ s :=\n  (nonempty_compl_of_mk_lt_mk h).choose_spec\n", "additional_info": "", "used_premises": [69, 29, 29, 364], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [51, 53], "informalization": "Function `ConNF.someOfMkLt` noncomputably chooses an element from the complement of a set `s` in a type `Î²`, given that the cardinality of `s` is less than the cardinality of `Î²`. The theorem `ConNF.someOfMkLt_spec` states that the chosen element does not belong to the set `s`."}
{"full_name": "ConNF.someOfMkLt", "url": "ConNF/Fuzz/Construction.html#ConNF.someOfMkLt", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.someOfMkLt {Î² : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î²) (h : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘s < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²) :Î²", "code": "noncomputable def someOfMkLt (s : Set Î²) (h : #s < #Î²) : Î² :=\n  (nonempty_compl_of_mk_lt_mk h).choose\n", "additional_info": "Noncomputably chooses an element of `Î² \\ s`, given `#s < #Î²`.\nEquations\n* ğŸ—ŸConNF.someOfMkLtğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.someOfMkLtğŸ”—  s h ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸExists.chooseğŸ—ŸğŸ”—../.././Init/Classical.html#Exists.chooseğŸ”—  â‹¯\n\n", "used_premises": [69, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [48, 50], "informalization": "Function `ConNF.someOfMkLt` noncomputably chooses an element from the complement of a set `s` in a type `Î²`, given that the cardinality of `s` is less than the cardinality of `Î²`."}
{"full_name": "ConNF.mk_imageâ‚‚_le", "url": "ConNF/Fuzz/Construction.html#ConNF.mk_imageâ‚‚_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_imageâ‚‚_le {Î± : Type u} {Î² : Type u} {p : Î± â†’ Prop } (f : (x : Î±) â†’ p x â†’ Î²) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { y : Î² // âˆƒ (z : Î±) (h : p z), f z h = y } â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { x : Î± // p x }", "code": "theorem mk_imageâ‚‚_le {p : Î± â†’ Prop} (f : âˆ€ x, p x â†’ Î²) :\n    #{ y // âˆƒ z h, f z h = y } â‰¤ #{ x // p x } :=\n  âŸ¨âŸ¨fun y => âŸ¨y.prop.choose, y.prop.choose_spec.chooseâŸ©, by\n    intro yâ‚ yâ‚‚ h\n    simp only [Subtype.mk.injEq] at h\n    have := yâ‚‚.prop.choose_spec.choose_spec\n    simp_rw [â† h] at this\n    rw [yâ‚.prop.choose_spec.choose_spec] at this\n    simp only [Subtype.coe_inj] at this\n    exact thisâŸ©âŸ©\n", "additional_info": "", "used_premises": [29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [54, 64], "informalization": "Function `ConNF.mk_imageâ‚‚_le` proves that the cardinality of the range of a function `f : (x : Î±) â†’ p x â†’ Î²` is less than or equal to the cardinality of the domain `{x : Î± // p x}`."}
{"full_name": "ConNF.chooseWfCore_spec", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWfCore_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWfCore_spec {Î± : Type u} {Î² : Type u} {r : Î± â†’ Î± â†’ Prop } {deny : Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î²} {h : âˆ€ (x : Î±), Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { y : Î± // r y x } + Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(deny x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²} (x : Î±) (f : (y : Î±) â†’ r y x â†’ Î²) :ConNF.chooseWfCoreğŸ”—<|PREMISE|>ğŸ”— deny h x f âˆ‰ {z : Î² | âˆƒ (y : Î±) (h : r y x), f y h = z} âˆª deny x", "code": "theorem chooseWfCore_spec {deny : Î± â†’ Set Î²} {h : âˆ€ x, #{ y // r y x } + #(deny x) < #Î²} (x : Î±)\n    (f : âˆ€ y : Î±, r y x â†’ Î²) :\n    chooseWfCore deny h x f âˆ‰ {z | âˆƒ y h, f y h = z} âˆª deny x :=\n  someOfMkLt_spec\n", "additional_info": "", "used_premises": [69, 29, 29, 29, 367], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [70, 74], "informalization": "Function `ConNF.chooseWfCore` is a noncomputable function that, given a type `Î±`, a type `Î²`, a relation `r` on `Î±`, a function `deny` from `Î±` to sets of `Î²`, a proof `h` that for each `x` in `Î±`, the cardinality of the set of `y` such that `r y x` plus the cardinality of `deny x` is less than the cardinality of `Î²`, an element `x` of `Î±`, and a function `f` from the set of `y` such that `r y x` to `Î²`, returns an element of `Î²` that is not in the union of the image of `f` and `deny x`."}
{"full_name": "ConNF.chooseWfCore", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWfCore", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.chooseWfCore {Î± : Type u} {Î² : Type u} {r : Î± â†’ Î± â†’ Prop } (deny : Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î²) (h : âˆ€ (x : Î±), Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { y : Î± // r y x } + Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(deny x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²) (x : Î±) (f : (y : Î±) â†’ r y x â†’ Î²) :Î²", "code": "noncomputable def chooseWfCore (deny : Î± â†’ Set Î²) (h : âˆ€ x, #{ y // r y x } + #(deny x) < #Î²)\n    (x : Î±) (f : âˆ€ y : Î±, r y x â†’ Î²) : Î² :=\n  someOfMkLt ({z | âˆƒ y h, f y h = z} âˆª deny x)\n    (lt_of_le_of_lt (mk_union_le _ _) (lt_of_le_of_lt (add_le_add_right (mk_imageâ‚‚_le _) _) (h x)))\n", "additional_info": "Equations\n* ğŸ—ŸConNF.chooseWfCoreğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.chooseWfCoreğŸ”—  deny h x f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.someOfMkLtğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.someOfMkLtğŸ”—  ({z : Î² | âˆƒ (y : Î±) (h : r y x), f y h ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  z} ğŸ—ŸâˆªğŸ—ŸğŸ”—../.././Init/Core.html#Union.unionğŸ”—  deny x) â‹¯\n\n", "used_premises": [69, 29, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [65, 69], "informalization": "Function `ConNF.chooseWfCore` is a noncomputable function that, given a type `Î±`, a type `Î²`, a relation `r` on `Î±`, a function `deny` from `Î±` to sets of `Î²`, a proof `h` that for each `x` in `Î±`, the cardinality of the set of `y` such that `r y x` plus the cardinality of `deny x` is less than the cardinality of `Î²`, an element `x` of `Î±`, and a function `f` from the set of `y` such that `r y x` to `Î²`, returns an element of `Î²`."}
{"full_name": "ConNF.chooseWf_spec", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWf_spec {Î± : Type u} {Î² : Type u} {r : Î± â†’ Î± â†’ Prop } [hwf : IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± r] {deny : Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î²} {h : âˆ€ (x : Î±), Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { y : Î± // r y x } + Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(deny x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²} (x : Î±) :ConNF.chooseWfğŸ”—<|PREMISE|>ğŸ”— deny h x âˆ‰ {z : Î² | âˆƒ (y : Î±) (_ : r y x), ConNF.chooseWfğŸ”—<|PREMISE|>ğŸ”— deny h y = z} âˆª deny x", "code": "theorem chooseWf_spec [hwf : IsWellOrder Î± r] {deny : Î± â†’ Set Î²}\n    {h : âˆ€ x, #{ y // r y x } + #(deny x) < #Î²} (x : Î±) :\n    chooseWf deny h x âˆ‰ {z | âˆƒ (y : _) (_ : r y x), chooseWf deny h y = z} âˆª deny x := by\n  rw [chooseWf, WellFounded.fix_eq]\n  exact chooseWfCore_spec x _\n", "additional_info": "", "used_premises": [15, 69, 29, 29, 29, 369, 369], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [80, 85], "informalization": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x âˆ‰ deny x`."}
{"full_name": "ConNF.chooseWf", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.chooseWf {Î± : Type u} {Î² : Type u} {r : Î± â†’ Î± â†’ Prop } [hwf : IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± r] (deny : Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î²) (h : âˆ€ (x : Î±), Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { y : Î± // r y x } + Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(deny x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²) :Î± â†’ Î²", "code": "noncomputable def chooseWf [hwf : IsWellOrder Î± r] (deny : Î± â†’ Set Î²)\n    (h : âˆ€ x, #{ y // r y x } + #(deny x) < #Î²) : Î± â†’ Î² :=\n  hwf.toIsWellFounded.wf.fix (chooseWfCore deny h)\n", "additional_info": "Constructs an injective function `f` such that `f x âˆ‰ deny x`.\nEquations\n* ğŸ—ŸConNF.chooseWfğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.chooseWfğŸ”—  deny h ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸWellFounded.fixğŸ—ŸğŸ”—../.././Init/WF.html#WellFounded.fixğŸ”—  â‹¯ (ğŸ—ŸConNF.chooseWfCoreğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.chooseWfCoreğŸ”—  deny h)\n\n", "used_premises": [15, 69, 29, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [76, 79], "informalization": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x âˆ‰ deny x`."}
{"full_name": "ConNF.chooseWf_not_mem_deny", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf_not_mem_deny", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWf_not_mem_deny {Î± : Type u} {Î² : Type u} {r : Î± â†’ Î± â†’ Prop } [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± r] {deny : Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î²} {h : âˆ€ (x : Î±), Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { y : Î± // r y x } + Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(deny x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²} (x : Î±) :ConNF.chooseWfğŸ”—<|PREMISE|>ğŸ”— deny h x âˆ‰ deny x", "code": "theorem chooseWf_not_mem_deny [IsWellOrder Î± r] {deny : Î± â†’ Set Î²}\n    {h : âˆ€ x, #{ y // r y x } + #(deny x) < #Î²} (x : Î±) : chooseWf deny h x âˆ‰ deny x :=\n  fun h' => chooseWf_spec x (mem_union_right _ h')\n", "additional_info": "", "used_premises": [15, 69, 29, 29, 29, 369], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [86, 89], "informalization": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x âˆ‰ deny x`."}
{"full_name": "ConNF.chooseWf_ne_of_r", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf_ne_of_r", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWf_ne_of_r {Î± : Type u} {Î² : Type u} {r : Î± â†’ Î± â†’ Prop } [_inst : IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± r] {deny : Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î²} {h : âˆ€ (x : Î±), Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { y : Î± // r y x } + Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(deny x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²} (xâ‚ : Î±) (xâ‚‚ : Î±) (hx : r xâ‚ xâ‚‚) :ConNF.chooseWfğŸ”—<|PREMISE|>ğŸ”— deny h xâ‚ â‰  ConNF.chooseWfğŸ”—<|PREMISE|>ğŸ”— deny h xâ‚‚", "code": "theorem chooseWf_ne_of_r [_inst : IsWellOrder Î± r] {deny : Î± â†’ Set Î²}\n    {h : âˆ€ x, #{ y // r y x } + #(deny x) < #Î²} (xâ‚ xâ‚‚ : Î±) (hx : r xâ‚ xâ‚‚) :\n    chooseWf deny h xâ‚ â‰  chooseWf deny h xâ‚‚ := fun hx' =>\n  not_mem_subset (subset_union_left _ _) (chooseWf_spec xâ‚‚) âŸ¨xâ‚, hx, hx'âŸ©\n", "additional_info": "", "used_premises": [15, 69, 29, 29, 29, 369, 369], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [90, 94], "informalization": "Function `ConNF.chooseWf_ne_of_r` is a proof that for any two elements `xâ‚` and `xâ‚‚` of a well-ordered type `Î±`, if `r xâ‚ xâ‚‚` (meaning `xâ‚` is less than `xâ‚‚` under the well-order `r`), then `ConNF.chooseWf deny h xâ‚` (which is an injective function `f` such that `f x âˆ‰ deny x`, where `deny` is a function that maps `Î±` to sets of `Î²` elements and `h` is a condition on the cardinality of the sets `{y : Î± // r y x}` and `deny x`) is not equal to `ConNF.chooseWf deny h xâ‚‚`. This result is crucial for showing that Conant's N-free construction can be applied to any well-ordered set."}
{"full_name": "ConNF.chooseWf_injective", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWf_injective {Î± : Type u} {Î² : Type u} {r : Î± â†’ Î± â†’ Prop } [inst : IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± r] {deny : Î± â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î²} {h : âˆ€ (x : Î±), Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { y : Î± // r y x } + Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(deny x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î²} :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.chooseWfğŸ”—<|PREMISE|>ğŸ”— deny h)", "code": "theorem chooseWf_injective [inst : IsWellOrder Î± r] {deny : Î± â†’ Set Î²}\n    {h : âˆ€ x, #{ y // r y x } + #(deny x) < #Î²} : Injective (chooseWf deny h) := by\n  intro xâ‚ xâ‚‚ h\n  obtain hx | hx | hx := @lt_trichotomy _ (IsWellOrder.linearOrder r) xâ‚ xâ‚‚\n  Â· cases chooseWf_ne_of_r (_inst := inst) xâ‚ xâ‚‚ hx h\n  Â· exact hx\n  Â· cases chooseWf_ne_of_r (_inst := inst) xâ‚‚ xâ‚ hx h.symm\n", "additional_info": "", "used_premises": [15, 69, 29, 29, 29, 89, 369], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [95, 102], "informalization": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x âˆ‰ deny x`. The theorem `ConNF.chooseWf_injective` proves that this function is indeed injective."}
{"full_name": "ConNF.mk_invImage_lt", "url": "ConNF/Fuzz/Construction.html#ConNF.mk_invImage_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_invImage_lt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] (t : ConNF.Tangle Î²) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { t' : ConNF.Tangle Î² // t' < t } < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_invImage_lt (t : Tangle Î²) : #{ t' // t' < t } < #Î¼ := by\n  refine lt_of_le_of_lt ?_ (show #{ Î½ // Î½ < pos t } < #Î¼ from card_Iio_lt _)\n  refine âŸ¨âŸ¨fun t' => âŸ¨_, t'.propâŸ©, ?_âŸ©âŸ©\n  intro yâ‚ yâ‚‚ h\n  simp only [Subtype.mk.injEq, EmbeddingLike.apply_eq_iff_eq, Subtype.coe_inj] at h\n  exact h\n", "additional_info": "", "used_premises": [1, 39, 72, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [123, 129], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_invImage_lt` asserts that for any tangle `t` at level `Î²`, the cardinality of the set of all tangles less than `t` is strictly less than the cardinality of the type `Î¼`. This result is crucial for establishing the well-foundedness of the `<` relation on tangles within the ConNF framework."}
{"full_name": "ConNF.mk_invImage_le", "url": "ConNF/Fuzz/Construction.html#ConNF.mk_invImage_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_invImage_le [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Î³ : ConNF.Î›) [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (t : ConNF.Tangle Î²) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { t' : ConNF.Tangle â†‘Î³ // ConNF.pos t' â‰¤ ConNF.pos t } < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_invImage_le (t : Tangle Î²) : #{ t' : Tangle Î³ // pos t' â‰¤ pos t } < #Î¼ := by\n  refine lt_of_le_of_lt ?_ (show #{ Î½ // Î½ â‰¤ pos t } < #Î¼ from card_Iic_lt _)\n  refine âŸ¨âŸ¨fun t' => âŸ¨_, t'.propâŸ©, ?_âŸ©âŸ©\n  intro yâ‚ yâ‚‚ h\n  simp only [Subtype.mk.injEq, EmbeddingLike.apply_eq_iff_eq, Subtype.coe_inj] at h\n  exact h\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [130, 136], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_invImage_le` asserts that the cardinality of the set of tangles `t'` at level `Î³` such that the position of `t'` is less than or equal to the position of a given tangle `t` at level `Î²`, is strictly less than the cardinality of the type `Î¼`. This result is crucial for establishing the well-foundedness of the ConNF hierarchy."}
{"full_name": "ConNF.mk_fuzzDeny", "url": "ConNF/Fuzz/Construction.html#ConNF.mk_fuzzDeny", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_fuzzDeny [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] (t : ConNF.Tangle Î²) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { t' : ConNF.Tangle Î² // t' < t } + Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.fuzzDenyğŸ”—<|PREMISE|>ğŸ”— Î³ t) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_fuzzDeny (t : Tangle Î²) :\n    #{ t' // t' < t } + #(fuzzDeny Î³ t) < #Î¼ := by\n  refine add_lt_of_lt Params.Î¼_isStrongLimit.isLimit.aleph0_le (mk_invImage_lt t) ?_\n  refine lt_of_le_of_lt (mk_union_le _ _) ?_\n  refine add_lt_of_lt Params.Î¼_isStrongLimit.isLimit.aleph0_le ?_ ?_\n  Â· refine lt_of_le_of_lt ?_ (mk_invImage_le Î³ t)\n    refine âŸ¨âŸ¨fun i => âŸ¨typedNearLitter i.prop.choose, i.prop.choose_spec.1âŸ©, ?_âŸ©âŸ©\n    intro Î½â‚ Î½â‚‚ h\n    have h' := typedNearLitter.injective (Subtype.coe_inj.mpr h)\n    have := Î½â‚.2.choose_spec.2\n    rw [h', â† Î½â‚‚.2.choose_spec.2] at this\n    exact Subtype.coe_inj.mp this\n  Â· have : #{ a : Atom | pos a â‰¤ pos t } < #Î¼\n    Â· refine lt_of_le_of_lt ?_ (card_Iic_lt (pos t))\n      refine âŸ¨âŸ¨fun a => âŸ¨pos a.1, a.2âŸ©, ?_âŸ©âŸ©\n      intro a b h\n      exact Subtype.coe_inj.mp (pos_injective (Subtype.coe_inj.mpr h))\n    refine lt_of_le_of_lt ?_ this\n    refine mk_le_of_surjective (f := fun a => âŸ¨_, a.1, a.2, rflâŸ©) ?_\n    rintro âŸ¨_, a, ha, rflâŸ©\n    exact âŸ¨âŸ¨a, haâŸ©, rflâŸ©\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 29, 29, 376, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [139, 160], "informalization": "Function `ConNF.fuzzDeny` defines a set of elements of type `ConNF.Î¼` that the function `ConNF.fuzz` cannot assign to a given tangle `t` of type `ConNF.Tangle Î²` in the context of Constructive Ordinal Notation (ConNF). This set is the union of two subsets: one for near-litters and one for atoms. The theorem `ConNF.mk_fuzzDeny` asserts that the sum of the cardinality of the set of tangles less than `t` and the cardinality of the set `ConNF.fuzzDeny Î³ t` is less than the cardinality of `ConNF.Î¼`."}
{"full_name": "ConNF.fuzzDeny", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzzDeny", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.fuzzDeny [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Î³ : ConNF.Î›) [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] (t : ConNF.Tangle Î²) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "def fuzzDeny (t : Tangle Î²) : Set Î¼ :=\n  { Î½ : Î¼ | âˆƒ (N : NearLitter), pos (typedNearLitter N : Tangle Î³) â‰¤ pos t âˆ§ Î½ = N.1.1 } âˆª\n  { Î½ : Î¼ | âˆƒ (a : Atom), pos a â‰¤ pos t âˆ§ Î½ = a.1.1 }\n", "additional_info": "The set of elements of `Î½` that `ğŸ—ŸfuzzğŸ—ŸğŸ”—../.././ConNF/Fuzz/Construction.html#ConNF.fuzzğŸ”—  _ t` cannot be.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 39, 72, 39, 72, 73, 69], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [119, 122], "informalization": "Function `ConNF.fuzzDeny` defines a set of elements of type `ConNF.Î¼` that the function `ConNF.fuzz` cannot assign to a given tangle `t` of type `ConNF.Tangle Î²` in the context of Constructive Ordinal Notation (ConNF). This set is the union of two subsets: one for near-litters and one for atoms."}
{"full_name": "ConNF.fuzz_Î²", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_Î²", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.fuzz_Î² [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] (hÎ²Î³ : Î² â‰  â†‘Î³) (t : ConNF.Tangle Î²) :(ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³ t).Î² = Î²", "code": "theorem fuzz_Î² (t : Tangle Î²) : (fuzz hÎ²Î³ t).Î² = Î² :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [186, 188], "informalization": "Function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `Î²` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `Î²`, a `Î›` object `Î³`, and a proof that `Î²` is not equal to `Î³`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny Î³`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `Î²` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `Î²`, the `Î›` object `Î³`, and the proof that `Î²` is not equal to `Î³`."}
{"full_name": "ConNF.fuzz_Î³", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_Î³", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.fuzz_Î³ [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] (hÎ²Î³ : Î² â‰  â†‘Î³) (t : ConNF.Tangle Î²) :(ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³ t).Î³ = Î³", "code": "theorem fuzz_Î³ (t : Tangle Î²) : (fuzz hÎ²Î³ t).Î³ = Î³ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [190, 192], "informalization": "Function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `Î²` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `Î²`, a `Î›` object `Î³`, and a proof that `Î²` is not equal to `Î³`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny Î³`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `Î²` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `Î²`, the `Î›` object `Î³`, and the proof that `Î²` is not equal to `Î³`."}
{"full_name": "ConNF.fuzz_congr_Î²", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_congr_Î²", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.fuzz_congr_Î² [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] {Î²' : ConNF.TypeIndex} {Î³' : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²'] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²'] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³'] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³'] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³'] {hÎ²Î³ : Î² â‰  â†‘Î³} {hÎ²Î³' : Î²' â‰  â†‘Î³'} {t : ConNF.Tangle Î²} {t' : ConNF.Tangle Î²'} (h : ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³ t = ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³' t') :Î² = Î²'", "code": "lemma fuzz_congr_Î² {hÎ²Î³ : (Î² : TypeIndex) â‰  Î³} {hÎ²Î³' : (Î²' : TypeIndex) â‰  Î³'}\n  {t : Tangle Î²} {t' : Tangle Î²'} (h : fuzz hÎ²Î³ t = fuzz hÎ²Î³' t') :\n  Î² = Î²' := by\n  have hâ‚ := fuzz_Î² hÎ²Î³ t\n  have hâ‚‚ := fuzz_Î² hÎ²Î³' t'\n  rw [â† h, hâ‚] at hâ‚‚\n  exact hâ‚‚\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 39, 72, 39, 72, 73, 78, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [198, 205], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.fuzz_congr_Î²` asserts that for any two tangles `t` and `t'` of types `Î²` and `Î²'` respectively, if the `fuzz` function applied to `t` and `t'` yields the same `Litter` object, then `Î²` must be equal to `Î²'`."}
{"full_name": "ConNF.fuzz_congr_Î³", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_congr_Î³", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.fuzz_congr_Î³ [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] {Î²' : ConNF.TypeIndex} {Î³' : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²'] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²'] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³'] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³'] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³'] {hÎ²Î³ : Î² â‰  â†‘Î³} {hÎ²Î³' : Î²' â‰  â†‘Î³'} {t : ConNF.Tangle Î²} {t' : ConNF.Tangle Î²'} (h : ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³ t = ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³' t') :Î³ = Î³'", "code": "lemma fuzz_congr_Î³ {hÎ²Î³ : (Î² : TypeIndex) â‰  Î³} {hÎ²Î³' : (Î²' : TypeIndex) â‰  Î³'}\n  {t : Tangle Î²} {t' : Tangle Î²'} (h : fuzz hÎ²Î³ t = fuzz hÎ²Î³' t') :\n  Î³ = Î³' := by\n  have hâ‚ := fuzz_Î³ hÎ²Î³ t\n  have hâ‚‚ := fuzz_Î³ hÎ²Î³' t'\n  rw [â† h, hâ‚] at hâ‚‚\n  exact hâ‚‚\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 39, 72, 39, 72, 73, 78, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [206, 213], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.fuzz_congr_Î³` asserts that for any two tangles `t` and `t'` of types `Î²` and `Î²'` respectively, if the `fuzz` function outputs the same `Litter` object for both tangles, then the type indices `Î³` and `Î³'` must be equal."}
{"full_name": "ConNF.fuzz_injective", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.fuzz_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] (hÎ²Î³ : Î² â‰  â†‘Î³) :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³)", "code": "theorem fuzz_injective : Injective (fuzz hÎ²Î³) := by\n  intro tâ‚ tâ‚‚ h\n  simp only [fuzz, Litter.mk.injEq, chooseWf_injective.eq_iff, and_self, and_true] at h\n  exact h\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 89, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [216, 220], "informalization": "The function `ConNF.fuzz_injective` is a theorem in the Constructive Ordinal Notation (ConNF) context in Lean 4. It claims that the function `ConNF.fuzz` is injective. This function `ConNF.fuzz` takes a tangle `t` of type `Î²` and returns a `Litter` object, which is defined as a 4-tuple consisting of a `Wf` object, a type index `Î²`, a `Î›` object `Î³`, and a proof that `Î²` is not equal to `Î³`. The `Litter` object is constructed using a chosen `Wf` object, the type index `Î²`, the `Î›` object `Î³`, and the proof that `Î²` is not equal to `Î³`. The theorem `ConNF.fuzz_injective` asserts that for any `Î²` and `Î³` of different types, the `ConNF.fuzz` function is injective, meaning that if it maps two different tangles to the same `Litter`, then those tangles must be identical."}
{"full_name": "ConNF.fuzz_not_mem_deny", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_not_mem_deny", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.fuzz_not_mem_deny [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] (hÎ²Î³ : Î² â‰  â†‘Î³) (t : ConNF.Tangle Î²) :(ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³ t).Î½ âˆ‰ ConNF.fuzzDenyğŸ”—<|PREMISE|>ğŸ”— Î³ t", "code": "theorem fuzz_not_mem_deny (t : Tangle Î²) : (fuzz hÎ²Î³ t).Î½ âˆ‰ fuzzDeny Î³ t :=\n  chooseWf_not_mem_deny t\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 78, 376], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [221, 223], "informalization": "Function `ConNF.fuzz` in the context of Constructive Ordinal Notation (ConNF) in Lean 4 takes as input a tangle `t` of type `Î²` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `Î²`, a `Î›` object `Î³`, and a proof that `Î²` is not equal to `Î³`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny Î³`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `Î²` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `Î²`, the `Î›` object `Î³`, and the proof that `Î²` is not equal to `Î³`. The theorem `ConNF.fuzz_not_mem_deny` states that the position `Î½` of the `Litter` object returned by `ConNF.fuzz` does not belong to the set `ConNF.fuzzDeny Î³ t`, which is the union of two subsets: one for near-litters and one for atoms."}
{"full_name": "ConNF.pos_lt_pos_fuzz", "url": "ConNF/Fuzz/Construction.html#ConNF.pos_lt_pos_fuzz", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pos_lt_pos_fuzz [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.PositionedTanglesğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] [ConNF.TypedObjectsğŸ”—<|PREMISE|>ğŸ”— Î³] (hÎ²Î³ : Î² â‰  â†‘Î³) (t : ConNF.Tangle Î²) (a : ConNF.Atom) (ha : a.1 = ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”— hÎ²Î³ t) :ConNF.pos t < ConNF.pos a", "code": "theorem pos_lt_pos_fuzz (t : Tangle Î²) (a : Atom) (ha : a.1 = fuzz hÎ²Î³ t) :\n    pos t < pos a := by\n  have h' := fuzz_not_mem_deny hÎ²Î³ t\n  contrapose! h'\n  refine Or.inr âŸ¨a, h', ?_âŸ©\n  rw [ha]\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [231, 237], "informalization": "The `ConNF.fuzz` function is a noncomputable function that takes a tangle `t` of type `Î²` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `Î²`, a `Î›` object `Î³`, and a proof that `Î²` is not equal to `Î³`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny Î³`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `Î²` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `Î²`, the `Î›` object `Î³`, and the proof that `Î²` is not equal to `Î³`. The theorem `ConNF.pos_lt_pos_fuzz` proves that for any tangle `t` of type `Î²` and any atom `a` such that `a.1 = fuzz hÎ²Î³ t`, the position of `t` is less than the position of `a`."}
{"full_name": "ConNF.Allowable.toStructPerm_smul", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.toStructPerm_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.toStructPerm_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î±) X] (Ï : ConNF.Allowable Î±) (x : X) :Ï â€¢ x = ConNF.Allowable.toStructPerm Ï â€¢ x", "code": "theorem toStructPerm_smul (Ï : Allowable Î±) (x : X) : Ï â€¢ x = Allowable.toStructPerm Ï â€¢ x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 56, 55], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [66, 68], "informalization": "The theorem `ConNF.Allowable.toStructPerm_smul` states that for any allowable permutation `Ï` on a proper type index `Î±`, the action of `Ï` on an element `x` of a type `X` that has a multiplicative action by the structural permutations at level `Î±` is equivalent to the action of the structural permutation `ConNF.Allowable.toStructPerm Ï` on `x`."}
{"full_name": "ConNF.Allowable.smul_support_max", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_support_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.smul_support_max [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] (Ï : ConNF.Allowable Î±) (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ S) = ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”— S", "code": "theorem smul_support_max (Ï : Allowable Î±) (S : Support Î±) :\n    (Ï â€¢ S).max = S.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 58, 338, 338], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [70, 73], "informalization": "The `ConNF.Allowable.smul_support_max` theorem states that for any allowable permutation `Ï` at level `Î±`, the maximum element of the support of `Ï` acting on a support `S` is equal to the maximum element of `S`. This theorem is used in the context of Constructive Ordinal Notation (ConNF), which is a form of ordinal notation based on a combinatorial game. The theorem is a fundamental property of the support of allowable permutations in the ConNF model."}
{"full_name": "ConNF.Allowable.smul_support_f", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_support_f", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.smul_support_f [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] (Ï : ConNF.Allowable Î±) (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±) (i : ConNF.Îº) (hi : i < ConNF.Support.maxğŸ”—<|PREMISE|>ğŸ”— S) :ConNF.Support.fğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ S) i hi = Ï â€¢ ConNF.Support.fğŸ”—<|PREMISE|>ğŸ”— S i hi", "code": "theorem smul_support_f (Ï : Allowable Î±) (S : Support Î±) (i : Îº) (hi : i < S.max) :\n    (Ï â€¢ S).f i hi = Ï â€¢ S.f i hi :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 58, 338, 339, 339], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [75, 78], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Allowable.smul_support_f` states that for any allowable permutation `Ï` at level `Î±`, and any `ConNF.Support` structure `S` at level `Î±`, the function `ConNF.Support.f` applied to `Ï â€¢ S`, `i`, and `hi` (where `i` is less than the maximum element of `S`) is equal to `Ï` applied to `ConNF.Support.f` applied to `S`, `i`, and `hi`."}
{"full_name": "ConNF.Allowable.smul_mem_smul_support", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_mem_smul_support", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.smul_mem_smul_support [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} (h : c âˆˆ S) (Ï : ConNF.Allowable Î±) :Ï â€¢ c âˆˆ Ï â€¢ S", "code": "theorem smul_mem_smul_support {S : Support Î±} {c : Address Î±}\n    (h : c âˆˆ S) (Ï : Allowable Î±) : Ï â€¢ c âˆˆ Ï â€¢ S :=\n  Support.smul_mem_smul h _\n", "additional_info": "", "used_premises": [1, 39, 58, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [89, 92], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Allowable.smul_mem_smul_support` asserts that if an address `c` is a member of a support `S`, and `Ï` is an allowable permutation, then the image of `c` under `Ï` (denoted as `Ï â€¢ c`) is also a member of the image of `S` under `Ï` (denoted as `Ï â€¢ S`)."}
{"full_name": "ConNF.Allowable.smul_eq_of_smul_support_eq", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_eq_of_smul_support_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.smul_eq_of_smul_support_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï : ConNF.Allowable Î±} (hS : Ï â€¢ S = S) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} (hc : c âˆˆ S) :Ï â€¢ c = c", "code": "theorem smul_eq_of_smul_support_eq {S : Support Î±} {Ï : Allowable Î±}\n    (hS : Ï â€¢ S = S) {c : Address Î±} (hc : c âˆˆ S) : Ï â€¢ c = c :=\n  Support.smul_eq_of_smul_eq hS hc\n", "additional_info": "", "used_premises": [1, 39, 58, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [93, 96], "informalization": "The theorem `ConNF.Allowable.smul_eq_of_smul_support_eq` asserts that if a support `S` is invariant under the action of an allowable permutation `Ï` (i.e., `Ï â€¢ S = S`), then for any address `c` in this support, the action of `Ï` on `c` leaves `c` unchanged (i.e., `Ï â€¢ c = c`). This theorem is crucial in establishing the correctness of the construction of natural numbers in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Allowable.support_isCompletion_smul", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.support_isCompletion_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.support_isCompletion_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {E : ConNF.EnumerationğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±)} (h : ConNF.Support.IsCompletionğŸ”—<|PREMISE|>ğŸ”— S E) (Ï : ConNF.Allowable Î±) :ConNF.Support.IsCompletionğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ S) (Ï â€¢ E)", "code": "theorem support_isCompletion_smul {S : Support Î±} {E : Enumeration (Address Î±)}\n    (h : S.IsCompletion E) (Ï : Allowable Î±) :\n    (Ï â€¢ S).IsCompletion (Ï â€¢ E) :=\n  h.smul _\n", "additional_info": "", "used_premises": [1, 39, 58, 59, 60, 349, 349], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [97, 101], "informalization": "The theorem `ConNF.Allowable.support_isCompletion_smul` states that if `S` is a completion of an enumeration of addresses `E`, and `Ï` is an allowable permutation, then `Ï â€¢ S` is a completion of the enumeration `Ï â€¢ E`."}
{"full_name": "ConNF.Allowable.support_isSum_smul", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.support_isSum_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.support_isSum_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {Sâ‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} {Sâ‚‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±} (h : ConNF.Support.IsSumğŸ”—<|PREMISE|>ğŸ”— S Sâ‚ Sâ‚‚) (Ï : ConNF.Allowable Î±) :ConNF.Support.IsSumğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ S) (Ï â€¢ Sâ‚) (Ï â€¢ Sâ‚‚)", "code": "theorem support_isSum_smul {S Sâ‚ Sâ‚‚ : Support Î±} (h : S.IsSum Sâ‚ Sâ‚‚) (Ï : Allowable Î±) :\n    (Ï â€¢ S).IsSum (Ï â€¢ Sâ‚) (Ï â€¢ Sâ‚‚) :=\n  h.smul _\n", "additional_info": "", "used_premises": [1, 39, 58, 58, 58, 361, 361], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [102, 105], "informalization": "The theorem `ConNF.Allowable.support_isSum_smul` states that if `S`, `Sâ‚`, and `Sâ‚‚` are `ConNF.Support` objects such that `S` is the sum of `Sâ‚` and `Sâ‚‚`, and `Ï` is an allowable permutation, then `Ï â€¢ S` is the sum of `Ï â€¢ Sâ‚` and `Ï â€¢ Sâ‚‚`."}
{"full_name": "ConNF.Allowable.smul_address", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_address", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.smul_address [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] {Ï : ConNF.Allowable Î±} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï â€¢ c = { path := c.path, value := ConNF.Allowable.toStructPerm Ï c.path â€¢ c.value }", "code": "theorem smul_address :\n    Ï â€¢ c = âŸ¨c.path, Allowable.toStructPerm Ï c.path â€¢ c.valueâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [108, 111], "informalization": "Function `ConNF.Allowable.smul_address` defines the action of an allowable permutation on an address in the context of Constructive Ordinal Notation (ConNF). Given an allowable permutation `Ï` at level `Î±` and an address `c` at level `Î±`, the result of the action `Ï â€¢ c` is a new address with the same path as `c` but with the value component transformed by the action of `Ï` on the path of `c`."}
{"full_name": "ConNF.Allowable.smul_address_eq_iff", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_address_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.smul_address_eq_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] {Ï : ConNF.Allowable Î±} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï â€¢ c = c â†” ConNF.Allowable.toStructPerm Ï c.path â€¢ c.value = c.value", "code": "theorem smul_address_eq_iff :\n    Ï â€¢ c = c â†” Allowable.toStructPerm Ï c.path â€¢ c.value = c.value :=\n  StructPerm.smul_address_eq_iff\n", "additional_info": "", "used_premises": [1, 39, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [113, 116], "informalization": "The theorem `ConNF.Allowable.smul_address_eq_iff` states that for an allowable permutation `Ï` acting on an address `c` in the context of Constructive Ordinal Notation (ConNF), the action of `Ï` on `c` results in the same address `c` if and only if the action of `Ï` on the path component of `c` results in the same value component of `c`."}
{"full_name": "ConNF.Allowable.smul_address_eq_smul_iff", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_address_eq_smul_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.smul_address_eq_smul_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] {Ï : ConNF.Allowable Î±} {Ï' : ConNF.Allowable Î±} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï â€¢ c = Ï' â€¢ c â†” ConNF.Allowable.toStructPerm Ï c.path â€¢ c.value = ConNF.Allowable.toStructPerm Ï' c.path â€¢ c.value", "code": "theorem smul_address_eq_smul_iff :\n    Ï â€¢ c = Ï' â€¢ c â†”\n    Allowable.toStructPerm Ï c.path â€¢ c.value = Allowable.toStructPerm Ï' c.path â€¢ c.value :=\n  StructPerm.smul_address_eq_smul_iff\n", "additional_info": "", "used_premises": [1, 39, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [118, 122], "informalization": "The theorem `ConNF.Allowable.smul_address_eq_smul_iff` states that for any two allowable permutations `Ï` and `Ï'` at level `Î±`, and any address `c` at level `Î±`, the equation `Ï â€¢ c = Ï' â€¢ c` holds if and only if the equation `ConNF.Allowable.toStructPerm Ï c.path â€¢ c.value = ConNF.Allowable.toStructPerm Ï' c.path â€¢ c.value` holds."}
{"full_name": "ConNF.support_supports", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.support_supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.support_supports [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] (t : ConNF.Tangle Î±) :MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable Î±) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”— t).enum) t", "code": "theorem support_supports {Î± : TypeIndex} [TangleData Î±] (t : Tangle Î±) :\n    MulAction.Supports (Allowable Î±) (t.support : Set (Address Î±)) t :=\n  TangleData.support_supports t\n", "additional_info": "", "used_premises": [1, 39, 68, 70, 395], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [130, 133], "informalization": "The theorem `ConNF.support_supports` asserts that for any tangle `t` at level `Î±` in the context of Constructive Ordinal Notation (ConNF), the set of atoms in the small support of `t` supports `t` under the action of the allowable permutations at level `Î±`."}
{"full_name": "ConNF.TangleData.Tangle.support", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.TangleData.Tangle.support", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.TangleData.Tangle.support [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : ConNF.TypeIndex} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— Î±] (t : ConNF.Tangle Î±) :ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def TangleData.Tangle.support {Î± : TypeIndex} [TangleData Î±] (t : Tangle Î±) : Support Î± :=\n  TangleData.support t\n", "additional_info": "For each tangle, we provide a small support for it. This is known as the designated support of\nthe tangle.\nEquations\n* ğŸ—ŸConNF.TangleData.Tangle.supportğŸ—ŸğŸ”—../.././ConNF/Fuzz/Hypotheses.html#ConNF.TangleData.Tangle.supportğŸ”—  t ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.TangleData.supportğŸ—ŸğŸ”—../.././ConNF/Fuzz/Hypotheses.html#ConNF.TangleData.supportğŸ”—  t\n\n", "used_premises": [1, 39, 58], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [127, 129], "informalization": "Function `ConNF.TangleData.Tangle.support` provides a small support for each tangle in the context of Constructive Ordinal Notation (ConNF). This designated support ensures that for any two near-litters `Nâ‚` and `Nâ‚‚` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "NearLitterPerm.ofBot_smul", "url": "ConNF/Fuzz/Hypotheses.html#NearLitterPerm.ofBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem NearLitterPerm.ofBot_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— ConNF.NearLitterPerm X] (Ï€ : ConNF.Allowable âŠ¥ ) (x : X) :NearLitterPerm.ofBot Ï€ â€¢ x = Ï€ â€¢ x", "code": "theorem NearLitterPerm.ofBot_smul {X : Type _} [MulAction NearLitterPerm X]\n    (Ï€ : Allowable âŠ¥) (x : X) :\n    NearLitterPerm.ofBot Ï€ â€¢ x = Ï€ â€¢ x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 56], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [205, 209], "informalization": "The theorem `NearLitterPerm.ofBot_smul` states that in the context of Constructive Ordinal Notation (ConNF), for any allowable finite sequence of litters `Ï€` at the bottom level (represented by `âŠ¥`), the action of the corresponding near-litter permutation `NearLitterPerm.ofBot Ï€` on an element `x` of a type `X` that is equipped with a multiplicative action of `ConNF.NearLitterPerm` is equivalent to the action of `Ï€` on `x`. This is a simplification statement that helps in understanding the relationship between the bottom-level allowable finite sequences and their corresponding near-litter permutations within the ConNF framework."}
{"full_name": "ConNF.pos_lt_pos", "url": "ConNF/Fuzz/Position.html#ConNF.pos_lt_pos", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pos_lt_pos {Î± : Type u_2} {Î² : Type u_1} [ConNF.PositionğŸ”—<|PREMISE|>ğŸ”— Î± Î²] [LTğŸ”—<|PREMISE|>ğŸ”— Î²] (c : Î±) (d : Î±) :ConNF.pos c < ConNF.pos d â†” c < d", "code": "theorem pos_lt_pos [LT Î²] (c d : Î±) :\n    pos c < pos d â†” c < d :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [398, 6], "def_path": "ConNF/Fuzz/Position.lean", "pos": [19, 22], "informalization": "Class `ConNF.Position Î± Î²` represents an injective function from `Î±` to `Î²`, which can be thought of as a way to \"position\" elements of `Î±` within a larger type `Î²`. Given two elements `c` and `d` of `Î±`, the theorem `ConNF.pos_lt_pos` states that `ConNF.pos c < ConNF.pos d` if and only if `c < d`."}
{"full_name": "ConNF.Position", "url": "ConNF/Fuzz/Position.html#ConNF.Position", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.Position (Î± : Type u_1) (Î² : outParamğŸ”—<|PREMISE|>ğŸ”— (Type u_2)) :Type (max u_1 u_2)\n | pos : Î± â†ª  Î²", "code": "class Position (Î± : Type _) (Î² : outParam <| Type _) where\n  pos : Î± â†ª Î²\n", "additional_info": "", "used_premises": [399], "def_path": "ConNF/Fuzz/Position.lean", "pos": [5, 7], "informalization": "Class `Position Î± Î²` represents an injective function from `Î±` to `Î²`, which can be thought of as a way to \"position\" elements of `Î±` within a larger type `Î²`."}
{"full_name": "outParam", "url": "Init/Prelude.html#outParam", "code_src": "lean4", "ptype": "def", "header": "@[reducible]def outParam (Î± : Sort u) :Sort u", "code": "@[reducible] def outParam (Î± : Sort u) : Sort u := Î±\n", "additional_info": "Gadget for marking output parameters in type classes.\nFor example, the `ğŸ—ŸMembershipğŸ—ŸğŸ”—.././Init/Prelude.html#MembershipğŸ”—`  class is defined as:\nclass ğŸ—ŸMembershipğŸ—ŸğŸ”—.././Init/Prelude.html#MembershipğŸ”—  (Î± : ğŸ—ŸoutParamğŸ—ŸğŸ”—.././Init/Prelude.html#outParamğŸ”—  (Type u)) (Î³ : Type v)\n\nThis means that whenever a typeclass goal of the form `ğŸ—ŸMembershipğŸ—ŸğŸ”—.././Init/Prelude.html#MembershipğŸ”—  ?Î± ?Î³` comes\nup, Lean will wait to solve it until `?Î³` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?Î±`,\nwhich thereby determines what `?Î±` should be.\nThis expresses that in a term like `a âˆˆ s`, `s` might be a `Set Î±` or\n`ğŸ—ŸListğŸ—ŸğŸ”—.././Init/Prelude.html#ListğŸ”—  Î±` or some other type with a membership operation, and in each case\nthe \"member\" type `Î±` is determined by looking at the container type.\nEquations\n* ğŸ—ŸoutParamğŸ—ŸğŸ”—.././Init/Prelude.html#outParamğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—.././Init/Prelude.html#EqğŸ”—  Î±\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [612, 613], "informalization": "Function `outParam` is a utility in Lean 4 for marking parameters in type classes as output-oriented, influencing the order of argument processing and ensuring these parameters are determined based on the values of other parameters."}
{"full_name": "ConNF.isWellOrder_invImage", "url": "ConNF/Fuzz/Position.html#ConNF.isWellOrder_invImage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isWellOrder_invImage {Î± : Type u_2} {Î² : Type u_1} {r : Î² â†’ Î² â†’ Prop } (h : IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î² r) (f : Î± â†’ Î²) (hf : Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— f) :IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± (InvImageğŸ”—<|PREMISE|>ğŸ”— r f)", "code": "theorem isWellOrder_invImage {r : Î² â†’ Î² â†’ Prop} (h : IsWellOrder Î² r)\n    (f : Î± â†’ Î²) (hf : Function.Injective f) :\n    IsWellOrder Î± (InvImage r f) where\n  trichotomous := by\n    intro x y\n    have := h.trichotomous (f x) (f y)\n    rw [hf.eq_iff] at this\n    exact this\n  trans x y z := h.trans (f x) (f y) (f z)\n  wf := InvImage.wf _ h.wf\n", "additional_info": "", "used_premises": [15, 89, 15, 96], "def_path": "ConNF/Fuzz/Position.lean", "pos": [23, 33], "informalization": "If `r` is a well order on `Î²` and `f` is an injective function from `Î±` to `Î²`, then the inverse image of `r` under `f` is a well order on `Î±`."}
{"full_name": "ConNF.CodingFunction.mem_iff", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.mem_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï‡ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :S âˆˆ Ï‡ â†” (Ï‡.decode S).Dom", "code": "theorem mem_iff {Ï‡ : CodingFunction Î²} {S : Support Î²} :\n    S âˆˆ Ï‡ â†” (Ï‡.decode S).Dom :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 402, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [30, 33], "informalization": "The theorem `ConNF.CodingFunction.mem_iff` in the context of Constructive Ordinal Notation (ConNF) states that for a given coding function `Ï‡` at type level `Î²` and a support `S`, the support `S` is an element of the coding function `Ï‡` if and only if the decoding of `S` by `Ï‡` is defined. This is a fundamental property of the relationship between supports and coding functions in ConNF."}
{"full_name": "ConNF.LeLevel", "url": "ConNF/Structural/Index.html#ConNF.LeLevel", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.LeLevel [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] (Î² : ConNF.TypeIndex) :Prop\n | elim : Î² â‰¤  â†‘ConNF.Î±", "code": "class LeLevel (Î² : TypeIndex) : Prop where\n  elim : Î² â‰¤ Î±\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Index.lean", "pos": [41, 43], "informalization": "Class `ConNF.LeLevel` represents the condition that a type index `Î²` is less than or equal to the type index `Î±` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.CodingFunction", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.CodingFunction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] (Î² : ConNF.Î›) [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] :Type u\n | decode : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†’.  ConNF.Tangle  â†‘Î²\n | dom_nonempty : Set.NonemptyğŸ”—<|PREMISE|>ğŸ”—  (PFun.DomğŸ”—<|PREMISE|>ğŸ”—  self.decode)\n | supports_decode' : âˆ€ (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) (hS : (self.decode S).Dom),\n MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Allowable  â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”—  S.enum) ((self.decode S).get hS)\n | dom_iff : âˆ€ (S T : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²), (self.decode S).Dom â†’ ((self.decode T).Dom â†”  âˆƒ (Ï : ConNF.Allowable  â†‘Î²), T =  Ï â€¢  S)\n | decode_smul' : âˆ€ (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) (Ï : ConNF.Allowable  â†‘Î²) (hâ‚ : (self.decode S).Dom) (hâ‚‚ : (self.decode (Ï â€¢  S)).Dom),\n (self.decode (Ï â€¢  S)).get hâ‚‚ =  Ï â€¢  (self.decode S).get hâ‚", "code": "structure CodingFunction (Î² : Î›) [LeLevel Î²] where\n  decode : Support Î² â†’. Tangle Î²\n  dom_nonempty : decode.Dom.Nonempty\n  supports_decode' (S : Support Î²) (hS : (decode S).Dom) :\n    Supports (Allowable Î²) (S : Set (Address Î²)) ((decode S).get hS)\n  dom_iff (S T : Support Î²) (hS : (decode S).Dom) :\n    (decode T).Dom â†” âˆƒ Ï : Allowable Î², T = Ï â€¢ S\n  decode_smul' (S : Support Î²) (Ï : Allowable Î²)\n    (hâ‚ : (decode S).Dom) (hâ‚‚ : (decode (Ï â€¢ S)).Dom) :\n    (decode (Ï â€¢ S)).get hâ‚‚ = Ï â€¢ (decode S).get hâ‚\n", "additional_info": "", "used_premises": [1, 402, 58, 83, 404, 58, 68, 70, 58, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [14, 24], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support Î²` to `Tangle Î²`, where `Î²` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable Î²` on `Support Î²`."}
{"full_name": "PFun.Dom", "url": "Mathlib/Data/PFun.html#PFun.Dom", "code_src": "mathlib4", "ptype": "def", "header": "def PFun.Dom {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’. Î²) :SetğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def Dom (f : Î± â†’. Î²) : Set Î± :=\n  { a | (f a).Dom }\n", "additional_info": "The domain of a partial function\nEquations\n* ğŸ—ŸPFun.DomğŸ—ŸğŸ”—../.././Mathlib/Data/PFun.html#PFun.DomğŸ”—  f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  {a : Î± | (f a).Dom}\n\n", "used_premises": [69], "def_path": "Mathlib/Data/PFun.lean", "pos": [74, 76], "informalization": "Function `PFun.Dom` defines the domain of a partial function, which is the set of elements for which the function is defined."}
{"full_name": "ConNF.CodingFunction.mem_iff_of_mem", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_iff_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.mem_iff_of_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï‡ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {T : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : S âˆˆ Ï‡) :T âˆˆ Ï‡ â†” âˆƒ (Ï : ConNF.Allowable â†‘Î²), T = Ï â€¢ S", "code": "theorem mem_iff_of_mem {Ï‡ : CodingFunction Î²} {S T : Support Î²} (h : S âˆˆ Ï‡) :\n    T âˆˆ Ï‡ â†” âˆƒ Ï : Allowable Î², T = Ï â€¢ S :=\n  Ï‡.dom_iff S T h\n", "additional_info": "", "used_premises": [1, 402, 403, 58, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [34, 37], "informalization": "Given a `CodingFunction` Ï‡ and two `Support`s S and T in the context of Constructive Ordinal Notation (ConNF), this theorem states that T is in the domain of Ï‡ if and only if there exists an `Allowable` Ï such that T is the image of S under the action of Ï. This theorem is crucial for proving the bijectivity of the coding function."}
{"full_name": "ConNF.CodingFunction.smul_mem", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.smul_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.smul_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï‡ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (Ï : ConNF.Allowable â†‘Î²) (h : S âˆˆ Ï‡) :Ï â€¢ S âˆˆ Ï‡", "code": "theorem smul_mem {Ï‡ : CodingFunction Î²} {S : Support Î²} (Ï : Allowable Î²) (h : S âˆˆ Ï‡) :\n    Ï â€¢ S âˆˆ Ï‡ :=\n  (Ï‡.mem_iff_of_mem h).mpr âŸ¨Ï, rflâŸ©\n", "additional_info": "", "used_premises": [1, 402, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [38, 41], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a type index `Î²` that is less than or equal to the type index `Î±`, a `CodingFunction` `Ï‡` with domain `S`, and an `Allowable` `Ï`, the theorem `smul_mem` ensures that the scaling of `S` by `Ï` results in another element within the domain of `Ï‡`. This property is crucial for establishing the correctness of the ConNF construction."}
{"full_name": "ConNF.CodingFunction.mem_of_smul_mem", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_of_smul_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.mem_of_smul_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï‡ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Ï : ConNF.Allowable â†‘Î²} (h : Ï â€¢ S âˆˆ Ï‡) :S âˆˆ Ï‡", "code": "theorem mem_of_smul_mem {Ï‡ : CodingFunction Î²} {S : Support Î²} {Ï : Allowable Î²}\n    (h : Ï â€¢ S âˆˆ Ï‡) : S âˆˆ Ï‡ :=\n  (Ï‡.mem_iff_of_mem h).mpr âŸ¨Ïâ»Â¹, by rw [inv_smul_smul]âŸ©\n", "additional_info": "", "used_premises": [1, 402, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [42, 45], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.mem_of_smul_mem` asserts that for any `CodingFunction` `Ï‡` at level `Î²`, if `Ï â€¢ S` (where `Ï` is an `Allowable` and `S` is a `Support`) is in the domain of `Ï‡`, then `S` itself must also be in the domain of `Ï‡`."}
{"full_name": "ConNF.CodingFunction.exists_mem", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.exists_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.exists_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (Ï‡ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²) :âˆƒ (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²), S âˆˆ Ï‡", "code": "theorem exists_mem (Ï‡ : CodingFunction Î²) :\n    âˆƒ S, S âˆˆ Ï‡ :=\n  Ï‡.dom_nonempty\n", "additional_info": "", "used_premises": [1, 402, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [46, 49], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support Î²` to `Tangle Î²`, where `Î²` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable Î²` on `Support Î²`. The theorem `ConNF.CodingFunction.exists_mem` states that for any `CodingFunction` `Ï‡`, there exists a `Support` `S` that is a member of `Ï‡`."}
{"full_name": "ConNF.CodingFunction.supports_decode", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.supports_decode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.supports_decode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï‡ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²} (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hS : S âˆˆ Ï‡) :MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) ((Ï‡.decode S).get hS)", "code": "theorem supports_decode {Ï‡ : CodingFunction Î²} (S : Support Î²) (hS : S âˆˆ Ï‡) :\n    Supports (Allowable Î²) (S : Set (Address Î²)) ((Ï‡.decode S).get hS) :=\n  Ï‡.supports_decode' S hS\n", "additional_info": "", "used_premises": [1, 402, 403, 58, 68, 70], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [50, 53], "informalization": "The `ConNF.CodingFunction.supports_decode` theorem states that for each `Î²` (a type index in the context of Constructive Ordinal Notation, ConNF) and for each `CodingFunction` `Ï‡` defined on `Î²`, if `S` is a `ConNF.Support` (a function from an initial segment of `Îº` to the type of addresses in ConNF), and if `S` is an element of `Ï‡`, then the action of `ConNF.Allowable â†‘Î²` (the set of allowable ordinals at level `Î²`) supports (`MulAction.Supports`) the `ConNF.Enumeration.carrier` (the set of elements `c` of type `Î±` that can be expressed as `S.enum.f i h` for some `i < S.enum.max`) of `S.enum` (an `Î±`-enumeration defined by `S`)."}
{"full_name": "ConNF.CodingFunction.ext", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.ext [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï‡â‚ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²} {Ï‡â‚‚ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²} (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : S âˆˆ Ï‡â‚) (hâ‚‚ : S âˆˆ Ï‡â‚‚) (h : (Ï‡â‚.decode S).get hâ‚ = (Ï‡â‚‚.decode S).get hâ‚‚) :Ï‡â‚ = Ï‡â‚‚", "code": "theorem ext {Ï‡â‚ Ï‡â‚‚ : CodingFunction Î²}\n    (S : Support Î²) (hâ‚ : S âˆˆ Ï‡â‚) (hâ‚‚ : S âˆˆ Ï‡â‚‚)\n    (h : (Ï‡â‚.decode S).get hâ‚ = (Ï‡â‚‚.decode S).get hâ‚‚) :\n    Ï‡â‚ = Ï‡â‚‚ := by\n  rw [mk.injEq]\n  funext T\n  refine Part.ext' ?_ ?_\n  Â· rw [â† mem_iff, mem_iff_of_mem hâ‚, â† mem_iff, mem_iff_of_mem hâ‚‚]\n  Â· intros hâ‚' hâ‚‚'\n    rw [â† mem_iff, mem_iff_of_mem hâ‚] at hâ‚'\n    obtain âŸ¨Ï, rflâŸ© := hâ‚'\n    rw [Ï‡â‚.decode_smul' S Ï hâ‚ hâ‚', Ï‡â‚‚.decode_smul' S Ï hâ‚‚ hâ‚‚', h]\n", "additional_info": "Two coding functions are equal if they decode a single ordered support to the same tangle.", "used_premises": [1, 402, 403, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [59, 71], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support Î²` to `Tangle Î²`, where `Î²` is a type index in the context of ConNF. This theorem states that two `CodingFunction`s are equal if they decode a single ordered support to the same tangle."}
{"full_name": "ConNF.CodingFunction.smul_supports", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.smul_supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.smul_supports [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {t : ConNF.Tangle â†‘Î²} (h : MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) t) (Ï : ConNF.Allowable â†‘Î²) :MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ S).enum) (Ï â€¢ t)", "code": "theorem smul_supports {S : Support Î²} {t : Tangle Î²}\n    (h : Supports (Allowable Î²) (S : Set (Address Î²)) t) (Ï : Allowable Î²) :\n    Supports (Allowable Î²) ((Ï â€¢ S : Support Î²) : Set (Address Î²)) (Ï â€¢ t) := by\n  intro Ï' hÏ'\n  have := h (Ïâ»Â¹ * Ï' * Ï) ?_\n  Â· rw [mul_assoc, mul_smul, inv_smul_eq_iff, mul_smul] at this\n    exact this\n  intros c hc\n  rw [mul_assoc, mul_smul, inv_smul_eq_iff, mul_smul]\n  refine hÏ' ?_\n  exact Enumeration.smul_mem_smul hc Ï\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 68, 70], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [72, 83], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.smul_supports` states that if a set `s` supports an element `b` under the action of a monoid `G`, and `Ï` is an element of `G`, then `Ï â€¢ s` also supports `Ï â€¢ b` under the same action."}
{"full_name": "ConNF.CodingFunction.decode_congr", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.decode_congr", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.decode_congr [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï‡ : ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²} {Sâ‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Sâ‚‚ : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {hâ‚ : Sâ‚ âˆˆ Ï‡} {hâ‚‚ : Sâ‚‚ âˆˆ Ï‡} (h : Sâ‚ = Sâ‚‚) :(Ï‡.decode Sâ‚).get hâ‚ = (Ï‡.decode Sâ‚‚).get hâ‚‚", "code": "theorem decode_congr {Ï‡ : CodingFunction Î²} {Sâ‚ Sâ‚‚ : Support Î²}\n    {hâ‚ : Sâ‚ âˆˆ Ï‡} {hâ‚‚ : Sâ‚‚ âˆˆ Ï‡} (h : Sâ‚ = Sâ‚‚) :\n    (Ï‡.decode Sâ‚).get hâ‚ = (Ï‡.decode Sâ‚‚).get hâ‚‚ := by\n  subst h\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 403, 58, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [84, 89], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support Î²` to `Tangle Î²`, where `Î²` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable Î²` on `Support Î²`. The theorem `ConNF.CodingFunction.decode_congr` states that for any two `CodingFunction`s `Ï‡` with supports `Sâ‚` and `Sâ‚‚`, if `Sâ‚` and `Sâ‚‚` are equal, then the decodings of `Sâ‚` and `Sâ‚‚` are also equal."}
{"full_name": "ConNF.CodingFunction.code_decode", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.code_decode", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.CodingFunction.code_decode [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (t : ConNF.Tangle â†‘Î²) (h : MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) t) :(ConNF.CodingFunction.codeğŸ”—<|PREMISE|>ğŸ”— S t h).decode S = Part.someğŸ”—<|PREMISE|>ğŸ”— t", "code": "theorem code_decode (S : Support Î²) (t : Tangle Î²)\n    (h : Supports (Allowable Î²) (S : Set (Address Î²)) t) :\n    (code S t h).decode S = Part.some t := by\n  refine Part.ext' ?_ ?_\n  Â· simp only [Allowable.toStructPerm_smul, Part.some_dom, iff_true]\n    refine âŸ¨1, ?_âŸ©\n    simp only [map_one, one_smul]\n  Â· intros h' _\n    refine h _ ?_\n    intros c hc\n    exact Allowable.smul_eq_of_smul_support_eq h'.choose_spec.symm hc\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 414, 415], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [120, 131], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.code_decode` states that for any ordered support `S` and tangle `t` that it supports, the decoding of the coding function `ConNF.CodingFunction.code S t h` with respect to `S` yields a partial value that is defined and equals `t`."}
{"full_name": "ConNF.CodingFunction.code", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.code", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.CodingFunction.code [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (t : ConNF.Tangle â†‘Î²) (h : MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) t) :ConNF.CodingFunctionğŸ”—<|PREMISE|>ğŸ”— Î²", "code": "noncomputable def code (S : Support Î²) (t : Tangle Î²)\n    (h : Supports (Allowable Î²) (S : Set (Address Î²)) t) :\n    CodingFunction Î² where\n  decode T := âŸ¨âˆƒ Ï : Allowable Î², T = Ï â€¢ S, fun hT => hT.choose â€¢ tâŸ©\n  dom_nonempty := âŸ¨S, 1, by rw [one_smul]âŸ©\n  supports_decode' T hT := by\n    have := smul_supports h hT.choose\n    rw [â† hT.choose_spec] at this\n    exact this\n  dom_iff T U hT := by\n    obtain âŸ¨Ï, rflâŸ© := hT\n    constructor\n    Â· rintro âŸ¨Ï', rflâŸ©\n      refine âŸ¨Ï' * Ïâ»Â¹, ?_âŸ©\n      rw [smul_smul, inv_mul_cancel_right]\n    Â· rintro âŸ¨Ï', hâŸ©\n      refine âŸ¨Ï' * Ï, ?_âŸ©\n      rw [mul_smul]\n      exact h\n  decode_smul' T Ï hâ‚ hâ‚‚ := by\n    rw [â† inv_smul_eq_iff, â† inv_smul_eq_iff, smul_smul, smul_smul]\n    refine h _ ?_\n    intros c hc\n    have := hâ‚‚.choose_spec.symm\n    conv_rhs at this => rw [hâ‚.choose_spec]\n    rw [â† inv_smul_eq_iff, â† inv_smul_eq_iff, smul_smul, smul_smul] at this\n    exact Allowable.smul_eq_of_smul_support_eq this hc\n", "additional_info": "Produce a coding function for a given ordered support and tangle it supports.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 58, 68, 70, 403], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [91, 118], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support Î²` to `Tangle Î²`, where `Î²` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable Î²` on `Support Î²`. The function `ConNF.CodingFunction.code` produces such a coding function for a given ordered support and tangle it supports."}
{"full_name": "Part.some", "url": "Mathlib/Data/Part.html#Part.some", "code_src": "mathlib4", "ptype": "def", "header": "def Part.some {Î± : Type u_1} (a : Î±) :PartğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def some (a : Î±) : Part Î± :=\n  âŸ¨True, fun _ => aâŸ©\n", "additional_info": "The `ğŸ—ŸsomeğŸ—ŸğŸ”—../.././Mathlib/Data/Part.html#Part.someğŸ”—  a` value in `ğŸ—ŸPartğŸ—ŸğŸ”—../.././Mathlib/Data/Part.html#PartğŸ”—`  has a `ğŸ—ŸTrueğŸ—ŸğŸ”—../.././Init/Prelude.html#TrueğŸ”—`  domain and the\nfunction returns `a`.\nEquations\n* ğŸ—ŸPart.someğŸ—ŸğŸ”—../.././Mathlib/Data/Part.html#Part.someğŸ”—  a ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  { Dom := ğŸ—ŸTrueğŸ—ŸğŸ”—../.././Init/Prelude.html#TrueğŸ”— , get := fun (x : ğŸ—ŸTrueğŸ—ŸğŸ”—../.././Init/Prelude.html#TrueğŸ”— ) => a }\n\n", "used_premises": [416], "def_path": "Mathlib/Data/Part.lean", "pos": [134, 136], "informalization": "Function `Part.some` is a constructor for the `Part` type, which represents partial values. Given an element `a` of type `Î±`, `Part.some a` creates a partial value that is defined and equals `a`."}
{"full_name": "Part", "url": "Mathlib/Data/Part.html#Part", "code_src": "mathlib4", "ptype": "structure", "header": "structure Part (Î± : Type u) :Type u\n | Dom : Prop \n | get : self.Dom â†’ Î±", "code": "structure Part.{u} (Î± : Type u) : Type u where\n  /-- The domain of a partial value -/\n  Dom : Prop\n  /-- Extract a value from a partial value given a proof of `Dom` -/\n  get : Dom â†’ Î±\n", "additional_info": "`ğŸ—ŸPartğŸ—ŸğŸ”—../.././Mathlib/Data/Part.html#PartğŸ”—  Î±` is the type of \"partial values\" of type `Î±`. It\nis similar to `ğŸ—ŸOptionğŸ—ŸğŸ”—../.././Init/Prelude.html#OptionğŸ”—  Î±` except the domain condition can be an\narbitrary proposition, not necessarily decidable.\n- Part.Dom: The domain of a partial value\n\n\n- Part.get: Extract a value from a partial value given a proof of `ğŸ—ŸDomğŸ—ŸğŸ”—../.././Mathlib/Data/Part.html#Part.DomğŸ”—` \n\n\n", "used_premises": [], "def_path": "Mathlib/Data/Part.lean", "pos": [51, 56], "informalization": "`Part  Î±` is the type of \"partial values\" of type `Î±`. It is similar to `Option  Î±` except the domain condition can be an arbitrary proposition, not necessarily decidable."}
{"full_name": "ConNF.CodingFunction.mem_code_self", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_code_self", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.CodingFunction.mem_code_self [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {t : ConNF.Tangle â†‘Î²} {h : MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) t} :S âˆˆ ConNF.CodingFunction.codeğŸ”—<|PREMISE|>ğŸ”— S t h", "code": "theorem mem_code_self {S : Support Î²} {t : Tangle Î²}\n    {h : Supports (Allowable Î²) (S : Set (Address Î²)) t} :\n    S âˆˆ code S t h :=\n  âŸ¨1, by rw [one_smul]âŸ©\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 414], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [133, 137], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support Î²` to `Tangle Î²`, where `Î²` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable Î²` on `Support Î²`. The function `ConNF.CodingFunction.code` produces such a coding function for a given ordered support and tangle it supports. The theorem `ConNF.CodingFunction.mem_code_self` states that for any ordered support `S` and tangle `t` it supports, the ordered support `S` is in the domain of the coding function produced by `ConNF.CodingFunction.code S t h`."}
{"full_name": "ConNF.CodingFunction.mem_code", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_code", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.CodingFunction.mem_code [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {t : ConNF.Tangle â†‘Î²} {h : MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) t} (T : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :T âˆˆ ConNF.CodingFunction.codeğŸ”—<|PREMISE|>ğŸ”— S t h â†” âˆƒ (Ï : ConNF.Allowable â†‘Î²), T = Ï â€¢ S", "code": "theorem mem_code {S : Support Î²} {t : Tangle Î²}\n    {h : Supports (Allowable Î²) (S : Set (Address Î²)) t} (T : Support Î²) :\n    T âˆˆ code S t h â†” âˆƒ Ï : Allowable Î², T = Ï â€¢ S :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 58, 414], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [139, 143], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support Î²` to `Tangle Î²`, where `Î²` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable Î²` on `Support Î²`. The function `ConNF.CodingFunction.mem_code` produces such a coding function for a given ordered support and tangle it supports."}
{"full_name": "ConNF.CodingFunction.code_smul", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.code_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.code_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (t : ConNF.Tangle â†‘Î²) (Ï : ConNF.Allowable â†‘Î²) (hâ‚ : MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ S).enum) (Ï â€¢ t)) (hâ‚‚ : MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— S.enum) t) :ConNF.CodingFunction.codeğŸ”—<|PREMISE|>ğŸ”— (Ï â€¢ S) (Ï â€¢ t) hâ‚ = ConNF.CodingFunction.codeğŸ”—<|PREMISE|>ğŸ”— S t hâ‚‚", "code": "theorem code_smul (S : Support Î²) (t : Tangle Î²) (Ï : Allowable Î²)\n    (hâ‚ : Supports (Allowable Î²) ((Ï â€¢ S : Support Î²) : Set (Address Î²)) (Ï â€¢ t))\n    (hâ‚‚ : Supports (Allowable Î²) (S : Set (Address Î²)) t) :\n    code (Ï â€¢ S) (Ï â€¢ t) hâ‚ = code S t hâ‚‚ := by\n  refine ext S âŸ¨Ïâ»Â¹, eq_inv_smul_iff.mpr rflâŸ© mem_code_self ?_\n  have := decode_smul (Ï‡ := code (Ï â€¢ S) (Ï â€¢ t) hâ‚) (Ï â€¢ S) Ïâ»Â¹ âŸ¨Ïâ»Â¹, rflâŸ©\n  simp_rw [inv_smul_smul] at this\n  rw [this]\n  simp only [code_decode, Part.get_some, inv_smul_smul]\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 68, 70, 414, 414], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [153, 162], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given an ordered support S and a tangle t supported by S, and an allowable Ï that stabilizes the enumeration of S, the coding function from S to t will be the same as the coding function from Ï â€¢ S to Ï â€¢ t. This means that if an allowable permutation Ï stabilizes the enumeration of the support S, then it also stabilizes the coding function."}
{"full_name": "ConNF.Spec.Specifies.smul", "url": "ConNF/Counting/SpecSMul.html#ConNF.Spec.Specifies.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Spec.Specifies.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [i : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ïƒ : ConNF.SpecğŸ”—<|PREMISE|>ğŸ”— Î²} {S : ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : ConNF.Spec.SpecifiesğŸ”—<|PREMISE|>ğŸ”— Ïƒ S) (Ï : ConNF.Allowable â†‘Î²) :ConNF.Spec.SpecifiesğŸ”—<|PREMISE|>ğŸ”— Ïƒ (Ï â€¢ S)", "code": "theorem Spec.Specifies.smul {Ïƒ : Spec Î²} {S : Support Î²} (h : Ïƒ.Specifies S) (Ï : Allowable Î²) :\n    Ïƒ.Specifies (Ï â€¢ S) := by\n  have : WellFoundedLT Î› := inferInstance\n  revert i Ïƒ S\n  have := this.induction\n    (C := fun Î² => âˆ€ (i : LeLevel â†‘Î²) {Ïƒ : Spec Î²} {S : Support â†‘Î²},\n      Specifies Ïƒ S â†’ âˆ€ (Ï : Allowable â†‘Î²), Specifies Ïƒ (Ï â€¢ S))\n  refine this Î² ?_\n  intro Î² ih i Ïƒ S h Ï\n  obtain âŸ¨_, _, max_eq_max, lS, hlSâ‚, hlSâ‚‚, hlSâ‚ƒ, condâŸ© := h\n  refine âŸ¨_, _, max_eq_max, fun hÎ³ A => (Allowable.toStructPerm Ï).comp A â€¢ lS hÎ³ A,\n      hlSâ‚, ?_, ?_, ?_âŸ©\n  Â· intro Î³ hÎ³ A i hi\n    simp only [Support.smul_f, Allowable.smul_support_f]\n    rw [â† hlSâ‚‚ hÎ³ A i hi]\n    rfl\n  Â· intro Î³ hÎ³ A\n    have : LeLevel Î³ := âŸ¨hÎ³.le.trans i.elimâŸ©\n    have := ih Î³ (coe_lt_coe.mp hÎ³) _ (hlSâ‚ƒ hÎ³ A) (Allowable.comp A Ï)\n    rw [Allowable.toStructPerm_smul, Allowable.toStructPerm_comp] at this\n    exact this\n  Â· intro i hiÏƒ hiS\n    exact (cond i hiÏƒ hiS).smul Ï\n", "additional_info": "", "used_premises": [1, 402, 421, 58, 422, 422], "def_path": "ConNF/Counting/SpecSMul.lean", "pos": [131, 154], "informalization": "The theorem `ConNF.Spec.Specifies.smul` asserts that the action of a scaling factor Ï on a ConNF.Spec object Ïƒ, represented by the operator `Ï â€¢ S`, results in another ConNF.Spec object that specifies the same natural number as the original object Ïƒ. This property is essential for ensuring that the construction of natural numbers in the context of ConNF is well-defined and consistent with the arithmetic operations."}
{"full_name": "ConNF.Spec", "url": "ConNF/Counting/Spec.html#ConNF.Spec", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Spec [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] :ConNF.Î› â†’ Type u", "code": "inductive Spec : Î› â†’ Type u\n  | mk {Î² : Î›} (cond : Enumeration (SpecComponent Î²))\n      (lower : âˆ€ {Î³ : Î›}, (Î³ : TypeIndex) < Î² â†’ Path (Î² : TypeIndex) Î³ â†’ Spec Î³)\n      (r : âˆ€ {Î³ : Î›}, (Î³ : TypeIndex) < Î² â†’ Path (Î² : TypeIndex) Î³ â†’ Îº â†’ Îº) : Spec Î²\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Counting/Spec.lean", "pos": [29, 33], "informalization": "The Lean 4 object `ConNF.Spec` is an inductive type used in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It is parameterized by `ConNF.Params`, which defines the types `Î›`, `Îº`, and `Î¼`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities. The inductive type `ConNF.Spec` is used to construct the natural numbers in the context of ConNF."}
{"full_name": "ConNF.Spec.Specifies", "url": "ConNF/Counting/Spec.html#ConNF.Spec.Specifies", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Spec.Specifies [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} :ConNF.SpecğŸ”—<|PREMISE|>ğŸ”— Î² â†’ ConNF.SupportğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†’ Prop", "code": "inductive Spec.Specifies : âˆ€ {Î² : Î›}, Spec Î² â†’ Support Î² â†’ Prop\n  | mk {Î² : Î›} (Ïƒ : Spec Î²) (S : Support Î²)\n    (max_eq_max : Ïƒ.cond.max = S.max)\n    (lS : âˆ€ {Î³ : Î›}, (Î³ : TypeIndex) < Î² â†’ Path (Î² : TypeIndex) Î³ â†’ Support Î³)\n    (hlSâ‚ : âˆ€ {Î³ : Î›} (hÎ³ : (Î³ : TypeIndex) < Î²) (A : Path (Î² : TypeIndex) Î³),\n      âˆ€ i < (lS hÎ³ A).max, Ïƒ.r hÎ³ A i < S.max)\n    (hlSâ‚‚ : âˆ€ {Î³ : Î›} (hÎ³ : (Î³ : TypeIndex) < Î²) (A : Path (Î² : TypeIndex) Î³)\n      (i : Îº) (hi : i < (lS hÎ³ A).max),\n      ((lS hÎ³ A).f i hi).comp A = S.f (Ïƒ.r hÎ³ A i) (hlSâ‚ hÎ³ A i hi))\n    (hlSâ‚ƒ : âˆ€ {Î³ : Î›} (hÎ³ : (Î³ : TypeIndex) < Î²) (A : Path (Î² : TypeIndex) Î³),\n      (Ïƒ.lower hÎ³ A).Specifies (lS hÎ³ A))\n    (cond : âˆ€ (i : Îº) (hiÏƒ : i < Ïƒ.cond.max) (hiS : i < S.max),\n      SpecifiesC Ïƒ S lS (Ïƒ.cond.f i hiÏƒ) (S.f i hiS)) :\n    Ïƒ.Specifies S\n", "additional_info": "", "used_premises": [1, 421, 58], "def_path": "ConNF/Counting/Spec.lean", "pos": [78, 92], "informalization": "The Lean 4 object `ConNF.Spec.Specifies` is an inductive type used in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It is parameterized by `ConNF.Params`, which defines the types `Î›`, `Îº`, and `Î¼`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities. The inductive type `ConNF.Spec.Specifies` is used to construct the natural numbers in the context of ConNF."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_injective", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.atomPerm_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— ConNF.NearLitterPerm.atomPerm", "code": "theorem atomPerm_injective : Injective NearLitterPerm.atomPerm := by\n  rintro âŸ¨Ï€a, Ï€L, hÏ€âŸ© âŸ¨Ï€a', Ï€L', hÏ€'âŸ© (h : Ï€a = Ï€a')\n  suffices Ï€L = Ï€L' by\n    subst h\n    subst this\n    rfl\n  ext i : 1\n  exact isNearLitter_litterSet_iff.1\n    (((hÏ€ <| isNearLitter_litterSet _).trans <| by rw [h]).trans\n      (hÏ€' <| isNearLitter_litterSet _).symm)\n", "additional_info": "The map from the type of near-litter permutations to the type of permutations of atoms is\ninjective. That is, if two near-litter permutations have the same action on atoms, they are\nequal.", "used_premises": [1, 89], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [64, 74], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_injective` states that the map from the type of near-litter permutations to the type of permutations of atoms is injective. This means that if two near-litter permutations have the same action on atoms, they are equal."}
{"full_name": "ConNF.NearLitterPerm.ext", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.ext [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€ : ConNF.NearLitterPerm} {Ï€' : ConNF.NearLitterPerm} (h : Ï€.atomPerm = Ï€'.atomPerm) :Ï€ = Ï€'", "code": "theorem ext (h : Ï€.atomPerm = Ï€'.atomPerm) : Ï€ = Ï€' :=\n  atomPerm_injective h\n", "additional_info": "An extensionality result for near-litter permutations.\nIf two near-litter permutations have the same action on atoms, they are equal.", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [78, 80], "informalization": "The theorem `ConNF.NearLitterPerm.ext` is an extensionality result for near-litter permutations. It states that if two near-litter permutations have the same action on atoms, they are equal."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_hMul", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_hMul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.atomPerm_hMul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (Ï€' : ConNF.NearLitterPerm) :(Ï€ * Ï€').atomPerm = Ï€.atomPerm * Ï€'.atomPerm", "code": "theorem atomPerm_hMul (Ï€ Ï€' : NearLitterPerm) : (Ï€ * Ï€').atomPerm = Ï€.atomPerm * Ï€'.atomPerm :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [151, 153], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_hMul` states that the atom permutation of the product of two near litter permutations is equal to the product of their atom permutations."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_div", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_div", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.atomPerm_div [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (Ï€' : ConNF.NearLitterPerm) :(Ï€ / Ï€').atomPerm = Ï€.atomPerm / Ï€'.atomPerm", "code": "theorem atomPerm_div (Ï€ Ï€' : NearLitterPerm) : (Ï€ / Ï€').atomPerm = Ï€.atomPerm / Ï€'.atomPerm :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [155, 157], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_div` states that the atom permutation of the division of two near litter permutations is equal to the division of their atom permutations."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_pow", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_pow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.atomPerm_pow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (n : â„• ) :(Ï€ ^ n).atomPerm = Ï€.atomPerm ^ n", "code": "theorem atomPerm_pow (Ï€ : NearLitterPerm) (n : â„•) : (Ï€ ^ n).atomPerm = Ï€.atomPerm ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [159, 161], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_pow` states that for a near litter permutation `Ï€` and a natural number `n`, the `atomPerm` of `Ï€` raised to the power `n` is equal to the `atomPerm` of `Ï€` raised to the power `n`."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_zpow", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_zpow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.atomPerm_zpow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (n : â„¤ ) :(Ï€ ^ n).atomPerm = Ï€.atomPerm ^ n", "code": "theorem atomPerm_zpow (Ï€ : NearLitterPerm) (n : â„¤) : (Ï€ ^ n).atomPerm = Ï€.atomPerm ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [163, 165], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_zpow` states that for any near litter permutation `Ï€` and any integer `n`, the atom permutation of `Ï€` raised to the power `n` is equal to the atom permutation of `Ï€` raised to the power `n`."}
{"full_name": "ConNF.NearLitterPerm.litterPerm_hMul", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.litterPerm_hMul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.litterPerm_hMul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (Ï€' : ConNF.NearLitterPerm) :(Ï€ * Ï€').litterPerm = Ï€.litterPerm * Ï€'.litterPerm", "code": "theorem litterPerm_hMul (Ï€ Ï€' : NearLitterPerm) : (Ï€ * Ï€').litterPerm = Ï€.litterPerm * Ï€'.litterPerm :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [175, 177], "informalization": "The theorem `ConNF.NearLitterPerm.litterPerm_hMul` states that the multiplication of two near litter permutations `Ï€` and `Ï€'` results in a near litter permutation whose litter permutation is the product of the litter permutations of `Ï€` and `Ï€'`."}
{"full_name": "ConNF.NearLitterPerm.litterPerm_div", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.litterPerm_div", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.litterPerm_div [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (Ï€' : ConNF.NearLitterPerm) :(Ï€ / Ï€').litterPerm = Ï€.litterPerm / Ï€'.litterPerm", "code": "theorem litterPerm_div (Ï€ Ï€' : NearLitterPerm) : (Ï€ / Ï€').litterPerm = Ï€.litterPerm / Ï€'.litterPerm :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [179, 181], "informalization": "The theorem `ConNF.NearLitterPerm.litterPerm_div` states that for two near litter permutations `Ï€` and `Ï€'`, the litter permutation of their quotient `Ï€ / Ï€'` is equal to the quotient of their litter permutations `Ï€.litterPerm / Ï€'.litterPerm`."}
{"full_name": "ConNF.NearLitterPerm.litterPerm_pow", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.litterPerm_pow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.litterPerm_pow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (n : â„• ) :(Ï€ ^ n).litterPerm = Ï€.litterPerm ^ n", "code": "theorem litterPerm_pow (Ï€ : NearLitterPerm) (n : â„•) : (Ï€ ^ n).litterPerm = Ï€.litterPerm ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [183, 185], "informalization": "The theorem `ConNF.NearLitterPerm.litterPerm_pow` states that for a near litter permutation `Ï€` and a natural number `n`, the `litterPerm` of `Ï€` raised to the power `n` is equal to the `litterPerm` of `Ï€` raised to the power `n`."}
{"full_name": "ConNF.NearLitterPerm.litterPerm_zpow", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.litterPerm_zpow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.litterPerm_zpow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (n : â„¤ ) :(Ï€ ^ n).litterPerm = Ï€.litterPerm ^ n", "code": "theorem litterPerm_zpow (Ï€ : NearLitterPerm) (n : â„¤) : (Ï€ ^ n).litterPerm = Ï€.litterPerm ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [187, 189], "informalization": "The theorem `ConNF.NearLitterPerm.litterPerm_zpow` states that for a near litter permutation `Ï€` and an integer `n`, the `litterPerm` of `Ï€` raised to the power `n` is equal to the `litterPerm` of `Ï€` raised to the power `n`."}
{"full_name": "ConNF.NearLitterPerm.smul_nearLitter_fst", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.smul_nearLitter_fst", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.smul_nearLitter_fst [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :(Ï€ â€¢ N).fst = Ï€ â€¢ N.fst", "code": "theorem smul_nearLitter_fst (Ï€ : NearLitterPerm) (N : NearLitter) : (Ï€ â€¢ N).fst = Ï€ â€¢ N.fst :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [221, 223], "informalization": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_fst` states that for any near-litter permutation `Ï€` and near-litter `N`, the first component of the near-litter permutation action on `N` is equal to the action of `Ï€` on the first component of `N`."}
{"full_name": "ConNF.NearLitterPerm.smul_nearLitter_coe_preimage", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.smul_nearLitter_coe_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.smul_nearLitter_coe_preimage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :â†‘(Ï€ â€¢ N) = â‡‘Ï€.atomPermâ»Â¹ â»Â¹' â†‘N", "code": "theorem smul_nearLitter_coe_preimage (Ï€ : NearLitterPerm) (N : NearLitter) :\n    (Ï€ â€¢ N : NearLitter) = ((Ï€.atomPermâ»Â¹ : Perm Atom) : Atom â†’ Atom) â»Â¹' N :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [224, 227], "informalization": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_coe_preimage` states that for any near-litter permutation `Ï€` and near-litter `N`, the set of atoms in the near-litter `Ï€ â€¢ N` is the preimage of the set of atoms in `N` under the inverse of the atom permutation of `Ï€`."}
{"full_name": "ConNF.NearLitterPerm.smul_nearLitter_coe", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.smul_nearLitter_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.smul_nearLitter_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :â†‘(Ï€ â€¢ N) = Ï€ â€¢ â†‘N", "code": "theorem smul_nearLitter_coe (Ï€ : NearLitterPerm) (N : NearLitter) :\n    (Ï€ â€¢ N : NearLitter) = Ï€ â€¢ (N : Set Atom) := by\n  rw [smul_nearLitter_coe_preimage, preimage_inv]\n  rfl\n", "additional_info": "The action of a near-litter perm on a near-litter agrees with the pointwise action on its\natoms.", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [230, 234], "informalization": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_coe` states that the action of a near-litter permutation on a near-litter is consistent with the pointwise action on its atoms."}
{"full_name": "ConNF.mk_litter", "url": "ConNF/BaseType/Litter.html#ConNF.mk_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Litter = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_litter : #Litter = #Î¼ := by\n  refine\n    litterEquiv.cardinal_eq.trans\n      (le_antisymm ((Cardinal.mk_subtype_le _).trans_eq ?_)\n        âŸ¨âŸ¨fun Î½ => âŸ¨âŸ¨Î½, âŠ¥, defaultâŸ©, WithBot.bot_ne_coeâŸ©, fun Î½â‚ Î½â‚‚ =>\n            congr_arg <| Prod.fst âˆ˜ Subtype.valâŸ©âŸ©)\n  have := mul_eq_left\n    (Params.Îº_isRegular.aleph0_le.trans Params.Îº_lt_Î¼.le)\n    (Params.Î›_lt_Îº.le.trans Params.Îº_lt_Î¼.le)\n    mk_Î›_ne_zero\n  simp only [mk_prod, lift_id, mk_typeIndex, mul_eq_self aleph0_le_mk_Î›, this]\n", "additional_info": "There are precisely `Î¼` litters.", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/Litter.lean", "pos": [48, 59], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the number of litters is equal to the cardinality of the type `Î¼`."}
{"full_name": "ConNF.Small.lt", "url": "ConNF/BaseType/Small.html#ConNF.Small.lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.lt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s â†’ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘s < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem Small.lt : Small s â†’ #s < #Îº :=\n  id\n", "additional_info": "", "used_premises": [1, 69, 233, 29, 29], "def_path": "ConNF/BaseType/Small.lean", "pos": [28, 30], "informalization": "The theorem `ConNF.Small.lt` states that if the cardinality of a set `s` is strictly less than the cardinality of the type `ConNF.Îº`, then the cardinality of `s` is less than the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.Set.Subsingleton.small", "url": "ConNF/BaseType/Small.html#ConNF.Set.Subsingleton.small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Set.Subsingleton.small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Set.SubsingletonğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s", "code": "theorem Set.Subsingleton.small {Î± : Type _} {s : Set Î±} (hs : s.Subsingleton) : Small s :=\n  hs.cardinal_mk_le_one.trans_lt <| one_lt_aleph0.trans_le Params.Îº_isRegular.aleph0_le\n", "additional_info": "", "used_premises": [1, 69, 115, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [31, 33], "informalization": "In the context of Constructive Ordinal Notation (ConNF), if a set `s` is a `Subsingleton`, meaning it contains at most one element, then the cardinality of `s` is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.small_singleton", "url": "ConNF/BaseType/Small.html#ConNF.small_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.small_singleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (x : Î±) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {x}", "code": "theorem small_singleton (x : Î±) : Small ({x} : Set Î±) :=\n  Set.Subsingleton.small subsingleton_singleton\n", "additional_info": "", "used_premises": [1, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [39, 41], "informalization": "The theorem `ConNF.small_singleton` states that the cardinality of a singleton set is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.small_setOf", "url": "ConNF/BaseType/Small.html#ConNF.small_setOf", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_setOf [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (p : Î± â†’ Prop ) :(ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— fun (a : Î±) => p a) â†” ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {a : Î± | p a}", "code": "theorem small_setOf (p : Î± â†’ Prop) : (Small fun a => p a) â†” Small {a | p a} :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [42, 44], "informalization": "The theorem `ConNF.small_setOf` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of a set defined by a predicate is strictly less than the cardinality of the type `ConNF.Îº` if and only if the cardinality of the set of elements satisfying the predicate is strictly less than the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.small_of_forall_not_mem", "url": "ConNF/BaseType/Small.html#ConNF.small_of_forall_not_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_of_forall_not_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : âˆ€ (x : Î±), x âˆ‰ s) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s", "code": "theorem small_of_forall_not_mem {s : Set Î±} (h : âˆ€ x, x âˆ‰ s) : Small s := by\n  simp only [eq_empty_of_forall_not_mem h, small_empty]\n", "additional_info": "", "used_premises": [1, 69, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [45, 47], "informalization": "The theorem `ConNF.small_of_forall_not_mem` states that if every element of a type `Î±` does not belong to a set `s`, then the set `s` is considered \"small\" in the context of Constructive Ordinal Notation (ConNF), meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.Small.mono", "url": "ConNF/BaseType/Small.html#ConNF.Small.mono", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.mono [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : s âŠ† t) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— t â†’ ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s", "code": "theorem Small.mono (h : s âŠ† t) : Small t â†’ Small s :=\n  (mk_le_mk_of_subset h).trans_lt\n", "additional_info": "Subsets of small sets are small. We say that the 'smallness' relation is monotone.", "used_premises": [1, 69, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [49, 51], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a set is considered \"small\" if its cardinality is strictly less than the cardinality of the type `ConNF.Îº`. The theorem `ConNF.Small.mono` states that if a set `s` is a subset of another set `t`, and `t` is known to be small, then `s` must also be small. This property is known as the monotonicity of the smallness relation."}
{"full_name": "ConNF.Small.union", "url": "ConNF/BaseType/Small.html#ConNF.Small.union", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.union [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (ht : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— t) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (s âˆª t)", "code": "theorem Small.union (hs : Small s) (ht : Small t) : Small (s âˆª t) :=\n  (mk_union_le _ _).trans_lt <| add_lt_of_lt Params.Îº_isRegular.aleph0_le hs ht\n", "additional_info": "Unions of small subsets are small.", "used_premises": [1, 69, 69, 233, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [53, 55], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Small.union` states that the union of two sets, each of which has a cardinality strictly less than the cardinality of the type `ConNF.Îº`, also has a cardinality strictly less than the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.Small.symmDiff", "url": "ConNF/BaseType/Small.html#ConNF.Small.symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.symmDiff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (ht : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— t) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (symmDiffğŸ”—<|PREMISE|>ğŸ”— s t)", "code": "theorem Small.symmDiff (hs : Small s) (ht : Small t) : Small (s âˆ† t) :=\n  (hs.union ht).mono symmDiff_subset_union\n", "additional_info": "", "used_premises": [1, 69, 69, 233, 233, 233, 62], "def_path": "ConNF/BaseType/Small.lean", "pos": [56, 58], "informalization": "`ConNF.Small.symmDiff` is a theorem in Lean 4 that states that the symmetric difference of two sets, each of which has a cardinality strictly less than the cardinality of the type `ConNF.Îº`, also has a cardinality strictly less than the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.Small.symmDiff_iff", "url": "ConNF/BaseType/Small.html#ConNF.Small.symmDiff_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.symmDiff_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— t â†” ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (symmDiffğŸ”—<|PREMISE|>ğŸ”— s t)", "code": "theorem Small.symmDiff_iff (hs : Small s) : Small t â†” Small (s âˆ† t) :=\n  âŸ¨hs.symmDiff, fun ht => by simpa only [symmDiff_symmDiff_self'] using ht.symmDiff hsâŸ©\n", "additional_info": "", "used_premises": [1, 69, 69, 233, 233, 233, 62], "def_path": "ConNF/BaseType/Small.lean", "pos": [59, 61], "informalization": "The theorem `ConNF.Small.symmDiff_iff` states that in the context of Constructive Ordinal Notation (ConNF), the symmetric difference of two sets `s` and `t` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.Îº`) if and only if both `s` and `t` are small."}
{"full_name": "ConNF.small_iUnion", "url": "ConNF/BaseType/Small.html#ConNF.small_iUnion", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_iUnion [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¹ : Type u} {Î± : Type u} (hÎ¹ : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î¹ < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº) {f : Î¹ â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hf : âˆ€ (i : Î¹), ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (f i)) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (â‹ƒ (i : Î¹), f i)", "code": "theorem small_iUnion (hÎ¹ : #Î¹ < #Îº) {f : Î¹ â†’ Set Î±} (hf : âˆ€ i, Small (f i)) :\n    Small (â‹ƒ i, f i) :=\n  (mk_iUnion_le _).trans_lt <|\n    mul_lt_of_lt Params.Îº_isRegular.aleph0_le hÎ¹ <| iSup_lt_of_isRegular Params.Îº_isRegular hÎ¹ hf\n", "additional_info": "", "used_premises": [1, 29, 29, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [62, 66], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_iUnion` states that if the cardinality of an index set `Î¹` is strictly less than the cardinality of the type `ConNF.Îº`, and each element of `Î¹` is mapped to a set whose cardinality is strictly less than the cardinality of `ConNF.Îº`, then the cardinality of the union of these sets is also strictly less than the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.small_iUnion_Prop", "url": "ConNF/BaseType/Small.html#ConNF.small_iUnion_Prop", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_iUnion_Prop [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {p : Prop } {f : p â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hf : âˆ€ (i : p), ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (f i)) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (â‹ƒ (i : p), f i)", "code": "theorem small_iUnion_Prop {p : Prop} {f : p â†’ Set Î±} (hf : âˆ€ i, Small (f i)) : Small (â‹ƒ i, f i) :=\n  by by_cases p <;> simp_all\n", "additional_info": "", "used_premises": [1, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [67, 69], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_iUnion_Prop` states that if the cardinality of each set in a family of sets is strictly less than the cardinality of the type `ConNF.Îº`, then the cardinality of the union of these sets is also strictly less than the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.Small.bUnion", "url": "ConNF/BaseType/Small.html#ConNF.Small.bUnion", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.bUnion [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¹ : Type u} {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î¹} (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) {f : (i : Î¹) â†’ i âˆˆ s â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hf : âˆ€ (i : Î¹) (hi : i âˆˆ s), ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (f i hi)) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (â‹ƒ (i : Î¹), â‹ƒ (hi : i âˆˆ s), f i hi)", "code": "protected theorem Small.bUnion {s : Set Î¹} (hs : Small s) {f : âˆ€ i âˆˆ s, Set Î±}\n    (hf : âˆ€ i (hi : i âˆˆ s), Small (f i hi)) : Small (â‹ƒ (i) (hi : i âˆˆ s), f i hi) :=\n  (mk_bUnion_le' _ _).trans_lt <|\n    mul_lt_of_lt Params.Îº_isRegular.aleph0_le hs <|\n    iSup_lt_of_isRegular Params.Îº_isRegular hs (fun _ => hf _ _)\n", "additional_info": "", "used_premises": [1, 69, 233, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [70, 75], "informalization": "The theorem `ConNF.Small.bUnion` states that if `s` is a set whose cardinality is strictly less than the cardinality of `ConNF.Îº`, and for each `i` in `s`, `f i hi` is a set whose cardinality is also strictly less than the cardinality of `ConNF.Îº`, then the cardinality of the union of all `f i hi` for `i` in `s` is also strictly less than the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.Small.image", "url": "ConNF/BaseType/Small.html#ConNF.Small.image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.image [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {Î² : Type u} {f : Î± â†’ Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s â†’ ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (f '' s)", "code": "theorem Small.image : Small s â†’ Small (f '' s) :=\n  mk_image_le.trans_lt\n", "additional_info": "The image of a small set under any function `f` is small.", "used_premises": [1, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [77, 79], "informalization": "The theorem `ConNF.Small.image` states that if a set `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.Îº`), then the image of `s` under any function `f` is also small."}
{"full_name": "ConNF.Small.preimage", "url": "ConNF/BaseType/Small.html#ConNF.Small.preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.preimage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {Î² : Type u} {f : Î± â†’ Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î²} (h : Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— f) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s â†’ ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (f â»Â¹' s)", "code": "theorem Small.preimage {s : Set Î²} (h : f.Injective) : Small s â†’ Small (f â»Â¹' s) :=\n  (mk_preimage_of_injective f s h).trans_lt\n", "additional_info": "The preimage of a small set under an injective function `f` is small.", "used_premises": [1, 69, 89, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [81, 83], "informalization": "The theorem `ConNF.Small.preimage` states that if `f` is an injective function and `s` is a small set, then the preimage of `s` under `f` is also small."}
{"full_name": "ConNF.Small.image_subset", "url": "ConNF/BaseType/Small.html#ConNF.Small.image_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.image_subset [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {Î² : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î²} (f : Î± â†’ Î²) (h : Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— f) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— t â†’ f '' s âŠ† t â†’ ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s", "code": "theorem Small.image_subset {t : Set Î²} (f : Î± â†’ Î²) (h : f.Injective) :\n    Small t â†’ f '' s âŠ† t â†’ Small s := by\n  intro hâ‚ hâ‚‚\n  have := (Small.mono hâ‚‚ hâ‚).preimage h\n  rw [preimage_image_eq s h] at this\n  exact this\n", "additional_info": "A set is small if its image under an injective function is contained in a small set.", "used_premises": [1, 69, 69, 89, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [86, 92], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a set is considered \"small\" if its cardinality is strictly less than the cardinality of the type `ConNF.Îº`. The theorem `ConNF.Small.image_subset` states that if the image of a set `s` under an injective function `f` is contained within a small set `t`, then `s` itself is also small."}
{"full_name": "ConNF.Small.pFun_image", "url": "ConNF/BaseType/Small.html#ConNF.Small.pFun_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.pFun_image [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {Î² : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) {f : Î± â†’. Î²} :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (PFun.imageğŸ”—<|PREMISE|>ğŸ”— f s)", "code": "theorem Small.pFun_image {Î± Î² : Type _} {s : Set Î±} (h : Small s) {f : Î± â†’. Î²} :\n    Small (f.image s) := by\n  have : Small (f '' s) := Small.image h\n  refine' Small.image_subset Part.some Part.some_injective this _\n  rintro x âŸ¨y, âŸ¨z, hzâ‚, hzâ‚‚âŸ©, rflâŸ©\n  exact âŸ¨z, hzâ‚, Part.eq_some_iff.mpr hzâ‚‚âŸ©\n", "additional_info": "", "used_premises": [1, 69, 233, 233, 453], "def_path": "ConNF/BaseType/Small.lean", "pos": [93, 99], "informalization": "The theorem `ConNF.Small.pFun_image` states that if the cardinality of a set `s` is strictly less than the cardinality of the type `ConNF.Îº`, and `f` is a partial function from `Î±` to `Î²`, then the cardinality of the image of `s` under `f` is also strictly less than the cardinality of `ConNF.Îº`."}
{"full_name": "PFun.image", "url": "Mathlib/Data/PFun.html#PFun.image", "code_src": "mathlib4", "ptype": "def", "header": "def PFun.image {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’. Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :SetğŸ”—<|PREMISE|>ğŸ”— Î²", "code": "def image (s : Set Î±) : Set Î² :=\n  f.graph'.image s\n", "additional_info": "Image of a set under a partial function.\nEquations\n* ğŸ—ŸPFun.imageğŸ—ŸğŸ”—../.././Mathlib/Data/PFun.html#PFun.imageğŸ”—  f s ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸRel.imageğŸ—ŸğŸ”—../.././Mathlib/Data/Rel.html#Rel.imageğŸ”—  (ğŸ—ŸPFun.graph'ğŸ—ŸğŸ”—../.././Mathlib/Data/PFun.html#PFun.graph'ğŸ”—  f) s\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/PFun.lean", "pos": [396, 398], "informalization": "Function `PFun.image` computes the image of a set `s` under a partial function `f`, which is the set of all possible outputs of `f` when applied to elements of `s`."}
{"full_name": "ConNF.isNear_refl", "url": "ConNF/BaseType/Small.html#ConNF.isNear_refl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNear_refl [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s s", "code": "theorem isNear_refl (s : Set Î±) : IsNear s s := by rw [IsNear, symmDiff_self]; exact small_empty\n", "additional_info": "A set is near itself.", "used_premises": [1, 69, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [106, 107], "informalization": "The theorem `ConNF.isNear_refl` states that any set is near itself in the context of Constructive Ordinal Notation (ConNF). This means that the symmetric difference of a set with itself, denoted as `s âˆ† s`, is considered \"small\" according to the `ConNF.Small` predicate. This is a fundamental property of the `ConNF.IsNear` relation, indicating that it is reflexive."}
{"full_name": "ConNF.IsNear", "url": "ConNF/BaseType/Small.html#ConNF.IsNear", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.IsNear [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (t : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "def IsNear (s t : Set Î±) : Prop :=\n  Small (s âˆ† t)\n", "additional_info": "Two sets are near if their symmetric difference is small.\nEquations\n* ğŸ—ŸConNF.IsNearğŸ—ŸğŸ”—../.././ConNF/BaseType/Small.html#ConNF.IsNearğŸ”—  s t ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.SmallğŸ—ŸğŸ”—../.././ConNF/BaseType/Small.html#ConNF.SmallğŸ”—  (ğŸ—ŸsymmDiffğŸ—ŸğŸ”—../.././Mathlib/Order/SymmDiff.html#symmDiffğŸ”—  s t)\n\n", "used_premises": [1, 69, 69], "def_path": "ConNF/BaseType/Small.lean", "pos": [101, 103], "informalization": "Function `ConNF.IsNear` defines a property of two sets `s` and `t` being \"near\" each other in the context of Constructive Ordinal Notation (ConNF). Two sets are considered near if their symmetric difference, denoted as `s âˆ† t`, is considered \"small\" according to the `ConNF.Small` predicate."}
{"full_name": "ConNF.isNear_rfl", "url": "ConNF/BaseType/Small.html#ConNF.isNear_rfl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNear_rfl [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s s", "code": "theorem isNear_rfl : IsNear s s :=\n  isNear_refl _\n", "additional_info": "A version of the `is_near_refl` lemma that does not require the set `s` to be given explicitly.\nThe value of `s` will be inferred automatically by the elaborator.", "used_premises": [1, 69, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [110, 112], "informalization": "The `ConNF.isNear_rfl` theorem is a version of the `is_near_refl` lemma that does not require the set `s` to be given explicitly. The value of `s` will be inferred automatically by the elaborator."}
{"full_name": "ConNF.IsNear.symm", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.symm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t) :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— t s", "code": "theorem IsNear.symm (h : IsNear s t) : IsNear t s := by rwa [IsNear, symmDiff_comm]\n", "additional_info": "If `s` is near `t`, then `t` is near `s`.", "used_premises": [1, 69, 69, 455, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [115, 116], "informalization": "In the context of Constructive Ordinal Notation (ConNF), two sets `s` and `t` are considered \"near\" if their symmetric difference, denoted as `s âˆ† t`, is considered \"small\" according to the `ConNF.Small` predicate. This theorem states that if `s` is near `t`, then `t` is also near `s`."}
{"full_name": "ConNF.isNear_comm", "url": "ConNF/BaseType/Small.html#ConNF.isNear_comm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNear_comm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t â†” ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— t s", "code": "theorem isNear_comm : IsNear s t â†” IsNear t s :=\n  âŸ¨IsNear.symm, IsNear.symmâŸ©\n", "additional_info": "`s` is near `t` if and only if `t` is near `s`.\nIn each direction, this is an application of the `is_near.ğŸ—ŸsymmğŸ—ŸğŸ”—../.././Mathlib/Init/Algebra/Classes.html#symmğŸ”—`  lemma.\nLemmas using `â†”` can be used with `rw`, so this form of the result is particularly useful.", "used_premises": [1, 69, 69, 455, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [120, 122], "informalization": "`s` is near `t` if and only if `t` is near `s`."}
{"full_name": "ConNF.IsNear.trans", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.trans", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.trans [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {u : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hst : ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t) (htu : ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— t u) :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s u", "code": "theorem IsNear.trans (hst : IsNear s t) (htu : IsNear t u) : IsNear s u :=\n  (hst.union htu).mono <| symmDiff_triangle s t u\n", "additional_info": "Nearness is transitive: if `s` is near `t` and `t` is near `u`, then `s` is near `u`.", "used_premises": [1, 69, 69, 69, 455, 455, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [125, 127], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the property of two sets being \"near\" each other is transitive. This means that if set `s` is near set `t`, and set `t` is near set `u`, then set `s` is also near set `u`."}
{"full_name": "ConNF.IsNear.image", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.image [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {Î² : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (f : Î± â†’ Î²) (h : ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t) :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— (f '' s) (f '' t)", "code": "theorem IsNear.image (f : Î± â†’ Î²) (h : IsNear s t) : IsNear (f '' s) (f '' t) :=\n  Small.mono subset_image_symmDiff (Small.image h)\n", "additional_info": "If two sets are near each other, then their images under an arbitrary function are also near.", "used_premises": [1, 69, 69, 455, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [129, 131], "informalization": "Function `ConNF.IsNear.image` proves that if two sets are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), then their images under an arbitrary function are also \"near\"."}
{"full_name": "ConNF.isNear_of_small", "url": "ConNF/BaseType/Small.html#ConNF.isNear_of_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNear_of_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (ht : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— t) :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t", "code": "theorem isNear_of_small (hs : Small s) (ht : Small t) : IsNear s t :=\n  Small.symmDiff hs ht\n", "additional_info": "", "used_premises": [1, 69, 69, 233, 233, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [132, 134], "informalization": "The theorem `ConNF.isNear_of_small` states that if two sets `s` and `t` are both considered \"small\" in the context of Constructive Ordinal Notation (ConNF), then they are considered \"near\" each other according to the `ConNF.IsNear` predicate."}
{"full_name": "ConNF.Small.isNear_iff", "url": "ConNF/BaseType/Small.html#ConNF.Small.isNear_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.isNear_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— t â†” ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t", "code": "theorem Small.isNear_iff (hs : Small s) : Small t â†” IsNear s t :=\n  hs.symmDiff_iff\n", "additional_info": "", "used_premises": [1, 69, 69, 233, 233, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [135, 137], "informalization": "The theorem `ConNF.Small.isNear_iff` states that for two sets `s` and `t` in the context of Constructive Ordinal Notation (ConNF), if `s` is considered \"small\" (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.Îº`), then `t` is considered \"small\" if and only if `s` and `t` are \"near\" each other (i.e., their symmetric difference is considered \"small\")."}
{"full_name": "ConNF.IsNear.Îº_le", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.Îº_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.Îº_le [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t) (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘s) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t", "code": "theorem IsNear.Îº_le (h : IsNear s t) (hs : #Îº â‰¤ #s) : #Îº â‰¤ #(t : Set Î±) := by\n  by_contra ht\n  rw [not_le] at ht\n  have := h.symm\n  rw [â† Small.isNear_iff ht] at this\n  exact (lt_iff_not_ge _ _).mp this hs\n", "additional_info": "", "used_premises": [1, 69, 69, 455, 29, 29, 29, 29], "def_path": "ConNF/BaseType/Small.lean", "pos": [138, 144], "informalization": "The theorem `ConNF.IsNear.Îº_le` states that if two sets `s` and `t` are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), and the cardinality of `ConNF.Îº` is less than or equal to the cardinality of `s`, then the cardinality of `ConNF.Îº` is also less than or equal to the cardinality of `t`."}
{"full_name": "ConNF.IsNear.mk_inter", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.mk_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.mk_inter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t) (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘s) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(s âˆ© t)", "code": "theorem IsNear.mk_inter (h : IsNear s t) (hs : #Îº â‰¤ #s) : #Îº â‰¤ #(s âˆ© t : Set Î±) := by\n  rw [IsNear, symmDiff_eq_sup_sdiff_inf] at h\n  exact le_of_not_gt fun hst =>\n    lt_irrefl _\n      (((hs.trans (mk_le_mk_of_subset (subset_union_left _ _))).trans\n            (le_mk_diff_add_mk (s âˆª t) (s âˆ© t))).trans_lt\n        (add_lt_of_lt Params.Îº_isRegular.aleph0_le h hst))\n", "additional_info": "", "used_premises": [1, 69, 69, 455, 29, 29, 29, 29], "def_path": "ConNF/BaseType/Small.lean", "pos": [145, 152], "informalization": "The theorem `ConNF.IsNear.mk_inter` states that if two sets `s` and `t` are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), and the cardinality of `s` is at least the cardinality of `ConNF.Îº`, then the cardinality of the intersection of `s` and `t` is also at least the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.isNearLitter_litterSet", "url": "ConNF/BaseType/NearLitter.html#ConNF.isNearLitter_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNearLitter_litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— L (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L)", "code": "theorem isNearLitter_litterSet (L : Litter) : IsNearLitter L (litterSet L) :=\n  isNear_rfl\n", "additional_info": "The litter set corresponding to `L` is a near-litter to litter `L`.", "used_premises": [1, 466, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [38, 40], "informalization": "The litter set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is a near-litter to litter `L`."}
{"full_name": "ConNF.IsNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.IsNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) (s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom) :Prop", "code": "def IsNearLitter (L : Litter) (s : Set Atom) : Prop :=\n  IsNear (litterSet L) s\n", "additional_info": "A `L`-near-litter is a set of small symmetric difference to litter `L`. In other words,\nit is near litter `L`.\nNote that here we keep track of which litter a set is near; a set cannot be merely a near-litter, it\nmust be an `L`-near-litter for some `L`. A priori, a set could be an `Lâ‚`-near-litter and also a\n`Lâ‚‚`-near-litter, but this is not the case.\nEquations\n* ğŸ—ŸConNF.IsNearLitterğŸ—ŸğŸ”—../.././ConNF/BaseType/NearLitter.html#ConNF.IsNearLitterğŸ”—  L s ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.IsNearğŸ—ŸğŸ”—../.././ConNF/BaseType/Small.html#ConNF.IsNearğŸ”—  (ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  L) s\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [34, 36], "informalization": "Function `ConNF.IsNearLitter` is a predicate that checks if a given set `s` of type `ConNF.Atom` is near a litter `L` in the context of Constructive Ordinal Notation (ConNF). This means that the set `s` has a small symmetric difference with the litter set of `L`."}
{"full_name": "ConNF.litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.litterSet", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def litterSet (L : Litter) : Set Atom :=\n  {a | a.1 = L}\n", "additional_info": "The set corresponding to litter `L`. We define a litter set as the set of atoms with first\nprojection `L`.\nEquations\n* ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  L ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  {a : ConNF.Atom | a.1 ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  L}\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/Atom.lean", "pos": [52, 54], "informalization": "Function `ConNF.litterSet` defines a set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set contains all atoms `a` such that the first projection of `a` is equal to `L`."}
{"full_name": "ConNF.isNear_litterSet", "url": "ConNF/BaseType/NearLitter.html#ConNF.isNear_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.isNear_litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {L : ConNF.Litter} {s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom} :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L) s â†” ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— L s", "code": "theorem isNear_litterSet : IsNear (litterSet L) s â†” IsNearLitter L s :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 69, 455, 467, 466], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [42, 44], "informalization": "The theorem `ConNF.isNear_litterSet` states that in the context of Constructive Ordinal Notation (ConNF), a set `s` of type `ConNF.Atom` is near a litter `L` if and only if `s` has a small symmetric difference with the litter set of `L`."}
{"full_name": "ConNF.IsNearLitter.near", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter.near", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNearLitter.near [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {L : ConNF.Litter} {s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom} {t : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom} (hs : ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— L s) (ht : ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— L t) :ConNF.IsNearğŸ”—<|PREMISE|>ğŸ”— s t", "code": "theorem IsNearLitter.near (hs : IsNearLitter L s) (ht : IsNearLitter L t) : IsNear s t :=\n  hs.symm.trans ht\n", "additional_info": "If two sets are `L`-near-litters, they are near each other.\nThis is because they are both near litter `L`, and nearness is transitive.", "used_premises": [1, 69, 69, 466, 466, 455], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [47, 49], "informalization": "The theorem `ConNF.IsNearLitter.near` states that if two sets `s` and `t` are both \"near\" a litter `L` in the context of Constructive Ordinal Notation (ConNF), then `s` and `t` are also \"near\" each other. This is a consequence of the transitivity of the \"nearness\" relation."}
{"full_name": "ConNF.IsNearLitter.mk_eq_Îº", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter.mk_eq_Îº", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNearLitter.mk_eq_Îº [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {L : ConNF.Litter} {s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom} (hs : ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— L s) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘s = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem IsNearLitter.mk_eq_Îº (hs : IsNearLitter L s) : #s = #Îº :=\n  ((le_mk_diff_add_mk _ _).trans <|\n        add_le_of_le Params.Îº_isRegular.aleph0_le (hs.mono <| subset_union_right _ _).lt.le\n          (mk_litterSet _).le).eq_of_not_lt\n    fun h =>\n    ((mk_litterSet _).symm.trans_le <| le_mk_diff_add_mk _ _).not_lt <|\n      add_lt_of_lt Params.Îº_isRegular.aleph0_le (hs.mono <| subset_union_left _ _) h\n", "additional_info": "", "used_premises": [1, 69, 466, 29, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [50, 57], "informalization": "The theorem `ConNF.IsNearLitter.mk_eq_Îº` states that if a set `s` of type `ConNF.Atom` is near a litter `L` in the context of Constructive Ordinal Notation (ConNF), then the cardinality of `s` is equal to the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.IsNearLitter.nonempty", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter.nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNearLitter.nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {L : ConNF.Litter} {s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom} (hs : ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— L s) :Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— s", "code": "protected theorem IsNearLitter.nonempty (hs : IsNearLitter L s) : s.Nonempty := by\n  rw [â† nonempty_coe_sort, â† mk_ne_zero_iff, hs.mk_eq_Îº]\n  exact Params.Îº_isRegular.pos.ne'\n", "additional_info": "", "used_premises": [1, 69, 466, 83], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [58, 61], "informalization": "Given a litter `L` and a set `s` of atoms, if `s` is near `L`, then `s` is nonempty."}
{"full_name": "ConNF.isNearLitter_litterSet_iff", "url": "ConNF/BaseType/NearLitter.html#ConNF.isNearLitter_litterSet_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.isNearLitter_litterSet_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} :ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— Lâ‚ (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚) â†” Lâ‚ = Lâ‚‚", "code": "theorem isNearLitter_litterSet_iff : IsNearLitter Lâ‚ (litterSet Lâ‚‚) â†” Lâ‚ = Lâ‚‚ := by\n  refine âŸ¨fun h => ?_, ?_âŸ©\n  Â· by_contra this\n    refine ((mk_litterSet Lâ‚).symm.trans_le <| mk_le_mk_of_subset ?_).not_lt h\n    change litterSet Lâ‚ â‰¤ _\n    exact (le_symmDiff_iff_left _ _).2 (pairwise_disjoint_litterSet this)\n  Â· rintro rfl\n    exact isNearLitter_litterSet _\n", "additional_info": "A litter set is only a near-litter to itself.", "used_premises": [1, 466, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [64, 72], "informalization": "A litter set is only a near-litter to itself."}
{"full_name": "ConNF.IsNearLitter.unique", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter.unique", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNearLitter.unique [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} {s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom} (hâ‚ : ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— Lâ‚ s) (hâ‚‚ : ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚ s) :Lâ‚ = Lâ‚‚", "code": "theorem IsNearLitter.unique {s : Set Atom} (hâ‚ : IsNearLitter Lâ‚ s) (hâ‚‚ : IsNearLitter Lâ‚‚ s) :\n    Lâ‚ = Lâ‚‚ :=\n  isNearLitter_litterSet_iff.1 <| hâ‚.trans hâ‚‚.symm\n", "additional_info": "A set is near at most one litter.", "used_premises": [1, 69, 466, 466], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [74, 77], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a set is near at most one litter."}
{"full_name": "ConNF.mk_nearLitter'", "url": "ConNF/BaseType/NearLitter.html#ConNF.mk_nearLitter'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_nearLitter' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— { s : SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom // ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— L s } = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_nearLitter' (L : Litter) : #{ s // IsNearLitter L s } = #Î¼ := by\n  refine (le_antisymm ?_ ?_).trans mk_atom\n  Â· have := mk_subset_mk_lt_cof (Params.Î¼_isStrongLimit.2)\n    refine le_of_le_of_eq ?_ (mk_subset_mk_lt_cof ?_)\n    Â· rw [mk_atom]\n      exact (Cardinal.mk_congr <|\n          subtypeEquiv\n            ((symmDiff_right_involutive <| litterSet L).toPerm _)\n            fun s => Iff.rfl).trans_le\n        âŸ¨Subtype.impEmbedding _ _ fun s => Params.Îº_le_Î¼_ord_cof.trans_lt'âŸ©\n    Â· simp_rw [mk_atom]\n      exact Params.Î¼_isStrongLimit.2\n  . refine âŸ¨âŸ¨fun a => âŸ¨litterSet L âˆ† {a}, ?_âŸ©, fun a b h => ?_âŸ©âŸ©\n    Â· rw [IsNearLitter, IsNear, Small, symmDiff_symmDiff_cancel_left, mk_singleton]\n      exact one_lt_aleph0.trans_le Params.Îº_isRegular.aleph0_le\n    Â· exact singleton_injective (symmDiff_right_injective _ <| by convert congr_arg Subtype.val h)\n", "additional_info": "There are `Î¼` near-litters to litter `L`.", "used_premises": [1, 29, 69, 466, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [80, 96], "informalization": "The theorem `ConNF.mk_nearLitter'` states that the number of near-litters to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `Î¼`."}
{"full_name": "ConNF.NearLitter.ext", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.ext [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Nâ‚ : ConNF.NearLitter} {Nâ‚‚ : ConNF.NearLitter} (hâ‚‚ : â†‘Nâ‚ = â†‘Nâ‚‚) :Nâ‚ = Nâ‚‚", "code": "theorem ext (hâ‚‚ : (Nâ‚ : Set Atom) = Nâ‚‚) : Nâ‚ = Nâ‚‚ :=\n  SetLike.coe_injective hâ‚‚\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [118, 120], "informalization": "The theorem `ConNF.NearLitter.ext` in Lean 4 is an extensionality theorem for the `ConNF.NearLitter` structure. It states that two `ConNF.NearLitter` objects are equal if their underlying sets are equal."}
{"full_name": "ConNF.NearLitter.nonempty", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (N : ConNF.NearLitter) :NonemptyğŸ”—<|PREMISE|>ğŸ”— â†¥N", "code": "theorem nonempty (N : NearLitter) : Nonempty N := by\n  obtain âŸ¨a, haâŸ© := IsNearLitter.nonempty N.2.2\n  exact âŸ¨a, haâŸ©\n", "additional_info": "", "used_premises": [1, 212], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [121, 124], "informalization": "The theorem `ConNF.NearLitter.nonempty` asserts that every `NearLitter` in the context of Constructive Ordinal Notation (ConNF) is nonempty, meaning it contains at least one element."}
{"full_name": "ConNF.NearLitter.toProd_fst", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd_fst", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitter.toProd_fst [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (N : ConNF.NearLitter) :(ConNF.NearLitter.toProdğŸ”—<|PREMISE|>ğŸ”— N).1 = N.fst", "code": "@[simps]\n", "additional_info": "", "used_premises": [1, 478], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [126, 127], "informalization": "The function `ConNF.NearLitter.toProd` reinterprets a near-litter as a product of a litter and a set of atoms. The first component of this product is equal to the first component of the near-litter."}
{"full_name": "ConNF.NearLitter.toProd", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitter.toProd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (N : ConNF.NearLitter) :ConNF.Litter Ã— SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def toProd (N : NearLitter) : Litter Ã— Set Atom :=\n  (N.1, N.2)\n", "additional_info": "Reinterpret a near-litter as a product of a litter and a set of atoms.\nEquations\n* ğŸ—ŸConNF.NearLitter.toProdğŸ—ŸğŸ”—../.././ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProdğŸ”—  N ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  (N.fst, â†‘N.snd)\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [127, 129], "informalization": "Function `ConNF.NearLitter.toProd` reinterprets a near-litter as a product of a litter and a set of atoms."}
{"full_name": "ConNF.NearLitter.toProd_snd", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd_snd", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitter.toProd_snd [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (N : ConNF.NearLitter) :(ConNF.NearLitter.toProdğŸ”—<|PREMISE|>ğŸ”— N).2 = â†‘N.snd", "code": "@[simps]\n", "additional_info": "", "used_premises": [1, 478], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [126, 127], "informalization": "Function `ConNF.NearLitter.toProd` reinterprets a near-litter as a product of a litter and a set of atoms. The second component of this product is equal to the set of atoms in the near-litter."}
{"full_name": "ConNF.NearLitter.toProd_injective", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.toProd_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— ConNF.NearLitter.toProd", "code": "theorem toProd_injective : Injective toProd := by\n  rintro âŸ¨Lâ‚, sâŸ© âŸ¨Lâ‚‚, tâŸ© h\n  rw [Prod.ext_iff] at h\n  exact ext h.2\n", "additional_info": "", "used_premises": [1, 89], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [130, 134], "informalization": "Function `ConNF.NearLitter.toProd` is injective."}
{"full_name": "ConNF.NearLitter.isNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.isNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitter.isNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (N : ConNF.NearLitter) (L : ConNF.Litter) :ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— L â†‘N â†” N.fst = L", "code": "protected theorem isNearLitter (N : NearLitter) (L : Litter) : IsNearLitter L N â†” N.fst = L :=\n  âŸ¨IsNearLitter.unique N.snd.prop, by rintro rfl; exact N.2.2âŸ©\n", "additional_info": "A near-litter `N` is near a given litter `L` if and only if `N` has first projection `L`.", "used_premises": [1, 466], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [137, 139], "informalization": "A near-litter `N` is near a given litter `L` if and only if `N` has first projection `L`."}
{"full_name": "ConNF.Litter.toNearLitter_fst", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter_fst", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Litter.toNearLitter_fst [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :(ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L).fst = L", "code": "theorem toNearLitter_fst (L : Litter) : L.toNearLitter.fst = L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 483], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [161, 163], "informalization": "The function `ConNF.Litter.toNearLitter` converts a litter in the context of Constructive Ordinal Notation (ConNF) to its corresponding near-litter. A near-litter is defined as a pair consisting of a litter and a subset of that litter, satisfying certain properties. The function `ConNF.Litter.toNearLitter` simply wraps a litter with its litter set to form a near-litter. The theorem `ConNF.Litter.toNearLitter_fst` states that the first component of the resulting near-litter is equal to the original litter."}
{"full_name": "ConNF.Litter.toNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Litter.toNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :ConNF.NearLitter", "code": "def toNearLitter (L : Litter) : NearLitter :=\n  âŸ¨L, litterSet L, isNearLitter_litterSet LâŸ©\n", "additional_info": "Convert a litter to its associated near-litter.\nEquations\n* ğŸ—ŸConNF.Litter.toNearLitterğŸ—ŸğŸ”—../.././ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitterğŸ”—  L ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  { fst := L, snd := { val := ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  L, property := â‹¯ } }\n\n", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [154, 156], "informalization": "Function `ConNF.Litter.toNearLitter` converts a litter in the context of Constructive Ordinal Notation (ConNF) to its corresponding near-litter. A near-litter is defined as a pair consisting of a litter and a subset of that litter, satisfying certain properties. The function `ConNF.Litter.toNearLitter` simply wraps a litter with its litter set to form a near-litter."}
{"full_name": "ConNF.Litter.coe_toNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.coe_toNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Litter.coe_toNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :â†‘(ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) = ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L", "code": "theorem coe_toNearLitter (L : Litter) : (L.toNearLitter : Set Atom) = litterSet L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 483, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [165, 167], "informalization": "The theorem `ConNF.Litter.coe_toNearLitter` states that the set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the set of all atoms `a` such that the first projection of `a` is equal to `L`."}
{"full_name": "ConNF.Litter.toNearLitter_injective", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Litter.toNearLitter_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— ConNF.Litter.toNearLitter", "code": "theorem toNearLitter_injective : Injective Litter.toNearLitter :=\n  fun i j hij => by cases hij; rfl\n", "additional_info": "", "used_premises": [1, 89], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [168, 170], "informalization": "The theorem `ConNF.Litter.toNearLitter_injective` states that the function `ConNF.Litter.toNearLitter` from `ConNF.Litter` to `ConNF.NearLitter` is injective. This means that if two `ConNF.Litter`s map to the same `ConNF.NearLitter`, then they must be the same `ConNF.Litter`."}
{"full_name": "ConNF.mk_nearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.mk_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.NearLitter = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_nearLitter : #NearLitter = #Î¼ := by\n  simp_rw [NearLitter, mk_sigma, mk_nearLitter', sum_const]\n  simp only [NearLitter, mk_sigma, mk_nearLitter', sum_const, mk_litter, lift_id]\n  exact mul_eq_left\n    (Params.Îº_isRegular.aleph0_le.trans Params.Îº_lt_Î¼.le)\n    le_rfl\n    Params.Î¼_isStrongLimit.ne_zero\n", "additional_info": "There are `Î¼` near-litters in total.", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [175, 182], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the number of near-litters is equal to the cardinality of the type `Î¼`."}
{"full_name": "ConNF.mem_localCardinal", "url": "ConNF/BaseType/NearLitter.html#ConNF.mem_localCardinal", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mem_localCardinal [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {L : ConNF.Litter} {N : ConNF.NearLitter} :N âˆˆ ConNF.localCardinalğŸ”—<|PREMISE|>ğŸ”— L â†” N.fst = L", "code": "theorem mem_localCardinal {L : Litter} {N : NearLitter} : N âˆˆ localCardinal L â†” N.1 = L :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 81], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [188, 190], "informalization": "The theorem `ConNF.mem_localCardinal` states that a near-litter `N` belongs to the local cardinal of a litter `L` if and only if the first component of `N` is equal to `L`."}
{"full_name": "ConNF.localCardinal_nonempty", "url": "ConNF/BaseType/NearLitter.html#ConNF.localCardinal_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.localCardinal_nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.localCardinalğŸ”—<|PREMISE|>ğŸ”— L)", "code": "theorem localCardinal_nonempty (L : Litter) : (localCardinal L).Nonempty :=\n  âŸ¨âŸ¨L, litterSet _, isNearLitter_litterSet _âŸ©, rflâŸ©\n", "additional_info": "", "used_premises": [1, 83, 81], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [191, 193], "informalization": "The theorem `ConNF.localCardinal_nonempty` states that for any litter `L` in the context of Constructive Ordinal Notation (ConNF), the local cardinal of `L` is non-empty. This means that there exists at least one near-litter `N` such that the first component of `N` is equal to `L`."}
{"full_name": "ConNF.localCardinal_disjoint", "url": "ConNF/BaseType/NearLitter.html#ConNF.localCardinal_disjoint", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.localCardinal_disjoint [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :PairwiseğŸ”—<|PREMISE|>ğŸ”— (Disjoint on ConNF.localCardinal)", "code": "theorem localCardinal_disjoint : Pairwise (Disjoint on localCardinal) :=\n  fun _ _ h => disjoint_left.2 fun _ hâ‚ hâ‚‚ => h <| hâ‚.symm.trans hâ‚‚\n", "additional_info": "", "used_premises": [1, 490], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [194, 196], "informalization": "The theorem `ConNF.localCardinal_disjoint` states that the local cardinals defined in the context of Constructive Ordinal Notation (ConNF) are pairwise disjoint. This means that for any two distinct local cardinals, their intersection is empty."}
{"full_name": "Pairwise", "url": "Mathlib/Logic/Pairwise.html#Pairwise", "code_src": "mathlib4", "ptype": "def", "header": "def Pairwise {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop ) :Prop", "code": "def Pairwise (r : Î± â†’ Î± â†’ Prop) :=\n  âˆ€ â¦ƒi jâ¦„, i â‰  j â†’ r i j\n", "additional_info": "A relation `r` holds pairwise if `r i j` for all `i â‰  j`.\nEquations\n* ğŸ—ŸPairwiseğŸ—ŸğŸ”—../.././Mathlib/Logic/Pairwise.html#PairwiseğŸ”—  r ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒi j : Î±â¦„, i ğŸ—Ÿâ‰ ğŸ—ŸğŸ”—../.././Init/Core.html#NeğŸ”—  j â†’ r i j\n\n", "used_premises": [], "def_path": "Mathlib/Logic/Pairwise.lean", "pos": [32, 34], "informalization": "Function `Pairwise` is a predicate that checks if a given binary relation `r` holds for all distinct pairs of elements in a type `Î±`."}
{"full_name": "ConNF.localCardinal_injective", "url": "ConNF/BaseType/NearLitter.html#ConNF.localCardinal_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.localCardinal_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— ConNF.localCardinal", "code": "theorem localCardinal_injective : Injective localCardinal := by\n  intro Lâ‚ Lâ‚‚ hâ‚â‚‚\n  by_contra h\n  have := (localCardinal_disjoint h).inter_eq\n  rw [hâ‚â‚‚, inter_self] at this\n  exact (localCardinal_nonempty _).ne_empty this\n", "additional_info": "", "used_premises": [1, 89], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [197, 203], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.localCardinal_injective` states that the function `ConNF.localCardinal` is injective. This means that if `ConNF.localCardinal x = ConNF.localCardinal y`, then `x = y`."}
{"full_name": "ConNF.Litter.toNearLitter_mem_localCardinal", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter_mem_localCardinal", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Litter.toNearLitter_mem_localCardinal [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L âˆˆ ConNF.localCardinalğŸ”—<|PREMISE|>ğŸ”— L", "code": "theorem Litter.toNearLitter_mem_localCardinal (L : Litter) : L.toNearLitter âˆˆ localCardinal L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 483, 81], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [204, 206], "informalization": "The theorem `ConNF.Litter.toNearLitter_mem_localCardinal` states that for any litter `L` in the context of Constructive Ordinal Notation (ConNF), the near-litter formed by wrapping `L` with its litter set is an element of the local cardinal of `L`. The local cardinal of a litter `L` is defined as the set of all near-litters `N` such that the first component of `N` is equal to `L`."}
{"full_name": "ConNF.mk_localCardinal", "url": "ConNF/BaseType/NearLitter.html#ConNF.mk_localCardinal", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_localCardinal [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.localCardinalğŸ”—<|PREMISE|>ğŸ”— L) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_localCardinal (L : Litter) : #(localCardinal L) = #Î¼ := by\n  refine Eq.trans (Cardinal.eq.2 âŸ¨âŸ¨?_, fun x => âŸ¨âŸ¨L, xâŸ©, rflâŸ©, ?_, ?_âŸ©âŸ©) (mk_nearLitter' L)\n  Â· rintro âŸ¨x, rfl : x.1 = LâŸ©\n    exact x.snd\n  Â· rintro âŸ¨âŸ¨j, SâŸ©, rfl : j = LâŸ©\n    rfl\n  Â· exact fun x => rfl\n", "additional_info": "", "used_premises": [1, 29, 81, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [208, 215], "informalization": "The theorem `ConNF.mk_localCardinal` states that the cardinality of the local cardinal of a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `ConNF.Î¼`."}
{"full_name": "ConNF.NearLitter.IsLitter.eq_fst_toNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.IsLitter.eq_fst_toNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.IsLitter.eq_fst_toNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitterğŸ”—<|PREMISE|>ğŸ”— N) :N = ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst", "code": "theorem NearLitter.IsLitter.eq_fst_toNearLitter {N : NearLitter} (h : N.IsLitter) :\n    N = N.fst.toNearLitter :=\n  by cases h; rfl\n", "additional_info": "", "used_premises": [1, 495, 483], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [220, 223], "informalization": "The theorem `ConNF.NearLitter.IsLitter.eq_fst_toNearLitter` states that if a near-litter `N` is of the form `L.toNearLitter` for some litter `L`, then `N` is equal to `ConNF.Litter.toNearLitter L`, where `L` is the first component of `N`."}
{"full_name": "ConNF.NearLitter.IsLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.IsLitter", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.NearLitter.IsLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :ConNF.NearLitter â†’ Prop", "code": "inductive NearLitter.IsLitter : NearLitter â†’ Prop\n  | mk (L : Litter) : IsLitter L.toNearLitter\n", "additional_info": "This near-litter is of the form `L.ğŸ—ŸtoNearLitterğŸ—ŸğŸ”—../.././ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitterğŸ”—` .\n", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [217, 219], "informalization": "Type `ConNF.NearLitter.IsLitter` represents the property that a near-litter is of the form `L.toNearLitter` for some litter `L`."}
{"full_name": "ConNF.NearLitter.IsLitter.litterSet_eq", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.IsLitter.litterSet_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.IsLitter.litterSet_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitterğŸ”—<|PREMISE|>ğŸ”— N) :ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— N.fst = â†‘N.snd", "code": "theorem NearLitter.IsLitter.litterSet_eq {N : NearLitter} (h : N.IsLitter) :\n    litterSet N.fst = N.snd :=\n  by cases h; rfl\n", "additional_info": "", "used_premises": [1, 495, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [224, 227], "informalization": "The theorem `ConNF.NearLitter.IsLitter.litterSet_eq` states that for any near-litter `N` that is also a litter (i.e., `N` is of the form `L.toNearLitter` for some litter `L`), the set of all atoms `a` such that the first projection of `a` is equal to `L` is equal to the near-litter `N` itself."}
{"full_name": "ConNF.NearLitter.IsLitter.exists_litter_eq", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.IsLitter.exists_litter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.IsLitter.exists_litter_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitterğŸ”—<|PREMISE|>ğŸ”— N) :âˆƒ (L : ConNF.Litter), N = ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L", "code": "theorem NearLitter.IsLitter.exists_litter_eq {N : NearLitter} (h : N.IsLitter) :\n    âˆƒ L : Litter, N = L.toNearLitter :=\n  by obtain âŸ¨LâŸ© := h; exact âŸ¨L, rflâŸ©\n", "additional_info": "", "used_premises": [1, 495, 483], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [228, 231], "informalization": "The theorem `ConNF.NearLitter.IsLitter.exists_litter_eq` states that if a near-litter `N` is of the form `L.toNearLitter` for some litter `L`, then there exists a litter `L` such that `N` is equal to `L.toNearLitter`."}
{"full_name": "ConNF.NearLitter.not_isLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.not_isLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.not_isLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {N : ConNF.NearLitter} (h : Â¬ ConNF.NearLitter.IsLitterğŸ”—<|PREMISE|>ğŸ”— N) :ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— N.fst â‰  â†‘N.snd", "code": "theorem NearLitter.not_isLitter {N : NearLitter} (h : Â¬N.IsLitter) : litterSet N.fst â‰  N.snd := by\n  contrapose! h\n  obtain âŸ¨L, S, hSâŸ© := N\n  simp only [Subtype.coe_mk] at h\n  cases h\n  exact NearLitter.IsLitter.mk _\n", "additional_info": "", "used_premises": [1, 495, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [232, 238], "informalization": "The theorem `ConNF.NearLitter.not_isLitter` states that if a near-litter `N` is not of the form `L.toNearLitter` for some litter `L`, then the set of atoms `a` such that the first projection of `a` is equal to `N.fst` is not equal to the near-litter `N.snd`."}
{"full_name": "ConNF.NearLitter.not_isLitter'", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.not_isLitter'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.not_isLitter' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {N : ConNF.NearLitter} (h : Â¬ ConNF.NearLitter.IsLitterğŸ”—<|PREMISE|>ğŸ”— N) :ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst â‰  N", "code": "theorem NearLitter.not_isLitter' {N : NearLitter} (h : Â¬N.IsLitter) : N.fst.toNearLitter â‰  N := by\n  contrapose! h\n  obtain âŸ¨L, S, hSâŸ© := N\n  simp only [Subtype.coe_mk] at h\n  cases h\n  exact NearLitter.IsLitter.mk _\n", "additional_info": "", "used_premises": [1, 495, 483], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [239, 245], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitter.not_isLitter'` states that if a near-litter `N` is not of the form `L.toNearLitter` for some litter `L`, then the near-litter obtained by wrapping the litter part of `N` (i.e., `N.fst.toNearLitter`) is not equal to `N` itself."}
{"full_name": "ConNF.mk_nearLitter''", "url": "ConNF/BaseType/NearLitter.html#ConNF.mk_nearLitter''", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_nearLitter'' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (N : ConNF.NearLitter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†¥N = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem mk_nearLitter'' (N : NearLitter) : #N = #Îº := by\n  change #(N : Set Atom) = _\n  rw [â† symmDiff_symmDiff_cancel_right (litterSet N.fst) N]\n  refine le_antisymm ?_ ?_\n  Â· refine (mk_le_mk_of_subset symmDiff_subset_union).trans ?_\n    refine (mk_union_le _ _).trans ?_\n    simp only [mk_litterSet, add_mk_eq_max', max_le_iff, le_refl, and_true_iff]\n    rw [symmDiff_comm]\n    exact le_of_lt N.2.2\n  Â· refine le_of_not_lt fun h : Small _ => ?_\n    rw [â† Small.symmDiff_iff _] at h\n    Â· simp only [Small, mk_litterSet, lt_self_iff_false] at h\n    Â· rw [symmDiff_comm]\n      exact N.2.2\n", "additional_info": "The size of each near-litter is `Îº`.", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [248, 262], "informalization": "The size of each near-litter in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `Îº`."}
{"full_name": "ConNF.symmDiff_union_inter", "url": "ConNF/BaseType/NearLitter.html#ConNF.symmDiff_union_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.symmDiff_union_inter {Î± : Type u_1} {a : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {b : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :symmDiffğŸ”—<|PREMISE|>ğŸ”— a b âˆª a âˆ© b = a âˆª b", "code": "theorem symmDiff_union_inter {Î± : Type _} {a b : Set Î±} : (a âˆ† b) âˆª (a âˆ© b) = a âˆª b := by\n  ext x\n  simp only [mem_union, mem_symmDiff, mem_inter_iff]\n  tauto\n", "additional_info": "", "used_premises": [69, 69, 62], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [263, 267], "informalization": "The theorem `ConNF.symmDiff_union_inter` states that for any two sets `a` and `b`, the symmetric difference of `a` and `b` union the intersection of `a` and `b` is equal to the union of `a` and `b`."}
{"full_name": "ConNF.noMaxOrder_of_ordinal_type_eq", "url": "ConNF/BaseType/Params.html#ConNF.noMaxOrder_of_ordinal_type_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.noMaxOrder_of_ordinal_type_eq {Î± : Type u} [PreorderğŸ”—<|PREMISE|>ğŸ”— Î±] [InfiniteğŸ”—<|PREMISE|>ğŸ”— Î±] [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± fun (x x_1 : Î±) => x < x_1] (h : Ordinal.IsLimitğŸ”—<|PREMISE|>ğŸ”— (Ordinal.typeğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : Î±) => x < x_1)) :NoMaxOrderğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "theorem noMaxOrder_of_ordinal_type_eq {Î± : Type u} [Preorder Î±] [Infinite Î±] [IsWellOrder Î± (Â· < Â·)]\n    (h : (Ordinal.type ((Â· < Â·) : Î± â†’ Î± â†’ Prop)).IsLimit) : NoMaxOrder Î± := by\n  refine âŸ¨fun a => ?_âŸ©\n  have := (Ordinal.succ_lt_of_isLimit h).mpr (Ordinal.typein_lt_type (Â· < Â·) a)\n  obtain âŸ¨b, hbâŸ© := Ordinal.typein_surj (Â· < Â·) this\n  refine âŸ¨b, ?_âŸ©\n  have := Order.lt_succ (Ordinal.typein (fun x y => x < y) a)\n  rw [â† hb, Ordinal.typein_lt_typein] at this\n  exact this\n", "additional_info": "", "used_premises": [4, 239, 15, 24, 26, 503], "def_path": "ConNF/BaseType/Params.lean", "pos": [90, 99], "informalization": "The theorem `ConNF.noMaxOrder_of_ordinal_type_eq` states that if the ordinal type of a well-ordered infinite set is a limit ordinal, then the set has no maximum order."}
{"full_name": "NoMaxOrder", "url": "Mathlib/Order/Max.html#NoMaxOrder", "code_src": "mathlib4", "ptype": "class", "header": "class NoMaxOrder (Î± : Type u_3) [LTğŸ”—<|PREMISE|>ğŸ”— Î±] :Prop\n | exists_gt : âˆ€ (a : Î±), âˆƒ (b : Î±), a <  b", "code": "class NoMaxOrder (Î± : Type*) [LT Î±] : Prop where\n  /-- For each term `a`, there is some strictly greater `b`. -/\n  exists_gt (a : Î±) : âˆƒ b, a < b\n", "additional_info": "Order without maximal elements. Sometimes called cofinal.\n- NoMaxOrder.exists_gt: For each term `a`, there is some strictly greater `b`.\n\n\n", "used_premises": [6], "def_path": "Mathlib/Order/Max.lean", "pos": [58, 61], "informalization": "Class `NoMaxOrder` represents a type where each element has another element greater than it. This means there is no maximum element in the type, as for any given element, there is always an element following it. This property is useful in certain mathematical contexts where order plays a significant role."}
{"full_name": "ConNF.typein_add_lt_of_type_eq_ord", "url": "ConNF/BaseType/Params.html#ConNF.typein_add_lt_of_type_eq_ord", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.typein_add_lt_of_type_eq_ord {Î± : Type u_1} [InfiniteğŸ”—<|PREMISE|>ğŸ”— Î±] [LinearOrderğŸ”—<|PREMISE|>ğŸ”— Î±] [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± fun (x x_1 : Î±) => x < x_1] (h : (Ordinal.typeğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : Î±) => x < x_1) = Cardinal.ordğŸ”—<|PREMISE|>ğŸ”— (Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î±)) (x : Î±) (y : Î±) :Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : Î±) => x < x_1) x + Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : Î±) => x < x_1) y < Ordinal.typeğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : Î±) => x < x_1", "code": "theorem typein_add_lt_of_type_eq_ord {Î± : Type _}\n    [Infinite Î±] [LinearOrder Î±] [IsWellOrder Î± (Â· < Â·)]\n    (h : Ordinal.type ((Â· < Â·) : Î± â†’ Î± â†’ Prop) = (#Î±).ord) (x y : Î±) :\n    Ordinal.typein (Â· < Â·) x + Ordinal.typein (Â· < Â·) y <\n      Ordinal.type ((Â· < Â·) : Î± â†’ Î± â†’ Prop) := by\n  have hâ‚ := Ordinal.typein_lt_type (Â· < Â·) x\n  have hâ‚‚ := Ordinal.typein_lt_type (Â· < Â·) y\n  rw [h, lt_ord] at hâ‚ hâ‚‚ âŠ¢\n  exact add_lt_of_lt (infinite_iff.mp inferInstance) hâ‚ hâ‚‚\n", "additional_info": "", "used_premises": [239, 2, 15, 26, 27, 29, 36, 36, 26], "def_path": "ConNF/BaseType/Params.lean", "pos": [125, 134], "informalization": "The theorem `ConNF.typein_add_lt_of_type_eq_ord` in Lean 4 allows us to show that the sum of the order types of two elements in an infinite well-ordered type is strictly less than the type of the well-order itself, provided that the type's cardinality equals its own ordinal type. This theorem is crucial for constructing the Conway's nimber type, which is an important part of combinatorial game theory."}
{"full_name": "IsWellFounded.not_lt_bot", "url": "ConNF/BaseType/Params.html#IsWellFounded.not_lt_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem IsWellFounded.not_lt_bot (Î± : Type u_1) [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (r : Î± â†’ Î± â†’ Prop ) [IsWellFoundedğŸ”—<|PREMISE|>ğŸ”— Î± r] (x : Î±) :Â¬ r x (IsWellFounded.botğŸ”—<|PREMISE|>ğŸ”— Î± r)", "code": "theorem IsWellFounded.not_lt_bot\n    (Î± : Type _) [Nonempty Î±] (r : Î± â†’ Î± â†’ Prop) [IsWellFounded Î± r] (x : Î±) :\n    Â¬r x (IsWellFounded.bot Î± r) :=\n  IsWellFounded.wf.not_lt_min _ _ (Set.mem_univ _)\n", "additional_info": "", "used_premises": [212, 18, 506], "def_path": "ConNF/BaseType/Params.lean", "pos": [145, 149], "informalization": "Function `IsWellFounded.bot` is a noncomputable function that takes a type `Î±`, a relation `r` on `Î±`, and a proof that `r` is well-founded, and returns an element of `Î±`. It does this by finding the minimal element of `Î±` with respect to `r` using the well-foundedness of `r`. The theorem `IsWellFounded.not_lt_bot` states that for any element `x` of `Î±`, the relation `r` does not hold between `x` and `IsWellFounded.bot Î± r`."}
{"full_name": "IsWellFounded.bot", "url": "ConNF/BaseType/Params.html#IsWellFounded.bot", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def IsWellFounded.bot (Î± : Type u_1) [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (r : Î± â†’ Î± â†’ Prop ) [i : IsWellFoundedğŸ”—<|PREMISE|>ğŸ”— Î± r] :Î±", "code": "noncomputable def IsWellFounded.bot\n    (Î± : Type _) [Nonempty Î±] (r : Î± â†’ Î± â†’ Prop) [i : IsWellFounded Î± r] : Î± :=\n  i.wf.min Set.univ Set.univ_nonempty\n", "additional_info": "Equations\n* ğŸ—ŸIsWellFounded.botğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#IsWellFounded.botğŸ”—  Î± r ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸWellFounded.minğŸ—ŸğŸ”—../.././Mathlib/Order/WellFounded.html#WellFounded.minğŸ”—  â‹¯ Set.univ â‹¯\n\n", "used_premises": [212, 18], "def_path": "ConNF/BaseType/Params.lean", "pos": [141, 144], "informalization": "Function `IsWellFounded.bot` is a noncomputable function that takes a type `Î±`, a relation `r` on `Î±`, and a proof that `r` is well-founded, and returns an element of `Î±`. It does this by finding the minimal element of `Î±` with respect to `r` using the well-foundedness of `r`."}
{"full_name": "Ordinal.typein_eq_zero_iff", "url": "ConNF/BaseType/Params.html#Ordinal.typein_eq_zero_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Ordinal.typein_eq_zero_iff {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop } [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± r] {x : Î±} :Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”— r x = 0 â†” âˆ€ (y : Î±), y â‰  x â†’ r x y", "code": "theorem Ordinal.typein_eq_zero_iff\n    {Î± : Type _} {r : Î± â†’ Î± â†’ Prop} [Nonempty Î±] [IsWellOrder Î± r] {x : Î±} :\n    Ordinal.typein r x = 0 â†” âˆ€ y â‰  x, r x y := by\n  constructor\n  Â· intro h y\n    rw [â† Ordinal.typein_lt_typein r, h, Ordinal.pos_iff_ne_zero, â† h]\n    exact (Ordinal.typein_injective r).ne\n  Â· intro h\n    have : 0 < Ordinal.type r\n    Â· rw [Ordinal.pos_iff_ne_zero, ne_eq, Ordinal.type_eq_zero_iff_isEmpty]\n      exact not_isEmpty_of_nonempty Î±\n    obtain âŸ¨y, hyâŸ© := Ordinal.typein_surj r this\n    have : y = x\n    Â· by_contra hyx\n      have := (Ordinal.typein_lt_typein r).mpr (h y hyx)\n      rw [hy, lt_iff_not_ge] at this\n      exact this (Ordinal.zero_le _)\n    subst this\n    exact hy\n", "additional_info": "", "used_premises": [212, 15, 36], "def_path": "ConNF/BaseType/Params.lean", "pos": [150, 169], "informalization": "Function `Ordinal.typein` computes the order type of an element `x` within a well-ordered type `Î±`, using the relation `r` to determine the order. The theorem `Ordinal.typein_eq_zero_iff` states that `Ordinal.typein r x = 0` if and only if `x` is the smallest element of `Î±` with respect to `r`."}
{"full_name": "Ordinal.typein_bot", "url": "ConNF/BaseType/Params.html#Ordinal.typein_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Ordinal.typein_bot {Î± : Type u_1} [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] [LinearOrderğŸ”—<|PREMISE|>ğŸ”— Î±] [IsWellOrderğŸ”—<|PREMISE|>ğŸ”— Î± fun (x x_1 : Î±) => x < x_1] :Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : Î±) => x < x_1) (IsWellFounded.botğŸ”—<|PREMISE|>ğŸ”— Î± fun (x x_1 : Î±) => x < x_1) = 0", "code": "theorem Ordinal.typein_bot\n    {Î± : Type _} [Nonempty Î±] [LinearOrder Î±] [IsWellOrder Î± (Â· < Â·)] :\n    Ordinal.typein (Â· < Â·) (IsWellFounded.bot Î± (Â· < Â·)) = 0 := by\n  rw [Ordinal.typein_eq_zero_iff]\n  intro x hx\n  rw [â† lt_or_lt_iff_ne] at hx\n  cases hx with\n  | inl hx => cases IsWellFounded.not_lt_bot Î± (Â· < Â·) x hx\n  | inr hx => exact hx\n", "additional_info": "", "used_premises": [212, 2, 15, 36, 506], "def_path": "ConNF/BaseType/Params.lean", "pos": [170, 179], "informalization": "The theorem `Ordinal.typein_bot` states that the order type of the smallest element in a well-ordered set is 0."}
{"full_name": "ConNF.aleph0_le_mk_Î›", "url": "ConNF/BaseType/Params.html#ConNF.aleph0_le_mk_Î›", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.aleph0_le_mk_Î› [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î›", "code": "theorem aleph0_le_mk_Î› : â„µâ‚€ â‰¤ #Î› := by\n  have := Ordinal.card_le_card (Ordinal.omega_le_of_isLimit Params.Î›_isLimit)\n  simp only [Ordinal.card_omega, Ordinal.card_type] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 510, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [253, 257], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.aleph0_le_mk_Î›` states that the smallest infinite cardinal number, denoted as `â„µâ‚€`, is less than or equal to the cardinality of the type `ConNF.Î›`."}
{"full_name": "Cardinal.aleph0", "url": "Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.aleph0 :CardinalğŸ”—<|PREMISE|>ğŸ”—", "code": "def aleph0 : Cardinal.{u} :=\n  lift #â„•\n", "additional_info": "`â„µâ‚€` is the smallest infinite cardinal.\nEquations\n* ğŸ—ŸCardinal.aleph0ğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0ğŸ”—  ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸCardinal.lift.{u, 0}ğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.liftğŸ”—  (ğŸ—ŸCardinal.mkğŸ—ŸğŸ”—../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mkğŸ”—  ğŸ—Ÿâ„•ğŸ—ŸğŸ”—../../.././Init/Prelude.html#NatğŸ”— )\n\n", "used_premises": [28], "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "pos": [1263, 1265], "informalization": "Function `Cardinal.aleph0` represents the smallest infinite cardinal number, denoted as `â„µâ‚€`, which is the cardinality of the set of natural numbers. It is defined as the lift of the cardinality of the natural numbers to any universe level `u`."}
{"full_name": "ConNF.mk_Î›_ne_zero", "url": "ConNF/BaseType/Params.html#ConNF.mk_Î›_ne_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_Î›_ne_zero [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î› â‰  0", "code": "theorem mk_Î›_ne_zero : #Î› â‰  0 :=\n  fun h => Cardinal.aleph0_pos.not_le (aleph0_le_mk_Î›.trans h.le)\n", "additional_info": "", "used_premises": [1, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [258, 260], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_Î›_ne_zero` asserts that the cardinality of the type `ConNF.Î›`, denoted as `Cardinal.mk ConNF.Î›`, is not equal to zero. This means that there exists at least one element in the type `ConNF.Î›`."}
{"full_name": "ConNF.Îº_typein_zero", "url": "ConNF/BaseType/Params.html#ConNF.Îº_typein_zero", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Îº_typein_zero [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.Îº) => x < x_1) 0 = 0", "code": "theorem Îº_typein_zero : Ordinal.typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop) 0 = 0 := by\n  have := add_zero (0 : Îº)\n  rw [â† Ordinal.typein_inj (Â· < Â·), Params.Îº_add_typein] at this\n  conv at this => rhs; rw [â† add_zero (Ordinal.typein _ _)]\n  rw [Ordinal.add_left_cancel] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 36], "def_path": "ConNF/BaseType/Params.lean", "pos": [318, 324], "informalization": "The theorem `ConNF.Îº_typein_zero` states that in the context of Constructive Ordinal Notation (ConNF), the order type of `0` within the well-ordered type `ConNF.Îº` is `0`."}
{"full_name": "ConNF.Îº_le_zero_iff", "url": "ConNF/BaseType/Params.html#ConNF.Îº_le_zero_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Îº_le_zero_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (i : ConNF.Îº) :i â‰¤ 0 â†” i = 0", "code": "theorem Îº_le_zero_iff (i : Îº) : i â‰¤ 0 â†” i = 0 :=\n  by rw [â† not_lt, â† Ordinal.typein_le_typein (Â· < Â·), Îº_typein_zero, Ordinal.le_zero,\n    â† Îº_typein_zero, Ordinal.typein_inj]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [325, 328], "informalization": "The theorem `ConNF.Îº_le_zero_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any ordinal `i` of type `ConNF.Îº`, `i` is less than or equal to `0` if and only if `i` is equal to `0`."}
{"full_name": "ConNF.Îº_not_lt_zero", "url": "ConNF/BaseType/Params.html#ConNF.Îº_not_lt_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Îº_not_lt_zero [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (i : ConNF.Îº) :Â¬ i < 0", "code": "theorem Îº_not_lt_zero (i : Îº) : Â¬i < 0 := by\n  obtain (h | h | h) := lt_trichotomy i 0\n  Â· cases h.ne ((Îº_le_zero_iff i).mp h.le)\n  Â· exact h.not_lt\n  Â· exact h.not_lt\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [329, 334], "informalization": "The theorem `ConNF.Îº_not_lt_zero` states that in the context of Constructive Ordinal Notation (ConNF), for any element `i` of the type `ConNF.Îº`, it cannot be less than zero."}
{"full_name": "ConNF.Îº_pos", "url": "ConNF/BaseType/Params.html#ConNF.Îº_pos", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Îº_pos [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (i : ConNF.Îº) :0 â‰¤ i", "code": "theorem Îº_pos (i : Îº) : 0 â‰¤ i := by\n  rw [â† not_lt]\n  exact Îº_not_lt_zero i\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [335, 338], "informalization": "The theorem `ConNF.Îº_pos` states that in the context of Constructive Ordinal Notation (ConNF), for any element `i` of the type `ConNF.Îº`, the value `0` is less than or equal to `i`."}
{"full_name": "ConNF.Îº_add_eq_zero_iff", "url": "ConNF/BaseType/Params.html#ConNF.Îº_add_eq_zero_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Îº_add_eq_zero_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (i : ConNF.Îº) (j : ConNF.Îº) :i + j = 0 â†” i = 0 âˆ§ j = 0", "code": "theorem Îº_add_eq_zero_iff (i j : Îº) : i + j = 0 â†” i = 0 âˆ§ j = 0 :=\n  by rw [â† Ordinal.typein_inj (Î± := Îº) (Â· < Â·), â† Ordinal.typein_inj (Î± := Îº) (Â· < Â·),\n    â† Ordinal.typein_inj (Î± := Îº) (Â· < Â·), Params.Îº_add_typein, Îº_typein_zero, Ordinal.add_eq_zero_iff]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [340, 343], "informalization": "The theorem `ConNF.Îº_add_eq_zero_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any two ordinals `i` and `j` of type `ConNF.Îº`, the sum `i + j` equals zero if and only if both `i` and `j` are zero."}
{"full_name": "ConNF.Îº_succ_typein", "url": "ConNF/BaseType/Params.html#ConNF.Îº_succ_typein", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Îº_succ_typein [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (i : ConNF.Îº) :Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.Îº) => x < x_1) (Order.succğŸ”—<|PREMISE|>ğŸ”— i) = Ordinal.typeinğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.Îº) => x < x_1) i + 1", "code": "theorem Îº_succ_typein (i : Îº) :\n    Ordinal.typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop) (Order.succ i) =\n    Ordinal.typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop) i + 1 := by\n  refine le_antisymm ?_ ?_\n  Â· have : i < Ordinal.enum (Â· < Â·) (Ordinal.typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop) i + 1) ?_\n    Â· conv_lhs => rw [â† Ordinal.enum_typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop) i]\n      rw [Ordinal.enum_lt_enum (r := (Â· < Â·))]\n      Â· exact lt_add_one _\n      Â· have := Order.lt_succ i\n        rw [â† Ordinal.typein_lt_typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop)] at this\n        exact (Order.succ_le_of_lt this).trans_lt (Ordinal.typein_lt_type _ _)\n    have := Order.succ_le_of_lt this\n    conv at this => lhs; rw [â† Ordinal.enum_typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop) (Order.succ i)]\n    rw [â† not_lt, Ordinal.enum_le_enum] at this\n    exact this\n  Â· simp only [Ordinal.add_one_eq_succ, Order.succ_le_iff, Ordinal.typein_lt_typein,\n      Order.lt_succ_iff_not_isMax, gt_iff_lt, not_isMax, not_false_eq_true]\n", "additional_info": "", "used_premises": [1, 36, 518, 36], "def_path": "ConNF/BaseType/Params.lean", "pos": [345, 362], "informalization": "The theorem `ConNF.Îº_succ_typein` states that the order type of the successor of an element `i` in the well-ordered type `ConNF.Îº` is equal to the order type of `i` plus one."}
{"full_name": "Order.succ", "url": "Mathlib/Order/SuccPred/Basic.html#Order.succ", "code_src": "mathlib4", "ptype": "def", "header": "def Order.succ {Î± : Type u_1} [PreorderğŸ”—<|PREMISE|>ğŸ”— Î±] [SuccOrderğŸ”—<|PREMISE|>ğŸ”— Î±] :Î± â†’ Î±", "code": "def succ : Î± â†’ Î± :=\n  SuccOrder.succ\n", "additional_info": "The successor of an element. If `a` is not maximal, then `ğŸ—ŸsuccğŸ—ŸğŸ”—../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succğŸ”—  a` is the least element greater\nthan `a`. If `a` is maximal, then `ğŸ—ŸsuccğŸ—ŸğŸ”—../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succğŸ”—  a = a`.\nEquations\n* Order.succ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  SuccOrder.succ\n\n", "used_premises": [4, 21], "def_path": "Mathlib/Order/SuccPred/Basic.lean", "pos": [208, 210], "informalization": "Function `Order.succ` returns the least element greater than a given element in a preordered set with a successor order."}
{"full_name": "ConNF.Îº_zero_lt_one", "url": "ConNF/BaseType/Params.html#ConNF.Îº_zero_lt_one", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Îº_zero_lt_one [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :0 < 1", "code": "theorem Îº_zero_lt_one : (0 : Îº) < 1 := by\n  rw [â† Ordinal.typein_lt_typein ((Â· < Â·) : Îº â†’ Îº â†’ Prop)]\n  exact lt_of_lt_of_eq (lt_add_one _) (Îº_succ_typein 0).symm\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [363, 366], "informalization": "In the context of Constructive Ordinal Notation (ConNF), it is proven that 0 is less than 1."}
{"full_name": "ConNF.Îº_lt_one_iff", "url": "ConNF/BaseType/Params.html#ConNF.Îº_lt_one_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Îº_lt_one_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (i : ConNF.Îº) :i < 1 â†” i = 0", "code": "theorem Îº_lt_one_iff (i : Îº) : i < 1 â†” i = 0 := by\n  constructor\n  Â· rw [â† Îº_le_zero_iff]\n    exact SuccOrder.le_of_lt_succ\n  Â· rintro rfl\n    exact Îº_zero_lt_one\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [368, 374], "informalization": "The theorem `ConNF.Îº_lt_one_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any ordinal `i` of type `ConNF.Îº`, the inequality `i < 1` holds if and only if `i` is equal to `0`."}
{"full_name": "ConNF.Îº_le_self_add", "url": "ConNF/BaseType/Params.html#ConNF.Îº_le_self_add", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Îº_le_self_add [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (i : ConNF.Îº) (j : ConNF.Îº) :i â‰¤ i + j", "code": "theorem Îº_le_self_add (i j : Îº) : i â‰¤ i + j := by\n  rw [â† not_lt, â† Ordinal.typein_le_typein (Â· < Â·), Params.Îº_add_typein]\n  exact Ordinal.le_add_right _ _\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [375, 378], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Îº_le_self_add` states that for any two ordinals `i` and `j` of type `ConNF.Îº`, the ordinal `i` is less than or equal to the sum of `i` and `j`."}
{"full_name": "ConNF.Îº_add_sub_cancel", "url": "ConNF/BaseType/Params.html#ConNF.Îº_add_sub_cancel", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Îº_add_sub_cancel [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (i : ConNF.Îº) (j : ConNF.Îº) :i + j - i = j", "code": "theorem Îº_add_sub_cancel (i j : Îº) : i + j - i = j := by\n  rw [â† Ordinal.typein_inj (Â· < Â·), Params.Îº_sub_typein, Params.Îº_add_typein]\n  exact Ordinal.add_sub_cancel _ _\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [379, 382], "informalization": "The theorem `ConNF.Îº_add_sub_cancel` states that in the context of Constructive Ordinal Notation (ConNF), for any two elements `i` and `j` of type `ConNF.Îº`, the expression `i + j - i` simplifies to `j`."}
{"full_name": "ConNF.Îº_sub_lt", "url": "ConNF/BaseType/Params.html#ConNF.Îº_sub_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Îº_sub_lt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {i : ConNF.Îº} {j : ConNF.Îº} {k : ConNF.Îº} (hâ‚ : i < j + k) (hâ‚‚ : j â‰¤ i) :i - j < k", "code": "theorem Îº_sub_lt {i j k : Îº} (hâ‚ : i < j + k) (hâ‚‚ : j â‰¤ i) : i - j < k := by\n  rw [â† Ordinal.typein_lt_typein (Â· < Â·)] at hâ‚ âŠ¢\n  rw [â† not_lt, â† Ordinal.typein_le_typein (Â· < Â·)] at hâ‚‚\n  rw [Params.Îº_add_typein, â† Ordinal.sub_lt_of_le hâ‚‚] at hâ‚\n  rw [Params.Îº_sub_typein]\n  exact hâ‚\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [383, 389], "informalization": "The theorem `ConNF.Îº_sub_lt` states that if `i < j + k` and `j â‰¤ i`, then `i - j < k` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.mk_typeIndex", "url": "ConNF/BaseType/Params.html#ConNF.mk_typeIndex", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_typeIndex [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.TypeIndex = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î›", "code": "theorem mk_typeIndex : #TypeIndex = #Î› :=\n  mk_option.trans <| add_eq_left aleph0_le_mk_Î› <| one_le_aleph0.trans aleph0_le_mk_Î›\n", "additional_info": "", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [406, 408], "informalization": "The cardinality of `ConNF.TypeIndex` is equal to the cardinality of `ConNF.Î›`."}
{"full_name": "ConNF.card_Iio_lt", "url": "ConNF/BaseType/Params.html#ConNF.card_Iio_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.card_Iio_lt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (x : ConNF.Î¼) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(Set.IioğŸ”—<|PREMISE|>ğŸ”— x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem card_Iio_lt (x : Î¼) : #(Set.Iio x) < #Î¼ :=\n  card_typein_lt (Â· < Â·) x Params.Î¼_ord.symm\n", "additional_info": "Principal segments (sets of the form `{y | y < x}`) have cardinality `< ğŸ—ŸÎ¼ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î¼ğŸ”—` .", "used_premises": [1, 29, 526, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [410, 412], "informalization": "Function `ConNF.card_Iio_lt` proves that the cardinality of the set of all elements less than a given element `x` in the type `ConNF.Î¼` is strictly less than the cardinality of `ConNF.Î¼`."}
{"full_name": "Set.Iio", "url": "Mathlib/Data/Set/Intervals/Basic.html#Set.Iio", "code_src": "mathlib4", "ptype": "def", "header": "def Set.Iio {Î± : Type u_1} [PreorderğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) :SetğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def Iio (a : Î±) :=\n  { x | x < a }\n", "additional_info": "Left-infinite right-open interval\nEquations\n* ğŸ—ŸSet.IioğŸ—ŸğŸ”—../../../.././Mathlib/Data/Set/Intervals/Basic.html#Set.IioğŸ”—  a ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  {x : Î± | x ğŸ—Ÿ<ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#LT.ltğŸ”—  a}\n\n", "used_premises": [4, 69], "def_path": "Mathlib/Data/Set/Intervals/Basic.lean", "pos": [53, 55], "informalization": "Function `Set.Iio` defines the left-infinite right-open interval `{x | x < a}` in a preordered type `Î±`, representing all elements strictly less than `a`."}
{"full_name": "ConNF.card_Iic_lt", "url": "ConNF/BaseType/Params.html#ConNF.card_Iic_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.card_Iic_lt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (x : ConNF.Î¼) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(Set.IicğŸ”—<|PREMISE|>ğŸ”— x) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem card_Iic_lt (x : Î¼) : #(Set.Iic x) < #Î¼ := by\n  rw [â† Set.Iio_union_right, mk_union_of_disjoint, mk_singleton]\n  -- TODO: This isn't the morally correct proof because it uses the fact `Î¼` is a limit cardinal.\n  Â· exact (add_one_le_succ _).trans_lt (Params.Î¼_isStrongLimit.isLimit.succ_lt (card_Iio_lt x))\n  Â· simp\n", "additional_info": "Initial segments (sets of the form `{y | y â‰¤ x}`) have cardinality `< ğŸ—ŸÎ¼ğŸ—ŸğŸ”—../.././ConNF/BaseType/Params.html#ConNF.Params.Î¼ğŸ”—` .", "used_premises": [1, 29, 528, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [414, 419], "informalization": "In the context of Constructive Ordinal Notation (ConNF), for any element `x` of type `ConNF.Î¼`, the cardinality of the set of all elements less than or equal to `x` is strictly less than the cardinality of `ConNF.Î¼`."}
{"full_name": "Set.Iic", "url": "Mathlib/Data/Set/Intervals/Basic.html#Set.Iic", "code_src": "mathlib4", "ptype": "def", "header": "def Set.Iic {Î± : Type u_1} [PreorderğŸ”—<|PREMISE|>ğŸ”— Î±] (b : Î±) :SetğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def Iic (b : Î±) :=\n  { x | x â‰¤ b }\n", "additional_info": "Left-infinite right-closed interval\nEquations\n* ğŸ—ŸSet.IicğŸ—ŸğŸ”—../../../.././Mathlib/Data/Set/Intervals/Basic.html#Set.IicğŸ”—  b ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  {x : Î± | x ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#LE.leğŸ”—  b}\n\n", "used_premises": [4, 69], "def_path": "Mathlib/Data/Set/Intervals/Basic.lean", "pos": [63, 65], "informalization": "Function `Set.Iic` defines the set of all elements less than or equal to a given element `b` in a preordered type `Î±`."}
{"full_name": "ConNF.mk_atom", "url": "ConNF/BaseType/Atom.html#ConNF.mk_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_atom : #Atom = #Î¼ := by\n  simp_rw [Atom, mk_prod, lift_id, mk_litter,\n    mul_eq_left\n      (Params.Îº_isRegular.aleph0_le.trans Params.Îº_lt_Î¼.le)\n      Params.Îº_lt_Î¼.le\n      Params.Îº_isRegular.pos.ne']\n", "additional_info": "The cardinality of `ğŸ—ŸAtomğŸ—ŸğŸ”—../.././ConNF/BaseType/Atom.html#ConNF.AtomğŸ”—`  is the cardinality of `Î¼`.\nWe will prove that all types constructed in our model have cardinality equal to `Î¼`.", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/Atom.lean", "pos": [43, 49], "informalization": "Function `ConNF.mk_atom` proves that the cardinality of the type `ConNF.Atom` is equal to the cardinality of the type `ConNF.Î¼` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.mem_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.mem_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mem_litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {a : ConNF.Atom} {L : ConNF.Litter} :a âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L â†” a.1 = L", "code": "theorem mem_litterSet {a : Atom} {L : Litter} : a âˆˆ litterSet L â†” a.1 = L :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 467], "def_path": "ConNF/BaseType/Atom.lean", "pos": [56, 58], "informalization": "The theorem `ConNF.mem_litterSet` states that an atom `a` belongs to the litter set `ConNF.litterSet L` if and only if the first projection of `a` is equal to `L`."}
{"full_name": "ConNF.mk_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.mk_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem mk_litterSet (L : Litter) : #(litterSet L) = #Îº :=\n  Cardinal.eq.2 âŸ¨litterSetEquiv LâŸ©\n", "additional_info": "Each litter set has cardinality `Îº`.", "used_premises": [1, 29, 467, 29], "def_path": "ConNF/BaseType/Atom.lean", "pos": [69, 71], "informalization": "In the context of Constructive Ordinal Notation (ConNF), each litter set has the same cardinality as the type `Îº`."}
{"full_name": "ConNF.litterSet_nonempty", "url": "ConNF/BaseType/Atom.html#ConNF.litterSet_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.litterSet_nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :NonemptyğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L)", "code": "theorem litterSet_nonempty (L : Litter) : Nonempty (litterSet L) := by\n  rw [â† Cardinal.mk_ne_zero_iff, mk_litterSet]\n  exact mk_ne_zero Îº\n", "additional_info": "", "used_premises": [1, 212, 467], "def_path": "ConNF/BaseType/Atom.lean", "pos": [72, 75], "informalization": "The theorem `ConNF.litterSet_nonempty` states that for any given litter `L` in the context of Constructive Ordinal Notation (ConNF), the set of all atoms `a` such that the first projection of `a` is equal to `L` is nonempty. This means there exists at least one such atom."}
{"full_name": "ConNF.pairwise_disjoint_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.pairwise_disjoint_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pairwise_disjoint_litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :PairwiseğŸ”—<|PREMISE|>ğŸ”— (Disjoint on ConNF.litterSet)", "code": "theorem pairwise_disjoint_litterSet : Pairwise (Disjoint on litterSet) :=\n  fun _ _ h => disjoint_left.2 fun _ hâ‚ hâ‚‚ => h <| hâ‚.symm.trans hâ‚‚\n", "additional_info": "Two litters with different indices have disjoint litter sets.", "used_premises": [1, 490], "def_path": "ConNF/BaseType/Atom.lean", "pos": [77, 79], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.pairwise_disjoint_litterSet` states that the litter sets of litters with different indices are pairwise disjoint. This means that for any two litters with different indices, their litter sets do not share any common elements. This property is crucial in ensuring that the construction of natural numbers using ConNF is well-defined and consistent."}
{"full_name": "ConNF.eq_of_mem_litterSet_of_mem_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.eq_of_mem_litterSet_of_mem_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.eq_of_mem_litterSet_of_mem_litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {a : ConNF.Atom} {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} (hi : a âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— Lâ‚) (hj : a âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚) :Lâ‚ = Lâ‚‚", "code": "theorem eq_of_mem_litterSet_of_mem_litterSet {a : Atom} {Lâ‚ Lâ‚‚ : Litter}\n    (hi : a âˆˆ litterSet Lâ‚) (hj : a âˆˆ litterSet Lâ‚‚) : Lâ‚ = Lâ‚‚ :=\n  pairwise_disjoint_litterSet.eq <| not_disjoint_iff.2 âŸ¨_, hi, hjâŸ©\n", "additional_info": "", "used_premises": [1, 467, 467], "def_path": "ConNF/BaseType/Atom.lean", "pos": [80, 83], "informalization": "The theorem `ConNF.eq_of_mem_litterSet_of_mem_litterSet` states that if an atom `a` belongs to two different litter sets `ConNF.litterSet Lâ‚` and `ConNF.litterSet Lâ‚‚`, then the litters `Lâ‚` and `Lâ‚‚` must be equal."}
{"full_name": "ConNF.litterSet_symmDiff_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.litterSet_symmDiff_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.litterSet_symmDiff_litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} (h : Lâ‚ â‰  Lâ‚‚) :symmDiffğŸ”—<|PREMISE|>ğŸ”— (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— Lâ‚) (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚) = ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— Lâ‚ âˆª ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚", "code": "theorem litterSet_symmDiff_litterSet {Lâ‚ Lâ‚‚ : Litter} (h : Lâ‚ â‰  Lâ‚‚) :\n    litterSet Lâ‚ âˆ† litterSet Lâ‚‚ = litterSet Lâ‚ âˆª litterSet Lâ‚‚ :=\n  (pairwise_disjoint_litterSet h).symmDiff_eq_sup\n", "additional_info": "", "used_premises": [1, 62, 467, 467, 467, 467], "def_path": "ConNF/BaseType/Atom.lean", "pos": [84, 87], "informalization": "The theorem `ConNF.litterSet_symmDiff_litterSet` states that for two different litters `Lâ‚` and `Lâ‚‚`, the symmetric difference of the sets `ConNF.litterSet Lâ‚` and `ConNF.litterSet Lâ‚‚` is equal to their union."}
{"full_name": "WithBot.coe_ne_coe", "url": "ConNF/Mathlib/WithBot.html#WithBot.coe_ne_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem WithBot.coe_ne_coe {Î± : Type u_1} {a : Î±} {b : Î±} :â†‘a â‰  â†‘b â†” a â‰  b", "code": "theorem coe_ne_coe {a b : Î±} : (a : WithBot Î±) â‰  b â†” a â‰  b :=\n  coe_eq_coe.not\n", "additional_info": "", "used_premises": [], "def_path": "ConNF/Mathlib/WithBot.lean", "pos": [8, 10], "informalization": "The theorem `WithBot.coe_ne_coe` states that for any two elements `a` and `b` of a type `Î±`, the inequality `â†‘a â‰  â†‘b` holds if and only if `a â‰  b`."}
{"full_name": "Ordinal.IsLimit.isSuccLimit", "url": "ConNF/Mathlib/Ordinal.html#Ordinal.IsLimit.isSuccLimit", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Ordinal.IsLimit.isSuccLimit {o : OrdinalğŸ”—<|PREMISE|>ğŸ”— } (h : Ordinal.IsLimitğŸ”—<|PREMISE|>ğŸ”— o) :Order.IsSuccLimitğŸ”—<|PREMISE|>ğŸ”— o", "code": "protected theorem IsLimit.isSuccLimit {o : Ordinal} (h : o.IsLimit) : Order.IsSuccLimit o := by\n  rw [Order.isSuccLimit_iff_succ_lt]; exact h.2\n", "additional_info": "", "used_premises": [25, 24, 538], "def_path": "ConNF/Mathlib/Ordinal.lean", "pos": [10, 12], "informalization": "The theorem `Ordinal.IsLimit.isSuccLimit` states that if an ordinal is a limit ordinal, then it is also a successor limit in the order sense."}
{"full_name": "Order.IsSuccLimit", "url": "Mathlib/Order/SuccPred/Limit.html#Order.IsSuccLimit", "code_src": "mathlib4", "ptype": "def", "header": "def Order.IsSuccLimit {Î± : Type u_1} [LTğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) :Prop", "code": "def IsSuccLimit (a : Î±) : Prop :=\n  âˆ€ b, Â¬b â‹– a\n", "additional_info": "A successor limit is a value that doesn't cover any other.\nIt's so named because in a successor order, a successor limit can't be the successor of anything\nsmaller.\nEquations\n* ğŸ—ŸOrder.IsSuccLimitğŸ—ŸğŸ”—../../.././Mathlib/Order/SuccPred/Limit.html#Order.IsSuccLimitğŸ”—  a ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (b : Î±), ğŸ—ŸÂ¬ğŸ—ŸğŸ”—../../.././Init/Prelude.html#NotğŸ”— b ğŸ—Ÿâ‹–ğŸ—ŸğŸ”—../../.././Mathlib/Order/Cover.html#CovByğŸ”—  a\n\n", "used_premises": [6], "def_path": "Mathlib/Order/SuccPred/Limit.lean", "pos": [41, 43], "informalization": "Function `Order.IsSuccLimit` checks if an element `a` in a preordered set is a successor limit, meaning there is no element `b` such that `b` covers `a`."}
{"full_name": "csupr_neg", "url": "ConNF/Mathlib/Order.html#csupr_neg", "code_src": "con-nf", "ptype": "theorem", "header": "theorem csupr_neg {Î± : Type u_1} [CompleteLatticeğŸ”—<|PREMISE|>ğŸ”— Î±] {p : Prop } {f : p â†’ Î±} (hp : Â¬ p) :â¨† (h : p), f h = âŠ¥", "code": "theorem csupr_neg [CompleteLattice Î±] {p : Prop} {f : p â†’ Î±} (hp : Â¬p) : (â¨† h, f h) = âŠ¥ :=\n  iSup_eq_bot.2 fun h => (hp h).elim\n", "additional_info": "", "used_premises": [540], "def_path": "ConNF/Mathlib/Order.lean", "pos": [12, 14], "informalization": "In a complete lattice, if the proposition `p` is false, then the supremum of the function `f` over `p` is equal to the bottom element of the lattice."}
{"full_name": "CompleteLattice", "url": "Mathlib/Order/CompleteLattice.html#CompleteLattice", "code_src": "mathlib4", "ptype": "class", "header": "class CompleteLattice (Î± : Type u_9) extends LatticeğŸ”—<|PREMISE|>ğŸ”— , SupSetğŸ”—<|PREMISE|>ğŸ”— , InfSetğŸ”—<|PREMISE|>ğŸ”— , TopğŸ”—<|PREMISE|>ğŸ”— , BotğŸ”—<|PREMISE|>ğŸ”— :Type u_9\n | sup : Î± â†’ Î± â†’ Î±\n | le : Î± â†’ Î± â†’ Prop \n | lt : Î± â†’ Î± â†’ Prop \n | le_refl : âˆ€ (a : Î±), a â‰¤  a\n | le_trans : âˆ€ (a b c : Î±), a â‰¤  b â†’ b â‰¤  c â†’ a â‰¤  c\n | lt_iff_le_not_le : âˆ€ (a b : Î±), a <  b â†”  a â‰¤  b âˆ§  Â¬ b â‰¤  a\n | le_antisymm : âˆ€ (a b : Î±), a â‰¤  b â†’ b â‰¤  a â†’ a =  b\n | le_sup_left : âˆ€ (a b : Î±), a â‰¤  a âŠ”  b\n | le_sup_right : âˆ€ (a b : Î±), b â‰¤  a âŠ”  b\n | sup_le : âˆ€ (a b c : Î±), a â‰¤  c â†’ b â‰¤  c â†’ a âŠ”  b â‰¤  c\n | inf : Î± â†’ Î± â†’ Î±\n | inf_le_left : âˆ€ (a b : Î±), a âŠ“  b â‰¤  a\n | inf_le_right : âˆ€ (a b : Î±), a âŠ“  b â‰¤  b\n | le_inf : âˆ€ (a b c : Î±), a â‰¤  b â†’ a â‰¤  c â†’ a â‰¤  b âŠ“  c\n | sSup : SetğŸ”—<|PREMISE|>ğŸ”—  Î± â†’ Î±\n | le_sSup : âˆ€ (s : SetğŸ”—<|PREMISE|>ğŸ”—  Î±), âˆ€ a âˆˆ s, a â‰¤  sSup  s\n | sSup_le : âˆ€ (s : SetğŸ”—<|PREMISE|>ğŸ”—  Î±) (a : Î±), (âˆ€ b âˆˆ s, b â‰¤  a) â†’ sSup  s â‰¤  a\n | sInf : SetğŸ”—<|PREMISE|>ğŸ”—  Î± â†’ Î±\n | sInf_le : âˆ€ (s : SetğŸ”—<|PREMISE|>ğŸ”—  Î±), âˆ€ a âˆˆ s, sInf  s â‰¤  a\n | le_sInf : âˆ€ (s : SetğŸ”—<|PREMISE|>ğŸ”—  Î±) (a : Î±), (âˆ€ b âˆˆ s, a â‰¤  b) â†’ a â‰¤  sInf  s\n | top : Î±\n | bot : Î±\n | le_top : âˆ€ (x : Î±), x â‰¤  âŠ¤ \n | bot_le : âˆ€ (x : Î±), âŠ¥  â‰¤  x", "code": "class CompleteLattice (Î± : Type*) extends Lattice Î±, CompleteSemilatticeSup Î±,\n  CompleteSemilatticeInf Î±, Top Î±, Bot Î± where\n  /-- Any element is less than the top one. -/\n  protected le_top : âˆ€ x : Î±, x â‰¤ âŠ¤\n  /-- Any element is more than the bottom one. -/\n  protected bot_le : âˆ€ x : Î±, âŠ¥ â‰¤ x\n", "additional_info": "A complete lattice is a bounded lattice which has suprema and infima for every subset.\n- CompleteLattice.le_sSup: Any element of a set is less than the set supremum.\n\n\n- CompleteLattice.sSup_le: Any upper bound is more than the set supremum.\n\n\n- CompleteLattice.sInf_le: Any element of a set is more than the set infimum.\n\n\n- CompleteLattice.le_sInf: Any lower bound is less than the set infimum.\n\n\n- CompleteLattice.le_top: Any element is less than the top one.\n\n\n- CompleteLattice.bot_le: Any element is more than the bottom one.\n\n\n", "used_premises": [541, 544, 545, 546, 547, 69, 69, 69, 69, 69, 69], "def_path": "Mathlib/Order/CompleteLattice.lean", "pos": [197, 203], "informalization": "Class `CompleteLattice` represents a structure with both a join-semilattice (with a least upper bound operation `âŠ”`) and a meet-semilattice (with a greatest lower bound operation `âŠ“`), forming a partially ordered set where every subset has a unique supremum and infimum."}
{"full_name": "Lattice", "url": "Mathlib/Order/Lattice.html#Lattice", "code_src": "mathlib4", "ptype": "class", "header": "class Lattice (Î± : Type u) extends SemilatticeSupğŸ”—<|PREMISE|>ğŸ”— , InfğŸ”—<|PREMISE|>ğŸ”— :Type u\n | sup : Î± â†’ Î± â†’ Î±\n | le : Î± â†’ Î± â†’ Prop \n | lt : Î± â†’ Î± â†’ Prop \n | le_refl : âˆ€ (a : Î±), a â‰¤  a\n | le_trans : âˆ€ (a b c : Î±), a â‰¤  b â†’ b â‰¤  c â†’ a â‰¤  c\n | lt_iff_le_not_le : âˆ€ (a b : Î±), a <  b â†”  a â‰¤  b âˆ§  Â¬ b â‰¤  a\n | le_antisymm : âˆ€ (a b : Î±), a â‰¤  b â†’ b â‰¤  a â†’ a =  b\n | le_sup_left : âˆ€ (a b : Î±), a â‰¤  a âŠ”  b\n | le_sup_right : âˆ€ (a b : Î±), b â‰¤  a âŠ”  b\n | sup_le : âˆ€ (a b c : Î±), a â‰¤  c â†’ b â‰¤  c â†’ a âŠ”  b â‰¤  c\n | inf : Î± â†’ Î± â†’ Î±\n | inf_le_left : âˆ€ (a b : Î±), a âŠ“  b â‰¤  a\n | inf_le_right : âˆ€ (a b : Î±), a âŠ“  b â‰¤  b\n | le_inf : âˆ€ (a b c : Î±), a â‰¤  b â†’ a â‰¤  c â†’ a â‰¤  b âŠ“  c", "code": "class Lattice (Î± : Type u) extends SemilatticeSup Î±, SemilatticeInf Î±\n", "additional_info": "A lattice is a join-semilattice which is also a meet-semilattice.\n- Lattice.inf_le_left: The infimum is a lower bound on the first argument\n\n\n- Lattice.inf_le_right: The infimum is a lower bound on the second argument\n\n\n- Lattice.le_inf: The infimum is the *greatest* lower bound\n\n\n", "used_premises": [542, 543], "def_path": "Mathlib/Order/Lattice.lean", "pos": [577, 578], "informalization": "Class `Lattice` represents a structure with both a join-semilattice (with a least upper bound operation `âŠ”`) and a meet-semilattice (with a greatest lower bound operation `âŠ“`), forming a partially ordered set where every pair of elements has a unique supremum and infimum."}
{"full_name": "SemilatticeSup", "url": "Mathlib/Order/Lattice.html#SemilatticeSup", "code_src": "mathlib4", "ptype": "class", "header": "class SemilatticeSup (Î± : Type u) extends SupğŸ”—<|PREMISE|>ğŸ”— , PartialOrderğŸ”—<|PREMISE|>ğŸ”— :Type u\n | sup : Î± â†’ Î± â†’ Î±\n | le : Î± â†’ Î± â†’ Prop \n | lt : Î± â†’ Î± â†’ Prop \n | le_refl : âˆ€ (a : Î±), a â‰¤  a\n | le_trans : âˆ€ (a b c : Î±), a â‰¤  b â†’ b â‰¤  c â†’ a â‰¤  c\n | lt_iff_le_not_le : âˆ€ (a b : Î±), a <  b â†”  a â‰¤  b âˆ§  Â¬ b â‰¤  a\n | le_antisymm : âˆ€ (a b : Î±), a â‰¤  b â†’ b â‰¤  a â†’ a =  b\n | le_sup_left : âˆ€ (a b : Î±), a â‰¤  a âŠ”  b\n | le_sup_right : âˆ€ (a b : Î±), b â‰¤  a âŠ”  b\n | sup_le : âˆ€ (a b c : Î±), a â‰¤  c â†’ b â‰¤  c â†’ a âŠ”  b â‰¤  c", "code": "class SemilatticeSup (Î± : Type u) extends Sup Î±, PartialOrder Î± where\n  /-- The supremum is an upper bound on the first argument -/\n  protected le_sup_left : âˆ€ a b : Î±, a â‰¤ a âŠ” b\n  /-- The supremum is an upper bound on the second argument -/\n  protected le_sup_right : âˆ€ a b : Î±, b â‰¤ a âŠ” b\n  /-- The supremum is the *least* upper bound -/\n  protected sup_le : âˆ€ a b c : Î±, a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c\n", "additional_info": "A `ğŸ—ŸSemilatticeSupğŸ—ŸğŸ”—../.././Mathlib/Order/Lattice.html#SemilatticeSupğŸ”—`  is a join-semilattice, that is, a partial order\nwith a join (a.k.a. lub / least upper bound, sup / supremum) operation\n`âŠ”` which is the least element larger than both factors.\n- SemilatticeSup.le_sup_left: The supremum is an upper bound on the first argument\n\n\n- SemilatticeSup.le_sup_right: The supremum is an upper bound on the second argument\n\n\n- SemilatticeSup.sup_le: The supremum is the *least* upper bound\n\n\n", "used_premises": [63, 3], "def_path": "Mathlib/Order/Lattice.lean", "pos": [72, 79], "informalization": "Class `SemilatticeSup` represents a join-semilattice, which is a partially ordered set with a least upper bound operation `âŠ”` that is associative, commutative, and idempotent, and satisfies the properties of being an upper bound and the least upper bound."}
{"full_name": "Inf", "url": "Mathlib/Order/Notation.html#Inf", "code_src": "mathlib4", "ptype": "class", "header": "class Inf (Î± : Type u_1) :Type u_1\n | inf : Î± â†’ Î± â†’ Î±", "code": "class Inf (Î± : Type*) where\n  /-- Greatest lower bound (`\\glb` notation) -/\n  inf : Î± â†’ Î± â†’ Î±\n", "additional_info": "Typeclass for the `âŠ“` (`\\glb`) notation\n- Inf.inf: Greatest lower bound (`\\glb` notation)\n\n\n", "used_premises": [], "def_path": "Mathlib/Order/Notation.lean", "pos": [53, 56], "informalization": "Class `Inf` represents the concept of a greatest lower bound operation, often denoted as `âŠ“` (`\\glb`), for a type `Î±`."}
{"full_name": "SupSet", "url": "Mathlib/Order/SetNotation.html#SupSet", "code_src": "mathlib4", "ptype": "class", "header": "class SupSet (Î± : Type u_1) :Type u_1\n | sSup : SetğŸ”—<|PREMISE|>ğŸ”—  Î± â†’ Î±", "code": "class SupSet (Î± : Type*) where\n  sSup : Set Î± â†’ Î±\n", "additional_info": "Class for the `ğŸ—ŸsSupğŸ—ŸğŸ”—../.././Mathlib/Order/SetNotation.html#SupSet.sSupğŸ”—`  operator\n- SupSet.sSup: Supremum of a set\n\n\n", "used_premises": [69], "def_path": "Mathlib/Order/SetNotation.lean", "pos": [39, 41], "informalization": "Class `SupSet` represents the concept of a supremum operation on a type `Î±`, which takes a set of elements of `Î±` and returns the least upper bound of that set."}
{"full_name": "InfSet", "url": "Mathlib/Order/SetNotation.html#InfSet", "code_src": "mathlib4", "ptype": "class", "header": "class InfSet (Î± : Type u_1) :Type u_1\n | sInf : SetğŸ”—<|PREMISE|>ğŸ”—  Î± â†’ Î±", "code": "class InfSet (Î± : Type*) where\n  sInf : Set Î± â†’ Î±\n", "additional_info": "Class for the `ğŸ—ŸsInfğŸ—ŸğŸ”—../.././Mathlib/Order/SetNotation.html#InfSet.sInfğŸ”—`  operator\n- InfSet.sInf: Infimum of a set\n\n\n", "used_premises": [69], "def_path": "Mathlib/Order/SetNotation.lean", "pos": [46, 48], "informalization": "Class `InfSet` represents the concept of an infimum operator on a type `Î±`, which computes the greatest lower bound of a set of elements in `Î±`."}
{"full_name": "Top", "url": "Mathlib/Order/Notation.html#Top", "code_src": "mathlib4", "ptype": "class", "header": "class Top (Î± : Type u_1) :Type u_1\n | top : Î±", "code": "class Top (Î± : Type*) where\n  /-- The top (`âŠ¤`, `\\top`) element -/\n  top : Î±\n", "additional_info": "Typeclass for the `âŠ¤` (`\\top`) notation\n- Top.top: The top (`âŠ¤`, `\\top`) element\n\n\n", "used_premises": [], "def_path": "Mathlib/Order/Notation.lean", "pos": [97, 100], "informalization": "Class `Top` represents a type `Î±` with a distinguished element `âŠ¤` (top), typically used to denote a maximum or universal element in a partially ordered set or lattice."}
{"full_name": "Bot", "url": "Mathlib/Order/Notation.html#Bot", "code_src": "mathlib4", "ptype": "class", "header": "class Bot (Î± : Type u_1) :Type u_1\n | bot : Î±", "code": "class Bot (Î± : Type*) where\n  /-- The bot (`âŠ¥`, `\\bot`) element -/\n  bot : Î±\n", "additional_info": "Typeclass for the `âŠ¥` (`\\bot`) notation\n- Bot.bot: The bot (`âŠ¥`, `\\bot`) element\n\n\n", "used_premises": [], "def_path": "Mathlib/Order/Notation.lean", "pos": [104, 107], "informalization": "Class `Bot` represents the concept of a bottom element in a type `Î±`, often denoted as `âŠ¥`, which is a minimal element in the order or hierarchy of that type."}
{"full_name": "Set.compl_eq_empty", "url": "ConNF/Mathlib/Order.html#Set.compl_eq_empty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.compl_eq_empty {Î± : Type u_1} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :sá¶œ = âˆ… â†” s = Set.univ", "code": "theorem compl_eq_empty : sá¶œ = âˆ… â†” s = univ :=\n  compl_eq_bot\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [20, 22], "informalization": "The complement of a set `s` is equal to the empty set if and only if `s` is equal to the universal set."}
{"full_name": "Set.compl_eq_univ", "url": "ConNF/Mathlib/Order.html#Set.compl_eq_univ", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.compl_eq_univ {Î± : Type u_1} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :sá¶œ = Set.univ â†” s = âˆ…", "code": "theorem compl_eq_univ : sá¶œ = univ â†” s = âˆ… :=\n  compl_eq_top\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [24, 26], "informalization": "The complement of a set `s` is equal to the universal set if and only if `s` is the empty set."}
{"full_name": "Set.image_sUnion", "url": "ConNF/Mathlib/Order.html#Set.image_sUnion", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Set.image_sUnion {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (S : SetğŸ”—<|PREMISE|>ğŸ”— (SetğŸ”—<|PREMISE|>ğŸ”— Î±)) :f '' â‹ƒâ‚€ S = â‹ƒ s âˆˆ S, f '' s", "code": "theorem image_sUnion (f : Î± â†’ Î²) (S : Set (Set Î±)) : f '' â‹ƒâ‚€ S = â‹ƒ s âˆˆ S, f '' s := by\n  rw [sUnion_eq_biUnion, image_iUnionâ‚‚]\n", "additional_info": "", "used_premises": [69, 69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [27, 29], "informalization": "The theorem `Set.image_sUnion` states that for any function `f` and any set of sets `S`, the image of the union of all sets in `S` under `f` is equal to the union of the images of each set in `S` under `f`."}
{"full_name": "Set.iUnion_pos", "url": "ConNF/Mathlib/Order.html#Set.iUnion_pos", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.iUnion_pos {Î± : Type u_1} {p : Prop } {f : p â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hp : p) :â‹ƒ (h : p), f h = f hp", "code": "theorem iUnion_pos {p : Prop} {f : p â†’ Set Î±} (hp : p) : (â‹ƒ h, f h) = f hp :=\n  iSup_pos hp\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [31, 33], "informalization": "The theorem `Set.iUnion_pos` states that if `p` is a true proposition, then the union of the sets `f h` for all `h : p` is equal to `f hp`, where `hp` is a proof of `p`."}
{"full_name": "Set.iUnion_neg'", "url": "ConNF/Mathlib/Order.html#Set.iUnion_neg'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.iUnion_neg' {Î± : Type u_1} {p : Prop } {f : p â†’ SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hp : Â¬ p) :â‹ƒ (h : p), f h = âˆ…", "code": "theorem iUnion_neg' {p : Prop} {f : p â†’ Set Î±} (hp : Â¬p) : (â‹ƒ h, f h) = âˆ… :=\n  csupr_neg hp\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [35, 37], "informalization": "The theorem `Set.iUnion_neg'` states that if `p` is a false proposition, then the union of sets indexed by `p` is the empty set."}
{"full_name": "Set.empty_symmDiff", "url": "ConNF/Mathlib/Order.html#Set.empty_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.empty_symmDiff {Î± : Type u_1} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :symmDiffğŸ”—<|PREMISE|>ğŸ”— âˆ… s = s", "code": "theorem empty_symmDiff : âˆ… âˆ† s = s :=\n  bot_symmDiff _\n", "additional_info": "", "used_premises": [69, 62], "def_path": "ConNF/Mathlib/Order.lean", "pos": [41, 43], "informalization": "The symmetric difference between the empty set and any set `s` is equal to `s`."}
{"full_name": "Set.symmDiff_empty", "url": "ConNF/Mathlib/Order.html#Set.symmDiff_empty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.symmDiff_empty {Î± : Type u_1} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :symmDiffğŸ”—<|PREMISE|>ğŸ”— s âˆ… = s", "code": "theorem symmDiff_empty : s âˆ† âˆ… = s :=\n  symmDiff_bot _\n", "additional_info": "", "used_premises": [69, 62], "def_path": "ConNF/Mathlib/Order.lean", "pos": [45, 47], "informalization": "The symmetric difference of a set `s` and the empty set is equal to `s`."}
{"full_name": "Cardinal.nonempty_compl_of_mk_lt_mk", "url": "ConNF/Mathlib/Cardinal.html#Cardinal.nonempty_compl_of_mk_lt_mk", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Cardinal.nonempty_compl_of_mk_lt_mk {Î± : Type u} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘s < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— Î±) :Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— sá¶œ", "code": "theorem nonempty_compl_of_mk_lt_mk (h : (#s) < (#Î±)) : sá¶œ.Nonempty := by\n  simp_rw [Set.nonempty_iff_ne_empty, Ne.def, compl_eq_empty]\n  rintro rfl\n  simp at h\n", "additional_info": "", "used_premises": [69, 29, 29, 83], "def_path": "ConNF/Mathlib/Cardinal.lean", "pos": [18, 22], "informalization": "If the cardinality of a set `s` is less than the cardinality of the type `Î±`, then the complement of `s` is nonempty."}
{"full_name": "PiProp.vadd_def", "url": "ConNF/Mathlib/GroupAction.html#PiProp.vadd_def", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.vadd_def {I : Prop } {f : I â†’ Type v} (x : (i : I) â†’ f i) {Î± : Type u_1} [(i : I) â†’ VAddğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] (s : Î±) :s +áµ¥ x = fun (i : I) => s +áµ¥ x i", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [557], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [33, 34], "informalization": "Function `PiProp.vadd_def` defines the vector addition operation `+áµ¥` for a dependent function type `(i : I) â†’ f i`, where `f : I â†’ Type v` and `x : (i : I) â†’ f i`. It states that for any `s : Î±` and `x : (i : I) â†’ f i`, the vector addition `s +áµ¥ x` is equal to the function that maps each `i : I` to `s +áµ¥ x i`."}
{"full_name": "VAdd", "url": "Mathlib/Algebra/Group/Defs.html#VAdd", "code_src": "mathlib4", "ptype": "class", "header": "class VAdd (G : Type u) (P : Type v) :Type (max u v)\n | vadd : G â†’ P â†’ P", "code": "class VAdd (G : Type u) (P : Type v) where\n  /-- `a +áµ¥ b` computes the sum of `a` and `b`. The meaning of this notation is type-dependent,\n  but it is intended to be used for left actions. -/\n  vadd : G â†’ P â†’ P\n", "additional_info": "Type class for the `+áµ¥` notation.\n- VAdd.vadd: `a +áµ¥ b` computes the sum of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions.\n\n\n", "used_premises": [], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [83, 87], "informalization": "Class `VAdd` represents the concept of a vector addition operation, denoted as `+áµ¥`, which is a binary operation between elements of a type `G` (often representing vectors) and elements of a type `P` (often representing points or another vector space), resulting in an element of `P`."}
{"full_name": "PiProp.smul_def", "url": "ConNF/Mathlib/GroupAction.html#PiProp.smul_def", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.smul_def {I : Prop } {f : I â†’ Type v} (x : (i : I) â†’ f i) {Î± : Type u_1} [(i : I) â†’ SMulğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] (s : Î±) :s â€¢ x = fun (i : I) => s â€¢ x i", "code": "theorem smul_def {Î± : Type _} [âˆ€ i, SMul Î± <| f i] (s : Î±) : s â€¢ x = fun i => s â€¢ x i :=\n  rfl\n", "additional_info": "", "used_premises": [57], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [34, 36], "informalization": "`PiProp.smul_def` is a theorem in Lean 4 that defines the scalar multiplication of an element `s : Î±` with a dependent function `x : (i : I) â†’ f i`, where `f : I â†’ Type v` and `SMul Î± (f i)` for each `i : I`. The theorem states that `s â€¢ x` is equal to the function that maps each `i : I` to `s â€¢ x i`."}
{"full_name": "PiProp.vadd_apply", "url": "ConNF/Mathlib/GroupAction.html#PiProp.vadd_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PiProp.vadd_apply {I : Prop } {f : I â†’ Type v} (x : (i : I) â†’ f i) (i : I) {Î± : Type u_1} [(i : I) â†’ VAddğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] (s : Î±) :(s +áµ¥ x) i = s +áµ¥ x i", "code": "@[to_additive (attr := simp)]\n", "additional_info": "", "used_premises": [557], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [37, 38], "informalization": "`PiProp.vadd_apply` is a theorem in Lean 4 that states that for a dependent function `x : (i : I) â†’ f i`, the vector addition `s +áµ¥ x` applied to an index `i` is equal to the vector addition of `s` and `x i`."}
{"full_name": "PiProp.smul_apply", "url": "ConNF/Mathlib/GroupAction.html#PiProp.smul_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PiProp.smul_apply {I : Prop } {f : I â†’ Type v} (x : (i : I) â†’ f i) (i : I) {Î± : Type u_1} [(i : I) â†’ SMulğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] (s : Î±) :(s â€¢ x) i = s â€¢ x i", "code": "theorem smul_apply {Î± : Type _} [âˆ€ i, SMul Î± <| f i] (s : Î±) : (s â€¢ x) i = s â€¢ x i :=\n  rfl\n", "additional_info": "", "used_premises": [57], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [38, 40], "informalization": "The `PiProp.smul_apply` theorem states that for any indexed family of types `f : I â†’ Type v` and any scalar `s : Î±`, the application of the scalar multiplication to an element `x : (i : I) â†’ f i` at an index `i : I` is equal to the scalar multiplication of `x i` by `s`."}
{"full_name": "PiProp.vadd_apply'", "url": "ConNF/Mathlib/GroupAction.html#PiProp.vadd_apply'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PiProp.vadd_apply' {I : Prop } {f : I â†’ Type v} (i : I) {g : I â†’ Type u_1} [(i : I) â†’ VAddğŸ”—<|PREMISE|>ğŸ”— (f i) (g i)] (s : (i : I) â†’ f i) (x : (i : I) â†’ g i) :(s +áµ¥ x) i = s i +áµ¥ x i", "code": "@[to_additive (attr := simp)]\n", "additional_info": "", "used_premises": [557], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [45, 46], "informalization": "The theorem `PiProp.vadd_apply'` states that for any indexed family of types `f : I â†’ Type v` and `g : I â†’ Type u_1`, where each `f i` has a vector addition operation with each `g i`, the vector addition of a dependent function `s : (i : I) â†’ f i` and a dependent function `x : (i : I) â†’ g i` at an index `i : I` is equal to the vector addition of `s i` and `x i`."}
{"full_name": "PiProp.smul_apply'", "url": "ConNF/Mathlib/GroupAction.html#PiProp.smul_apply'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PiProp.smul_apply' {I : Prop } {f : I â†’ Type v} (i : I) {g : I â†’ Type u_1} [(i : I) â†’ SMulğŸ”—<|PREMISE|>ğŸ”— (f i) (g i)] (s : (i : I) â†’ f i) (x : (i : I) â†’ g i) :(s â€¢ x) i = s i â€¢ x i", "code": "theorem smul_apply' {g : I â†’ Type _} [âˆ€ i, SMul (f i) (g i)] (s : âˆ€ i, f i) (x : âˆ€ i, g i) :\n    (s â€¢ x) i = s i â€¢ x i :=\n  rfl\n", "additional_info": "", "used_premises": [57], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [46, 49], "informalization": "The `PiProp.smul_apply'` theorem states that for any indexed family of types `f : I â†’ Type v` and `g : I â†’ Type u_1`, where `SMul (f i) (g i)` is defined for each `i : I`, and given `s : (i : I) â†’ f i` and `x : (i : I) â†’ g i`, the `i`-th component of `s â€¢ x` is equal to `s i â€¢ x i`."}
{"full_name": "PiProp.has_faithful_vadd_at", "url": "ConNF/Mathlib/GroupAction.html#PiProp.has_faithful_vadd_at", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.has_faithful_vadd_at {I : Prop } {f : I â†’ Type v} {Î± : Type u_1} [(i : I) â†’ VAddğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] [âˆ€ (i : I), NonemptyğŸ”—<|PREMISE|>ğŸ”— (f i)] (i : I) [FaithfulVAddğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] :FaithfulVAddğŸ”—<|PREMISE|>ğŸ”— Î± ((i : I) â†’ f i)", "code": "@[to_additive PiProp.has_faithful_vadd_at]\n", "additional_info": "", "used_premises": [557, 212, 564, 564], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [86, 87], "informalization": "The theorem `PiProp.has_faithful_vadd_at` states that if each `f i` has a faithful vector addition operation for each `i : I`, then the type `(i : I) â†’ f i` also has a faithful vector addition operation. This theorem is a special case of the more general `PiProp.has_faithful_vadd` which applies when `I` is a type instead of a proposition. The proof of `PiProp.has_faithful_vadd_at` is straightforward, using the `faithfulVAdd_at` lemma which is applied to each `i : I`."}
{"full_name": "FaithfulVAdd", "url": "Mathlib/GroupTheory/GroupAction/Defs.html#FaithfulVAdd", "code_src": "mathlib4", "ptype": "class", "header": "class FaithfulVAdd (G : Type u_10) (P : Type u_11) [VAddğŸ”—<|PREMISE|>ğŸ”— G P] :Prop\n | eq_of_vadd_eq_vadd : âˆ€ {gâ‚ gâ‚‚ : G}, (âˆ€ (p : P), gâ‚ +áµ¥  p =  gâ‚‚ +áµ¥  p) â†’ gâ‚ =  gâ‚‚", "code": "class FaithfulVAdd (G : Type*) (P : Type*) [VAdd G P] : Prop where\n  /-- Two elements `gâ‚` and `gâ‚‚` are equal whenever they act in the same way on all points. -/\n  eq_of_vadd_eq_vadd : âˆ€ {gâ‚ gâ‚‚ : G}, (âˆ€ p : P, gâ‚ +áµ¥ p = gâ‚‚ +áµ¥ p) â†’ gâ‚ = gâ‚‚\n", "additional_info": "Typeclass for faithful actions.\n- FaithfulVAdd.eq_of_vadd_eq_vadd: Two elements `gâ‚` and `gâ‚‚` are equal whenever they act in the same way on all points.\n\n\n", "used_premises": [557], "def_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "pos": [60, 63], "informalization": "Class `FaithfulVAdd` represents a faithful vector addition operation, meaning that for any two distinct elements `gâ‚` and `gâ‚‚` of type `G`, their vector addition results in different elements for some point of type `P`."}
{"full_name": "PiProp.faithfulSMul_at", "url": "ConNF/Mathlib/GroupAction.html#PiProp.faithfulSMul_at", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.faithfulSMul_at {I : Prop } {f : I â†’ Type v} {Î± : Type u_1} [(i : I) â†’ SMulğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] [âˆ€ (i : I), NonemptyğŸ”—<|PREMISE|>ğŸ”— (f i)] (i : I) [FaithfulSMulğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] :FaithfulSMulğŸ”—<|PREMISE|>ğŸ”— Î± ((i : I) â†’ f i)", "code": "theorem faithfulSMul_at {Î± : Type _} [âˆ€ i, SMul Î± <| f i] [âˆ€ i, Nonempty (f i)] (i : I)\n    [FaithfulSMul Î± (f i)] : FaithfulSMul Î± (âˆ€ i, f i) :=\n  âŸ¨fun h =>\n    eq_of_smul_eq_smul fun a : f i => by\n      classical\n      have :=\n        congr_fun (h <| Function.update (fun j => Classical.choice (â€¹âˆ€ i, Nonempty (f i)â€º j)) i a) i\n      simpa using thisâŸ©\n", "additional_info": "If `f i` has a faithful scalar action for a given `i`, then so does `Î  i, f i`. This is\nnot an instance as `i` cannot be inferred.", "used_premises": [57, 212, 566, 566], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [87, 95], "informalization": "The theorem `PiProp.faithfulSMul_at` states that if `f i` has a faithful scalar action for a given `i`, then the product type `Î  i, f i` also has a faithful scalar action. This is not an instance because the index `i` cannot be inferred from the context."}
{"full_name": "FaithfulSMul", "url": "Mathlib/GroupTheory/GroupAction/Defs.html#FaithfulSMul", "code_src": "mathlib4", "ptype": "class", "header": "class FaithfulSMul (M : Type u_10) (Î± : Type u_11) [SMulğŸ”—<|PREMISE|>ğŸ”— M Î±] :Prop\n | eq_of_smul_eq_smul : âˆ€ {mâ‚ mâ‚‚ : M}, (âˆ€ (a : Î±), mâ‚ â€¢  a =  mâ‚‚ â€¢  a) â†’ mâ‚ =  mâ‚‚", "code": "class FaithfulSMul (M : Type*) (Î± : Type*) [SMul M Î±] : Prop where\n  /-- Two elements `mâ‚` and `mâ‚‚` are equal whenever they act in the same way on all points. -/\n  eq_of_smul_eq_smul : âˆ€ {mâ‚ mâ‚‚ : M}, (âˆ€ a : Î±, mâ‚ â€¢ a = mâ‚‚ â€¢ a) â†’ mâ‚ = mâ‚‚\n", "additional_info": "Typeclass for faithful actions.\n- FaithfulSMul.eq_of_smul_eq_smul: Two elements `mâ‚` and `mâ‚‚` are equal whenever they act in the same way on all points.\n\n\n", "used_premises": [57], "def_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "pos": [67, 70], "informalization": "Class `FaithfulSMul` represents a faithful scalar multiplication, meaning that for any two scalars `mâ‚` and `mâ‚‚`, if `mâ‚` and `mâ‚‚` act in the same way on all points, then `mâ‚` must be equal to `mâ‚‚`."}
{"full_name": "PiProp.addAction.proof_2", "url": "ConNF/Mathlib/GroupAction.html#PiProp.addAction.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addAction.proof_2 {I : Prop } {f : I â†’ Type u_1} (Î± : Type u_2) {m : AddMonoidğŸ”—<|PREMISE|>ğŸ”— Î±} [(i : I) â†’ AddActionğŸ”—<|PREMISE|>ğŸ”— Î± (f i)] :âˆ€ (x x_1 : Î±) (x_2 : (i : I) â†’ f i), x + x_1 +áµ¥ x_2 = x +áµ¥ (x_1 +áµ¥ x_2)", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31, 568], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [102, 103], "informalization": "`PiProp.addAction` is a proof that for any type `I` (which in Lean 4 is interpreted as a logical proposition), for any family of types `f : I â†’ Type u_1`, and for any additive monoid `Î±` with an additive action on each `f i`, the addition operation on `Î±` and the action of `Î±` on `f i` commute. This is a property that if holds for any `x`, `x_1` from `Î±` and `x_2` from `(i : I) â†’ f i`, then `x + x_1 +áµ¥ x_2` equals `x +áµ¥ (x_1 +áµ¥ x_2)`. This property is used to define an additive action on the Pi type `(i : I) â†’ f i` when `Î±` is an additive monoid."}
{"full_name": "AddAction", "url": "Mathlib/GroupTheory/GroupAction/Defs.html#AddAction", "code_src": "mathlib4", "ptype": "class", "header": "class AddAction (G : Type u_10) (P : Type u_11) [AddMonoidğŸ”—<|PREMISE|>ğŸ”— G] extends VAddğŸ”—<|PREMISE|>ğŸ”— :Type (max u_10 u_11)\n | vadd : G â†’ P â†’ P\n | zero_vadd : âˆ€ (p : P), 0 +áµ¥  p =  p\n | add_vadd : âˆ€ (gâ‚ gâ‚‚ : G) (p : P), gâ‚ +  gâ‚‚ +áµ¥  p =  gâ‚ +áµ¥  (gâ‚‚ +áµ¥  p)", "code": "class AddAction (G : Type*) (P : Type*) [AddMonoid G] extends VAdd G P where\n  /-- Zero is a neutral element for `+áµ¥` -/\n  protected zero_vadd : âˆ€ p : P, (0 : G) +áµ¥ p = p\n  /-- Associativity of `+` and `+áµ¥` -/\n  add_vadd : âˆ€ (gâ‚ gâ‚‚ : G) (p : P), gâ‚ + gâ‚‚ +áµ¥ p = gâ‚ +áµ¥ (gâ‚‚ +áµ¥ p)\n", "additional_info": "Type class for additive monoid actions.\n- AddAction.zero_vadd: Zero is a neutral element for `+áµ¥`\n\n\n- AddAction.add_vadd: Associativity of `+` and `+áµ¥`\n\n\n", "used_premises": [31, 557], "def_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "pos": [98, 103], "informalization": "Class `AddAction` represents the concept of an additive action of a monoid `G` on a type `P`, where `0 +áµ¥ p = p` and `(gâ‚ + gâ‚‚) +áµ¥ p = gâ‚ +áµ¥ (gâ‚‚ +áµ¥ p)`."}
{"full_name": "PiProp.addAction'.proof_2", "url": "ConNF/Mathlib/GroupAction.html#PiProp.addAction'.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addAction'.proof_2 {I : Prop } {f : I â†’ Type u_2} {g : I â†’ Type u_1} {m : (i : I) â†’ AddMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)} [(i : I) â†’ AddActionğŸ”—<|PREMISE|>ğŸ”— (f i) (g i)] :âˆ€ (x x_1 : (i : I) â†’ f i) (x_2 : (i : I) â†’ g i), x + x_1 +áµ¥ x_2 = x +áµ¥ (x_1 +áµ¥ x_2)", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31, 568], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [109, 110], "informalization": "`PiProp.addAction'.proof_2` is a proof of the associativity of the `+áµ¥` operation in a family of types parameterized by a proposition `I`, where each type is equipped with an `AddMonoid` and `AddAction` instance. The theorem asserts that for any two elements of the `I â†’ f i` type (which is a product type over `f i` for all `i : I`) and an element of the `I â†’ g i` type, the operation `+áµ¥` is associative. This property is inherent to the `AddAction` instances on each `f i` acting on each `g i`."}
{"full_name": "Equiv.orderIso_apply", "url": "ConNF/Mathlib/Transfer.html#Equiv.orderIso_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.orderIso_apply {Î± : Type u_2} {Î² : Type u_1} (e : Î± â‰ƒ Î²) [LEğŸ”—<|PREMISE|>ğŸ”— Î²] (a : Î±) :(Equiv.orderIsoğŸ”—<|PREMISE|>ğŸ”— e) a = e a", "code": "theorem orderIso_apply [LE Î²] (a : Î±) : orderIso e a = e a :=\n  rfl\n", "additional_info": "", "used_premises": [5, 571], "def_path": "ConNF/Mathlib/Transfer.lean", "pos": [88, 90], "informalization": "Function `Equiv.orderIso` constructs an order isomorphism between two types `Î±` and `Î²` given an equivalence `e : Î± â‰ƒ Î²` and a partial order on `Î²`. The application of this order isomorphism to an element `a : Î±` is equivalent to applying the equivalence `e` to `a`."}
{"full_name": "Equiv.orderIso", "url": "ConNF/Mathlib/Transfer.html#Equiv.orderIso", "code_src": "con-nf", "ptype": "def", "header": "def Equiv.orderIso {Î± : Type u_1} {Î² : Type u_2} (e : Î± â‰ƒ Î²) [LEğŸ”—<|PREMISE|>ğŸ”— Î²] :Î± â‰ƒo Î²", "code": "def orderIso (e : Î± â‰ƒ Î²) [LE Î²] :\n    letI := e.hasLe\n    Î± â‰ƒo Î² :=\n  by intros; exact { e with map_rel_iff' := fun {a b} => Iff.rfl }\n", "additional_info": "An equivalence `e : Î± â‰ƒ Î²` gives a suptiplicative equivalence `Î± â‰ƒâŠ” Î²` where the suptiplicative\nstructure on `Î±` is the top obtained by transporting a suptiplicative structure on `Î²` back along\n`e`.\nEquations\n* ğŸ—ŸEquiv.orderIsoğŸ—ŸğŸ”—../.././ConNF/Mathlib/Transfer.html#Equiv.orderIsoğŸ”—  e ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  { toEquiv := e, map_rel_iff' := â‹¯ }\n\n", "used_premises": [5], "def_path": "ConNF/Mathlib/Transfer.lean", "pos": [82, 86], "informalization": "Function `Equiv.orderIso` constructs an order isomorphism between two types `Î±` and `Î²` given an equivalence `e : Î± â‰ƒ Î²` and a partial order on `Î²`."}
{"full_name": "Set.neg_sUnion", "url": "ConNF/Mathlib/Pointwise.html#Set.neg_sUnion", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.neg_sUnion {Î± : Type u_1} [InvolutiveNegğŸ”—<|PREMISE|>ğŸ”— Î±] (S : SetğŸ”—<|PREMISE|>ğŸ”— (SetğŸ”—<|PREMISE|>ğŸ”— Î±)) :- â‹ƒâ‚€ S = â‹ƒ s âˆˆ S, - s", "code": "@[to_additive (attr := simp)]\n", "additional_info": "", "used_premises": [573, 69, 69], "def_path": "ConNF/Mathlib/Pointwise.lean", "pos": [13, 14], "informalization": "The negation of the union of a set of sets is equal to the union of the negation of each set in the set of sets."}
{"full_name": "InvolutiveNeg", "url": "Mathlib/Algebra/Group/Defs.html#InvolutiveNeg", "code_src": "mathlib4", "ptype": "class", "header": "class InvolutiveNeg (A : Type u_2) extends NegğŸ”—<|PREMISE|>ğŸ”— :Type u_2\n | neg : A â†’ A\n | neg_neg : âˆ€ (x : A), -  - x =  x", "code": "class InvolutiveNeg (A : Type*) extends Neg A where\n  protected neg_neg : âˆ€ x : A, - -x = x\n", "additional_info": "Auxiliary typeclass for types with an involutive `ğŸ—ŸNegğŸ—ŸğŸ”—../../.././Init/Prelude.html#NegğŸ”—` .\n", "used_premises": [574], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [794, 796], "informalization": "Class `InvolutiveNeg` represents a type with a negation operation that is involutive, meaning applying the negation twice returns the original element."}
{"full_name": "Neg", "url": "Init/Prelude.html#Neg", "code_src": "lean4", "ptype": "class", "header": "class Neg (Î± : Type u) :Type u\n | neg : Î± â†’ Î±", "code": "class Neg (Î± : Type u) where\n  /-- `-a` computes the negative or opposite of `a`.\n  The meaning of this notation is type-dependent. -/\n  neg : Î± â†’ Î±\n", "additional_info": "The notation typeclass for negation.\nThis enables the notation `-a : Î±` where `a : Î±`.\n- Neg.neg: `-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent.\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1307, 1311], "informalization": "Class `Neg` represents the concept of negation, which is a unary operation that computes the negative or opposite of an element. This operation is type-dependent, meaning its interpretation can vary based on the specific type of the element involved."}
{"full_name": "Set.inv_sUnion", "url": "ConNF/Mathlib/Pointwise.html#Set.inv_sUnion", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.inv_sUnion {Î± : Type u_1} [InvolutiveInvğŸ”—<|PREMISE|>ğŸ”— Î±] (S : SetğŸ”—<|PREMISE|>ğŸ”— (SetğŸ”—<|PREMISE|>ğŸ”— Î±)) :(â‹ƒâ‚€ S)â»Â¹ = â‹ƒ s âˆˆ S, sâ»Â¹", "code": "theorem inv_sUnion (S : Set (Set Î±)) : (â‹ƒâ‚€ S)â»Â¹ = â‹ƒ s âˆˆ S, sâ»Â¹ := by\n  simp_rw [â† image_inv, image_sUnion]\n", "additional_info": "", "used_premises": [576, 69, 69], "def_path": "ConNF/Mathlib/Pointwise.lean", "pos": [14, 16], "informalization": "The theorem `Set.inv_sUnion` states that the inverse of the union of a set of sets is equal to the union of the inverses of each set in the set of sets."}
{"full_name": "InvolutiveInv", "url": "Mathlib/Algebra/Group/Defs.html#InvolutiveInv", "code_src": "mathlib4", "ptype": "class", "header": "class InvolutiveInv (G : Type u_2) extends InvğŸ”—<|PREMISE|>ğŸ”— :Type u_2\n | inv : G â†’ G\n | inv_inv : âˆ€ (x : G), xâ»Â¹ â»Â¹  =  x", "code": "class InvolutiveInv (G : Type*) extends Inv G where\n  protected inv_inv : âˆ€ x : G, xâ»Â¹â»Â¹ = x\n", "additional_info": "Auxiliary typeclass for types with an involutive `ğŸ—ŸInvğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#InvğŸ”—` .\n", "used_premises": [47], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [801, 803], "informalization": "Class `InvolutiveInv` represents a type with an involutive inverse operation. This means that for any element `x` of the type, applying the inverse operation twice returns the original element, i.e., `xâ»Â¹â»Â¹ = x`. This class is useful in contexts where the inverse operation is expected to be its own inverse, such as complex conjugation or taking the conjugate transpose of a matrix."}
{"full_name": "Set.addActionNonempty.proof_1", "url": "ConNF/Mathlib/Pointwise.html#Set.addActionNonempty.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Set.addActionNonempty.proof_1 {Î² : Type u_1} :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— fun (a : { s : SetğŸ”—<|PREMISE|>ğŸ”— Î² // Set.NonemptyğŸ”—<|PREMISE|>ğŸ”— s }) => â†‘a", "code": "@[to_additive \"An additive action on a type gives an additive action on its nonempty sets.\"]\n", "additional_info": "", "used_premises": [89, 69, 83], "def_path": "ConNF/Mathlib/Pointwise.lean", "pos": [45, 46], "informalization": "The function `fun (a : { s : Set Î² // Set.Nonempty s }) => â†‘a` is injective."}
{"full_name": "Equiv.symm_trans", "url": "ConNF/Mathlib/Equiv.html#Equiv.symm_trans", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.symm_trans {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â‰ƒ Î²) (g : Î² â‰ƒ Î³) :(f.trans g).symm = g.symm.trans f.symm", "code": "theorem symm_trans (f : Î± â‰ƒ Î²) (g : Î² â‰ƒ Î³) : (f.trans g).symm = g.symm.trans f.symm :=\n  rfl\n", "additional_info": "", "used_premises": [], "def_path": "ConNF/Mathlib/Equiv.lean", "pos": [7, 9], "informalization": "The theorem `Equiv.symm_trans` states that for any two equivalences `f : Î± â‰ƒ Î²` and `g : Î² â‰ƒ Î³`, the inverse of their composition `f.trans g` is equal to the composition of their inverses `g.symm.trans f.symm`."}
{"full_name": "PiProp.addSemigroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addSemigroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addSemigroup.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddSemigroupğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) (c : (i : I) â†’ f i) :a + b + c = a + (b + c)", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [32], "def_path": "ConNF/Mathlib/Group.lean", "pos": [38, 39], "informalization": "`PiProp.addSemigroup.proof_1` is a proof of the associativity of addition in a product of additive semigroups."}
{"full_name": "PiProp.addCommSemigroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addCommSemigroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addCommSemigroup.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddCommSemigroupğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) :a + b = b + a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [581], "def_path": "ConNF/Mathlib/Group.lean", "pos": [51, 52], "informalization": "The `PiProp.addCommSemigroup.proof_1` theorem is a proof that the binary operation `+` on the set `(I â†’ Type u_1)` of functions from a type `I` to a type `Type u_1`, where each `f i` is an `AddCommSemigroup`, is commutative. This is because `+` is defined pointwise on the components of the functions, and for each `i`, the operation `+` on `f i` is commutative by the `AddCommSemigroup` assumption."}
{"full_name": "AddCommSemigroup", "url": "Mathlib/Algebra/Group/Defs.html#AddCommSemigroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddCommSemigroup (G : Type u) extends AddSemigroupğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : G â†’ G â†’ G\n | add_assoc : âˆ€ (a b c : G), a +  b +  c =  a +  (b +  c)\n | add_comm : âˆ€ (a b : G), a +  b =  b +  a", "code": "class AddCommSemigroup (G : Type u) extends AddSemigroup G, AddCommMagma G where\n", "additional_info": "A commutative additive semigroup is a type with an associative commutative `(+)`.\n- AddCommSemigroup.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [32], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [315, 316], "informalization": "Class `AddCommSemigroup` represents a type with an associative and commutative addition operation."}
{"full_name": "PiProp.addZeroClass.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addZeroClass.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addZeroClass.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddZeroClassğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :0 + a = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [583], "def_path": "ConNF/Mathlib/Group.lean", "pos": [57, 58], "informalization": "The theorem `PiProp.addZeroClass.proof_1` states that for any type family `f : I â†’ Type u_1` where each `f i` is an `AddZeroClass`, the zero element of the product type `(i : I) â†’ f i` (denoted as `0`) added to any element `a` of the product type results in `a`."}
{"full_name": "AddZeroClass", "url": "Mathlib/Algebra/Group/Defs.html#AddZeroClass", "code_src": "mathlib4", "ptype": "class", "header": "class AddZeroClass (M : Type u) extends ZeroğŸ”—<|PREMISE|>ğŸ”— , AddğŸ”—<|PREMISE|>ğŸ”— :Type u\n | zero : M\n | add : M â†’ M â†’ M\n | zero_add : âˆ€ (a : M), 0 +  a =  a\n | add_zero : âˆ€ (a : M), a +  0 =  a", "code": "class AddZeroClass (M : Type u) extends Zero M, Add M where\n  /-- Zero is a left neutral element for addition -/\n  protected zero_add : âˆ€ a : M, 0 + a = a\n  /-- Zero is a right neutral element for addition -/\n  protected add_zero : âˆ€ a : M, a + 0 = a\n", "additional_info": "Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`.\n- AddZeroClass.zero_add: Zero is a left neutral element for addition\n\n\n- AddZeroClass.add_zero: Zero is a right neutral element for addition\n\n\n", "used_premises": [20, 33], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [449, 454], "informalization": "Class `AddZeroClass` represents a type with an additive identity (zero) and an addition operation that satisfies both left and right neutrality of zero."}
{"full_name": "PiProp.addZeroClass.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.addZeroClass.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addZeroClass.proof_2 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddZeroClassğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :a + 0 = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [583], "def_path": "ConNF/Mathlib/Group.lean", "pos": [57, 58], "informalization": "`PiProp.addZeroClass.proof_2` is a proof of the statement that for any type family `f : I â†’ Type u_1` where each `f i` is an `AddZeroClass`, and any dependent function `a : (i : I) â†’ f i`, the equation `a + 0 = a` holds."}
{"full_name": "PiProp.addMonoid.proof_4", "url": "ConNF/Mathlib/Group.html#PiProp.addMonoid.proof_4", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addMonoid.proof_4 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ AddMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (n : â„• ) (a : (i : I) â†’ f i) :(fun (n : â„• ) (x : (i : I) â†’ f i) (i : I) => n â€¢ x i) (n + 1) a = a + (fun (n : â„• ) (x : (i : I) â†’ f i) (i : I) => n â€¢ x i) n a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31], "def_path": "ConNF/Mathlib/Group.lean", "pos": [65, 66], "informalization": "The theorem `PiProp.addMonoid.proof_4` in Lean 4 is a part of the proof that the Pi-type `(I â†’ f i)` forms an additive monoid when each `f i` is an additive monoid. It asserts that the addition of a natural number `n` to each element of a function-type `(i : I) â†’ f i` at each index `i`, followed by the addition of a function-type `(i : I) â†’ f i` itself, results in the function-type being unchanged when `n = 1`. This is essentially the property that the addition of `1` to a natural number `n` results in a function that is the identity function on `f i` at each index `i`."}
{"full_name": "PiProp.addMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ AddMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :0 + a = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31], "def_path": "ConNF/Mathlib/Group.lean", "pos": [65, 66], "informalization": "`PiProp.addMonoid.proof_1` is a proof that for any type `I` and any family of types `f : I â†’ Type u_1`, if each `f i` is an `AddMonoid`, then the addition defined pointwise on the product type `(i : I) â†’ f i` satisfies the property of an additive monoid that `0 + a = a`. This is one of the axioms of an additive monoid, stating that the zero element, when added to any element, results in the original element."}
{"full_name": "PiProp.addMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.addMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addMonoid.proof_2 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ AddMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :a + 0 = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31], "def_path": "ConNF/Mathlib/Group.lean", "pos": [65, 66], "informalization": "The theorem `PiProp.addMonoid.proof_2` states that for any family of types `f : I â†’ Type u_1` where each `f i` is an additive monoid, the sum of any function `a : (i : I) â†’ f i` with the zero function is equal to `a`."}
{"full_name": "PiProp.addMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.addMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addMonoid.proof_3 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ AddMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :(fun (n : â„• ) (x : (i : I) â†’ f i) (i : I) => n â€¢ x i) 0 a = 0", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31], "def_path": "ConNF/Mathlib/Group.lean", "pos": [65, 66], "informalization": "`PiProp.addMonoid.proof_3` proves that for any type family `f : I â†’ Type u_1` where each `f i` is an additive monoid, and any `a : (i : I) â†’ f i`, the operation `(fun (n : â„•) (x : (i : I) â†’ f i) (i : I) â†¦ n â€¢ x i)` applied to `0` and `a` results in `0`."}
{"full_name": "PiProp.addCommMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addCommMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addCommMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddCommMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) :a + b = b + a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [590], "def_path": "ConNF/Mathlib/Group.lean", "pos": [74, 75], "informalization": "`PiProp.addCommMonoid.proof_1` is a proof that for any family of additive commutative monoids, the Pi type of that family is also an additive commutative monoid, where the addition operation is defined component-wise. This is essentially stating that the addition operation in the Pi type is commutative."}
{"full_name": "AddCommMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddCommMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddCommMonoid (M : Type u) extends AddMonoidğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : M â†’ M â†’ M\n | add_assoc : âˆ€ (a b c : M), a +  b +  c =  a +  (b +  c)\n | zero : M\n | zero_add : âˆ€ (a : M), 0 +  a =  a\n | add_zero : âˆ€ (a : M), a +  0 =  a\n | nsmul : â„•  â†’ M â†’ M\n | nsmul_zero : âˆ€ (x : M), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : M), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | add_comm : âˆ€ (a b : M), a +  b =  b +  a", "code": "class AddCommMonoid (M : Type u) extends AddMonoid M, AddCommSemigroup M\n", "additional_info": "An additive commutative monoid is an additive monoid with commutative `(+)`.\n- AddCommMonoid.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [31, 34, 34, 34], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [674, 675], "informalization": "Class `AddCommMonoid` represents the concept of an additive commutative monoid. An additive commutative monoid is an additive monoid (a type with an associative addition operation, a zero element, and a natural number multiplication operation) where the addition operation is commutative."}
{"full_name": "PiProp.subNegMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.subNegMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subNegMonoid.proof_2 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ SubNegMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] :âˆ€ (a : (i : I) â†’ f i), zsmulRec 0 a = zsmulRec 0 a", "code": "@[to_additive PiProp.subNegMonoid]\n", "additional_info": "", "used_premises": [592], "def_path": "ConNF/Mathlib/Group.lean", "pos": [80, 81], "informalization": "Given a type I, the Pi type (I â†’ Type u_1) is also a SubNegMonoid if each component type (f i) is a SubNegMonoid. The theorem `PiProp.subNegMonoid.proof_2` is a part of the proof that the Pi type (I â†’ Type u_1) is a SubNegMonoid. The theorem states that for any element a of the type (I â†’ Type u_1), multiplying a by 0 using the integer scalar multiplication `zsmulRec` (which is a recursive version of `zsmul`) results in the same value as multiplying a by 0 using `zsmulRec`. This is the second part of the proof that `zsmulRec 0 a` is equal to `zsmulRec 0 a`, which is a trivial equality and does not require any further simplification."}
{"full_name": "SubNegMonoid", "url": "Mathlib/Algebra/Group/Defs.html#SubNegMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class SubNegMonoid (G : Type u) extends AddMonoidğŸ”—<|PREMISE|>ğŸ”— , NegğŸ”—<|PREMISE|>ğŸ”— , SubğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : G â†’ G â†’ G\n | add_assoc : âˆ€ (a b c : G), a +  b +  c =  a +  (b +  c)\n | zero : G\n | zero_add : âˆ€ (a : G), 0 +  a =  a\n | add_zero : âˆ€ (a : G), a +  0 =  a\n | nsmul : â„•  â†’ G â†’ G\n | nsmul_zero : âˆ€ (x : G), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : G), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | neg : G â†’ G\n | sub : G â†’ G â†’ G\n | sub_eq_add_neg : âˆ€ (a b : G), a -  b =  a +  - b\n | zsmul : â„¤  â†’ G â†’ G\n | zsmul_zero' : âˆ€ (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  0 a =  0\n | zsmul_succ' : âˆ€ (n : â„• ) (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  (Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a =  a +  SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  n) a\n | zsmul_neg' : âˆ€ (n : â„• ) (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.negSuccğŸ”—<|PREMISE|>ğŸ”—  n) a =  - SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (â†‘(Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a", "code": "class SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : âˆ€ a b : G, a - b = a + -b := by intros; rfl\n  protected zsmul : â„¤ â†’ G â†’ G := zsmulRec\n  protected zsmul_zero' : âˆ€ a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : â„•) (a : G) :\n      zsmul (Int.ofNat n.succ) a = a + zsmul (Int.ofNat n) a := by\n    intros; rfl\n  protected zsmul_neg' (n : â„•) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by intros; rfl\n", "additional_info": "A `ğŸ—ŸSubNegMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#SubNegMonoidğŸ”—`  is an `ğŸ—ŸAddMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddMonoidğŸ”—`  with unary `-` and binary `-` operations\nsatisfying `ğŸ—Ÿsub_eq_add_negğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#sub_eq_add_negğŸ”—  : âˆ€ a b, a - b = a + -b`.\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `âˆ€ X, ğŸ—ŸSubğŸ—ŸğŸ”—../../.././Init/Prelude.html#SubğŸ”—  (Foo X)` instance but no\n`âˆ€ X, ğŸ—ŸNegğŸ—ŸğŸ”—../../.././Init/Prelude.html#NegğŸ”—  (Foo X)`. Suppose we also have an instance\n`âˆ€ X [Cromulent X], ğŸ—ŸAddGroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddGroupğŸ”—  (Foo X)`. Then the `(-)` coming from\n`AddGroup.sub` cannot be definitionally equal to the `(-)` coming from\n`Foo.ğŸ—ŸSubğŸ—ŸğŸ”—../../.././Init/Prelude.html#SubğŸ”—` .\nIn the same way, adding a `ğŸ—ŸzsmulğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#SubNegMonoid.zsmulğŸ”—`  field makes it possible to avoid definitional failures\nin diamonds. See the definition of `ğŸ—ŸAddMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddMonoidğŸ”—`  and Note [forgetful inheritance] for more\nexplanations on this.\n", "used_premises": [31, 574, 35, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [918, 927], "informalization": "Class `SubNegMonoid` represents the concept of a type `G` that extends an additive monoid (`AddMonoid`) with additional operations: negation (`Neg`) and subtraction (`Sub`). This algebraic structure includes all the properties of an additive monoid, such as associative addition, a zero element, and natural number scalar multiplication (`nsmul`), along with the unary operation of negation and the binary operation of subtraction. The subtraction operation is defined in terms of addition and negation, satisfying the property `sub_eq_add_neg`, which states that subtracting an element is equivalent to adding its negation. Additionally, `SubNegMonoid` introduces integer scalar multiplication (`zsmul`), which extends the natural number scalar multiplication to include negative integers, providing a more comprehensive framework for handling scalar operations in the context of additive structures. This class is designed to avoid certain unification failures and definitional ambiguities that can arise in more complex type hierarchies, ensuring a robust and flexible approach to defining and working with additive algebraic structures."}
{"full_name": "SubNegMonoid.zsmul", "url": "Mathlib/Algebra/Group/Defs.html#SubNegMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field SubNegMonoidğŸ”—<|PREMISE|>ğŸ”—.zsmul : â„¤  â†’ G â†’ G", "code": "class SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : âˆ€ a b : G, a - b = a + -b := by intros; rfl\n  protected zsmul : â„¤ â†’ G â†’ G := zsmulRec\n  protected zsmul_zero' : âˆ€ a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : â„•) (a : G) :\n      zsmul (Int.ofNat n.succ) a = a + zsmul (Int.ofNat n) a := by\n    intros; rfl\n  protected zsmul_neg' (n : â„•) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by intros; rfl\n", "additional_info": "", "used_premises": [592], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [918, 927], "informalization": "Function `SubNegMonoid.zsmul` takes an integer and an element from a type `G` that extends an additive monoid with negation and subtraction, and returns the result of their multiplication, extending natural number scalar multiplication to include negative integers."}
{"full_name": "PiProp.subNegMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.subNegMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subNegMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ SubNegMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) :a - b = a + - b", "code": "@[to_additive PiProp.subNegMonoid]\n", "additional_info": "", "used_premises": [592], "def_path": "ConNF/Mathlib/Group.lean", "pos": [80, 81], "informalization": "The theorem `PiProp.subNegMonoid.proof_1` states that for any type family `f : I â†’ Type u_1` where each `f i` is a `SubNegMonoid`, the subtraction operation on the Pi type `(i : I) â†’ f i` is equivalent to addition with the negation of the second operand."}
{"full_name": "PiProp.subNegMonoid.proof_4", "url": "ConNF/Mathlib/Group.html#PiProp.subNegMonoid.proof_4", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subNegMonoid.proof_4 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ SubNegMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] :âˆ€ (n : â„• ) (a : (i : I) â†’ f i), zsmulRec (Int.negSuccğŸ”—<|PREMISE|>ğŸ”— n) a = zsmulRec (Int.negSuccğŸ”—<|PREMISE|>ğŸ”— n) a", "code": "@[to_additive PiProp.subNegMonoid]\n", "additional_info": "", "used_premises": [592, 54, 54], "def_path": "ConNF/Mathlib/Group.lean", "pos": [80, 81], "informalization": "The `PiProp.subNegMonoid.proof_4` theorem is a proof of the property that `zsmulRec (Int.negSucc n) a` equals itself, which is a part of extending the `SubNegMonoid` class to the pi-type `âˆ€ i, f i` where each `f i` is a `SubNegMonoid`. This theorem ensures that the negation operation `zsmulRec` on negative integers satisfies the properties required by the `SubNegMonoid` class."}
{"full_name": "PiProp.subNegMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.subNegMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subNegMonoid.proof_3 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ SubNegMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] :âˆ€ (n : â„• ) (a : (i : I) â†’ f i), zsmulRec (Int.ofNatğŸ”—<|PREMISE|>ğŸ”— (Nat.succğŸ”—<|PREMISE|>ğŸ”— n)) a = zsmulRec (Int.ofNatğŸ”—<|PREMISE|>ğŸ”— (Nat.succğŸ”—<|PREMISE|>ğŸ”— n)) a", "code": "@[to_additive PiProp.subNegMonoid]\n", "additional_info": "", "used_premises": [592, 50, 53, 50, 53], "def_path": "ConNF/Mathlib/Group.lean", "pos": [80, 81], "informalization": "The proof `PiProp.subNegMonoid.proof_3` is a part of the proof that the Pi type (a dependent function type) of `SubNegMonoid`s is itself a `SubNegMonoid`. This proof is specifically for the case when the exponent in the zsmul (scalar multiplication by an integer) is a natural number with a successor (i.e., a whole number plus one). It asserts that for any natural number `n` and any dependent function `a` (an element of the Pi type), the zsmul operation using `Int.ofNat (Nat.succ n)` (which represents the successor of `n` as an integer) on `a` is equal to itself, which is a trivial statement in the context of the successor operation. This proof is part of the construction of the `SubNegMonoid` instance for the Pi type, which is necessary for the development of the Lean mathematical library."}
{"full_name": "PiProp.hasInvolutiveNeg.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.hasInvolutiveNeg.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.hasInvolutiveNeg.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ InvolutiveNegğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :- - a = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [573], "def_path": "ConNF/Mathlib/Group.lean", "pos": [87, 88], "informalization": "The theorem `PiProp.hasInvolutiveNeg.proof_1` states that for any family of types `f : I â†’ Type u_1` where each type `f i` has an involutive negation, the negation of a dependent function `a : (i : I) â†’ f i` is equal to the function itself, i.e., `- - a = a`."}
{"full_name": "PiProp.subtractionMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.subtractionMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subtractionMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ SubtractionMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (x : (i : I) â†’ f i) :- - x = x", "code": "@[to_additive PiProp.subtractionMonoid]\n", "additional_info": "", "used_premises": [599], "def_path": "ConNF/Mathlib/Group.lean", "pos": [93, 94], "informalization": "This theorem states that, for any function `x` from a type `I` to a family of types `f i`, where each `f i` is a `SubtractionMonoid`, the negation of `x` is equal to `x` itself. This property only holds under certain conditions, specifically when the domain `I` is a proposition, which means it contains only two elements: `True` and `False`. In this context, `x`, being a function from a proposition to a type, essentially represents a single value when evaluated at `True` or `False`. The negation of `x`, which in the context of `SubtractionMonoid` is defined as `-x`, results in the same value as `x`, as indicated by the equation `- - x = x`. This behavior aligns with the properties of `SubtractionMonoid`, where negating a number twice returns the original number, and thus, negating a function from a proposition to a `SubtractionMonoid` type results in the same function."}
{"full_name": "SubtractionMonoid", "url": "Mathlib/Algebra/Group/Defs.html#SubtractionMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class SubtractionMonoid (G : Type u) extends SubNegMonoidğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : G â†’ G â†’ G\n | add_assoc : âˆ€ (a b c : G), a +  b +  c =  a +  (b +  c)\n | zero : G\n | zero_add : âˆ€ (a : G), 0 +  a =  a\n | add_zero : âˆ€ (a : G), a +  0 =  a\n | nsmul : â„•  â†’ G â†’ G\n | nsmul_zero : âˆ€ (x : G), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : G), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | neg : G â†’ G\n | sub : G â†’ G â†’ G\n | sub_eq_add_neg : âˆ€ (a b : G), a -  b =  a +  - b\n | zsmul : â„¤  â†’ G â†’ G\n | zsmul_zero' : âˆ€ (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  0 a =  0\n | zsmul_succ' : âˆ€ (n : â„• ) (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  (Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a =  a +  SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  n) a\n | zsmul_neg' : âˆ€ (n : â„• ) (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.negSuccğŸ”—<|PREMISE|>ğŸ”—  n) a =  - SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (â†‘(Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a\n | neg_neg : âˆ€ (x : G), -  - x =  x\n | neg_add_rev : âˆ€ (a b : G), - (a +  b) =  - b +  - a\n | neg_eq_of_add : âˆ€ (a b : G), a +  b =  0 â†’ - a =  b", "code": "class SubtractionMonoid (G : Type u) extends SubNegMonoid G, InvolutiveNeg G where\n  protected neg_add_rev (a b : G) : -(a + b) = -b + -a\n  /- Despite the asymmetry of `neg_eq_of_add`, the symmetric version is true thanks to the\n  involutivity of negation. -/\n  protected neg_eq_of_add (a b : G) : a + b = 0 â†’ -a = b\n", "additional_info": "A `ğŸ—ŸSubtractionMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#SubtractionMonoidğŸ”—`  is a `ğŸ—ŸSubNegMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#SubNegMonoidğŸ”—`  with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 â†’ -a = b`.\n", "used_premises": [592, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1039, 1044], "informalization": "The `SubtractionMonoid` class in Lean 4 is an extension of the `SubNegMonoid` class, which represents a type `G` that extends an additive monoid with additional operations: negation (`Neg`) and subtraction (`Sub`). This algebraic structure includes all the properties of an additive monoid, such as associative addition, a zero element, and natural number scalar multiplication (`nsmul`), along with the unary operation of negation and the binary operation of subtraction. The subtraction operation is defined in terms of addition and negation, satisfying the property `sub_eq_add_neg`, which states that subtracting an element is equivalent to adding its negation. Additionally, `SubtractionMonoid` introduces integer scalar multiplication (`zsmul`), which extends the natural number scalar multiplication to include negative integers, providing a more comprehensive framework for handling scalar operations in the context of additive algebraic structures. This class is designed to avoid certain unification failures and definitional ambiguities that can arise in more complex type hierarchies, ensuring a robust and flexible approach to defining and working with additive algebraic structures."}
{"full_name": "PiProp.subtractionMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.subtractionMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subtractionMonoid.proof_2 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ SubtractionMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) :- (a + b) = - b + - a", "code": "@[to_additive PiProp.subtractionMonoid]\n", "additional_info": "", "used_premises": [599], "def_path": "ConNF/Mathlib/Group.lean", "pos": [93, 94], "informalization": "`PiProp.subtractionMonoid.proof_2` is a proof of the property for the negation operation in the `SubtractionMonoid` class in Lean 4. It states that for any two elements `a` and `b` in the product type `(i : I) â†’ f i`, where each component `f i` is a subtraction monoid, the negation of the sum `- (a + b)` is equal to the sum of the negations `- b + - a`. This property is crucial for establishing the full subtraction monoid structure in the product type."}
{"full_name": "PiProp.subtractionMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.subtractionMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subtractionMonoid.proof_3 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ SubtractionMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) (h : a + b = 0) :- a = b", "code": "@[to_additive PiProp.subtractionMonoid]\n", "additional_info": "", "used_premises": [599], "def_path": "ConNF/Mathlib/Group.lean", "pos": [93, 94], "informalization": "In mathematics, the concept of subtraction is defined as the inverse of addition. In an algebraic structure where addition is commutative, subtraction is well-defined as a binary operation, and the structure is known as a commutative group. The `SubtractionMonoid` class in Lean 4 represents a type `G` that extends an additive monoid with additional operations, including subtraction. Given an instance of `SubtractionMonoid` for a type `G`, we can define a subtraction operation `a - b` on elements of `G` using the `Sub.sub` function. The theorem `PiProp.subtractionMonoid.proof_3` asserts that for a type `G` that is a `SubtractionMonoid`, in a pointwise manner, if the sum of two elements `a` and `b` of type `G` is equal to zero, then `a` must be equal to `b`. This theorem is crucial for establishing the uniqueness of negation in a `SubtractionMonoid`, which is part of the definition of a `SubtractionMonoid`."}
{"full_name": "PiProp.subtractionCommMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.subtractionCommMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subtractionCommMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ SubtractionCommMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) :a + b = b + a", "code": "@[to_additive PiProp.subtractionCommMonoid]\n", "additional_info": "", "used_premises": [603], "def_path": "ConNF/Mathlib/Group.lean", "pos": [101, 102], "informalization": "`PiProp.subtractionCommMonoid.proof_1` is a proof of the commutativity of addition in a product of subtraction commutative monoids."}
{"full_name": "SubtractionCommMonoid", "url": "Mathlib/Algebra/Group/Defs.html#SubtractionCommMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class SubtractionCommMonoid (G : Type u) extends SubtractionMonoidğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : G â†’ G â†’ G\n | add_assoc : âˆ€ (a b c : G), a +  b +  c =  a +  (b +  c)\n | zero : G\n | zero_add : âˆ€ (a : G), 0 +  a =  a\n | add_zero : âˆ€ (a : G), a +  0 =  a\n | nsmul : â„•  â†’ G â†’ G\n | nsmul_zero : âˆ€ (x : G), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : G), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | neg : G â†’ G\n | sub : G â†’ G â†’ G\n | sub_eq_add_neg : âˆ€ (a b : G), a -  b =  a +  - b\n | zsmul : â„¤  â†’ G â†’ G\n | zsmul_zero' : âˆ€ (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  0 a =  0\n | zsmul_succ' : âˆ€ (n : â„• ) (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  (Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a =  a +  SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  n) a\n | zsmul_neg' : âˆ€ (n : â„• ) (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.negSuccğŸ”—<|PREMISE|>ğŸ”—  n) a =  - SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (â†‘(Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a\n | neg_neg : âˆ€ (x : G), -  - x =  x\n | neg_add_rev : âˆ€ (a b : G), - (a +  b) =  - b +  - a\n | neg_eq_of_add : âˆ€ (a b : G), a +  b =  0 â†’ - a =  b\n | add_comm : âˆ€ (a b : G), a +  b =  b +  a", "code": "class SubtractionCommMonoid (G : Type u) extends SubtractionMonoid G, AddCommMonoid G\n", "additional_info": "Commutative `ğŸ—ŸSubtractionMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#SubtractionMonoidğŸ”—` .\n- SubtractionCommMonoid.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [599, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1091, 1092], "informalization": "Class `SubtractionCommMonoid` represents a commutative group that is also a subtraction monoid, meaning it has operations of addition, negation, subtraction, and scalar multiplication by both natural numbers and integers, all of which are commutative."}
{"full_name": "PiProp.addGroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addGroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addGroup.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddGroupğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :- a + a = 0", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [605], "def_path": "ConNF/Mathlib/Group.lean", "pos": [107, 108], "informalization": "Function `PiProp.addGroup.proof_1` is a proof that for any type family `f : I â†’ Type u_1` where each `f i` is an additive group, the sum of any element `a : (i : I) â†’ f i` with itself is equal to zero."}
{"full_name": "AddGroup", "url": "Mathlib/Algebra/Group/Defs.html#AddGroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddGroup (A : Type u) extends SubNegMonoidğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : A â†’ A â†’ A\n | add_assoc : âˆ€ (a b c : A), a +  b +  c =  a +  (b +  c)\n | zero : A\n | zero_add : âˆ€ (a : A), 0 +  a =  a\n | add_zero : âˆ€ (a : A), a +  0 =  a\n | nsmul : â„•  â†’ A â†’ A\n | nsmul_zero : âˆ€ (x : A), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : A), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | neg : A â†’ A\n | sub : A â†’ A â†’ A\n | sub_eq_add_neg : âˆ€ (a b : A), a -  b =  a +  - b\n | zsmul : â„¤  â†’ A â†’ A\n | zsmul_zero' : âˆ€ (a : A), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  0 a =  0\n | zsmul_succ' : âˆ€ (n : â„• ) (a : A), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  (Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a =  a +  SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  n) a\n | zsmul_neg' : âˆ€ (n : â„• ) (a : A), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.negSuccğŸ”—<|PREMISE|>ğŸ”—  n) a =  - SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (â†‘(Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a\n | add_left_neg : âˆ€ (a : A), - a +  a =  0", "code": "class AddGroup (A : Type u) extends SubNegMonoid A where\n  protected add_left_neg : âˆ€ a : A, -a + a = 0\n", "additional_info": "An `ğŸ—ŸAddGroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddGroupğŸ”—`  is an `ğŸ—ŸAddMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddMonoidğŸ”—`  with a unary `-` satisfying `-a + a = 0`.\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition.\nUse `AddGroup.ofLeftAxioms` or `AddGroup.ofRightAxioms` to define an\nadditive group structure on a type with the minumum proof obligations.\n", "used_premises": [592, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1123, 1125], "informalization": "Class `AddGroup` represents the concept of an additive group, which is an additive monoid with an additional operation of negation that satisfies the property of having an inverse for every element, ensuring that the sum of any element and its negation equals the zero element."}
{"full_name": "PiProp.addCommGroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addCommGroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addCommGroup.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddCommGroupğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) :a + b = b + a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [607], "def_path": "ConNF/Mathlib/Group.lean", "pos": [113, 114], "informalization": "Function `PiProp.addCommGroup.proof_1` is a proof of the commutativity of addition in a product of additive commutative groups."}
{"full_name": "AddCommGroup", "url": "Mathlib/Algebra/Group/Defs.html#AddCommGroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddCommGroup (G : Type u) extends AddGroupğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : G â†’ G â†’ G\n | add_assoc : âˆ€ (a b c : G), a +  b +  c =  a +  (b +  c)\n | zero : G\n | zero_add : âˆ€ (a : G), 0 +  a =  a\n | add_zero : âˆ€ (a : G), a +  0 =  a\n | nsmul : â„•  â†’ G â†’ G\n | nsmul_zero : âˆ€ (x : G), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : G), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | neg : G â†’ G\n | sub : G â†’ G â†’ G\n | sub_eq_add_neg : âˆ€ (a b : G), a -  b =  a +  - b\n | zsmul : â„¤  â†’ G â†’ G\n | zsmul_zero' : âˆ€ (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  0 a =  0\n | zsmul_succ' : âˆ€ (n : â„• ) (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  (Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a =  a +  SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.ofNatğŸ”—<|PREMISE|>ğŸ”—  n) a\n | zsmul_neg' : âˆ€ (n : â„• ) (a : G), SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (Int.negSuccğŸ”—<|PREMISE|>ğŸ”—  n) a =  - SubNegMonoid.zsmulğŸ”—<|PREMISE|>ğŸ”—  (â†‘(Nat.succğŸ”—<|PREMISE|>ğŸ”—  n)) a\n | add_left_neg : âˆ€ (a : G), - a +  a =  0\n | add_comm : âˆ€ (a b : G), a +  b =  b +  a", "code": "class AddCommGroup (G : Type u) extends AddGroup G, AddCommMonoid G\n", "additional_info": "An additive commutative group is an additive group with commutative `(+)`.\n- AddCommGroup.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [605, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1202, 1203], "informalization": "Class `AddCommGroup` represents the concept of an additive commutative group, which is an additive group with the additional property that addition is commutative."}
{"full_name": "PiProp.AddLeftCancelSemigroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelSemigroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelSemigroup.proof_1 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ AddLeftCancelSemigroupğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) (c : (i : I) â†’ f i) (h : a + b = a + c) :b = c", "code": "@[to_additive AddLeftCancelSemigroup]\n", "additional_info": "", "used_premises": [609], "def_path": "ConNF/Mathlib/Group.lean", "pos": [119, 120], "informalization": "Function `PiProp.AddLeftCancelSemigroup.proof_1` proves that if `a`, `b`, and `c` are elements of a family of additive left-cancellative semigroups, and `a + b = a + c`, then `b = c`."}
{"full_name": "AddLeftCancelSemigroup", "url": "Mathlib/Algebra/Group/Defs.html#AddLeftCancelSemigroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddLeftCancelSemigroup (G : Type u) extends AddSemigroupğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : G â†’ G â†’ G\n | add_assoc : âˆ€ (a b c : G), a +  b +  c =  a +  (b +  c)\n | add_left_cancel : âˆ€ (a b c : G), a +  b =  a +  c â†’ b =  c", "code": "class AddLeftCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_left_cancel : âˆ€ a b c : G, a + b = a + c â†’ b = c\n", "additional_info": "An `ğŸ—ŸAddLeftCancelSemigroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddLeftCancelSemigroupğŸ”—`  is an additive semigroup such that\n`a + b = a + c` implies `b = c`.\n", "used_premises": [32], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [387, 389], "informalization": "An `AddLeftCancelSemigroup` is an additive semigroup where addition is left-cancellative, meaning that if `a + b = a + c`, then `b = c`."}
{"full_name": "PiProp.AddRightCancelSemigroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelSemigroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelSemigroup.proof_1 {I : Prop } {f : I â†’ Type u_1} [inst : (i : I) â†’ AddRightCancelSemigroupğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) (c : (i : I) â†’ f i) (h : a + b = c + b) :a = c", "code": "@[to_additive AddRightCancelSemigroup]\n", "additional_info": "", "used_premises": [611], "def_path": "ConNF/Mathlib/Group.lean", "pos": [127, 128], "informalization": "`PiProp.AddRightCancelSemigroup.proof_1` is a proof that for any family of types `f : I â†’ Type u_1`, if each `f i` is an `AddRightCancelSemigroup`, then the type `(i : I) â†’ f i` is also an `AddRightCancelSemigroup`."}
{"full_name": "AddRightCancelSemigroup", "url": "Mathlib/Algebra/Group/Defs.html#AddRightCancelSemigroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddRightCancelSemigroup (G : Type u) extends AddSemigroupğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : G â†’ G â†’ G\n | add_assoc : âˆ€ (a b c : G), a +  b +  c =  a +  (b +  c)\n | add_right_cancel : âˆ€ (a b c : G), a +  b =  c +  b â†’ a =  c", "code": "class AddRightCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_right_cancel : âˆ€ a b c : G, a + b = c + b â†’ a = c\n", "additional_info": "An `ğŸ—ŸAddRightCancelSemigroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddRightCancelSemigroupğŸ”—`  is an additive semigroup such that\n`a + b = c + b` implies `a = c`.\n", "used_premises": [32], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [419, 421], "informalization": "An `AddRightCancelSemigroup` is an additive semigroup where `a + b = c + b` implies `a = c`."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_5", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_5", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_5 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddLeftCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (n : â„• ) (x : (i : I) â†’ f i) :AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”— (n + 1) x = x + AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”— n x", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613, 34, 34], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The theorem `PiProp.AddLeftCancelMonoid.proof_5` states that for an indexed family of additive left-cancellative monoids, the `n+1`th multiple of an element `x` is equal to `x` plus the `n`th multiple of `x`."}
{"full_name": "AddLeftCancelMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddLeftCancelMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddLeftCancelMonoid (M : Type u) extends AddLeftCancelSemigroupğŸ”—<|PREMISE|>ğŸ”— , ZeroğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : M â†’ M â†’ M\n | add_assoc : âˆ€ (a b c : M), a +  b +  c =  a +  (b +  c)\n | add_left_cancel : âˆ€ (a b c : M), a +  b =  a +  c â†’ b =  c\n | zero : M\n | zero_add : âˆ€ (a : M), 0 +  a =  a\n | add_zero : âˆ€ (a : M), a +  0 =  a\n | nsmul : â„•  â†’ M â†’ M\n | nsmul_zero : âˆ€ (x : M), AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : M), AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x", "code": "class AddLeftCancelMonoid (M : Type u) extends AddLeftCancelSemigroup M, AddMonoid M\n", "additional_info": "An additive monoid in which addition is left-cancellative.\nMain examples are `â„•` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `ğŸ—ŸAddLeftCancelSemigroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddLeftCancelSemigroupğŸ”—`  is not enough.\n- AddLeftCancelMonoid.zero_add: Zero is a left neutral element for addition\n\n\n- AddLeftCancelMonoid.add_zero: Zero is a right neutral element for addition\n\n\n- AddLeftCancelMonoid.nsmul: Multiplication by a natural number.\n\n\n- AddLeftCancelMonoid.nsmul_zero: Multiplication by `(0 : â„•)` gives `0`.\n\n\n- AddLeftCancelMonoid.nsmul_succ: Multiplication by `(n + 1 : â„•)` behaves as expected.\n\n\n", "used_premises": [609, 20, 614, 614, 614], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [689, 690], "informalization": "The Lean 4 object `AddLeftCancelMonoid` represents an additive monoid where addition is left-cancellative, meaning if `a + b = a + c`, then `b = c`. This is useful to define the sum over the empty set, so `AddLeftCancelSemigroup` is not enough."}
{"full_name": "AddLeftCancelMonoid.nsmul", "url": "Mathlib/Algebra/Group/Defs.html#AddLeftCancelMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field AddLeftCancelMonoidğŸ”—<|PREMISE|>ğŸ”—.nsmul : â„•  â†’ M â†’ M", "code": "class AddLeftCancelMonoid (M : Type u) extends AddLeftCancelSemigroup M, AddMonoid M\n", "additional_info": "Multiplication by a natural number.\n\n", "used_premises": [613], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [689, 690], "informalization": "Function `AddLeftCancelMonoid.nsmul` takes a natural number and an element from an additive monoid where addition is left-cancellative, and returns the result of their multiplication."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddLeftCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) (c : (i : I) â†’ f i) :a + b = a + c â†’ b = c", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The theorem `PiProp.AddLeftCancelMonoid.proof_1` states that if you have a dependent family of types `f : I â†’ Type u_1`, each of which is an additive left-cancellative monoid (a monoid where `a + b = a + c` implies `b = c`), then for any `a : (i : I) â†’ f i` and `b : (i : I) â†’ f i` and `c : (i : I) â†’ f i`, if `a + b = a + c`, then `b = c`. This is a generalization of the property of left-cancellative monoids to dependent families of types."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_4", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_4", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_4 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddLeftCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (x : (i : I) â†’ f i) :AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”— 0 x = 0", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613, 34], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The theorem `PiProp.AddLeftCancelMonoid.proof_4` states that for any type family `f : I â†’ Type u_1` where each `f i` is an additive left-cancellative monoid, the zeroth power of any element `x : (i : I) â†’ f i` is equal to zero."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_2 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddLeftCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :0 + a = a", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The proof provided for the theorem stating that for any type family indexed by a proposition $I$, the additive monoid structure on the product type $(\\prod_{i : I} f_i)$ is an additive left-cancel monoid. This requires the proof that the sum of the zero element with any element of the product type is equal to that element (i.e., $0 + a = a$). This theorem is derived from the instance of `AddLeftCancelMonoid` for each $f_i$, which ensures that within each component of the product, the sum of zero with any element is equal to that element. Hence, the proof is completed by using the `pi_zero` (which states that the zero vector is the constant function mapping to the zero of each component) and `pi_add` (which states that addition in the product is done component-wise)."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_3 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddLeftCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :a + 0 = a", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The theorem `PiProp.AddLeftCancelMonoid.proof_3` is a part of the `PiProp` class which is used to define a monoid structure on the type `(I â†’ Type u_1)` where `I` is a type and `u_1` is a universe level. The theorem states that for any dependent function `a : (i : I) â†’ f i` where `f i` are additive left-cancellative monoids, the sum of `a` and the zero function is equal to `a`."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddRightCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) (c : (i : I) â†’ f i) :a + b = c + b â†’ a = c", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "Function `PiProp.AddRightCancelMonoid.proof_1` is a proof that for any family of types `f : I â†’ Type u_1` where each `f i` is an `AddRightCancelMonoid`, the product type `(i : I) â†’ f i` is also an `AddRightCancelMonoid`. Specifically, it proves that for any `a, b, c : (i : I) â†’ f i`, if `a + b = c + b`, then `a = c`."}
{"full_name": "AddRightCancelMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddRightCancelMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddRightCancelMonoid (M : Type u) extends AddRightCancelSemigroupğŸ”—<|PREMISE|>ğŸ”— , ZeroğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : M â†’ M â†’ M\n | add_assoc : âˆ€ (a b c : M), a +  b +  c =  a +  (b +  c)\n | add_right_cancel : âˆ€ (a b c : M), a +  b =  c +  b â†’ a =  c\n | zero : M\n | zero_add : âˆ€ (a : M), 0 +  a =  a\n | add_zero : âˆ€ (a : M), a +  0 =  a\n | nsmul : â„•  â†’ M â†’ M\n | nsmul_zero : âˆ€ (x : M), AddRightCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : M), AddRightCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddRightCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x", "code": "class AddRightCancelMonoid (M : Type u) extends AddRightCancelSemigroup M, AddMonoid M\n", "additional_info": "An additive monoid in which addition is right-cancellative.\nMain examples are `â„•` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `ğŸ—ŸAddRightCancelSemigroupğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddRightCancelSemigroupğŸ”—`  is not enough.\n- AddRightCancelMonoid.zero_add: Zero is a left neutral element for addition\n\n\n- AddRightCancelMonoid.add_zero: Zero is a right neutral element for addition\n\n\n- AddRightCancelMonoid.nsmul: Multiplication by a natural number.\n\n\n- AddRightCancelMonoid.nsmul_zero: Multiplication by `(0 : â„•)` gives `0`.\n\n\n- AddRightCancelMonoid.nsmul_succ: Multiplication by `(n + 1 : â„•)` behaves as expected.\n\n\n", "used_premises": [611, 20, 621, 621, 621], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [710, 711], "informalization": "Class `AddRightCancelMonoid` represents an additive monoid where addition is right-cancellative, meaning that if `a + b = c + b`, then `a = c`. This class extends `AddRightCancelSemigroup` and `AddMonoid`, ensuring that the monoid has a zero element and satisfies the properties of an additive monoid."}
{"full_name": "AddRightCancelMonoid.nsmul", "url": "Mathlib/Algebra/Group/Defs.html#AddRightCancelMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field AddRightCancelMonoidğŸ”—<|PREMISE|>ğŸ”—.nsmul : â„•  â†’ M â†’ M", "code": "class AddRightCancelMonoid (M : Type u) extends AddRightCancelSemigroup M, AddMonoid M\n", "additional_info": "Multiplication by a natural number.\n\n", "used_premises": [620], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [710, 711], "informalization": "Function `AddRightCancelMonoid.nsmul` takes a natural number and an element from an additive monoid where addition is right-cancellative, and returns the result of their multiplication."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_2 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddRightCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :0 + a = a", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "The theorem `PiProp.AddRightCancelMonoid.proof_2` states that for any family of types `f : I â†’ Type u_1`, where each `f i` is an additive right-cancellative monoid, the zero element added to any element `a : (i : I) â†’ f i` is equal to `a`."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_4", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_4", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_4 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddRightCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (x : (i : I) â†’ f i) :AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”— 0 x = 0", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620, 34], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "`PiProp.AddRightCancelMonoid.proof_4` is a proof of the statement that for any type family `f : I â†’ Type u_1` where each `f i` is an additive right-cancellative monoid, the zero scalar multiplication of any element `x : (i : I) â†’ f i` is equal to zero."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_3 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddRightCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) :a + 0 = a", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "The theorem `PiProp.AddRightCancelMonoid.proof_3` states that for any family of types `f : I â†’ Type u_1`, where each `f i` is an additive right-cancellative monoid, the sum of any element `a : (i : I) â†’ f i` with the zero element of the product type is equal to `a`."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_5", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_5", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_5 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddRightCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (n : â„• ) (x : (i : I) â†’ f i) :AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”— (n + 1) x = x + AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”— n x", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620, 34, 34], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "Function `PiProp.AddRightCancelMonoid.proof_5` is a proof of the property that the `n+1`th multiple of an element `x` in a product of additive right-cancellative monoids is equal to `x` plus the `n`th multiple of `x`."}
{"full_name": "PiProp.AddCancelMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddCancelMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddCancelMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddCancelMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) (c : (i : I) â†’ f i) :a + b = c + b â†’ a = c", "code": "@[to_additive AddCancelMonoid]\n", "additional_info": "", "used_premises": [627], "def_path": "ConNF/Mathlib/Group.lean", "pos": [147, 148], "informalization": "Class `AddCancelMonoid` represents an additive monoid where addition is cancellative on both sides, meaning if `a + b = c + b`, then `a = c`. This is useful to define the sum over the empty set, so `AddRightCancelMonoid` is not enough."}
{"full_name": "AddCancelMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddCancelMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddCancelMonoid (M : Type u) extends AddLeftCancelMonoidğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : M â†’ M â†’ M\n | add_assoc : âˆ€ (a b c : M), a +  b +  c =  a +  (b +  c)\n | add_left_cancel : âˆ€ (a b c : M), a +  b =  a +  c â†’ b =  c\n | zero : M\n | zero_add : âˆ€ (a : M), 0 +  a =  a\n | add_zero : âˆ€ (a : M), a +  0 =  a\n | nsmul : â„•  â†’ M â†’ M\n | nsmul_zero : âˆ€ (x : M), AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : M), AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | add_right_cancel : âˆ€ (a b c : M), a +  b =  c +  b â†’ a =  c", "code": "class AddCancelMonoid (M : Type u) extends AddLeftCancelMonoid M, AddRightCancelMonoid M\n", "additional_info": "An additive monoid in which addition is cancellative on both sides.\nMain examples are `â„•` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `ğŸ—ŸAddRightCancelMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddRightCancelMonoidğŸ”—`  is not enough.\n", "used_premises": [613, 614, 614, 614], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [731, 732], "informalization": "Class `AddCancelMonoid` represents an additive monoid where addition is cancellative on both sides, meaning if `a + b = c + b`, then `a = c`. This is useful to define the sum over the empty set, so `AddRightCancelMonoid` is not enough."}
{"full_name": "PiProp.AddCancelCommMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddCancelCommMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddCancelCommMonoid.proof_1 {I : Prop } {f : I â†’ Type u_1} [(i : I) â†’ AddCancelCommMonoidğŸ”—<|PREMISE|>ğŸ”— (f i)] (a : (i : I) â†’ f i) (b : (i : I) â†’ f i) :a + b = b + a", "code": "@[to_additive AddCancelCommMonoid]\n", "additional_info": "", "used_premises": [629], "def_path": "ConNF/Mathlib/Group.lean", "pos": [153, 154], "informalization": "`PiProp.AddCancelCommMonoid.proof_1` is a proof of the commutativity of addition in a product of additive cancellative commutative monoids."}
{"full_name": "AddCancelCommMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddCancelCommMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddCancelCommMonoid (M : Type u) extends AddLeftCancelMonoidğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : M â†’ M â†’ M\n | add_assoc : âˆ€ (a b c : M), a +  b +  c =  a +  (b +  c)\n | add_left_cancel : âˆ€ (a b c : M), a +  b =  a +  c â†’ b =  c\n | zero : M\n | zero_add : âˆ€ (a : M), 0 +  a =  a\n | add_zero : âˆ€ (a : M), a +  0 =  a\n | nsmul : â„•  â†’ M â†’ M\n | nsmul_zero : âˆ€ (x : M), AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : M), AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddLeftCancelMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | add_comm : âˆ€ (a b : M), a +  b =  b +  a", "code": "class AddCancelCommMonoid (M : Type u) extends AddLeftCancelMonoid M, AddCommMonoid M\n", "additional_info": "Commutative version of `ğŸ—ŸAddCancelMonoidğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#AddCancelMonoidğŸ”—` .\n- AddCancelCommMonoid.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [613, 614, 614, 614], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [742, 743], "informalization": "Class `AddCancelCommMonoid` represents a commutative additive monoid where addition is left-cancellative, meaning if `a + b = a + c`, then `b = c`. This is useful to define the sum over the empty set, so `AddLeftCancelSemigroup` is not enough."}
{"full_name": "Nat.odd_succ", "url": "ConNF/Mathlib/Nat.html#Nat.odd_succ", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Nat.odd_succ {n : â„• } :OddğŸ”—<|PREMISE|>ğŸ”— (Nat.succğŸ”—<|PREMISE|>ğŸ”— n) â†” Â¬ OddğŸ”—<|PREMISE|>ğŸ”— n", "code": "theorem odd_succ : Odd (succ n) â†” Â¬Odd n := by rw [succ_eq_add_one, odd_add]; simp [not_even_one]\n", "additional_info": "", "used_premises": [631, 53, 631], "def_path": "ConNF/Mathlib/Nat.lean", "pos": [7, 8], "informalization": "The theorem `Nat.odd_succ` states that for any natural number `n`, the successor of `n` is odd if and only if `n` is not odd."}
{"full_name": "Odd", "url": "Mathlib/Algebra/Parity.html#Odd", "code_src": "mathlib4", "ptype": "def", "header": "def Odd {Î± : Type u_2} [SemiringğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) :Prop", "code": "def Odd (a : Î±) : Prop :=\n  âˆƒ k, a = 2 * k + 1\n", "additional_info": "An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`.\nEquations\n* ğŸ—ŸOddğŸ—ŸğŸ”—../.././Mathlib/Algebra/Parity.html#OddğŸ”—  a ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆƒ (k : Î±), a ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  2 ğŸ—Ÿ*ğŸ—ŸğŸ”—../.././Init/Prelude.html#HMul.hMulğŸ”—  k ğŸ—Ÿ+ğŸ—ŸğŸ”—../.././Init/Prelude.html#HAdd.hAddğŸ”—  1\n\n", "used_premises": [632], "def_path": "Mathlib/Algebra/Parity.lean", "pos": [335, 337], "informalization": "`Odd` is a predicate asserting that an element `a` in a semiring `Î±` can be expressed as `2*k + 1` for some element `k` in `Î±`."}
{"full_name": "Semiring", "url": "Mathlib/Algebra/Ring/Defs.html#Semiring", "code_src": "mathlib4", "ptype": "class", "header": "class Semiring (Î± : Type u) extends NonUnitalSemiringğŸ”—<|PREMISE|>ğŸ”— , OneğŸ”—<|PREMISE|>ğŸ”— , NatCastğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : Î± â†’ Î± â†’ Î±\n | add_assoc : âˆ€ (a b c : Î±), a +  b +  c =  a +  (b +  c)\n | zero : Î±\n | zero_add : âˆ€ (a : Î±), 0 +  a =  a\n | add_zero : âˆ€ (a : Î±), a +  0 =  a\n | nsmul : â„•  â†’ Î± â†’ Î±\n | nsmul_zero : âˆ€ (x : Î±), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : Î±), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | add_comm : âˆ€ (a b : Î±), a +  b =  b +  a\n | mul : Î± â†’ Î± â†’ Î±\n | left_distrib : âˆ€ (a b c : Î±), a *  (b +  c) =  a *  b +  a *  c\n | right_distrib : âˆ€ (a b c : Î±), (a +  b) *  c =  a *  c +  b *  c\n | zero_mul : âˆ€ (a : Î±), 0 *  a =  0\n | mul_zero : âˆ€ (a : Î±), a *  0 =  0\n | mul_assoc : âˆ€ (a b c : Î±), a *  b *  c =  a *  (b *  c)\n | one : Î±\n | one_mul : âˆ€ (a : Î±), 1 *  a =  a\n | mul_one : âˆ€ (a : Î±), a *  1 =  a\n | natCast : â„•  â†’ Î±\n | natCast_zero : NatCast.natCastğŸ”—<|PREMISE|>ğŸ”—  0 =  0\n | natCast_succ : âˆ€ (n : â„• ), NatCast.natCastğŸ”—<|PREMISE|>ğŸ”—  (n +  1) =  NatCast.natCastğŸ”—<|PREMISE|>ğŸ”—  n +  1\n | npow : â„•  â†’ Î± â†’ Î±\n | npow_zero : âˆ€ (x : Î±), Semiring.npowğŸ”—<|PREMISE|>ğŸ”—  0 x =  1\n | npow_succ : âˆ€ (n : â„• ) (x : Î±), Semiring.npowğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x *  Semiring.npowğŸ”—<|PREMISE|>ğŸ”—  n x", "code": "class Semiring (Î± : Type u) extends NonUnitalSemiring Î±, NonAssocSemiring Î±, MonoidWithZero Î±\n", "additional_info": "A `ğŸ—ŸSemiringğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Ring/Defs.html#SemiringğŸ”—`  is a type with addition, multiplication, a `0` and a `1` where addition is\ncommutative and associative, multiplication is associative and left and right distributive over\naddition, and `0` and `1` are additive and multiplicative identities.\n- Semiring.one_mul: One is a left neutral element for multiplication\n\n\n- Semiring.mul_one: One is a right neutral element for multiplication\n\n\n- Semiring.natCast_zero: The canonical map `â„• â†’ R` sends `0 : â„•` to `0 : R`.\n\n\n- Semiring.natCast_succ: The canonical map `â„• â†’ R` is a homomorphism.\n\n\n- Semiring.npow: Raising to the power of a natural number.\n\n\n- Semiring.npow_zero: Raising to the power `(0 : â„•)` gives `1`.\n\n\n- Semiring.npow_succ: Raising to the power `(n + 1 : â„•)` behaves as expected.\n\n\n", "used_premises": [633, 45, 635, 34, 34, 34, 636, 636, 636, 637, 637, 637], "def_path": "Mathlib/Algebra/Ring/Defs.lean", "pos": [140, 141], "informalization": "Class `Semiring` represents the concept of a semiring, which is an algebraic structure that combines aspects of both additive and multiplicative systems."}
{"full_name": "NonUnitalSemiring", "url": "Mathlib/Algebra/Ring/Defs.html#NonUnitalSemiring", "code_src": "mathlib4", "ptype": "class", "header": "class NonUnitalSemiring (Î± : Type u) extends NonUnitalNonAssocSemiringğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : Î± â†’ Î± â†’ Î±\n | add_assoc : âˆ€ (a b c : Î±), a +  b +  c =  a +  (b +  c)\n | zero : Î±\n | zero_add : âˆ€ (a : Î±), 0 +  a =  a\n | add_zero : âˆ€ (a : Î±), a +  0 =  a\n | nsmul : â„•  â†’ Î± â†’ Î±\n | nsmul_zero : âˆ€ (x : Î±), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : Î±), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | add_comm : âˆ€ (a b : Î±), a +  b =  b +  a\n | mul : Î± â†’ Î± â†’ Î±\n | left_distrib : âˆ€ (a b c : Î±), a *  (b +  c) =  a *  b +  a *  c\n | right_distrib : âˆ€ (a b c : Î±), (a +  b) *  c =  a *  c +  b *  c\n | zero_mul : âˆ€ (a : Î±), 0 *  a =  0\n | mul_zero : âˆ€ (a : Î±), a *  0 =  0\n | mul_assoc : âˆ€ (a b c : Î±), a *  b *  c =  a *  (b *  c)", "code": "class NonUnitalSemiring (Î± : Type u) extends NonUnitalNonAssocSemiring Î±, SemigroupWithZero Î±\n", "additional_info": "An associative but not-necessarily unital semiring.\n- NonUnitalSemiring.mul_assoc: Multiplication is associative\n\n\n", "used_premises": [634, 34, 34, 34], "def_path": "Mathlib/Algebra/Ring/Defs.lean", "pos": [116, 117], "informalization": "Class `NonUnitalSemiring` represents the concept of a non-unital semiring, which is an algebraic structure that extends `NonUnitalNonAssocSemiring` by adding the requirement for associative multiplication. This means that in addition to the properties of a non-unital, non-associative semiring (such as having an additive commutative monoid structure with associative and commutative addition, a zero element, natural number multiplication, distributive multiplication over addition, and zero as an absorbing element for multiplication), the multiplication operation is now associative. This is expressed by the property `mul_assoc`, which states that for any elements `a`, `b`, and `c`, `a * b * c = a * (b * c)`."}
{"full_name": "NonUnitalNonAssocSemiring", "url": "Mathlib/Algebra/Ring/Defs.html#NonUnitalNonAssocSemiring", "code_src": "mathlib4", "ptype": "class", "header": "class NonUnitalNonAssocSemiring (Î± : Type u) extends AddCommMonoidğŸ”—<|PREMISE|>ğŸ”— , MulğŸ”—<|PREMISE|>ğŸ”— :Type u\n | add : Î± â†’ Î± â†’ Î±\n | add_assoc : âˆ€ (a b c : Î±), a +  b +  c =  a +  (b +  c)\n | zero : Î±\n | zero_add : âˆ€ (a : Î±), 0 +  a =  a\n | add_zero : âˆ€ (a : Î±), a +  0 =  a\n | nsmul : â„•  â†’ Î± â†’ Î±\n | nsmul_zero : âˆ€ (x : Î±), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  0 x =  0\n | nsmul_succ : âˆ€ (n : â„• ) (x : Î±), AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  (n +  1) x =  x +  AddMonoid.nsmulğŸ”—<|PREMISE|>ğŸ”—  n x\n | add_comm : âˆ€ (a b : Î±), a +  b =  b +  a\n | mul : Î± â†’ Î± â†’ Î±\n | left_distrib : âˆ€ (a b c : Î±), a *  (b +  c) =  a *  b +  a *  c\n | right_distrib : âˆ€ (a b c : Î±), (a +  b) *  c =  a *  c +  b *  c\n | zero_mul : âˆ€ (a : Î±), 0 *  a =  0\n | mul_zero : âˆ€ (a : Î±), a *  0 =  0", "code": "class NonUnitalNonAssocSemiring (Î± : Type u) extends AddCommMonoid Î±, Distrib Î±, MulZeroClass Î±\n", "additional_info": "A not-necessarily-unital, not-necessarily-associative semiring.\n- NonUnitalNonAssocSemiring.left_distrib: Multiplication is left distributive over addition\n\n\n- NonUnitalNonAssocSemiring.right_distrib: Multiplication is right distributive over addition\n\n\n- NonUnitalNonAssocSemiring.zero_mul: Zero is a left absorbing element for multiplication\n\n\n- NonUnitalNonAssocSemiring.mul_zero: Zero is a right absorbing element for multiplication\n\n\n", "used_premises": [590, 44, 34, 34, 34], "def_path": "Mathlib/Algebra/Ring/Defs.lean", "pos": [112, 113], "informalization": "Class `NonUnitalNonAssocSemiring` represents the concept of a non-unital, non-associative semiring. This algebraic structure extends `AddCommMonoid` and includes multiplication operations, but without the requirement for a multiplicative identity (unital) or associative multiplication. It features an additive commutative monoid structure, where addition is associative and commutative, there is a zero element that acts as a neutral element for addition, and natural number multiplication (nsmul) is defined with specific behaviors for zero and successor. Additionally, it includes a multiplication operation (`mul`) that is distributive over addition (both left and right) and has zero as an absorbing element for multiplication (both left and right). This means that multiplying any element by zero results in zero, and multiplication distributes over addition, meaning `a * (b + c) = a * b + a * c` and `(a + b) * c = a * c + b * c`."}
{"full_name": "NatCast", "url": "Init/Data/Cast.html#NatCast", "code_src": "lean4", "ptype": "class", "header": "class NatCast (R : Type u) :Type u\n | natCast : NatğŸ”—<|PREMISE|>ğŸ”—  â†’ R", "code": "class NatCast (R : Type u) where\n  /-- The canonical map `Nat â†’ R`. -/\n  protected natCast : Nat â†’ R\n", "additional_info": "Type class for the canonical homomorphism `ğŸ—ŸNatğŸ—ŸğŸ”—../.././Init/Prelude.html#NatğŸ”—  â†’ R`.\n- NatCast.natCast: The canonical map `ğŸ—ŸNatğŸ—ŸğŸ”—../.././Init/Prelude.html#NatğŸ”—  â†’ R`.\n\n\n", "used_premises": [52], "def_path": "Init/Data/Cast.lean", "pos": [47, 50], "informalization": "Class `NatCast` represents the concept of a canonical homomorphism from natural numbers to another type `R`. It provides a method `natCast` that maps natural numbers to elements of type `R`."}
{"full_name": "NatCast.natCast", "url": "Init/Data/Cast.html#NatCast", "code_src": "lean4", "ptype": "structure_field", "header": "structure_field NatCastğŸ”—<|PREMISE|>ğŸ”—.natCast : NatğŸ”—<|PREMISE|>ğŸ”—  â†’ R", "code": "class NatCast (R : Type u) where\n  /-- The canonical map `Nat â†’ R`. -/\n  protected natCast : Nat â†’ R\n", "additional_info": "The canonical map `ğŸ—ŸNatğŸ—ŸğŸ”—../.././Init/Prelude.html#NatğŸ”—  â†’ R`.\n\n", "used_premises": [635, 52], "def_path": "Init/Data/Cast.lean", "pos": [47, 50], "informalization": "Function `NatCast.natCast` is a method provided by the `NatCast` class that takes a natural number (of type `Nat`) and returns an element of another type `R`. This function serves as a canonical homomorphism, or a mapping, from the natural numbers to the type `R`."}
{"full_name": "Semiring.npow", "url": "Mathlib/Algebra/Ring/Defs.html#Semiring", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field SemiringğŸ”—<|PREMISE|>ğŸ”—.npow : â„•  â†’ Î± â†’ Î±", "code": "class Semiring (Î± : Type u) extends NonUnitalSemiring Î±, NonAssocSemiring Î±, MonoidWithZero Î±\n", "additional_info": "Raising to the power of a natural number.\n\n", "used_premises": [632], "def_path": "Mathlib/Algebra/Ring/Defs.lean", "pos": [140, 141], "informalization": "Function `Semiring.npow` takes a natural number and an element from a semiring, and returns the result of raising the element to the power of the natural number. This operation is defined recursively, where raising an element to the power of zero results in the multiplicative identity (usually denoted as `1`), and raising an element to the power of `n + 1` is equivalent to multiplying the element by its power of `n`. This function is essential for defining and working with exponentiation within the algebraic structure of a semiring."}
{"full_name": "Nat.not_even", "url": "ConNF/Mathlib/Nat.html#Nat.not_even", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Nat.not_even {n : â„• } :Â¬ EvenğŸ”—<|PREMISE|>ğŸ”— n â†” OddğŸ”—<|PREMISE|>ğŸ”— n", "code": "theorem not_even : Â¬Even n â†” Odd n :=\n  Nat.odd_iff_not_even.symm\n", "additional_info": "", "used_premises": [639, 631], "def_path": "ConNF/Mathlib/Nat.lean", "pos": [9, 11], "informalization": "A natural number is odd if and only if it is not even."}
{"full_name": "Even", "url": "Mathlib/Algebra/Parity.html#Even", "code_src": "mathlib4", "ptype": "def", "header": "def Even {Î± : Type u_2} [AddğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) :Prop", "code": "@[to_additive\n      \"An element `a` of a type `Î±` with addition satisfies `Even a` if `a = r + r`,\n      for some `r : Î±`.\"]\n", "additional_info": "An element `a` of a type `Î±` with addition satisfies `ğŸ—ŸEvenğŸ—ŸğŸ”—../.././Mathlib/Algebra/Parity.html#EvenğŸ”—  a` if `a = r + r`,\nfor some `r : Î±`.\nEquations\n* ğŸ—ŸEvenğŸ—ŸğŸ”—../.././Mathlib/Algebra/Parity.html#EvenğŸ”—  a ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆƒ (r : Î±), a ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  r ğŸ—Ÿ+ğŸ—ŸğŸ”—../.././Init/Prelude.html#HAdd.hAddğŸ”—  r\n\n", "used_premises": [33], "def_path": "Mathlib/Algebra/Parity.lean", "pos": [47, 50], "informalization": "Function `Even` checks if an element `a` in a type `Î±` with addition can be expressed as the sum of two identical elements `r`, i.e., `a = r + r`."}
{"full_name": "Nat.not_odd", "url": "ConNF/Mathlib/Nat.html#Nat.not_odd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Nat.not_odd {n : â„• } :Â¬ OddğŸ”—<|PREMISE|>ğŸ”— n â†” EvenğŸ”—<|PREMISE|>ğŸ”— n", "code": "theorem not_odd : Â¬Odd n â†” Even n :=\n  Nat.even_iff_not_odd.symm\n", "additional_info": "", "used_premises": [631, 639], "def_path": "ConNF/Mathlib/Nat.lean", "pos": [12, 14], "informalization": "A natural number is not odd if and only if it is even."}
{"full_name": "AddAction.forall_mem_image", "url": "ConNF/Mathlib/Support.html#AddAction.forall_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem AddAction.forall_mem_image {Î± : Type u_3} {Î² : Type u_4} {f : Î± â†’ Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {p : Î² â†’ Prop } :(âˆ€ y âˆˆ f '' s, p y) â†” âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s â†’ p (f x)", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Support.lean", "pos": [10, 11], "informalization": "The theorem `AddAction.forall_mem_image` states that for any function `f : Î± â†’ Î²`, a set `s : Set Î±`, and a property `p : Î² â†’ Prop`, the statement \"for all `y` in the image of `s` under `f`, `p y` holds\" is equivalent to \"for all `x` in `s`, `p (f x)` holds\"."}
{"full_name": "MulAction.forall_mem_image", "url": "ConNF/Mathlib/Support.html#MulAction.forall_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem MulAction.forall_mem_image {Î± : Type u_3} {Î² : Type u_4} {f : Î± â†’ Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {p : Î² â†’ Prop } :(âˆ€ y âˆˆ f '' s, p y) â†” âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s â†’ p (f x)", "code": "theorem forall_mem_image {f : Î± â†’ Î²} {s : Set Î±} {p : Î² â†’ Prop} :\n    (âˆ€ y âˆˆ f '' s, p y) â†” âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ p (f x) := by simp\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Support.lean", "pos": [11, 13], "informalization": "Given a function `f : Î± â†’ Î²` and a set `s : Set Î±`, the statement `âˆ€ y âˆˆ f '' s, p y` is equivalent to `âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s â†’ p (f x)`."}
{"full_name": "PartialPerm.coe_symm_mk", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_symm_mk", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_symm_mk {Î± : Type u_1} (f : Î± â†’ Î±) (g : Î± â†’ Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (ml : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s â†’ f x âˆˆ s) (mr : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s â†’ g x âˆˆ s) (il : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s â†’ g (f x) = x) (ir : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s â†’ f (g x) = x) :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— { toFun := f, invFun := g, domain := s, toFun_domain' := ml, invFun_domain' := mr, left_inv' := il, right_inv' := ir }).toFun = g", "code": "theorem coe_symm_mk (f : Î± â†’ Î±) (g s ml mr il ir) :\n    ((PartialPerm.mk f g s ml mr il ir).symm : Î± â†’ Î±) = g :=\n  rfl\n", "additional_info": "", "used_premises": [69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [64, 67], "informalization": "The theorem `PartialPerm.coe_symm_mk` states that for a partial permutation defined by a function `f`, an inverse function `g`, and a domain `s`, the inverse function of the partial permutation is indeed `g`."}
{"full_name": "PartialPerm.symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.symm {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "protected def symm : PartialPerm Î± where\n  toFun := Ï€.invFun\n  invFun := Ï€.toFun\n  domain := Ï€.domain\n  toFun_domain' := Ï€.invFun_domain'\n  invFun_domain' := Ï€.toFun_domain'\n  left_inv' := Ï€.right_inv'\n  right_inv' := Ï€.left_inv'\n", "additional_info": "The inverse of a partial permutation.\nEquations\n* ğŸ—ŸPartialPerm.symmğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symmğŸ”—  Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toFun := Ï€.invFun, invFun := Ï€.toFun, domain := Ï€.domain, toFun_domain' := â‹¯, invFun_domain' := â‹¯, left_inv' := â‹¯,\n right_inv' := â‹¯ }\n\n", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [47, 55], "informalization": "Function `PartialPerm.symm` returns the inverse of a partial permutation."}
{"full_name": "PartialPerm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm", "code_src": "con-nf", "ptype": "structure", "header": "structure PartialPerm (Î± : Type u_1) :Type u_1\n | toFun : Î± â†’ Î±\n | invFun : Î± â†’ Î±\n | domain : SetğŸ”—<|PREMISE|>ğŸ”—  Î±\n | toFun_domain' : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ  self.domain â†’ self.toFun x âˆˆ  self.domain\n | invFun_domain' : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ  self.domain â†’ self.invFun x âˆˆ  self.domain\n | left_inv' : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ  self.domain â†’ self.invFun (self.toFun x) =  x\n | right_inv' : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ  self.domain â†’ self.toFun (self.invFun x) =  x", "code": "structure PartialPerm (Î± : Type _) where\n  (toFun invFun : Î± â†’ Î±)\n  domain : Set Î±\n  toFun_domain' : âˆ€ â¦ƒxâ¦„, x âˆˆ domain â†’ toFun x âˆˆ domain\n  invFun_domain' : âˆ€ â¦ƒxâ¦„, x âˆˆ domain â†’ invFun x âˆˆ domain\n  left_inv' : âˆ€ â¦ƒxâ¦„, x âˆˆ domain â†’ invFun (toFun x) = x\n  right_inv' : âˆ€ â¦ƒxâ¦„, x âˆˆ domain â†’ toFun (invFun x) = x\n", "additional_info": "A partial permutation of a subset `ğŸ—ŸdomainğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domainğŸ”—`  of `Î±`. The (global) maps `ğŸ—ŸtoFunğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toFunğŸ”—  : Î± â†’ Î±` and\n`ğŸ—ŸinvFunğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invFunğŸ”—  : Î± â†’ Î±` map `ğŸ—ŸdomainğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domainğŸ”—`  to itself, and are inverse to each other there. The values of\n`ğŸ—ŸtoFunğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toFunğŸ”—`  and `ğŸ—ŸinvFunğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invFunğŸ”—`  outside of `ğŸ—ŸdomainğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domainğŸ”—`  are irrelevant.\n", "used_premises": [69], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [23, 30], "informalization": "Structure `PartialPerm` represents a partial permutation of a subset `domain` of `Î±`. The (global) maps `toFun` and `invFun` map `domain` to itself, and are inverse to each other there. The values of `toFun` and `invFun` outside of `domain` are irrelevant."}
{"full_name": "PartialPerm.toFun_as_coe", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toFun_as_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toFun_as_coe {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.toFun = Ï€.toFun", "code": "theorem toFun_as_coe : Ï€.toFun = Ï€ :=\n  rfl\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [69, 71], "informalization": "The theorem `PartialPerm.toFun_as_coe` states that the function `toFun` of a partial permutation `Ï€` is equal to itself when considered as a coercion to a function."}
{"full_name": "PartialPerm.invFun_as_coe", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invFun_as_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.invFun_as_coe {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.invFun = (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun", "code": "theorem invFun_as_coe : Ï€.invFun = Ï€.symm :=\n  rfl\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [73, 75], "informalization": "Function `invFun` of a partial permutation `Ï€` is equal to the function `toFun` of its inverse `symm Ï€`."}
{"full_name": "PartialPerm.map_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.map_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.map_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {x : Î±} (h : x âˆˆ Ï€.domain) :Ï€.toFun x âˆˆ Ï€.domain", "code": "theorem map_domain {x : Î±} (h : x âˆˆ Ï€.domain) : Ï€ x âˆˆ Ï€.domain :=\n  Ï€.toFun_domain' h\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [77, 79], "informalization": "Given a partial permutation `Ï€` and an element `x` in its domain, the image of `x` under `Ï€` is also in its domain."}
{"full_name": "PartialPerm.iterate_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.iterate_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.iterate_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {x : Î±} (h : x âˆˆ Ï€.domain) {n : â„• } :Ï€.toFun^[ n] x âˆˆ Ï€.domain", "code": "theorem iterate_domain {x : Î±} (h : x âˆˆ Ï€.domain) {n : â„•} : Ï€^[n] x âˆˆ Ï€.domain := by\n  induction' n with n ih\n  exact h\n  rw [Function.iterate_succ']\n  exact Ï€.map_domain ih\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [81, 86], "informalization": "The theorem `PartialPerm.iterate_domain` states that if `x` is in the domain of a partial permutation `Ï€` and `n` is a natural number, then the `n`th iterate of `Ï€` applied to `x` is also in the domain of `Ï€`."}
{"full_name": "PartialPerm.left_inv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.left_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.left_inv {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {x : Î±} (h : x âˆˆ Ï€.domain) :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun (Ï€.toFun x) = x", "code": "theorem left_inv {x : Î±} (h : x âˆˆ Ï€.domain) : Ï€.symm (Ï€ x) = x :=\n  Ï€.left_inv' h\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [88, 90], "informalization": "`PartialPerm.left_inv` states that for a partial permutation `Ï€`, if `x` is in the domain of `Ï€`, then the inverse of `Ï€` applied to `Ï€` applied to `x` equals `x`."}
{"full_name": "PartialPerm.right_inv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.right_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.right_inv {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {x : Î±} (h : x âˆˆ Ï€.domain) :Ï€.toFun ((PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun x) = x", "code": "theorem right_inv {x : Î±} (h : x âˆˆ Ï€.domain) : Ï€ (Ï€.symm x) = x :=\n  Ï€.right_inv' h\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [92, 94], "informalization": "Function `PartialPerm.right_inv` states that for any partial permutation `Ï€` and any element `x` in the domain of `Ï€`, applying `Ï€` to the result of applying the inverse of `Ï€` to `x` yields `x`."}
{"full_name": "PartialPerm.symm_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.symm_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).domain = Ï€.domain", "code": "theorem symm_domain : Ï€.symm.domain = Ï€.domain :=\n  rfl\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [96, 98], "informalization": "The domain of a partial permutation and its inverse are the same."}
{"full_name": "PartialPerm.symm_symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.symm_symm {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€) = Ï€", "code": "theorem symm_symm : Ï€.symm.symm = Ï€ := by cases Ï€; rfl\n", "additional_info": "", "used_premises": [645, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [100, 101], "informalization": "Function `PartialPerm.symm_symm` states that the inverse of the inverse of a partial permutation is the original partial permutation."}
{"full_name": "PartialPerm.eq_symm_apply", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.eq_symm_apply", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.eq_symm_apply {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {x : Î±} {y : Î±} (hx : x âˆˆ Ï€.domain) (hy : y âˆˆ Ï€.domain) :x = (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun y â†” Ï€.toFun x = y", "code": "theorem eq_symm_apply {x : Î±} {y : Î±} (hx : x âˆˆ Ï€.domain) (hy : y âˆˆ Ï€.domain) :\n    x = Ï€.symm y â†” Ï€ x = y :=\n  âŸ¨fun h => by rw [â† Ï€.right_inv hy, h], fun h => by rw [â† Ï€.left_inv hx, h]âŸ©\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [102, 105], "informalization": "Function `eq_symm_apply` states that for a partial permutation `Ï€`, if `x` and `y` are both in the domain of `Ï€`, then `x` equals the inverse of `Ï€` applied to `y` if and only if `Ï€` applied to `x` equals `y`."}
{"full_name": "PartialPerm.mapsTo", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.mapsTo", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mapsTo {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Set.MapsToğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun Ï€.domain Ï€.domain", "code": "protected theorem mapsTo : MapsTo Ï€ Ï€.domain Ï€.domain := fun _ => Ï€.map_domain\n", "additional_info": "", "used_premises": [645, 656], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [106, 107], "informalization": "The function `PartialPerm.toFun` maps the domain of the partial permutation `Ï€` to itself."}
{"full_name": "Set.MapsTo", "url": "Mathlib/Data/Set/Defs.html#Set.MapsTo", "code_src": "mathlib4", "ptype": "def", "header": "def Set.MapsTo {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (t : SetğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def MapsTo (f : Î± â†’ Î²) (s : Set Î±) (t : Set Î²) : Prop := âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ f x âˆˆ t\n", "additional_info": "`ğŸ—ŸMapsToğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.MapsToğŸ”—  f a b` means that the image of `a` is contained in `b`.\nEquations\n* ğŸ—ŸSet.MapsToğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.MapsToğŸ”—  f s t ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒx : Î±â¦„, x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s â†’ f x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  t\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [266, 267], "informalization": "Function `Set.MapsTo` checks if the image of a set `s` under a function `f` is contained within another set `t`."}
{"full_name": "PartialPerm.leftInvOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.leftInvOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.leftInvOn {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Set.LeftInvOnğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun Ï€.toFun Ï€.domain", "code": "protected theorem leftInvOn : LeftInvOn Ï€.symm Ï€ Ï€.domain := fun _ => Ï€.left_inv\n", "additional_info": "", "used_premises": [645, 658, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [108, 109], "informalization": "Function `PartialPerm.leftInvOn` proves that the inverse of a partial permutation `Ï€` is indeed a left inverse to `Ï€` on the domain of `Ï€`."}
{"full_name": "Set.LeftInvOn", "url": "Mathlib/Data/Set/Defs.html#Set.LeftInvOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.LeftInvOn {Î± : Type u} {Î² : Type v} (f' : Î² â†’ Î±) (f : Î± â†’ Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "def LeftInvOn (f' : Î² â†’ Î±) (f : Î± â†’ Î²) (s : Set Î±) : Prop := âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ f' (f x) = x\n", "additional_info": "`g` is a left inverse to `f` on `a` means that `g (f x) = x` for all `x âˆˆ a`.\nEquations\n* ğŸ—ŸSet.LeftInvOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.LeftInvOnğŸ”—  f' f s ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒx : Î±â¦„, x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s â†’ f' (f x) ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  x\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [305, 306], "informalization": "Function `Set.LeftInvOn` checks if a function `f'` is a left inverse to a function `f` on a subset `s`, meaning `f' (f x) = x` for all `x âˆˆ s`."}
{"full_name": "PartialPerm.rightInvOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.rightInvOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.rightInvOn {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Set.RightInvOnğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun Ï€.toFun Ï€.domain", "code": "protected theorem rightInvOn : RightInvOn Ï€.symm Ï€ Ï€.domain := fun _ => Ï€.right_inv\n", "additional_info": "", "used_premises": [645, 660, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [110, 111], "informalization": "Function `PartialPerm.rightInvOn` proves that the inverse of a partial permutation `Ï€` is indeed a right inverse on the domain of `Ï€`."}
{"full_name": "Set.RightInvOn", "url": "Mathlib/Data/Set/Defs.html#Set.RightInvOn", "code_src": "mathlib4", "ptype": "def", "header": "@[reducible]def Set.RightInvOn {Î± : Type u} {Î² : Type v} (f' : Î² â†’ Î±) (f : Î± â†’ Î²) (t : SetğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def RightInvOn (f' : Î² â†’ Î±) (f : Î± â†’ Î²) (t : Set Î²) : Prop := LeftInvOn f f' t\n", "additional_info": "`g` is a right inverse to `f` on `b` if `f (g x) = x` for all `x âˆˆ b`.\nEquations\n* ğŸ—ŸSet.RightInvOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.RightInvOnğŸ”—  f' f t ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸSet.LeftInvOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.LeftInvOnğŸ”—  f f' t\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [310, 311], "informalization": "Function `Set.RightInvOn` defines the property that a function `f'` is a right inverse to a function `f` on a set `t`. This means that for every element `x` in the set `t`, applying the function `f` to the result of applying `f'` to `x` yields `x` itself, i.e., `f (f' x) = x` for all `x âˆˆ t`."}
{"full_name": "PartialPerm.invOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.invOn {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Set.InvOnğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun Ï€.toFun Ï€.domain Ï€.domain", "code": "protected theorem invOn : InvOn Ï€.symm Ï€ Ï€.domain Ï€.domain :=\n  âŸ¨Ï€.leftInvOn, Ï€.rightInvOnâŸ©\n", "additional_info": "", "used_premises": [645, 662, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [112, 114], "informalization": "Function `PartialPerm.invOn` proves that the inverse of a partial permutation `Ï€` is indeed an inverse on the domain of `Ï€`."}
{"full_name": "Set.InvOn", "url": "Mathlib/Data/Set/Defs.html#Set.InvOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.InvOn {Î± : Type u} {Î² : Type v} (g : Î² â†’ Î±) (f : Î± â†’ Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (t : SetğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def InvOn (g : Î² â†’ Î±) (f : Î± â†’ Î²) (s : Set Î±) (t : Set Î²) : Prop :=\n  LeftInvOn g f s âˆ§ RightInvOn g f t\n", "additional_info": "`g` is an inverse to `f` viewed as a map from `a` to `b`\nEquations\n* ğŸ—ŸSet.InvOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.InvOnğŸ”—  g f s t ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸSet.LeftInvOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.LeftInvOnğŸ”—  g f s ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  ğŸ—ŸSet.RightInvOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.RightInvOnğŸ”—  g f t)\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [314, 316], "informalization": "Function `Set.InvOn` checks if a function `g : Î² â†’ Î±` is an inverse to a function `f : Î± â†’ Î²` on sets `s : Set Î±` and `t : Set Î²`. This means that `g` is a left inverse of `f` on `s` and a right inverse of `f` on `t`."}
{"full_name": "PartialPerm.injOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.injOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.injOn {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Set.InjOnğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun Ï€.domain", "code": "protected theorem injOn : InjOn Ï€ Ï€.domain :=\n  Ï€.leftInvOn.injOn\n", "additional_info": "", "used_premises": [645, 111], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [115, 117], "informalization": "The function `toFun` of a partial permutation `Ï€` is injective on its domain."}
{"full_name": "PartialPerm.bijOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.bijOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.bijOn {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Set.BijOnğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun Ï€.domain Ï€.domain", "code": "protected theorem bijOn : BijOn Ï€ Ï€.domain Ï€.domain :=\n  Ï€.invOn.bijOn Ï€.mapsTo Ï€.symm.mapsTo\n", "additional_info": "", "used_premises": [645, 665], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [118, 120], "informalization": "Function `PartialPerm.bijOn` proves that a partial permutation `Ï€` is bijective between its domain and itself."}
{"full_name": "Set.BijOn", "url": "Mathlib/Data/Set/Defs.html#Set.BijOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.BijOn {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (t : SetğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def BijOn (f : Î± â†’ Î²) (s : Set Î±) (t : Set Î²) : Prop := MapsTo f s t âˆ§ InjOn f s âˆ§ SurjOn f s t\n", "additional_info": "`f` is bijective from `s` to `t` if `f` is injective on `s` and `f '' s = t`.\nEquations\n* ğŸ—ŸSet.BijOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.BijOnğŸ”—  f s t ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸSet.MapsToğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.MapsToğŸ”—  f s t ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  ğŸ—ŸSet.InjOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.InjOnğŸ”—  f s ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  ğŸ—ŸSet.SurjOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.SurjOnğŸ”—  f s t)\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [301, 302], "informalization": "Function `Set.BijOn` checks if a function `f` is bijective between two sets `s` and `t`, meaning `f` is both injective (one-to-one) and surjective (onto) from `s` to `t`."}
{"full_name": "PartialPerm.surjOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.surjOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.surjOn {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Set.SurjOnğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun Ï€.domain Ï€.domain", "code": "protected theorem surjOn : SurjOn Ï€ Ï€.domain Ï€.domain :=\n  Ï€.bijOn.surjOn\n", "additional_info": "", "used_premises": [645, 667], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [121, 123], "informalization": "The theorem `PartialPerm.surjOn` states that for any partial permutation `Ï€` of a set `Î±`, the function `Ï€.toFun` is surjective on the domain `Ï€.domain`."}
{"full_name": "Set.SurjOn", "url": "Mathlib/Data/Set/Defs.html#Set.SurjOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.SurjOn {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (t : SetğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def SurjOn (f : Î± â†’ Î²) (s : Set Î±) (t : Set Î²) : Prop := t âŠ† f '' s\n", "additional_info": "`f` is surjective from `a` to `b` if `b` is contained in the image of `a`.\nEquations\n* ğŸ—ŸSet.SurjOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.SurjOnğŸ”—  f s t ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (t ğŸ—ŸâŠ†ğŸ—ŸğŸ”—../../.././Init/Core.html#HasSubset.SubsetğŸ”—  f ğŸ—Ÿ''ğŸ—ŸğŸ”—../../.././Mathlib/Init/Set.html#Set.imageğŸ”—  s)\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [297, 298], "informalization": "Function `Set.SurjOn` checks if the image of set `s` under function `f` contains set `t`."}
{"full_name": "PartialPerm.copy_toFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy_toFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.copy_toFun {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î±) (hf : Ï€.toFun = f) (g : Î± â†’ Î±) (hg : (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun = g) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : Ï€.domain = s) :(PartialPerm.copyğŸ”—<|PREMISE|>ğŸ”— Ï€ f hf g hg s hs).toFun = f", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 644, 69, 669], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [125, 126], "informalization": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation. The theorem `PartialPerm.copy_toFun` states that the function of the copy is equal to the function of the original partial permutation."}
{"full_name": "PartialPerm.copy", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.copy {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î±) (hf : Ï€.toFun = f) (g : Î± â†’ Î±) (hg : (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun = g) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : Ï€.domain = s) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def copy (Ï€ : PartialPerm Î±) (f : Î± â†’ Î±) (hf : â‡‘Ï€ = f) (g : Î± â†’ Î±) (hg : â‡‘Ï€.symm = g) (s : Set Î±)\n    (hs : Ï€.domain = s) : PartialPerm Î± where\n  toFun := f\n  invFun := g\n  domain := s\n  toFun_domain' := hs â–¸ hf â–¸ Ï€.toFun_domain'\n  invFun_domain' := hs â–¸ hg â–¸ Ï€.invFun_domain'\n  left_inv' _ := hs â–¸ hf â–¸ hg â–¸ Ï€.left_inv\n  right_inv' _ := hs â–¸ hf â–¸ hg â–¸ Ï€.right_inv\n", "additional_info": "Create a copy of a `ğŸ—ŸPartialPermğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPermğŸ”—`  providing better definitional equalities.\nEquations\n* ğŸ—ŸPartialPerm.copyğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copyğŸ”—  Ï€ f hf g hg s hs ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toFun := f, invFun := g, domain := s, toFun_domain' := â‹¯, invFun_domain' := â‹¯, left_inv' := â‹¯, right_inv' := â‹¯ }\n\n", "used_premises": [645, 644, 69, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [126, 135], "informalization": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation."}
{"full_name": "PartialPerm.copy_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.copy_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î±) (hf : Ï€.toFun = f) (g : Î± â†’ Î±) (hg : (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun = g) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : Ï€.domain = s) :(PartialPerm.copyğŸ”—<|PREMISE|>ğŸ”— Ï€ f hf g hg s hs).domain = s", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 644, 69, 669], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [125, 126], "informalization": "Function `PartialPerm.copy_domain` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation."}
{"full_name": "PartialPerm.copy_invFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy_invFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.copy_invFun {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î±) (hf : Ï€.toFun = f) (g : Î± â†’ Î±) (hg : (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun = g) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : Ï€.domain = s) :(PartialPerm.copyğŸ”—<|PREMISE|>ğŸ”— Ï€ f hf g hg s hs).invFun = g", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 644, 69, 669], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [125, 126], "informalization": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation. The theorem `PartialPerm.copy_invFun` states that the inverse function of the copy is equal to the inverse function of the original partial permutation."}
{"full_name": "PartialPerm.copy_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.copy_eq {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (f : Î± â†’ Î±) (hf : Ï€.toFun = f) (g : Î± â†’ Î±) (hg : (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun = g) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : Ï€.domain = s) :PartialPerm.copyğŸ”—<|PREMISE|>ğŸ”— Ï€ f hf g hg s hs = Ï€", "code": "theorem copy_eq (Ï€ : PartialPerm Î±) (f : Î± â†’ Î±) (hf : â‡‘Ï€ = f) (g : Î± â†’ Î±) (hg : â‡‘Ï€.symm = g)\n    (s : Set Î±) (hs : Ï€.domain = s) : Ï€.copy f hf g hg s hs = Ï€ := by substs f g s; cases Ï€; rfl\n", "additional_info": "", "used_premises": [645, 644, 69, 669], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [136, 138], "informalization": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation."}
{"full_name": "PartialPerm.image_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.image_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.toFun '' Ï€.domain = Ï€.domain", "code": "theorem image_domain : Ï€ '' Ï€.domain = Ï€.domain :=\n  Ï€.bijOn.image_eq\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [148, 150], "informalization": "The image of the domain of a partial permutation is equal to the domain itself."}
{"full_name": "PartialPerm.forall_mem_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.forall_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.forall_mem_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {p : Î± â†’ Prop } :(âˆ€ y âˆˆ Ï€.domain, p y) â†” âˆ€ x âˆˆ Ï€.domain, p (Ï€.toFun x)", "code": "theorem forall_mem_domain {p : Î± â†’ Prop} : (âˆ€ y âˆˆ Ï€.domain, p y) â†” âˆ€ x âˆˆ Ï€.domain, p (Ï€ x) := by\n  conv_lhs => rw [â† image_domain, ball_image_iff]\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [151, 153], "informalization": "The statement `âˆ€ y âˆˆ Ï€.domain, p y` is equivalent to `âˆ€ x âˆˆ Ï€.domain, p (Ï€.toFun x)`."}
{"full_name": "PartialPerm.exists_mem_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.exists_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.exists_mem_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {p : Î± â†’ Prop } :(âˆƒ y âˆˆ Ï€.domain, p y) â†” âˆƒ x âˆˆ Ï€.domain, p (Ï€.toFun x)", "code": "theorem exists_mem_domain {p : Î± â†’ Prop} : (âˆƒ y âˆˆ Ï€.domain, p y) â†” âˆƒ x âˆˆ Ï€.domain, p (Ï€ x) := by\n  conv_lhs => rw [â† image_domain, bex_image_iff]\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [154, 156], "informalization": "Given a partial permutation `Ï€` and a property `p`, if there exists an element `y` in the domain of `Ï€` such that `p y` holds, then there exists an element `x` in the domain of `Ï€` such that `p (Ï€.toFun x)` holds."}
{"full_name": "PartialPerm.IsStable.apply_mem_iff", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.apply_mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.apply_mem_iff {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {x : Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) (hx : x âˆˆ Ï€.domain) :Ï€.toFun x âˆˆ s â†” x âˆˆ s", "code": "theorem apply_mem_iff (h : Ï€.IsStable s) (hx : x âˆˆ Ï€.domain) : Ï€ x âˆˆ s â†” x âˆˆ s :=\n  h hx\n", "additional_info": "", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [165, 167], "informalization": "Given a partial permutation `Ï€` and a set `s`, if `Ï€` is stable on `s`, then for any element `x` in the domain of `Ï€`, `x` is in `s` if and only if its image under `Ï€` is also in `s`."}
{"full_name": "PartialPerm.IsStable", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.IsStable {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "def IsStable (s : Set Î±) : Prop :=\n  âˆ€ â¦ƒxâ¦„, x âˆˆ Ï€.domain â†’ (Ï€ x âˆˆ s â†” x âˆˆ s)\n", "additional_info": "A set `s` is *stable* under a partial equivalence `Ï€` if it preserved by it.\nEquations\n* ğŸ—ŸPartialPerm.IsStableğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStableğŸ”—  Ï€ s ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒx : Î±â¦„, x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../../.././Init/Prelude.html#Membership.memğŸ”—  Ï€.domain â†’ (Ï€.toFun x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../../.././Init/Prelude.html#Membership.memğŸ”—  s ğŸ—Ÿâ†”ğŸ—ŸğŸ”—../../../.././Init/Core.html#IffğŸ”—  x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../../.././Init/Prelude.html#Membership.memğŸ”—  s)\n\n", "used_premises": [645, 69], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [158, 160], "informalization": "Function `PartialPerm.IsStable` checks if a set `s` is preserved by a partial permutation `Ï€`, meaning that for any element `x` in the domain of `Ï€`, `x` is in `s` if and only if its image under `Ï€` is also in `s`."}
{"full_name": "PartialPerm.IsStable.symm_apply_mem_iff", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_apply_mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_apply_mem_iff {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) â¦ƒy : Î±â¦„ :y âˆˆ Ï€.domain â†’ ((PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun y âˆˆ s â†” y âˆˆ s)", "code": "theorem symm_apply_mem_iff (h : Ï€.IsStable s) : âˆ€ â¦ƒyâ¦„, y âˆˆ Ï€.domain â†’ (Ï€.symm y âˆˆ s â†” y âˆˆ s) :=\n  Ï€.forall_mem_domain.mpr fun x hx => by rw [Ï€.left_inv hx, h hx]\n", "additional_info": "", "used_premises": [645, 69, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [168, 170], "informalization": "Function `PartialPerm.IsStable.symm_apply_mem_iff` states that for a partial permutation `Ï€` that is stable on a set `s`, if `y` is in the domain of `Ï€`, then `y` is in `s` if and only if its image under the inverse of `Ï€` is also in `s`."}
{"full_name": "PartialPerm.IsStable.symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€) s", "code": "protected theorem symm (h : Ï€.IsStable s) : Ï€.symm.IsStable s :=\n  h.symm_apply_mem_iff\n", "additional_info": "", "used_premises": [645, 69, 677, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [171, 173], "informalization": "If a partial permutation `Ï€` is stable on a set `s`, then its inverse `Ï€.symm` is also stable on `s`."}
{"full_name": "PartialPerm.IsStable.symm_iff", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.IsStable.symm_iff {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€) s â†” PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s", "code": "theorem symm_iff : Ï€.symm.IsStable s â†” Ï€.IsStable s :=\n  âŸ¨fun h => h.symm, fun h => h.symmâŸ©\n", "additional_info": "", "used_premises": [645, 69, 677, 644, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [175, 177], "informalization": "Function `PartialPerm.IsStable.symm_iff` states that a set `s` is preserved by the inverse of a partial permutation `Ï€` if and only if `s` is preserved by `Ï€` itself."}
{"full_name": "PartialPerm.IsStable.mapsTo", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.mapsTo", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.mapsTo {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :Set.MapsToğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun (Ï€.domain âˆ© s) (Ï€.domain âˆ© s)", "code": "protected theorem mapsTo (h : Ï€.IsStable s) : MapsTo Ï€ (Ï€.domain âˆ© s) (Ï€.domain âˆ© s) :=\n  fun _ hx => âŸ¨Ï€.mapsTo hx.1, (h hx.1).2 hx.2âŸ©\n", "additional_info": "", "used_premises": [645, 69, 677, 656], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [178, 180], "informalization": "Function `PartialPerm.IsStable` checks if a set `s` is preserved by a partial permutation `Ï€`, meaning that for any element `x` in the domain of `Ï€`, `x` is in `s` if and only if its image under `Ï€` is also in `s`. Function `Set.MapsTo` checks if the image of a set `s` under a function `f` is contained within another set `t`. The theorem `PartialPerm.IsStable.mapsTo` states that if a set `s` is preserved by a partial permutation `Ï€`, then the image of the intersection of the domain of `Ï€` and `s` under `Ï€` is contained within the intersection of the domain of `Ï€` and `s`."}
{"full_name": "PartialPerm.IsStable.symm_mapsTo", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_mapsTo", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_mapsTo {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :Set.MapsToğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun (Ï€.domain âˆ© s) (Ï€.domain âˆ© s)", "code": "theorem symm_mapsTo (h : Ï€.IsStable s) : MapsTo Ï€.symm (Ï€.domain âˆ© s) (Ï€.domain âˆ© s) :=\n  h.symm.mapsTo\n", "additional_info": "", "used_premises": [645, 69, 677, 656, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [181, 183], "informalization": "The theorem `PartialPerm.IsStable.symm_mapsTo` proves that the inverse of a partial permutation `Ï€` maps elements of the intersection of its domain and a set `s` back into the intersection of its domain and `s`, assuming `s` is preserved by `Ï€` (i.e., `s` is `Ï€.IsStable`). This is a crucial property for understanding how partial permutations interact with sets, especially in the context where the set is preserved by the permutation."}
{"full_name": "PartialPerm.IsStable.restr_toFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr_toFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.IsStable.restr_toFun {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :(PartialPerm.IsStable.restrğŸ”—<|PREMISE|>ğŸ”— h).toFun = Ï€.toFun", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 69, 677, 684], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [185, 186], "informalization": "Function `PartialPerm.IsStable.restr` restricts a partial permutation `Ï€` to a subset `s` of its domain, where `s` is preserved by `Ï€` in the sense that for any element `x` in the domain of `Ï€`, `x` is in `s` if and only if its image under `Ï€` is also in `s`. The result is a new partial permutation whose domain is the intersection of the original domain of `Ï€` and `s`, and whose action on this domain is the same as that of `Ï€`. The theorem `PartialPerm.IsStable.restr_toFun` states that the function `toFun` of the restricted partial permutation is equal to the function `toFun` of the original partial permutation."}
{"full_name": "PartialPerm.IsStable.restr", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.IsStable.restr {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def restr (h : Ï€.IsStable s) : PartialPerm Î±\n    where\n  toFun := Ï€\n  invFun := Ï€.symm\n  domain := Ï€.domain âˆ© s\n  toFun_domain' := h.mapsTo\n  invFun_domain' := h.symm_mapsTo\n  left_inv' := Ï€.leftInvOn.mono (inter_subset_left _ _)\n  right_inv' := Ï€.rightInvOn.mono (inter_subset_left _ _)\n", "additional_info": "Restrict a `ğŸ—ŸPartialPermğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPermğŸ”—`  to a stable subset.\nEquations\n* ğŸ—ŸPartialPerm.IsStable.restrğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restrğŸ”—  h ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toFun := Ï€.toFun, invFun := (ğŸ—ŸPartialPerm.symmğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symmğŸ”—  Ï€).toFun, domain := Ï€.domain ğŸ—Ÿâˆ©ğŸ—ŸğŸ”—../../../.././Init/Core.html#Inter.interğŸ”—  s, toFun_domain' := â‹¯,\n invFun_domain' := â‹¯, left_inv' := â‹¯, right_inv' := â‹¯ }\n\n", "used_premises": [645, 69, 677, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [186, 195], "informalization": "Function `PartialPerm.IsStable.restr` restricts a partial permutation `Ï€` to a subset `s` of its domain, where `s` is preserved by `Ï€` in the sense that for any element `x` in the domain of `Ï€`, `x` is in `s` if and only if its image under `Ï€` is also in `s`. The result is a new partial permutation whose domain is the intersection of the original domain of `Ï€` and `s`, and whose action on this domain is the same as that of `Ï€`."}
{"full_name": "PartialPerm.IsStable.restr_invFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr_invFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.IsStable.restr_invFun {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :(PartialPerm.IsStable.restrğŸ”—<|PREMISE|>ğŸ”— h).invFun = (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 69, 677, 684, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [185, 186], "informalization": "Function `PartialPerm.IsStable.restr_invFun` states that the inverse function of the restriction of a partial permutation `Ï€` to a set `s`, where `s` is preserved by `Ï€`, is equal to the function of the inverse of `Ï€`."}
{"full_name": "PartialPerm.IsStable.restr_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.IsStable.restr_domain {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :(PartialPerm.IsStable.restrğŸ”—<|PREMISE|>ğŸ”— h).domain = Ï€.domain âˆ© s", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 69, 677, 684], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [185, 186], "informalization": "Function `PartialPerm.IsStable.restr_domain` states that the domain of a partial permutation `Ï€` restricted to a subset `s` of its domain, where `s` is preserved by `Ï€`, is equal to the intersection of the original domain of `Ï€` and `s`."}
{"full_name": "PartialPerm.IsStable.image_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.image_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.image_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :Ï€.toFun '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© s", "code": "theorem image_eq (h : Ï€.IsStable s) : Ï€ '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© s :=\n  h.restr.image_domain\n", "additional_info": "", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [196, 198], "informalization": "Given a partial permutation `Ï€` and a set `s`, if `Ï€` is stable on `s`, the image of the intersection of the domain of `Ï€` and `s` under `Ï€` is equal to the intersection of the domain of `Ï€` and `s`."}
{"full_name": "PartialPerm.IsStable.symm_image_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_image_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_image_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© s", "code": "theorem symm_image_eq (h : Ï€.IsStable s) : Ï€.symm '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© s :=\n  h.symm.image_eq\n", "additional_info": "", "used_premises": [645, 69, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [199, 201], "informalization": "Function `PartialPerm.IsStable.symm_image_eq` states that for a partial permutation `Ï€` that is stable on a set `s`, the image of the intersection of the domain of `Ï€` and `s` under the inverse of `Ï€` is equal to the intersection of the domain of `Ï€` and `s`."}
{"full_name": "PartialPerm.IsStable.iff_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.iff_preimage_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s â†” Ï€.domain âˆ© Ï€.toFun â»Â¹' s = Ï€.domain âˆ© s", "code": "theorem iff_preimage_eq : Ï€.IsStable s â†” Ï€.domain âˆ© Ï€ â»Â¹' s = Ï€.domain âˆ© s := by\n  simp only [IsStable, Set.ext_iff, mem_inter_iff, and_congr_right_iff, mem_preimage]\n", "additional_info": "", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [202, 204], "informalization": "Function `PartialPerm.IsStable` checks if a set `s` is preserved by a partial permutation `Ï€`, meaning that for any element `x` in the domain of `Ï€`, `x` is in `s` if and only if its image under `Ï€` is also in `s`. The theorem `iff_preimage_eq` states that this condition is equivalent to the intersection of the domain of `Ï€` and the preimage of `s` under `Ï€.toFun` being equal to the intersection of the domain of `Ï€` and `s`."}
{"full_name": "PartialPerm.IsStable.of_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.of_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.of_preimage_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï€.domain âˆ© Ï€.toFun â»Â¹' s = Ï€.domain âˆ© s â†’ PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s", "code": "alias âŸ¨preimage_eq, of_preimage_eqâŸ© := iff_preimage_eq\n", "additional_info": "**Alias** of the reverse direction of `ğŸ—ŸPartialPerm.IsStable.iff_preimage_eqğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_preimage_eqğŸ”—` .", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [205, 206], "informalization": "Given a partial permutation `Ï€` and a set `s`, if the intersection of the domain of `Ï€` and the preimage of `s` under `Ï€` is equal to the intersection of the domain of `Ï€` and `s`, then `s` is preserved by `Ï€`."}
{"full_name": "PartialPerm.IsStable.preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.preimage_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s â†’ Ï€.domain âˆ© Ï€.toFun â»Â¹' s = Ï€.domain âˆ© s", "code": "alias âŸ¨preimage_eq, of_preimage_eqâŸ© := iff_preimage_eq\n", "additional_info": "**Alias** of the forward direction of `ğŸ—ŸPartialPerm.IsStable.iff_preimage_eqğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_preimage_eqğŸ”—` .", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [205, 206], "informalization": "Function `PartialPerm.IsStable.preimage_eq` is an alias of the forward direction of `PartialPerm.IsStable.iff_preimage_eq`. It states that if a partial permutation `Ï€` is stable on a set `s`, then the intersection of the domain of `Ï€` and the preimage of `s` under `Ï€` is equal to the intersection of the domain of `Ï€` and `s`."}
{"full_name": "PartialPerm.IsStable.iff_symm_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_symm_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.iff_symm_preimage_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s â†” Ï€.domain âˆ© (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun â»Â¹' s = Ï€.domain âˆ© s", "code": "theorem iff_symm_preimage_eq : Ï€.IsStable s â†” Ï€.domain âˆ© Ï€.symm â»Â¹' s = Ï€.domain âˆ© s :=\n  symm_iff.symm.trans iff_preimage_eq\n", "additional_info": "", "used_premises": [645, 69, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [207, 209], "informalization": "The theorem `PartialPerm.IsStable.iff_symm_preimage_eq` states that a set `s` is preserved by a partial permutation `Ï€` if and only if the intersection of the domain of `Ï€` and the preimage of `s` under the inverse of `Ï€` is equal to the intersection of the domain of `Ï€` and `s`."}
{"full_name": "PartialPerm.IsStable.symm_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_preimage_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s â†’ Ï€.domain âˆ© (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun â»Â¹' s = Ï€.domain âˆ© s", "code": "alias âŸ¨symm_preimage_eq, of_symm_preimage_eqâŸ© := iff_symm_preimage_eq\n", "additional_info": "**Alias** of the forward direction of `ğŸ—ŸPartialPerm.IsStable.iff_symm_preimage_eqğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_symm_preimage_eqğŸ”—` .", "used_premises": [645, 69, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [210, 211], "informalization": "Function `PartialPerm.IsStable.symm_preimage_eq` is an alias of the forward direction of `PartialPerm.IsStable.iff_symm_preimage_eq`, which states that if a set `s` is preserved by a partial permutation `Ï€`, then the intersection of the domain of `Ï€` and the preimage of `s` under the inverse of `Ï€` is equal to the intersection of the domain of `Ï€` and `s`."}
{"full_name": "PartialPerm.IsStable.of_symm_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.of_symm_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.of_symm_preimage_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï€.domain âˆ© (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun â»Â¹' s = Ï€.domain âˆ© s â†’ PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s", "code": "alias âŸ¨symm_preimage_eq, of_symm_preimage_eqâŸ© := iff_symm_preimage_eq\n", "additional_info": "**Alias** of the reverse direction of `ğŸ—ŸPartialPerm.IsStable.iff_symm_preimage_eqğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_symm_preimage_eqğŸ”—` .", "used_premises": [645, 69, 644, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [210, 211], "informalization": "The theorem `PartialPerm.IsStable.of_symm_preimage_eq` is an alias of the reverse direction of `PartialPerm.IsStable.iff_symm_preimage_eq`. It states that if the intersection of the domain of a partial permutation `Ï€` and the preimage of a set `s` under the inverse of `Ï€` is equal to the intersection of the domain of `Ï€` and `s`, then `s` is stable under `Ï€`."}
{"full_name": "PartialPerm.IsStable.compl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.compl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.compl {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ sá¶œ", "code": "protected theorem compl (h : Ï€.IsStable s) : Ï€.IsStable (sá¶œ) :=\n  fun _ hx => not_congr (h hx)\n", "additional_info": "", "used_premises": [645, 69, 677, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [212, 214], "informalization": "If a partial permutation `Ï€` is stable on a set `s`, then it is also stable on the complement of `s`."}
{"full_name": "PartialPerm.IsStable.inter", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.inter {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {s' : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) (h' : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s') :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ (s âˆ© s')", "code": "protected theorem inter {s'} (h : Ï€.IsStable s) (h' : Ï€.IsStable s') : Ï€.IsStable (s âˆ© s') :=\n  fun _ hx => and_congr (h hx) (h' hx)\n", "additional_info": "", "used_premises": [645, 69, 69, 677, 677, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [215, 217], "informalization": "Function `PartialPerm.IsStable.inter` proves that if two sets `s` and `s'` are preserved by a partial permutation `Ï€`, then their intersection `s âˆ© s'` is also preserved by `Ï€`."}
{"full_name": "PartialPerm.IsStable.union", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.union", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.union {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {s' : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) (h' : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s') :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ (s âˆª s')", "code": "protected theorem union {s'} (h : Ï€.IsStable s) (h' : Ï€.IsStable s') : Ï€.IsStable (s âˆª s') :=\n  fun _ hx => or_congr (h hx) (h' hx)\n", "additional_info": "", "used_premises": [645, 69, 69, 677, 677, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [218, 220], "informalization": "Function `PartialPerm.IsStable.union` proves that if two sets `s` and `s'` are both preserved by a partial permutation `Ï€`, then their union `s âˆª s'` is also preserved by `Ï€`."}
{"full_name": "PartialPerm.IsStable.diff", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.diff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.diff {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {s' : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) (h' : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s') :PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ (s \\ s')", "code": "protected theorem diff {s'} (h : Ï€.IsStable s) (h' : Ï€.IsStable s') : Ï€.IsStable (s \\ s') :=\n  h.inter h'.compl\n", "additional_info": "", "used_premises": [645, 69, 69, 677, 677, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [221, 223], "informalization": "Function `PartialPerm.IsStable.diff` proves that if two sets `s` and `s'` are preserved by a partial permutation `Ï€`, then their difference `s \\ s'` is also preserved by `Ï€`."}
{"full_name": "PartialPerm.IsStable.leftInvOn_piecewise", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.leftInvOn_piecewise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.leftInvOn_piecewise {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} [(i : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (i âˆˆ s)] (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) (h' : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€' s) :Set.LeftInvOnğŸ”—<|PREMISE|>ğŸ”— (Set.piecewiseğŸ”—<|PREMISE|>ğŸ”— s (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€').toFun) (Set.piecewiseğŸ”—<|PREMISE|>ğŸ”— s Ï€.toFun Ï€'.toFun) (Set.iteğŸ”—<|PREMISE|>ğŸ”— s Ï€.domain Ï€'.domain)", "code": "theorem leftInvOn_piecewise {Ï€' : PartialPerm Î±} [âˆ€ i, Decidable (i âˆˆ s)] (h : Ï€.IsStable s)\n    (h' : Ï€'.IsStable s) :\n    LeftInvOn (s.piecewise Ï€.symm Ï€'.symm) (s.piecewise Ï€ Ï€') (s.ite Ï€.domain Ï€'.domain) := by\n  rintro x (âŸ¨he, hsâŸ© | âŸ¨he, hs : x âˆ‰ sâŸ©)\n  Â· rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), Ï€.left_inv he]\n  Â· rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs),\n      Ï€'.left_inv he]\n", "additional_info": "", "used_premises": [645, 69, 645, 14, 677, 677, 658, 700, 644, 644, 700, 701], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [224, 231], "informalization": "Given a partial permutation `Ï€` and a set `s`, if both `Ï€` and `Ï€'` are stable on `s`, then the piecewise function defined by them and their inverses is a left inverse on the union of the domains of `Ï€` and `Ï€'` restricted to `s`."}
{"full_name": "Set.piecewise", "url": "Mathlib/Logic/Function/Basic.html#Set.piecewise", "code_src": "mathlib4", "ptype": "def", "header": "def Set.piecewise {Î± : Type u} {Î² : Î± â†’ Sort v} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (f : (i : Î±) â†’ Î² i) (g : (i : Î±) â†’ Î² i) [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ s)] (i : Î±) :Î² i", "code": "def Set.piecewise {Î± : Type u} {Î² : Î± â†’ Sort v} (s : Set Î±) (f g : âˆ€ i, Î² i)\n    [âˆ€ j, Decidable (j âˆˆ s)] : âˆ€ i, Î² i :=\n  fun i â†¦ if i âˆˆ s then f i else g i\n", "additional_info": "`s.ğŸ—ŸpiecewiseğŸ—ŸğŸ”—../../.././Mathlib/Logic/Function/Basic.html#Set.piecewiseğŸ”—  f g` is the function equal to `f` on the set `s`, and to `g` on its complement.\nEquations\n* ğŸ—ŸSet.piecewiseğŸ—ŸğŸ”—../../.././Mathlib/Logic/Function/Basic.html#Set.piecewiseğŸ”—  s f g i ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  if i ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s then f i else g i\n\n", "used_premises": [69, 14], "def_path": "Mathlib/Logic/Function/Basic.lean", "pos": [1038, 1041], "informalization": "`Set.piecewise` is a function that takes a set `s`, two functions `f` and `g`, and an element `i`. It returns `f i` if `i` is in `s`, and `g i` otherwise."}
{"full_name": "Set.ite", "url": "Mathlib/Data/Set/Basic.html#Set.ite", "code_src": "mathlib4", "ptype": "def", "header": "def Set.ite {Î± : Type u} (t : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (s' : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :SetğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "protected def ite (t s s' : Set Î±) : Set Î± :=\n  s âˆ© t âˆª s' \\ t\n", "additional_info": "`ğŸ—ŸiteğŸ—ŸğŸ”—../../.././Init/Prelude.html#iteğŸ”—`  for sets: `ğŸ—ŸSet.iteğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Basic.html#Set.iteğŸ”—  t s s' âˆ© t = s âˆ© t`, `ğŸ—ŸSet.iteğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Basic.html#Set.iteğŸ”—  t s s' âˆ© tá¶œ = s' âˆ© tá¶œ`.\nDefined as `s âˆ© t âˆª s' \\ t`.\nEquations\n* ğŸ—ŸSet.iteğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Basic.html#Set.iteğŸ”—  t s s' ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  s ğŸ—Ÿâˆ©ğŸ—ŸğŸ”—../../.././Init/Core.html#Inter.interğŸ”—  t ğŸ—ŸâˆªğŸ—ŸğŸ”—../../.././Init/Core.html#Union.unionğŸ”—  s' ğŸ—Ÿ\\ğŸ—ŸğŸ”—../../.././Init/Core.html#SDiff.sdiffğŸ”—  t\n\n", "used_premises": [69, 69, 69, 69], "def_path": "Mathlib/Data/Set/Basic.lean", "pos": [2235, 2237], "informalization": "`Set.ite` is a function that takes three sets `t`, `s`, and `s'`, and returns the union of the intersection of `s` and `t`, and the difference of `s'` and `t`."}
{"full_name": "PartialPerm.IsStable.inter_eq_of_inter_eq_of_eqOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.inter_eq_of_inter_eq_of_eqOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.inter_eq_of_inter_eq_of_eqOn {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) (h' : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€' s) (hs : Ï€.domain âˆ© s = Ï€'.domain âˆ© s) (Heq : Set.EqOnğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun Ï€'.toFun (Ï€.domain âˆ© s)) :Ï€.domain âˆ© s = Ï€'.domain âˆ© s", "code": "theorem inter_eq_of_inter_eq_of_eqOn {Ï€' : PartialPerm Î±} (h : Ï€.IsStable s) (h' : Ï€'.IsStable s)\n    (hs : Ï€.domain âˆ© s = Ï€'.domain âˆ© s) (Heq : EqOn Ï€ Ï€' (Ï€.domain âˆ© s)) :\n    Ï€.domain âˆ© s = Ï€'.domain âˆ© s := by rw [â† h.image_eq, â† h'.image_eq, â† hs, Heq.image_eq]\n", "additional_info": "", "used_premises": [645, 69, 645, 677, 677, 703], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [232, 235], "informalization": "This theorem proves that, given two partial permutations `Ï€` and `Ï€'` of some type `Î±` which are stable on a set `s` (i.e., `s` is preserved by both permutations), and given that the intersection of the domains of `Ï€` and `Ï€'` with `s` is equal, and that `Ï€` and `Ï€'` are equal on the intersection of their domains with `s`, then the intersection of the domains of `Ï€` and `s` is equal to the intersection of the domains of `Ï€'` and `s`. This theorem helps in proving that the set `s` can be used as a domain for a larger partial permutation which is the union of `Ï€` and `Ï€'`, making the intersection of the domains of the resulting permutation and `s` equal to `s` itself."}
{"full_name": "Set.EqOn", "url": "Mathlib/Data/Set/Defs.html#Set.EqOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.EqOn {Î± : Type u} {Î² : Type v} (fâ‚ : Î± â†’ Î²) (fâ‚‚ : Î± â†’ Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Prop", "code": "def EqOn (fâ‚ fâ‚‚ : Î± â†’ Î²) (s : Set Î±) : Prop := âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ fâ‚ x = fâ‚‚ x\n", "additional_info": "Two functions `fâ‚ fâ‚‚ : Î± â†’ Î²` are equal on `s` if `fâ‚ x = fâ‚‚ x` for all `x âˆˆ s`.\nEquations\n* ğŸ—ŸSet.EqOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.EqOnğŸ”—  fâ‚ fâ‚‚ s ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒx : Î±â¦„, x ğŸ—ŸâˆˆğŸ—ŸğŸ”—../../.././Init/Prelude.html#Membership.memğŸ”—  s â†’ fâ‚ x ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  fâ‚‚ x\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [262, 263], "informalization": "Function `Set.EqOn` checks if two functions `fâ‚` and `fâ‚‚` are equal on a given set `s`. This means that for every element `x` in the set `s`, the values of `fâ‚ x` and `fâ‚‚ x` are equal."}
{"full_name": "PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : PartialPerm.IsStableğŸ”—<|PREMISE|>ğŸ”— Ï€ s) (hs : Ï€.domain âˆ© s = Ï€'.domain âˆ© s) (Heq : Set.EqOnğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun Ï€'.toFun (Ï€.domain âˆ© s)) :Set.EqOnğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€').toFun (Ï€.domain âˆ© s)", "code": "theorem symm_eqOn_of_inter_eq_of_eqOn {Ï€' : PartialPerm Î±} (h : Ï€.IsStable s)\n    (hs : Ï€.domain âˆ© s = Ï€'.domain âˆ© s) (Heq : EqOn Ï€ Ï€' (Ï€.domain âˆ© s)) :\n    EqOn Ï€.symm Ï€'.symm (Ï€.domain âˆ© s) := by\n  rw [â† h.image_eq]\n  rintro y âŸ¨x, hx, rflâŸ©\n  have hx' := hx; rw [hs] at hx'\n  rw [Ï€.left_inv hx.1, Heq hx, Ï€'.left_inv hx'.1]\n", "additional_info": "", "used_premises": [645, 69, 645, 677, 703, 703, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [236, 243], "informalization": "The theorem `PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn` states that if a partial permutation `Ï€` is stable on a set `s`, and `Ï€` and `Ï€'` are equal on the intersection of their domains with `s`, then the inverses of `Ï€` and `Ï€'` are equal on the intersection of their domains with `s`."}
{"full_name": "PartialPerm.image_domain_inter_eq'", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_domain_inter_eq'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.image_domain_inter_eq' {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.toFun '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun â»Â¹' s", "code": "theorem image_domain_inter_eq' (s : Set Î±) : Ï€ '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© Ï€.symm â»Â¹' s := by\n  rw [inter_comm, Ï€.leftInvOn.image_inter', image_domain, inter_comm]\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [246, 248], "informalization": "Function `image_domain_inter_eq'` states that for a partial permutation `Ï€` and a set `s`, the image of the intersection of the domain of `Ï€` and `s` under `Ï€` is equal to the intersection of the domain of `Ï€` and the preimage of `s` under the inverse of `Ï€`."}
{"full_name": "PartialPerm.image_domain_inter_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_domain_inter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.image_domain_inter_eq {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.toFun '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun â»Â¹' (Ï€.domain âˆ© s)", "code": "theorem image_domain_inter_eq (s : Set Î±) :\n    Ï€ '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© Ï€.symm â»Â¹' (Ï€.domain âˆ© s) := by\n  rw [inter_comm, Ï€.leftInvOn.image_inter, image_domain, inter_comm]\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [249, 252], "informalization": "The theorem `image_domain_inter_eq` states that for a partial permutation `Ï€` and a set `s`, the image of the intersection of the domain of `Ï€` and `s` under `Ï€` is equal to the intersection of the domain of `Ï€` and the preimage of the intersection of the domain of `Ï€` and `s` under the inverse of `Ï€`."}
{"full_name": "PartialPerm.image_eq_domain_inter_inv_preimage", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_eq_domain_inter_inv_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.image_eq_domain_inter_inv_preimage {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : s âŠ† Ï€.domain) :Ï€.toFun '' s = Ï€.domain âˆ© (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun â»Â¹' s", "code": "theorem image_eq_domain_inter_inv_preimage {s : Set Î±} (h : s âŠ† Ï€.domain) :\n    Ï€ '' s = Ï€.domain âˆ© Ï€.symm â»Â¹' s := by\n  rw [â† Ï€.image_domain_inter_eq', inter_eq_self_of_subset_right h]\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [253, 256], "informalization": "The image of a set `s` under a partial permutation `Ï€` is equal to the intersection of the domain of `Ï€` and the preimage of `s` under the inverse of `Ï€`."}
{"full_name": "PartialPerm.symm_image_eq_domain_inter_preimage", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_eq_domain_inter_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_eq_domain_inter_preimage {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : s âŠ† Ï€.domain) :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun '' s = Ï€.domain âˆ© Ï€.toFun â»Â¹' s", "code": "theorem symm_image_eq_domain_inter_preimage {s : Set Î±} (h : s âŠ† Ï€.domain) :\n    Ï€.symm '' s = Ï€.domain âˆ© Ï€ â»Â¹' s :=\n  Ï€.symm.image_eq_domain_inter_inv_preimage h\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [257, 260], "informalization": "The theorem `PartialPerm.symm_image_eq_domain_inter_preimage` states that for a partial permutation `Ï€` and a subset `s` of its domain, the image of `s` under the inverse of `Ï€` is equal to the intersection of `Ï€`'s domain with the preimage of `s` under `Ï€`."}
{"full_name": "PartialPerm.symm_image_domain_inter_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_domain_inter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_domain_inter_eq {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© Ï€.toFun â»Â¹' (Ï€.domain âˆ© s)", "code": "theorem symm_image_domain_inter_eq (s : Set Î±) :\n    Ï€.symm '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© Ï€ â»Â¹' (Ï€.domain âˆ© s) :=\n  Ï€.symm.image_domain_inter_eq _\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [261, 264], "informalization": "The theorem `PartialPerm.symm_image_domain_inter_eq` states that for a partial permutation `Ï€` and a set `s`, the image of the intersection of the domain of `Ï€` and `s` under the inverse of `Ï€` is equal to the intersection of the domain of `Ï€` and the preimage of the intersection of the domain of `Ï€` and `s` under `Ï€`."}
{"full_name": "PartialPerm.symm_image_domain_inter_eq'", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_domain_inter_eq'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_domain_inter_eq' {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© Ï€.toFun â»Â¹' s", "code": "theorem symm_image_domain_inter_eq' (s : Set Î±) : Ï€.symm '' (Ï€.domain âˆ© s) = Ï€.domain âˆ© Ï€ â»Â¹' s :=\n  Ï€.symm.image_domain_inter_eq' _\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [265, 267], "informalization": "The theorem `PartialPerm.symm_image_domain_inter_eq'` states that for a partial permutation `Ï€` and a set `s`, the image of the intersection of the domain of `Ï€` and `s` under the inverse of `Ï€` is equal to the intersection of the domain of `Ï€` and the preimage of `s` under `Ï€`."}
{"full_name": "PartialPerm.domain_inter_preimage_inv_preimage", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_inter_preimage_inv_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_inter_preimage_inv_preimage {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.domain âˆ© Ï€.toFun â»Â¹' ((PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun â»Â¹' s) = Ï€.domain âˆ© s", "code": "theorem domain_inter_preimage_inv_preimage (s : Set Î±) :\n    Ï€.domain âˆ© Ï€ â»Â¹' (Ï€.symm â»Â¹' s) = Ï€.domain âˆ© s :=\n  Set.ext fun x => and_congr_right_iff.2 fun hx => by simp only [mem_preimage, Ï€.left_inv hx]\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [268, 271], "informalization": "The theorem `domain_inter_preimage_inv_preimage` states that for a partial permutation `Ï€` and a set `s`, the intersection of the domain of `Ï€` with the preimage of the preimage of `s` under the inverse of `Ï€` is equal to the intersection of the domain of `Ï€` with `s`."}
{"full_name": "PartialPerm.domain_inter_preimage_domain_inter", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_inter_preimage_domain_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_inter_preimage_domain_inter {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.domain âˆ© Ï€.toFun â»Â¹' (Ï€.domain âˆ© s) = Ï€.domain âˆ© Ï€.toFun â»Â¹' s", "code": "theorem domain_inter_preimage_domain_inter (s : Set Î±) :\n    Ï€.domain âˆ© Ï€ â»Â¹' (Ï€.domain âˆ© s) = Ï€.domain âˆ© Ï€ â»Â¹' s :=\n  ext fun _ => âŸ¨fun hx => âŸ¨hx.1, hx.2.2âŸ©, fun hx => âŸ¨hx.1, Ï€.map_domain hx.1, hx.2âŸ©âŸ©\n", "additional_info": "", "used_premises": [645, 69], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [272, 275], "informalization": "The theorem `domain_inter_preimage_domain_inter` states that for a partial permutation `Ï€`, the intersection of its domain with the preimage of the intersection of its domain and a set `s` is equal to the intersection of its domain and the preimage of `s`."}
{"full_name": "PartialPerm.domain_inter_inv_preimage_preimage", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_inter_inv_preimage_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_inter_inv_preimage_preimage {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.domain âˆ© (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun â»Â¹' (Ï€.toFun â»Â¹' s) = Ï€.domain âˆ© s", "code": "theorem domain_inter_inv_preimage_preimage (s : Set Î±) :\n    Ï€.domain âˆ© Ï€.symm â»Â¹' (Ï€ â»Â¹' s) = Ï€.domain âˆ© s :=\n  Ï€.symm.domain_inter_preimage_inv_preimage _\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [276, 279], "informalization": "The theorem `domain_inter_inv_preimage_preimage` states that for a partial permutation `Ï€`, the intersection of its domain with the preimage of the preimage of a set `s` under `Ï€` is equal to the intersection of its domain with `s`."}
{"full_name": "PartialPerm.symm_image_image_of_subset_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_image_of_subset_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_image_of_subset_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : s âŠ† Ï€.domain) :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun '' (Ï€.toFun '' s) = s", "code": "theorem symm_image_image_of_subset_domain {s : Set Î±} (h : s âŠ† Ï€.domain) : Ï€.symm '' (Ï€ '' s) = s :=\n  (Ï€.leftInvOn.mono h).image_image\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [280, 282], "informalization": "The theorem `PartialPerm.symm_image_image_of_subset_domain` states that for a partial permutation `Ï€` and a set `s` that is a subset of the domain of `Ï€`, the image of `s` under `Ï€` followed by the image of the result under the inverse of `Ï€` is equal to `s`."}
{"full_name": "PartialPerm.image_symm_image_of_subset_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_symm_image_of_subset_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.image_symm_image_of_subset_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (h : s âŠ† Ï€.domain) :Ï€.toFun '' ((PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun '' s) = s", "code": "theorem image_symm_image_of_subset_domain {s : Set Î±} (h : s âŠ† Ï€.domain) : Ï€ '' (Ï€.symm '' s) = s :=\n  Ï€.symm.symm_image_image_of_subset_domain h\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [283, 285], "informalization": "The theorem `image_symm_image_of_subset_domain` states that for a partial permutation `Ï€` and a set `s` that is a subset of the domain of `Ï€`, the image of `s` under `Ï€` followed by the image of the result under the inverse of `Ï€` is equal to `s`."}
{"full_name": "PartialPerm.domain_subset_preimage_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_subset_preimage_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_subset_preimage_domain {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï€.domain âŠ† Ï€.toFun â»Â¹' Ï€.domain", "code": "theorem domain_subset_preimage_domain : Ï€.domain âŠ† Ï€ â»Â¹' Ï€.domain :=\n  Ï€.mapsTo\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [288, 290], "informalization": "The domain of a partial permutation is a subset of the preimage of its domain under its forward function."}
{"full_name": "PartialPerm.symm_image_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_domain {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun '' Ï€.domain = Ï€.domain", "code": "theorem symm_image_domain : Ï€.symm '' Ï€.domain = Ï€.domain :=\n  Ï€.symm.image_domain\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [291, 293], "informalization": "The image of the domain of a partial permutation under its inverse is equal to the domain itself."}
{"full_name": "PartialPerm.ext", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.ext {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : âˆ€ (x : Î±), Ï€.toFun x = Ï€'.toFun x) (hsymm : âˆ€ (x : Î±), (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun x = (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€').toFun x) (hs : Ï€.domain = Ï€'.domain) :Ï€ = Ï€'", "code": "protected theorem ext (h : âˆ€ x, Ï€ x = Ï€' x) (hsymm : âˆ€ x, Ï€.symm x = Ï€'.symm x)\n    (hs : Ï€.domain = Ï€'.domain) : Ï€ = Ï€' := by\n  have A : (Ï€ : Î± â†’ Î±) = Ï€' := by ext x; exact h x\n  have B : (Ï€.symm : Î± â†’ Î±) = Ï€'.symm := by ext x; exact hsymm x\n  have I : Ï€ '' Ï€.domain = Ï€.domain := Ï€.image_domain\n  have I' : Ï€' '' Ï€'.domain = Ï€'.domain := Ï€'.image_domain\n  rw [A, hs, I'] at I\n  cases Ï€; cases Ï€'\n  simp_all only [coe_symm_mk, coe_mk, eq_self_iff_true, and_self_iff]\n", "additional_info": "Two partial permutations that have the same `ğŸ—ŸdomainğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domainğŸ”—` , same `ğŸ—ŸtoFunğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toFunğŸ”—`  and same `ğŸ—ŸinvFunğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invFunğŸ”—` , coincide.", "used_premises": [645, 645, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [296, 305], "informalization": "Two partial permutations are equal if they have the same domain, the same function, and the same inverse function."}
{"full_name": "PartialPerm.refl_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.refl_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.refl_domain {Î± : Type u_1} :(PartialPerm.reflğŸ”—<|PREMISE|>ğŸ”— Î±).domain = Set.univ", "code": "theorem refl_domain : (PartialPerm.refl Î±).domain = univ :=\n  rfl\n", "additional_info": "", "used_premises": [720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [311, 313], "informalization": "The domain of the identity partial permutation is the universal set."}
{"full_name": "PartialPerm.refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.refl", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.refl (Î± : Type u_1) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "protected def refl (Î± : Type _) : PartialPerm Î± :=\n  Equiv.Perm.toPartialPerm <| Equiv.refl _\n", "additional_info": "The identity partial permutation.\nEquations\n* ğŸ—ŸPartialPerm.reflğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.reflğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸEquiv.Perm.toPartialPermğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPermğŸ”—  (ğŸ—ŸEquiv.reflğŸ—ŸğŸ”—../../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.reflğŸ”—  Î±)\n\n", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [307, 309], "informalization": "Function `PartialPerm.refl` defines the identity partial permutation on a type `Î±`, which maps every element of `Î±` to itself."}
{"full_name": "PartialPerm.coe_refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_refl", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_refl {Î± : Type u_1} :(PartialPerm.reflğŸ”—<|PREMISE|>ğŸ”— Î±).toFun = id", "code": "theorem coe_refl : â‡‘(PartialPerm.refl Î±) = id :=\n  rfl\n", "additional_info": "", "used_premises": [720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [315, 317], "informalization": "The theorem `PartialPerm.coe_refl` states that the identity partial permutation on a type `Î±`, when coerced to a function, is equal to the identity function on `Î±`."}
{"full_name": "PartialPerm.symm_refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_refl", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.symm_refl {Î± : Type u_1} :PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.reflğŸ”—<|PREMISE|>ğŸ”— Î±) = PartialPerm.reflğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "theorem symm_refl : (PartialPerm.refl Î±).symm = PartialPerm.refl Î± :=\n  rfl\n", "additional_info": "", "used_premises": [644, 720, 720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [319, 321], "informalization": "The inverse of the identity partial permutation is itself."}
{"full_name": "PartialPerm.trans_invFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.trans_invFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.trans_invFun {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (h : Ï€.domain = Ï€'.domain) :âˆ€ (a : Î±), (PartialPerm.transğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h).invFun a = ((PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun âˆ˜ (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€').toFun) a", "code": "@[simps]\n", "additional_info": "", "used_premises": [645, 645, 724, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [330, 331], "informalization": "Function `PartialPerm.trans_invFun` states that the inverse of the composition of two partial permutations `Ï€` and `Ï€'` is equal to the composition of the inverses of `Ï€` and `Ï€'` in reverse order."}
{"full_name": "PartialPerm.trans", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.trans", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.trans {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (h : Ï€.domain = Ï€'.domain) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "protected def trans (Ï€' : PartialPerm Î±) (h : Ï€.domain = Ï€'.domain) : PartialPerm Î±\n    where\n  toFun := Ï€' âˆ˜ Ï€\n  invFun := Ï€.symm âˆ˜ Ï€'.symm\n  domain := Ï€.domain\n  toFun_domain' x hx := by\n    rw [h]\n    refine map_domain _ ?_\n    have := map_domain Ï€ hx\n    rwa [h] at this\n  invFun_domain' y hy := by\n    refine map_domain _ ?_\n    rw [h] at hy\n    have := map_domain Ï€'.symm hy\n    rwa [symm_domain, â† h] at this\n  left_inv' x hx := by\n    simp [hx, h.symm]\n    rw [left_inv Ï€', left_inv Ï€ hx]\n    have := map_domain Ï€ hx\n    rwa [â† h]\n  right_inv' y hy := by\n    simp\n    rw [h] at hy\n    rw [right_inv Ï€, right_inv Ï€' hy]\n    have := map_domain Ï€'.symm hy\n    rwa [symm_domain, â† h] at this\n", "additional_info": "Composing two partial permutations if the domain of the first coincides with the domain of the\nsecond.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [645, 645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [331, 357], "informalization": "Function `PartialPerm.trans` composes two partial permutations if the domain of the first coincides with the domain of the second, resulting in a new partial permutation."}
{"full_name": "PartialPerm.trans_toFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.trans_toFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.trans_toFun {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (h : Ï€.domain = Ï€'.domain) :âˆ€ (a : Î±), (PartialPerm.transğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h).toFun a = (Ï€'.toFun âˆ˜ Ï€.toFun) a", "code": "@[simps]\n", "additional_info": "", "used_premises": [645, 645, 724], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [330, 331], "informalization": "Function `PartialPerm.trans` composes two partial permutations if the domain of the first coincides with the domain of the second, resulting in a new partial permutation. The `toFun` of the resulting partial permutation is the composition of the `toFun`s of the two original partial permutations."}
{"full_name": "PartialPerm.trans_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.trans_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.trans_domain {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (h : Ï€.domain = Ï€'.domain) :(PartialPerm.transğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h).domain = Ï€.domain", "code": "@[simps]\n", "additional_info": "", "used_premises": [645, 645, 724], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [330, 331], "informalization": "`PartialPerm.trans_domain` states that the domain of the composition of two partial permutations is equal to the domain of the first partial permutation."}
{"full_name": "PartialPerm.ofSet_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.ofSet_domain {Î± : Type u_1} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :(PartialPerm.ofSetğŸ”—<|PREMISE|>ğŸ”— s).domain = s", "code": "theorem ofSet_domain (s : Set Î±) : (ofSet s).domain = s :=\n  rfl\n", "additional_info": "", "used_premises": [69, 728], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [369, 371], "informalization": "The domain of the partial permutation `PartialPerm.ofSet s` is equal to the set `s`."}
{"full_name": "PartialPerm.ofSet", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.ofSet {Î± : Type u_1} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def ofSet (s : Set Î±) : PartialPerm Î± where\n  toFun := id\n  invFun := id\n  domain := s\n  toFun_domain' _ hx := hx\n  invFun_domain' _ hx := hx\n  left_inv' _ _ := rfl\n  right_inv' _ _ := rfl\n", "additional_info": "The identity partial PERMUTATION on a set `s`\nEquations\n* ğŸ—ŸPartialPerm.ofSetğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSetğŸ”—  s ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toFun := id, invFun := id, domain := s, toFun_domain' := â‹¯, invFun_domain' := â‹¯, left_inv' := â‹¯, right_inv' := â‹¯ }\n\n", "used_premises": [69, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [359, 367], "informalization": "Function `PartialPerm.ofSet` constructs a partial permutation from a given set `s`. This partial permutation is the identity function on `s`, meaning it maps each element of `s` to itself, and its inverse also maps each element of `s` to itself. The domain of this partial permutation is `s`, and it is undefined outside of `s`."}
{"full_name": "PartialPerm.coe_ofSet", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_ofSet", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_ofSet {Î± : Type u_1} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :(PartialPerm.ofSetğŸ”—<|PREMISE|>ğŸ”— s).toFun = id", "code": "theorem coe_ofSet (s : Set Î±) : (ofSet s : Î± â†’ Î±) = id :=\n  rfl\n", "additional_info": "", "used_premises": [69, 728], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [373, 375], "informalization": "Function `PartialPerm.ofSet` constructs a partial permutation from a given set `s`. This partial permutation is the identity function on `s`, meaning it maps each element of `s` to itself, and its inverse also maps each element of `s` to itself. The domain of this partial permutation is `s`, and it is undefined outside of `s`."}
{"full_name": "PartialPerm.ofSet_symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.ofSet_symm {Î± : Type u_1} (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.ofSetğŸ”—<|PREMISE|>ğŸ”— s) = PartialPerm.ofSetğŸ”—<|PREMISE|>ğŸ”— s", "code": "theorem ofSet_symm (s : Set Î±) : (ofSet s).symm = ofSet s :=\n  rfl\n", "additional_info": "", "used_premises": [69, 644, 728, 728], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [377, 379], "informalization": "Function `PartialPerm.ofSet_symm` states that the inverse of a partial permutation constructed from a set `s` is equal to the partial permutation itself."}
{"full_name": "PartialPerm.ofSet_univ", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet_univ", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.ofSet_univ {Î± : Type u_1} :PartialPerm.ofSetğŸ”—<|PREMISE|>ğŸ”— Set.univ = PartialPerm.reflğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "theorem ofSet_univ : ofSet univ = PartialPerm.refl Î± :=\n  rfl\n", "additional_info": "", "used_premises": [728, 720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [385, 387], "informalization": "Function `PartialPerm.ofSet` constructs a partial permutation from a given set `s`. This partial permutation is the identity function on `s`, meaning it maps each element of `s` to itself, and its inverse also maps each element of `s` to itself. The domain of this partial permutation is `s`, and it is undefined outside of `s`. When `s` is the universal set `univ`, the partial permutation `ofSet univ` is equivalent to the identity partial permutation `refl`."}
{"full_name": "PartialPerm.coe_toPartialEquiv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_toPartialEquiv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_toPartialEquiv {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :â†‘(PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— Ï€) = Ï€.toFun", "code": "theorem coe_toPartialEquiv : â‡‘Ï€.toPartialEquiv = Ï€ :=\n  rfl\n", "additional_info": "", "used_premises": [645, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [400, 402], "informalization": "The theorem `PartialPerm.coe_toPartialEquiv` states that the coercion of a partial permutation `Ï€` to a partial equivalence is equal to the function `toFun` of `Ï€`."}
{"full_name": "PartialPerm.toPartialEquiv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.toPartialEquiv {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :PartialEquivğŸ”—<|PREMISE|>ğŸ”— Î± Î±", "code": "def toPartialEquiv : PartialEquiv Î± Î± where\n  toFun := Ï€\n  invFun := Ï€.symm\n  source := Ï€.domain\n  target := Ï€.domain\n  map_source' := Ï€.mapsTo\n  map_target' := Ï€.symm.mapsTo\n  left_inv' := Ï€.leftInvOn\n  right_inv' := Ï€.rightInvOn\n", "additional_info": "Reinterpret a partial permutation as a partial equivalence.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [645, 734], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [389, 398], "informalization": "Function `PartialPerm.toPartialEquiv` converts a partial permutation `Ï€` of a type `Î±` into a partial equivalence, which is a structure consisting of two functions `toFun` and `invFun` (representing the partial permutation and its inverse, respectively), and two sets `source` and `target` (both equal to the domain of the partial permutation), along with proofs that these functions are inverses of each other on their respective domains."}
{"full_name": "PartialEquiv", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv", "code_src": "mathlib4", "ptype": "structure", "header": "structure PartialEquiv (Î± : Type u_5) (Î² : Type u_6) :Type (max u_5 u_6)\n | toFun : Î± â†’ Î²\n | invFun : Î² â†’ Î±\n | source : SetğŸ”—<|PREMISE|>ğŸ”—  Î±\n | target : SetğŸ”—<|PREMISE|>ğŸ”—  Î²\n | map_source' : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ  self.source â†’ â†‘self x âˆˆ  self.target\n | map_target' : âˆ€ â¦ƒx : Î²â¦„, x âˆˆ  self.target â†’ self.invFun x âˆˆ  self.source\n | left_inv' : âˆ€ â¦ƒx : Î±â¦„, x âˆˆ  self.source â†’ self.invFun (â†‘self x) =  x\n | right_inv' : âˆ€ â¦ƒx : Î²â¦„, x âˆˆ  self.target â†’ â†‘self (self.invFun x) =  x", "code": "structure PartialEquiv (Î± : Type*) (Î² : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : Î± â†’ Î²\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : Î² â†’ Î±\n  /-- The domain of the partial equivalence. -/\n  source : Set Î±\n  /-- The codomain of the partial equivalence. -/\n  target : Set Î²\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : âˆ€ â¦ƒxâ¦„, x âˆˆ source â†’ toFun x âˆˆ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : âˆ€ â¦ƒxâ¦„, x âˆˆ target â†’ invFun x âˆˆ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : âˆ€ â¦ƒxâ¦„, x âˆˆ source â†’ invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : âˆ€ â¦ƒxâ¦„, x âˆˆ target â†’ toFun (invFun x) = x\n", "additional_info": "Local equivalence between subsets `ğŸ—ŸsourceğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.sourceğŸ”—`  and `ğŸ—ŸtargetğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.targetğŸ”—`  of `Î±` and `Î²` respectively. The\n(global) maps `ğŸ—ŸtoFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFunğŸ”—  : Î± â†’ Î²` and `ğŸ—ŸinvFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.invFunğŸ”—  : Î² â†’ Î±` map `ğŸ—ŸsourceğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.sourceğŸ”—`  to `ğŸ—ŸtargetğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.targetğŸ”—`  and conversely, and are\ninverse to each other there. The values of `ğŸ—ŸtoFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFunğŸ”—`  outside of `ğŸ—ŸsourceğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.sourceğŸ”—`  and of `ğŸ—ŸinvFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.invFunğŸ”—`  outside of\n`ğŸ—ŸtargetğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.targetğŸ”—`  are irrelevant.\n- PartialEquiv.toFun: The global function which has a partial inverse. Its value outside of the `ğŸ—ŸsourceğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.sourceğŸ”—`  subset is\nirrelevant.\n\n\n- PartialEquiv.invFun: The partial inverse to `ğŸ—ŸtoFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFunğŸ”—` . Its value outside of the `ğŸ—ŸtargetğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.targetğŸ”—`  subset is irrelevant.\n\n\n- PartialEquiv.source: The domain of the partial equivalence.\n\n\n- PartialEquiv.target: The codomain of the partial equivalence.\n\n\n- PartialEquiv.map_source': The proposition that elements of `ğŸ—ŸsourceğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.sourceğŸ”—`  are mapped to elements of `ğŸ—ŸtargetğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.targetğŸ”—` .\n\n\n- PartialEquiv.map_target': The proposition that elements of `ğŸ—ŸtargetğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.targetğŸ”—`  are mapped to elements of `ğŸ—ŸsourceğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.sourceğŸ”—` .\n\n\n- PartialEquiv.left_inv': The proposition that `ğŸ—ŸinvFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.invFunğŸ”—`  is a left-inverse of `ğŸ—ŸtoFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFunğŸ”—`  on `ğŸ—ŸsourceğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.sourceğŸ”—` .\n\n\n- PartialEquiv.right_inv': The proposition that `ğŸ—ŸinvFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.invFunğŸ”—`  is a right-inverse of `ğŸ—ŸtoFunğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFunğŸ”—`  on `ğŸ—ŸtargetğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.targetğŸ”—` .\n\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [119, 137], "informalization": "The Lean 4 object `Prod` represents a product type (pair) of two types, providing two projections to access the first and second elements."}
{"full_name": "PartialPerm.coe_toPartialEquiv_symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_toPartialEquiv_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_toPartialEquiv_symm {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :â†‘(PartialEquiv.symmğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— Ï€)) = (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun", "code": "theorem coe_toPartialEquiv_symm : â‡‘Ï€.toPartialEquiv.symm = Ï€.symm :=\n  rfl\n", "additional_info": "", "used_premises": [645, 736, 733, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [404, 406], "informalization": "The theorem `PartialPerm.coe_toPartialEquiv_symm` states that for a partial permutation `Ï€` of a type `Î±`, the inverse of the partial equivalence obtained from `Ï€` is equal to the function representing the inverse of `Ï€`."}
{"full_name": "PartialEquiv.symm", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.symm", "code_src": "mathlib4", "ptype": "def", "header": "def PartialEquiv.symm {Î± : Type u_1} {Î² : Type u_2} (e : PartialEquivğŸ”—<|PREMISE|>ğŸ”— Î± Î²) :PartialEquivğŸ”—<|PREMISE|>ğŸ”— Î² Î±", "code": "protected def symm : PartialEquiv Î² Î± where\n  toFun := e.invFun\n  invFun := e.toFun\n  source := e.target\n  target := e.source\n  map_source' := e.map_target'\n  map_target' := e.map_source'\n  left_inv' := e.right_inv'\n  right_inv' := e.left_inv'\n", "additional_info": "The inverse of a partial equivalence\nEquations\n* ğŸ—ŸPartialEquiv.symmğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.symmğŸ”—  e ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { toFun := e.invFun, invFun := â†‘e, source := e.target, target := e.source, map_source' := â‹¯, map_target' := â‹¯,\n left_inv' := â‹¯, right_inv' := â‹¯ }\n\n", "used_premises": [734, 734], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [151, 160], "informalization": "Function `PartialEquiv.symm` defines the inverse of a partial equivalence `e` between two types `Î±` and `Î²`. A partial equivalence is a relation that is one-to-one and onto between a subset of `Î±` and a subset of `Î²`. The inverse of a partial equivalence is another partial equivalence that reverses the roles of `Î±` and `Î²`, essentially swapping the domain and range of the original partial equivalence. This operation is crucial in understanding the structure of partial equivalences and their applications in various mathematical contexts."}
{"full_name": "PartialPerm.toPartialEquiv_source", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_source", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_source {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :(PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— Ï€).source = Ï€.domain", "code": "theorem toPartialEquiv_source : Ï€.toPartialEquiv.source = Ï€.domain :=\n  rfl\n", "additional_info": "", "used_premises": [645, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [408, 410], "informalization": "The function `PartialPerm.toPartialEquiv` converts a partial permutation `Ï€` of a type `Î±` into a partial equivalence. The `source` of this partial equivalence is equal to the `domain` of the partial permutation `Ï€`."}
{"full_name": "PartialPerm.toPartialEquiv_target", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_target", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_target {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :(PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— Ï€).target = Ï€.domain", "code": "theorem toPartialEquiv_target : Ï€.toPartialEquiv.target = Ï€.domain :=\n  rfl\n", "additional_info": "", "used_premises": [645, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [412, 414], "informalization": "Function `PartialPerm.toPartialEquiv` converts a partial permutation `Ï€` of a type `Î±` into a partial equivalence. The `target` of this partial equivalence is equal to the `domain` of the partial permutation `Ï€`."}
{"full_name": "PartialPerm.toPartialEquiv_refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_refl", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_refl {Î± : Type u_1} :PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.reflğŸ”—<|PREMISE|>ğŸ”— Î±) = PartialEquiv.reflğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "theorem toPartialEquiv_refl : (PartialPerm.refl Î±).toPartialEquiv = PartialEquiv.refl _ :=\n  rfl\n", "additional_info": "", "used_premises": [733, 720, 740], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [416, 418], "informalization": "Function `PartialPerm.toPartialEquiv_refl` states that converting the identity partial permutation to a partial equivalence yields the identity partial equivalence."}
{"full_name": "PartialEquiv.refl", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.refl", "code_src": "mathlib4", "ptype": "def", "header": "def PartialEquiv.refl (Î± : Type u_5) :PartialEquivğŸ”—<|PREMISE|>ğŸ”— Î± Î±", "code": "protected def refl (Î± : Type*) : PartialEquiv Î± Î± :=\n  (Equiv.refl Î±).toPartialEquiv\n", "additional_info": "The identity partial equiv\nEquations\n* ğŸ—ŸPartialEquiv.reflğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.reflğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸEquiv.toPartialEquivğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#Equiv.toPartialEquivğŸ”—  (ğŸ—ŸEquiv.reflğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.reflğŸ”—  Î±)\n\n", "used_premises": [734], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [608, 610], "informalization": "Function `PartialEquiv.refl` defines the identity partial equivalence on a type `Î±`."}
{"full_name": "PartialPerm.toPartialEquiv_symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_symm {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) :PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€) = PartialEquiv.symmğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— Ï€)", "code": "theorem toPartialEquiv_symm : Ï€.symm.toPartialEquiv = Ï€.toPartialEquiv.symm :=\n  rfl\n", "additional_info": "", "used_premises": [645, 733, 644, 736, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [420, 422], "informalization": "Function `PartialPerm.toPartialEquiv_symm` states that the inverse of a partial permutation, when converted to a partial equivalence, is equal to the inverse of the partial equivalence obtained from the original partial permutation."}
{"full_name": "PartialPerm.toPartialEquiv_trans", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_trans", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_trans {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (h : Ï€.domain = Ï€'.domain) :PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.transğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h) = PartialEquiv.transğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— Ï€) (PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— Ï€')", "code": "theorem toPartialEquiv_trans (h) :\n    (Ï€.trans Ï€' h).toPartialEquiv = Ï€.toPartialEquiv.trans Ï€'.toPartialEquiv := by\n  ext\n  Â· rfl\n  Â· rfl\n  Â· simpa [â† h] using fun hx => Ï€.mapsTo hx\n", "additional_info": "", "used_premises": [645, 645, 733, 724, 743, 733, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [424, 430], "informalization": "The theorem `PartialPerm.toPartialEquiv_trans` states that the composition of two partial permutations, when converted to partial equivalences, is equal to the composition of the partial equivalences themselves."}
{"full_name": "PartialEquiv.trans", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.trans", "code_src": "mathlib4", "ptype": "def", "header": "def PartialEquiv.trans {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (e : PartialEquivğŸ”—<|PREMISE|>ğŸ”— Î± Î²) (e' : PartialEquivğŸ”—<|PREMISE|>ğŸ”— Î² Î³) :PartialEquivğŸ”—<|PREMISE|>ğŸ”— Î± Î³", "code": "protected def trans : PartialEquiv Î± Î³ :=\n  PartialEquiv.trans' (e.symm.restr e'.source).symm (e'.restr e.target) (inter_comm _ _)\n", "additional_info": "Composing two partial equivs, by restricting to the maximal domain where their composition\nis well defined.\nEquations\n* ğŸ—ŸPartialEquiv.transğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.transğŸ”—  e e' ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸPartialEquiv.trans'ğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.trans'ğŸ”—  (ğŸ—ŸPartialEquiv.symmğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.symmğŸ”—  (ğŸ—ŸPartialEquiv.restrğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.restrğŸ”—  (ğŸ—ŸPartialEquiv.symmğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.symmğŸ”—  e) e'.source))\n(ğŸ—ŸPartialEquiv.restrğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.restrğŸ”—  e' e.target) â‹¯\n\n", "used_premises": [734, 734, 734], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [693, 695], "informalization": "Function `PartialEquiv.trans` composes two partial equivs, by restricting to the maximal domain where their composition is well defined."}
{"full_name": "PartialPerm.eq_on_domain_refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.eq_on_domain_refl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.eq_on_domain_refl {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} :Ï€ â‰ˆ Ï€", "code": "theorem eq_on_domain_refl : Ï€ â‰ˆ Ï€ :=\n  Setoid.refl _\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [458, 460], "informalization": "The theorem `eq_on_domain_refl` states that a partial permutation is equal to itself on its domain."}
{"full_name": "PartialPerm.EqOnDomain.domain_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.domain_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.domain_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰ˆ Ï€') :Ï€.domain = Ï€'.domain", "code": "theorem EqOnDomain.domain_eq (h : Ï€ â‰ˆ Ï€') : Ï€.domain = Ï€'.domain :=\n  h.1\n", "additional_info": "Two equivalent partial permutations have the same domain", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [462, 464], "informalization": "Two equivalent partial permutations have the same domain."}
{"full_name": "PartialPerm.EqOnDomain.symm_domain_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.symm_domain_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.symm_domain_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰ˆ Ï€') :(PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).domain = (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€').domain", "code": "theorem EqOnDomain.symm_domain_eq (h : Ï€ â‰ˆ Ï€') : Ï€.symm.domain = Ï€'.symm.domain :=\n  h.1\n", "additional_info": "", "used_premises": [645, 645, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [465, 467], "informalization": "`PartialPerm.EqOnDomain.symm_domain_eq` states that for two partial permutations `Ï€` and `Ï€'` that are equal on their domains, the domains of their inverses are also equal."}
{"full_name": "PartialPerm.EqOnDomain.eqOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.eqOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.eqOn {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰ˆ Ï€') :Set.EqOnğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun Ï€'.toFun Ï€.domain", "code": "theorem EqOnDomain.eqOn (h : Ï€ â‰ˆ Ï€') : Ï€.domain.EqOn Ï€ Ï€' :=\n  h.2\n", "additional_info": "Two equivalent partial permutations coincide on the domain", "used_premises": [645, 645, 703], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [469, 471], "informalization": "Function `eqOn` checks if two partial permutations `Ï€` and `Ï€'` are equal on the domain of `Ï€`."}
{"full_name": "PartialPerm.EqOnDomain.symm'", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.symm'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.symm' {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰ˆ Ï€') :PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â‰ˆ PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€'", "code": "theorem EqOnDomain.symm' (h : Ï€ â‰ˆ Ï€') : Ï€.symm â‰ˆ Ï€'.symm := by\n  refine âŸ¨EqOnDomain.symm_domain_eq h, eqOn_of_leftInvOn_of_rightInvOn Ï€.leftInvOn ?_ ?_âŸ© <;>\n    simp only [symm_domain, EqOnDomain.domain_eq h, Ï€'.symm.mapsTo]\n  exact Ï€'.rightInvOn.congr_right Ï€'.symm.mapsTo (EqOnDomain.domain_eq h â–¸ h.eqOn.symm)\n  exact Ï€'.symm.mapsTo\n", "additional_info": "If two partial permutations are equivalent, so are their inverses.", "used_premises": [645, 645, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [473, 478], "informalization": "Function `PartialPerm.EqOnDomain.symm'` proves that if two partial permutations are equivalent, then their inverses are also equivalent."}
{"full_name": "PartialPerm.EqOnDomain.symm_eqOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.symm_eqOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.symm_eqOn {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰ˆ Ï€') :Set.EqOnğŸ”—<|PREMISE|>ğŸ”— (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).toFun (PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€').toFun Ï€.domain", "code": "theorem EqOnDomain.symm_eqOn (h : Ï€ â‰ˆ Ï€') : EqOn Ï€.symm Ï€'.symm Ï€.domain :=\n  EqOnDomain.eqOn (EqOnDomain.symm' h)\n", "additional_info": "Two equivalent partial permutations have coinciding inverses on the domain", "used_premises": [645, 645, 703, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [480, 482], "informalization": "If two partial permutations are equivalent, then their inverses are equal on the domain of the partial permutations."}
{"full_name": "PartialPerm.EqOnDomain.domain_inter_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.domain_inter_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.domain_inter_preimage_eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (hÏ€ : Ï€ â‰ˆ Ï€') (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :Ï€.domain âˆ© Ï€.toFun â»Â¹' s = Ï€'.domain âˆ© Ï€'.toFun â»Â¹' s", "code": "theorem EqOnDomain.domain_inter_preimage_eq (hÏ€ : Ï€ â‰ˆ Ï€') (s : Set Î±) :\n    Ï€.domain âˆ© Ï€ â»Â¹' s = Ï€'.domain âˆ© Ï€' â»Â¹' s := by rw [hÏ€.eqOn.inter_preimage_eq, EqOnDomain.domain_eq hÏ€]\n", "additional_info": "Preimages are respected by equivalence.", "used_premises": [645, 645, 69], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [484, 486], "informalization": "Function `PartialPerm.EqOnDomain.domain_inter_preimage_eq` proves that the intersection of the domain of a partial permutation `Ï€` and the preimage of a set `s` under `Ï€.toFun` is equal to the intersection of the domain of an equivalent partial permutation `Ï€'` and the preimage of `s` under `Ï€'.toFun`."}
{"full_name": "PartialPerm.EqOnDomain.eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.eq {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰ˆ Ï€') (hÏ€ : Ï€.domain = Set.univ) :Ï€ = Ï€'", "code": "protected theorem EqOnDomain.eq (h : Ï€ â‰ˆ Ï€') (hÏ€ : Ï€.domain = univ) : Ï€ = Ï€' := by\n  apply PartialPerm.ext (fun x => h.2 _) (fun x => h.symm'.2 _) h.1 <;> simp [hÏ€]\n", "additional_info": "Two equivalent partial permutations are equal when the domain and domain are univ.", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [488, 490], "informalization": "The theorem `PartialPerm.EqOnDomain.eq` states that two equivalent partial permutations are equal when the domain and domain are univ."}
{"full_name": "PartialPerm.domain_mono", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_mono", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_mono {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰¤ Ï€') :Ï€.domain âŠ† Ï€'.domain", "code": "theorem domain_mono (h : Ï€ â‰¤ Ï€') : Ï€.domain âŠ† Ï€'.domain :=\n  h.1\n", "additional_info": "", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [499, 501], "informalization": "For partial permutations `Ï€` and `Ï€'`, if `Ï€ â‰¤ Ï€'`, then the domain of `Ï€` is a subset of the domain of `Ï€'`."}
{"full_name": "PartialPerm.eqOn_domain_of_le", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.eqOn_domain_of_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.eqOn_domain_of_le {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰¤ Ï€') :Set.EqOnğŸ”—<|PREMISE|>ğŸ”— Ï€.toFun Ï€'.toFun Ï€.domain", "code": "theorem eqOn_domain_of_le (h : Ï€ â‰¤ Ï€') : Ï€.domain.EqOn Ï€ Ï€' :=\n  h.2\n", "additional_info": "", "used_premises": [645, 645, 703], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [502, 504], "informalization": "Given two partial permutations `Ï€` and `Ï€'`, if `Ï€` is less than or equal to `Ï€'`, then `Ï€` and `Ï€'` are equal on the domain of `Ï€`."}
{"full_name": "PartialPerm.le_of_eq_on_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.le_of_eq_on_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.le_of_eq_on_domain {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰ˆ Ï€') :Ï€ â‰¤ Ï€'", "code": "theorem le_of_eq_on_domain (h : Ï€ â‰ˆ Ï€') : Ï€ â‰¤ Ï€' :=\n  âŸ¨subset_of_eq h.1, h.2âŸ©\n", "additional_info": "", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [505, 507], "informalization": "If two partial permutations `Ï€` and `Ï€'` are equal on their domains, then `Ï€` is less than or equal to `Ï€'`."}
{"full_name": "PartialPerm.apply_eq_of_le", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.apply_eq_of_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.apply_eq_of_le {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} (h : Ï€ â‰¤ Ï€') {x : Î±} (hx : x âˆˆ Ï€.domain) :Ï€'.toFun x = Ï€.toFun x", "code": "theorem apply_eq_of_le (h : Ï€ â‰¤ Ï€') {x : Î±} (hx : x âˆˆ Ï€.domain) : Ï€' x = Ï€ x :=\n  (eqOn_domain_of_le h hx).symm\n", "additional_info": "", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [508, 510], "informalization": "If `Ï€ â‰¤ Ï€'` and `x âˆˆ Ï€.domain`, then `Ï€'.toFun x = Ï€.toFun x`."}
{"full_name": "PartialPerm.piecewise_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.piecewise_domain {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ Ï€.domain)] {h : DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.domain Ï€'.domain} :(PartialPerm.piecewiseğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h).domain = Ï€.domain âˆª Ï€'.domain", "code": "theorem piecewise_domain : (piecewise Ï€ Ï€' h).domain = Ï€.domain âˆª Ï€'.domain :=\n  rfl\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [551, 553], "informalization": "Function `PartialPerm.piecewise` takes two partial permutations `Ï€` and `Ï€'` with disjoint domains and returns a new partial permutation that coincides with `Ï€` on `Ï€.domain` and with `Ï€'` on `Ï€'.domain`. The domain of the resulting partial permutation is the union of the domains of `Ï€` and `Ï€'`."}
{"full_name": "Disjoint", "url": "Mathlib/Order/Disjoint.html#Disjoint", "code_src": "mathlib4", "ptype": "def", "header": "def Disjoint {Î± : Type u_1} [PartialOrderğŸ”—<|PREMISE|>ğŸ”— Î±] [OrderBotğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) (b : Î±) :Prop", "code": "def Disjoint (a b : Î±) : Prop :=\n  âˆ€ â¦ƒxâ¦„, x â‰¤ a â†’ x â‰¤ b â†’ x â‰¤ âŠ¥\n", "additional_info": "Two elements of a lattice are disjoint if their inf is the bottom element.\n(This generalizes disjoint sets, viewed as members of the subset lattice.)\nNote that we define this without reference to `âŠ“`, as this allows us to talk about orders where\nthe infimum is not unique, or where implementing `ğŸ—ŸInfğŸ—ŸğŸ”—../.././Mathlib/Order/Notation.html#InfğŸ”—`  would require additional `ğŸ—ŸDecidableğŸ—ŸğŸ”—../.././Init/Prelude.html#DecidableğŸ”—` \narguments.\nEquations\n* ğŸ—ŸDisjointğŸ—ŸğŸ”—../.././Mathlib/Order/Disjoint.html#DisjointğŸ”—  a b ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒx : Î±â¦„, x ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../.././Init/Prelude.html#LE.leğŸ”—  a â†’ x ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../.././Init/Prelude.html#LE.leğŸ”—  b â†’ x ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../.././Init/Prelude.html#LE.leğŸ”—  ğŸ—ŸâŠ¥ğŸ—ŸğŸ”—../.././Mathlib/Order/Notation.html#Bot.botğŸ”—\n\n", "used_premises": [3, 758], "def_path": "Mathlib/Order/Disjoint.lean", "pos": [41, 43], "informalization": "Function `Disjoint` checks if two elements `a` and `b` in a partially ordered set with a bottom element are disjoint, meaning any element `x` that is less than or equal to both `a` and `b` must also be less than or equal to the bottom element `âŠ¥`."}
{"full_name": "OrderBot", "url": "Mathlib/Order/BoundedOrder.html#OrderBot", "code_src": "mathlib4", "ptype": "class", "header": "class OrderBot (Î± : Type u) [LEğŸ”—<|PREMISE|>ğŸ”— Î±] extends BotğŸ”—<|PREMISE|>ğŸ”— :Type u\n | bot : Î±\n | bot_le : âˆ€ (a : Î±), âŠ¥  â‰¤  a", "code": "class OrderBot (Î± : Type u) [LE Î±] extends Bot Î± where\n  /-- `âŠ¥` is the least element -/\n  bot_le : âˆ€ a : Î±, âŠ¥ â‰¤ a\n", "additional_info": "An order is an `ğŸ—ŸOrderBotğŸ—ŸğŸ”—../.././Mathlib/Order/BoundedOrder.html#OrderBotğŸ”—`  if it has a least element.\nWe state this using a data mixin, holding the value of `âŠ¥` and the least element constraint.\n- OrderBot.bot_le: `âŠ¥` is the least element\n\n\n", "used_premises": [5, 547], "def_path": "Mathlib/Order/BoundedOrder.lean", "pos": [201, 204], "informalization": "Class `OrderBot` represents a type `Î±` with a least element `âŠ¥` under a given less-equal relation, ensuring `âŠ¥` is less than or equal to every element in `Î±`."}
{"full_name": "PartialPerm.piecewise", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.piecewise {Î± : Type u_1} (Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) (Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±) [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ Ï€.domain)] (h : DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.domain Ï€'.domain) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def piecewise (h : Disjoint Ï€.domain Ï€'.domain) : PartialPerm Î±\n    where\n  toFun := Ï€.domain.piecewise Ï€ Ï€'\n  invFun := Ï€.domain.piecewise Ï€.symm Ï€'.symm\n  domain := Ï€.domain âˆª Ï€'.domain\n  toFun_domain' := by\n    rintro x (hx | hx)\n    Â· rw [piecewise_eqOn Ï€.domain Ï€ Ï€' hx]\n      exact Or.inl (Ï€.map_domain hx)\n    Â· rw [piecewise_eqOn_compl Ï€.domain Ï€ Ï€' (disjoint_right.mp h hx)]\n      exact Or.inr (Ï€'.map_domain hx)\n  invFun_domain' := by\n    rintro x (hx | hx)\n    Â· rw [piecewise_eqOn Ï€.domain Ï€.symm Ï€'.symm hx]\n      exact Or.inl (Ï€.symm.map_domain hx)\n    Â· rw [piecewise_eqOn_compl Ï€.domain Ï€.symm Ï€'.symm (disjoint_right.mp h hx)]\n      exact Or.inr (Ï€'.symm.map_domain hx)\n  left_inv' := by\n    rintro x (hx | hx)\n    Â· rw [piecewise_eqOn Ï€.domain Ï€ Ï€' hx,\n        piecewise_eqOn Ï€.domain Ï€.symm Ï€'.symm (Ï€.map_domain hx), Ï€.left_inv hx]\n    Â· rw [piecewise_eqOn_compl Ï€.domain Ï€ Ï€' (disjoint_right.mp h hx),\n        piecewise_eqOn_compl Ï€.domain Ï€.symm Ï€'.symm (disjoint_right.mp h (Ï€'.map_domain hx)),\n        Ï€'.left_inv hx]\n  right_inv' := by\n    rintro x (hx | hx)\n    Â· rw [piecewise_eqOn Ï€.domain Ï€.symm Ï€'.symm hx,\n        piecewise_eqOn Ï€.domain Ï€ Ï€' (Ï€.symm.map_domain hx), Ï€.right_inv hx]\n    Â· rw [piecewise_eqOn_compl Ï€.domain Ï€.symm Ï€'.symm (disjoint_right.mp h hx),\n        piecewise_eqOn_compl Ï€.domain Ï€ Ï€' (disjoint_right.mp h (Ï€'.symm.map_domain hx)),\n        Ï€'.right_inv hx]\n", "additional_info": "Construct a partial permutation from two partial permutations with disjoint domains.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [645, 645, 14, 757, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [516, 547], "informalization": "Function `PartialPerm.piecewise` takes two partial permutations `Ï€` and `Ï€'` with disjoint domains and returns a new partial permutation that coincides with `Ï€` on `Ï€.domain` and with `Ï€'` on `Ï€'.domain`."}
{"full_name": "PartialPerm.mem_piecewise_domain_left", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.mem_piecewise_domain_left", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mem_piecewise_domain_left {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ Ï€.domain)] {h : DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.domain Ï€'.domain} {x : Î±} (hx : x âˆˆ Ï€.domain) :x âˆˆ (PartialPerm.piecewiseğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h).domain", "code": "theorem mem_piecewise_domain_left {x : Î±} (hx : x âˆˆ Ï€.domain) : x âˆˆ (piecewise Ï€ Ï€' h).domain :=\n  mem_union_left _ hx\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [554, 556], "informalization": "Given two partial permutations `Ï€` and `Ï€'` with disjoint domains, if `x` is in the domain of `Ï€`, then `x` is also in the domain of the piecewise composition of `Ï€` and `Ï€'`."}
{"full_name": "PartialPerm.mem_piecewise_domain_right", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.mem_piecewise_domain_right", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mem_piecewise_domain_right {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ Ï€.domain)] {h : DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.domain Ï€'.domain} {x : Î±} (hx : x âˆˆ Ï€'.domain) :x âˆˆ (PartialPerm.piecewiseğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h).domain", "code": "theorem mem_piecewise_domain_right {x : Î±} (hx : x âˆˆ Ï€'.domain) : x âˆˆ (piecewise Ï€ Ï€' h).domain :=\n  mem_union_right _ hx\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [557, 559], "informalization": "Given two partial permutations `Ï€` and `Ï€'` with disjoint domains, if `x` is in the domain of `Ï€'`, then `x` is also in the domain of the piecewise composition of `Ï€` and `Ï€'`."}
{"full_name": "PartialPerm.piecewise_apply_eq_left", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise_apply_eq_left", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.piecewise_apply_eq_left {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ Ï€.domain)] {h : DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.domain Ï€'.domain} {x : Î±} (hx : x âˆˆ Ï€.domain) :(PartialPerm.piecewiseğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h).toFun x = Ï€.toFun x", "code": "theorem piecewise_apply_eq_left {x : Î±} (hx : x âˆˆ Ï€.domain) : piecewise Ï€ Ï€' h x = Ï€ x :=\n  piecewise_eqOn _ _ _ hx\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [560, 562], "informalization": "Function `PartialPerm.piecewise` takes two partial permutations `Ï€` and `Ï€'` with disjoint domains and returns a new partial permutation that coincides with `Ï€` on `Ï€.domain` and with `Ï€'` on `Ï€'.domain`. The theorem `PartialPerm.piecewise_apply_eq_left` states that if `x` is in the domain of `Ï€`, then applying the piecewise permutation to `x` yields the same result as applying `Ï€` to `x`."}
{"full_name": "PartialPerm.piecewise_apply_eq_right", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise_apply_eq_right", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.piecewise_apply_eq_right {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ Ï€.domain)] {h : DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.domain Ï€'.domain} {x : Î±} (hx : x âˆˆ Ï€'.domain) :(PartialPerm.piecewiseğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h).toFun x = Ï€'.toFun x", "code": "theorem piecewise_apply_eq_right {x : Î±} (hx : x âˆˆ Ï€'.domain) : piecewise Ï€ Ï€' h x = Ï€' x :=\n  piecewise_eqOn_compl _ _ _ (disjoint_right.mp h hx)\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [563, 565], "informalization": "The function `PartialPerm.piecewise` takes two partial permutations `Ï€` and `Ï€'` with disjoint domains and returns a new partial permutation that coincides with `Ï€` on `Ï€.domain` and with `Ï€'` on `Ï€'.domain`. The theorem `PartialPerm.piecewise_apply_eq_right` states that for any element `x` in the domain of `Ï€'`, the function `(PartialPerm.piecewise Ï€ Ï€' h).toFun x` is equal to `Ï€'.toFun x`."}
{"full_name": "PartialPerm.le_piecewise_left", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.le_piecewise_left", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.le_piecewise_left {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ Ï€.domain)] {h : DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.domain Ï€'.domain} :Ï€ â‰¤ PartialPerm.piecewiseğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h", "code": "theorem le_piecewise_left : Ï€ â‰¤ piecewise Ï€ Ï€' h :=\n  âŸ¨subset_union_left _ _, fun _ hx => (piecewise_apply_eq_left hx).symmâŸ©\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [566, 568], "informalization": "The theorem `le_piecewise_left` states that for any two partial permutations `Ï€` and `Ï€'` with disjoint domains, `Ï€` is less than or equal to the piecewise composition of `Ï€` and `Ï€'`."}
{"full_name": "PartialPerm.le_piecewise_right", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.le_piecewise_right", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.le_piecewise_right {Î± : Type u_1} {Ï€ : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} {Ï€' : PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±} [(j : Î±) â†’ DecidableğŸ”—<|PREMISE|>ğŸ”— (j âˆˆ Ï€.domain)] {h : DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.domain Ï€'.domain} :Ï€' â‰¤ PartialPerm.piecewiseğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' h", "code": "theorem le_piecewise_right : Ï€' â‰¤ piecewise Ï€ Ï€' h :=\n  âŸ¨subset_union_right _ _, fun _ hx => (piecewise_apply_eq_right hx).symmâŸ©\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [569, 571], "informalization": "Function `le_piecewise_right` states that for two partial permutations `Ï€` and `Ï€'` with disjoint domains, `Ï€'` is less than or equal to the piecewise composition of `Ï€` and `Ï€'`."}
{"full_name": "Set.BijOn.toPartialPerm_toFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm_toFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.BijOn.toPartialPerm_toFun {Î± : Type u_1} [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (f : Î± â†’ Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hf : Set.BijOnğŸ”—<|PREMISE|>ğŸ”— f s s) :(Set.BijOn.toPartialPermğŸ”—<|PREMISE|>ğŸ”— f s hf).toFun = f", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [212, 69, 665, 767], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [580, 581], "informalization": "Function `Set.BijOn.toPartialPerm` converts a bijective function `f` between two sets `s` and `t` into a partial permutation on the type `Î±`. The resulting partial permutation has `f` as its forward function, the inverse function of `f` restricted to `s` as its inverse function, and `s` as its domain. The theorem `Set.BijOn.toPartialPerm_toFun` states that the forward function of the resulting partial permutation is indeed `f`."}
{"full_name": "Set.BijOn.toPartialPerm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def Set.BijOn.toPartialPerm {Î± : Type u_1} [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (f : Î± â†’ Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hf : Set.BijOnğŸ”—<|PREMISE|>ğŸ”— f s s) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "noncomputable def BijOn.toPartialPerm [Nonempty Î±] (f : Î± â†’ Î±) (s : Set Î±) (hf : BijOn f s s) :\n    PartialPerm Î± where\n  toFun := f\n  invFun := invFunOn f s\n  domain := s\n  toFun_domain' := hf.mapsTo\n  invFun_domain' := hf.surjOn.mapsTo_invFunOn\n  left_inv' := hf.invOn_invFunOn.1\n  right_inv' := hf.invOn_invFunOn.2\n", "additional_info": "A bijection between two sets `s : ğŸ—ŸSetğŸ—ŸğŸ”—../../../.././Mathlib/Init/Set.html#SetğŸ”—  Î±` and `t : ğŸ—ŸSetğŸ—ŸğŸ”—../../../.././Mathlib/Init/Set.html#SetğŸ”—  Î±` provides a partial permutation on `Î±`.\nEquations\n* ğŸ—ŸSet.BijOn.toPartialPermğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPermğŸ”—  f s hf ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toFun := f, invFun := ğŸ—ŸFunction.invFunOnğŸ—ŸğŸ”—../../../.././Mathlib/Data/Set/Function.html#Function.invFunOnğŸ”—  f s, domain := s, toFun_domain' := â‹¯, invFun_domain' := â‹¯, left_inv' := â‹¯,\n right_inv' := â‹¯ }\n\n", "used_premises": [212, 69, 665, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [581, 590], "informalization": "Function `Set.BijOn.toPartialPerm` converts a bijective function `f` between two sets `s` and `t` into a partial permutation on the type `Î±`. The resulting partial permutation has `f` as its forward function, the inverse function of `f` restricted to `s` as its inverse function, and `s` as its domain."}
{"full_name": "Set.BijOn.toPartialPerm_invFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm_invFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.BijOn.toPartialPerm_invFun {Î± : Type u_1} [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (f : Î± â†’ Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hf : Set.BijOnğŸ”—<|PREMISE|>ğŸ”— f s s) :(Set.BijOn.toPartialPermğŸ”—<|PREMISE|>ğŸ”— f s hf).invFun = Function.invFunOnğŸ”—<|PREMISE|>ğŸ”— f s", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [212, 69, 665, 767, 769], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [580, 581], "informalization": "The theorem `Set.BijOn.toPartialPerm_invFun` states that for a bijective function `f` on a set `s`, the inverse function of the partial permutation `Set.BijOn.toPartialPerm f s hf` is equal to the inverse function of `f` restricted to `s`."}
{"full_name": "Function.invFunOn", "url": "Mathlib/Data/Set/Function.html#Function.invFunOn", "code_src": "mathlib4", "ptype": "noncomputable def", "header": "noncomputable def Function.invFunOn {Î± : Type u_1} {Î² : Type u_2} [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (f : Î± â†’ Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (b : Î²) :Î±", "code": "noncomputable def invFunOn (f : Î± â†’ Î²) (s : Set Î±) (b : Î²) : Î± :=\n  if h : âˆƒ a, a âˆˆ s âˆ§ f a = b then Classical.choose h else Classical.choice â€¹Nonempty Î±â€º\n", "additional_info": "Construct the inverse for a function `f` on domain `s`. This function is a right inverse of `f`\non `f '' s`. For a computable version, see `Function.Embedding.invOfMemRange`.\nEquations\n* ğŸ—ŸFunction.invFunOnğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Function.html#Function.invFunOnğŸ”—  f s b ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  if h : âˆƒ a âˆˆ s, f a ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  b then ğŸ—ŸClassical.chooseğŸ—ŸğŸ”—../../.././Init/Classical.html#Classical.chooseğŸ”—  h else ğŸ—ŸClassical.choiceğŸ—ŸğŸ”—../../.././Init/Prelude.html#Classical.choiceğŸ”—  inst\n\n", "used_premises": [212, 69], "def_path": "Mathlib/Data/Set/Function.lean", "pos": [1243, 1245], "informalization": "Function `Function.invFunOn` is a noncomputable function that, given a function `f : Î± â†’ Î²`, a set `s : Set Î±`, and an element `b : Î²`, returns an element `a : Î±` such that `f a = b` and `a âˆˆ s`, if such an element exists. If no such element exists, it returns an arbitrary element of `Î±` using `Classical.choice`."}
{"full_name": "Set.BijOn.toPartialPerm_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.BijOn.toPartialPerm_domain {Î± : Type u_1} [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (f : Î± â†’ Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hf : Set.BijOnğŸ”—<|PREMISE|>ğŸ”— f s s) :(Set.BijOn.toPartialPermğŸ”—<|PREMISE|>ğŸ”— f s hf).domain = s", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [212, 69, 665, 767], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [580, 581], "informalization": "The theorem `Set.BijOn.toPartialPerm_domain` states that the domain of the partial permutation `Set.BijOn.toPartialPerm f s hf` is equal to the set `s`."}
{"full_name": "Equiv.Perm.toPartialPerm_one", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPerm_one", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.Perm.toPartialPerm_one {Î± : Type u_1} :Equiv.Perm.toPartialPermğŸ”—<|PREMISE|>ğŸ”— (Equiv.reflğŸ”—<|PREMISE|>ğŸ”— Î±) = PartialPerm.reflğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "theorem toPartialPerm_one : toPartialPerm (Equiv.refl Î±) = PartialPerm.refl Î± :=\n  rfl\n", "additional_info": "", "used_premises": [772, 774, 720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [607, 609], "informalization": "The theorem `Equiv.Perm.toPartialPerm_one` states that converting the identity permutation on a type `Î±` to a partial permutation results in the identity partial permutation on `Î±`."}
{"full_name": "Equiv.Perm.toPartialPerm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPerm", "code_src": "con-nf", "ptype": "def", "header": "def Equiv.Perm.toPartialPerm {Î± : Type u_1} (Ï€ : Equiv.PermğŸ”—<|PREMISE|>ğŸ”— Î±) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def Equiv.Perm.toPartialPerm (Ï€ : Equiv.Perm Î±) : PartialPerm Î±\n    where\n  toFun := Ï€\n  invFun := Ï€.symm\n  domain := univ\n  toFun_domain' _ _ := mem_univ _\n  invFun_domain' _ _ := mem_univ _\n  left_inv' x _ := Ï€.left_inv x\n  right_inv' x _ := Ï€.right_inv x\n", "additional_info": "A `Perm` gives rise to a `ğŸ—ŸPartialPermğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPermğŸ”—`  defined on the entire type.\nEquations\n* ğŸ—ŸEquiv.Perm.toPartialPermğŸ—ŸğŸ”—../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPermğŸ”—  Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toFun := â‡‘Ï€, invFun := â‡‘Ï€.symm, domain := Set.univ, toFun_domain' := â‹¯, invFun_domain' := â‹¯, left_inv' := â‹¯,\n right_inv' := â‹¯ }\n\n", "used_premises": [773, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [32, 41], "informalization": "Function `Equiv.Perm.toPartialPerm` converts a permutation of a type `Î±` into a partial permutation defined on the entire type `Î±`."}
{"full_name": "Equiv.Perm", "url": "Mathlib/Logic/Equiv/Defs.html#Equiv.Perm", "code_src": "mathlib4", "ptype": "def", "header": "@[reducible]def Equiv.Perm (Î± : Sort u_1) :Sort (max 1 u_1)", "code": "def Equiv.Perm (Î± : Sort*) :=\n  Equiv Î± Î±\n", "additional_info": "`ğŸ—ŸPermğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.PermğŸ”—  Î±` is the type of bijections from `Î±` to itself.\nEquations\n* ğŸ—ŸEquiv.PermğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.PermğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (Î± ğŸ—Ÿâ‰ƒğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/Defs.html#EquivğŸ”—  Î±)\n\n", "used_premises": [], "def_path": "Mathlib/Logic/Equiv/Defs.lean", "pos": [90, 92], "informalization": "`Equiv.Perm` defines the type of all bijective equivalences (permutations) from a type `Î±` to itself, representing the group of automorphisms on `Î±`."}
{"full_name": "Equiv.refl", "url": "Mathlib/Logic/Equiv/Defs.html#Equiv.refl", "code_src": "mathlib4", "ptype": "def", "header": "def Equiv.refl (Î± : Sort u_1) :Î± â‰ƒ Î±", "code": "@[refl] protected def refl (Î± : Sort*) : Î± â‰ƒ Î± := âŸ¨id, id, fun _ => rfl, fun _ => rflâŸ©\n", "additional_info": "Any type is equivalent to itself.\nEquations\n* ğŸ—ŸEquiv.reflğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.reflğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { toFun := id, invFun := id, left_inv := â‹¯, right_inv := â‹¯ }\n\n", "used_premises": [], "def_path": "Mathlib/Logic/Equiv/Defs.lean", "pos": [158, 159], "informalization": "Function `Equiv.refl` is the identity equivalence, which states that any type is equivalent to itself."}
{"full_name": "Equiv.Perm.toPartialPerm_inv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPerm_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.Perm.toPartialPerm_inv {Î± : Type u_1} (Ï€ : Equiv.PermğŸ”—<|PREMISE|>ğŸ”— Î±) :Equiv.Perm.toPartialPermğŸ”—<|PREMISE|>ğŸ”— Ï€â»Â¹ = PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— (Equiv.Perm.toPartialPermğŸ”—<|PREMISE|>ğŸ”— Ï€)", "code": "theorem toPartialPerm_inv : Ï€â»Â¹.toPartialPerm = Ï€.toPartialPerm.symm :=\n  rfl\n", "additional_info": "", "used_premises": [773, 772, 644, 772], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [611, 613], "informalization": "Function `Equiv.Perm.toPartialPerm_inv` states that the inverse of a permutation, when converted to a partial permutation, is equal to the inverse of the partial permutation obtained from the original permutation."}
{"full_name": "Equiv.Perm.toPartialEquiv_toPartialPerm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialEquiv_toPartialPerm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.Perm.toPartialEquiv_toPartialPerm {Î± : Type u_1} (Ï€ : Equiv.PermğŸ”—<|PREMISE|>ğŸ”— Î±) :PartialPerm.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— (Equiv.Perm.toPartialPermğŸ”—<|PREMISE|>ğŸ”— Ï€) = Equiv.toPartialEquivğŸ”—<|PREMISE|>ğŸ”— Ï€", "code": "theorem toPartialEquiv_toPartialPerm : Ï€.toPartialPerm.toPartialEquiv = Ï€.toPartialEquiv :=\n  rfl\n", "additional_info": "", "used_premises": [773, 733, 772, 777], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [619, 621], "informalization": "The theorem `Equiv.Perm.toPartialEquiv_toPartialPerm` states that converting a permutation to a partial permutation and then back to a partial equivalence yields the same result as converting the permutation directly to a partial equivalence."}
{"full_name": "Equiv.toPartialEquiv", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#Equiv.toPartialEquiv", "code_src": "mathlib4", "ptype": "def", "header": "def Equiv.toPartialEquiv {Î± : Type u_1} {Î² : Type u_2} (e : Î± â‰ƒ Î²) :PartialEquivğŸ”—<|PREMISE|>ğŸ”— Î± Î²", "code": "def Equiv.toPartialEquiv (e : Î± â‰ƒ Î²) : PartialEquiv Î± Î² :=\n  e.toPartialEquivOfImageEq univ univ <| by rw [image_univ, e.surjective.range_eq]\n", "additional_info": "Associate a `ğŸ—ŸPartialEquivğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquivğŸ”—`  to an `ğŸ—ŸEquivğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/Defs.html#EquivğŸ”—` .\nEquations\n* ğŸ—ŸEquiv.toPartialEquivğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#Equiv.toPartialEquivğŸ”—  e ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸEquiv.toPartialEquivOfImageEqğŸ—ŸğŸ”—../../.././Mathlib/Logic/Equiv/PartialEquiv.html#Equiv.toPartialEquivOfImageEqğŸ”—  e Set.univ Set.univ â‹¯\n\n", "used_premises": [734], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [273, 275], "informalization": "Function `Equiv.toPartialEquiv` converts an `Equiv` object to a `PartialEquiv` object, which represents a partial equivalence between two types."}
{"full_name": "ConNF.StructApprox.completeAtomPerm_apply", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAtomPerm_apply", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomPerm_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom) :(ConNF.StructApprox.completeAtomPermğŸ”—<|PREMISE|>ğŸ”— hÏ€f A) a = ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a", "code": "theorem completeAtomPerm_apply (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) (a : Atom) :\n    completeAtomPerm hÏ€f A a = Ï€.completeAtomMap A a :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 783, 784], "def_path": "ConNF/FOA/Result.lean", "pos": [21, 24], "informalization": "Function `ConNF.StructApprox.completeAtomPerm` defines a permutation on the set of atoms in the context of Constructive Ordinal Notation (ConNF), given a free `Î²`-structural approximation `Ï€` and a `Î²`-extended index `A`. This permutation is constructed by applying the `Î²`-structural approximation to `A`, which results in a near-litter approximation, and then using this near-litter approximation to define a permutation on the set of atoms."}
{"full_name": "ConNF.StructApprox.FreedomOfActionHypothesis", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.FreedomOfActionHypothesis", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.StructApprox.FreedomOfActionHypothesis [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] (Î² : ConNF.Î›) [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] :Prop\n | freedomOfAction_of_lt : âˆ€ Î³ < Î², âˆ€ [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³], ConNF.StructApprox.FOAIhğŸ”—<|PREMISE|>ğŸ”—  Î³", "code": "class FreedomOfActionHypothesis (Î² : Î›) [LeLevel Î²] : Prop where\n  freedomOfAction_of_lt : âˆ€ Î³ < Î², [LeLevel Î³] â†’ FOAIh Î³\n", "additional_info": "", "used_premises": [1, 402, 402, 780], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [23, 25], "informalization": "Class `FreedomOfActionHypothesis` is an inductive hypothesis used in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.FOAIh", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.FOAIh", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.FOAIh [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] (Î² : ConNF.Î›) [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] :Prop", "code": "def FOAIh (Î² : Î›) [LeLevel Î²] : Prop :=\n  âˆ€ Ï€â‚€ : StructApprox Î², Ï€â‚€.Free â†’\n  âˆƒ Ï€ : Allowable Î², Ï€â‚€.ExactlyApproximates (Allowable.toStructPerm Ï€)\n", "additional_info": "The inductive hypothesis used for proving freedom of action:\nEvery free approximation exactly approximates some allowable permutation.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [19, 22], "informalization": "Function `ConNF.StructApprox.FOAIh` is an inductive hypothesis used in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox", "code_src": "con-nf", "ptype": "abbrev", "header": "@[inline, reducible]abbrev ConNF.StructApprox [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Type u", "code": "abbrev StructApprox :=\n  Tree NearLitterApprox\n", "additional_info": "A `Î²`-structural approximation is a product that assigns a near-litter approximation to each\n`Î²`-extended index.\nEquations\n* ConNF.StructApprox ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.TreeğŸ—ŸğŸ”—../../.././ConNF/Structural/Tree.html#ConNF.TreeğŸ”—  ConNF.NearLitterApprox\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [18, 20], "informalization": "Function `ConNF.StructApprox` defines a `Î²`-structural approximation in the context of Constructive Ordinal Notation (ConNF), which is a product that assigns a near-litter approximation to each `Î²`-extended index."}
{"full_name": "ConNF.StructApprox.Free", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.Free", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.Free [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï€â‚€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Prop", "code": "def Free {Î² : Î›} (Ï€â‚€ : StructApprox Î²) : Prop :=\n  âˆ€ A, (Ï€â‚€ A).Free A\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.FreeğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.FreeğŸ”—  Ï€â‚€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (A : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  â†‘Î²), ğŸ—ŸConNF.NearLitterApprox.FreeğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.FreeğŸ”—  (Ï€â‚€ A) A\n\n", "used_premises": [1, 781], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [31, 33], "informalization": "Function `ConNF.StructApprox.Free` checks if a `Î²`-structural approximation `Ï€â‚€` is free, meaning that for every `Î²`-extended index `A`, the near-litter approximation `(Ï€â‚€ A)` is free with respect to `A`."}
{"full_name": "ConNF.StructApprox.completeAtomPerm", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAtomPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeAtomPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Equiv.PermğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "noncomputable def completeAtomPerm (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) : Perm Atom :=\n  Equiv.ofBijective _ (completeAtomMap_bijective hÏ€f A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.completeAtomPermğŸ—ŸğŸ”—../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeAtomPermğŸ”—  hÏ€f A ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸEquiv.ofBijectiveğŸ—ŸğŸ”—../.././Mathlib/Logic/Equiv/Defs.html#Equiv.ofBijectiveğŸ”—  (ğŸ—ŸConNF.StructApprox.completeAtomMapğŸ—ŸğŸ”—../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMapğŸ”—  Ï€ A) â‹¯\n\n", "used_premises": [1, 402, 779, 781, 782, 61, 773], "def_path": "ConNF/FOA/Result.lean", "pos": [15, 17], "informalization": "Function `ConNF.StructApprox.completeAtomPerm` defines a permutation on the set of atoms in the context of Constructive Ordinal Notation (ConNF), given a free `Î²`-structural approximation `Ï€` and a `Î²`-extended index `A`. This permutation is constructed by applying the `Î²`-structural approximation to `A`, which results in a near-litter approximation, and then using this near-litter approximation to define a permutation on the set of atoms."}
{"full_name": "ConNF.StructApprox.completeAtomMap", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeAtomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†’ ConNF.Atom â†’ ConNF.Atom", "code": "noncomputable def completeAtomMap (Ï€ : StructApprox Î²) : ExtendedIndex Î² â†’ Atom â†’ Atom :=\n  HypAction.fixAtom Ï€.atomCompletion Ï€.nearLitterCompletion\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.completeAtomMapğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMapğŸ”—  Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.HypAction.fixAtomğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/HypAction.html#ConNF.HypAction.fixAtomğŸ”—  (ğŸ—ŸConNF.StructApprox.atomCompletionğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/AtomCompletion.html#ConNF.StructApprox.atomCompletionğŸ”—  Ï€) (ğŸ—ŸConNF.StructApprox.nearLitterCompletionğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletionğŸ”—  Ï€)\n\n", "used_premises": [1, 402, 779, 781, 61], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [23, 25], "informalization": "Function `ConNF.StructApprox.completeAtomMap` is a noncomputable definition in the context of Constructive Ordinal Notation (ConNF). It takes a `Î²`-structural approximation `Ï€` and returns a function that maps each `Î²`-extended index to an atom. This function is defined using the `ConNF.HypAction.fixAtom` function, which is part of the `ConNF.HypAction` class. The `ConNF.HypAction.fixAtom` function uses the `ConNF.StructApprox.atomCompletion` and `ConNF.StructApprox.nearLitterCompletion` components of the `Î²`-structural approximation `Ï€`."}
{"full_name": "ConNF.StructApprox.completeLitterPerm_apply", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeLitterPerm_apply", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterPerm_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) :(ConNF.StructApprox.completeLitterPermğŸ”—<|PREMISE|>ğŸ”— hÏ€f A) L = ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L", "code": "theorem completeLitterPerm_apply (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) (L : Litter) :\n    completeLitterPerm hÏ€f A L = Ï€.completeLitterMap A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 786, 787], "def_path": "ConNF/FOA/Result.lean", "pos": [25, 28], "informalization": "The theorem `ConNF.StructApprox.completeLitterPerm_apply` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It defines a permutation on the litter type `ConNF.Litter` from a free `Î²`-structural approximation `Ï€` and a `Î²`-extended index `A`. This permutation is derived from the `ConNF.StructApprox.completeLitterMap` function, which maps elements of `ConNF.Litter` to other elements of `ConNF.Litter` based on the approximation `Ï€` and the index `A`."}
{"full_name": "ConNF.StructApprox.completeLitterPerm", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeLitterPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeLitterPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Equiv.PermğŸ”—<|PREMISE|>ğŸ”— ConNF.Litter", "code": "noncomputable def completeLitterPerm (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) : Perm Litter :=\n  Equiv.ofBijective _ (completeLitterMap_bijective hÏ€f A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.completeLitterPermğŸ—ŸğŸ”—../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeLitterPermğŸ”—  hÏ€f A ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸEquiv.ofBijectiveğŸ—ŸğŸ”—../.././Mathlib/Logic/Equiv/Defs.html#Equiv.ofBijectiveğŸ”—  (ğŸ—ŸConNF.StructApprox.completeLitterMapğŸ—ŸğŸ”—../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMapğŸ”—  Ï€ A) â‹¯\n\n", "used_premises": [1, 402, 779, 781, 782, 61, 773], "def_path": "ConNF/FOA/Result.lean", "pos": [18, 20], "informalization": "Function `ConNF.StructApprox.completeLitterPerm` constructs a permutation on the litter type `ConNF.Litter` from a free `Î²`-structural approximation `Ï€` and a `Î²`-extended index `A`. This permutation is derived from the `ConNF.StructApprox.completeLitterMap` function, which maps elements of `ConNF.Litter` to other elements of `ConNF.Litter` based on the approximation `Ï€` and the index `A`."}
{"full_name": "ConNF.StructApprox.completeLitterMap", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeLitterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) :ConNF.Litter", "code": "noncomputable def completeLitterMap (Ï€ : StructApprox Î²) (A : ExtendedIndex Î²) (L : Litter) :\n    Litter :=\n  (Ï€.completeNearLitterMap A L.toNearLitter).1\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.completeLitterMapğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMapğŸ”—  Ï€ A L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸConNF.StructApprox.completeNearLitterMapğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMapğŸ”—  Ï€ A (ğŸ—ŸConNF.Litter.toNearLitterğŸ—ŸğŸ”—../../.././ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitterğŸ”—  L)).fst\n\n", "used_premises": [1, 402, 779, 781, 61], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [30, 33], "informalization": "Function `ConNF.StructApprox.completeLitterMap` takes a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, and a litter `L`, and returns a litter. This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.completeNearLitterPerm_smul_atom", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm_smul_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterPerm_smul_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom) :ConNF.StructApprox.completeNearLitterPermğŸ”—<|PREMISE|>ğŸ”— hÏ€f A â€¢ a = ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a", "code": "theorem completeNearLitterPerm_smul_atom (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) (a : Atom) :\n    completeNearLitterPerm hÏ€f A â€¢ a = Ï€.completeAtomMap A a :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 789, 784], "def_path": "ConNF/FOA/Result.lean", "pos": [44, 47], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a free Î²-structural approximation Ï€, the `ConNF.StructApprox.completeNearLitterPerm` function provides a near-litter permutation for each Î²-extended index A, and the `ConNF.StructApprox.completeAtomMap` function completes each atom. The theorem `ConNF.StructApprox.completeNearLitterPerm_smul_atom` proves that the action of the near-litter permutation on an atom is equal to the atom's completion by the Î²-structural approximation Ï€."}
{"full_name": "ConNF.StructApprox.completeNearLitterPerm", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeNearLitterPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.NearLitterPerm", "code": "noncomputable def completeNearLitterPerm (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) : NearLitterPerm\n    where\n  atomPerm := completeAtomPerm hÏ€f A\n  litterPerm := completeLitterPerm hÏ€f A\n  near := by\n    intro L s hs\n    have :\n      â†‘(completeAtomPerm hÏ€f A)â»Â¹ â»Â¹' s =\n        (Ï€.completeNearLitterMap A âŸ¨L, s, hsâŸ© : Set Atom)\n    Â· simp only [completeNearLitterMap_coe hÏ€f, toFun_as_coe, Perm.preimage_inv, NearLitter.coe_mk]\n      rfl\n    rw [this]\n    simp only [NearLitter.isNearLitter, completeNearLitterMap_fst_eq']\n    rfl\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.completeNearLitterPermğŸ—ŸğŸ”—../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPermğŸ”—  hÏ€f A ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  { atomPerm := ğŸ—ŸConNF.StructApprox.completeAtomPermğŸ—ŸğŸ”—../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeAtomPermğŸ”—  hÏ€f A, litterPerm := ğŸ—ŸConNF.StructApprox.completeLitterPermğŸ—ŸğŸ”—../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeLitterPermğŸ”—  hÏ€f A,\n near := â‹¯ }\n\n", "used_premises": [1, 402, 779, 781, 782, 61], "def_path": "ConNF/FOA/Result.lean", "pos": [29, 43], "informalization": "Function `ConNF.StructApprox.completeNearLitterPerm` takes a `Î²`-structural approximation `Ï€` and a `Î²`-extended index `A`, and returns a `NearLitterPerm`. This `NearLitterPerm` consists of an `AtomPerm` and a `LitterPerm`, as well as a proof that the `AtomPerm` is near the `LitterPerm`."}
{"full_name": "ConNF.StructApprox.completeNearLitterPerm_smul_litter", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm_smul_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterPerm_smul_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) :ConNF.StructApprox.completeNearLitterPermğŸ”—<|PREMISE|>ğŸ”— hÏ€f A â€¢ L = ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L", "code": "theorem completeNearLitterPerm_smul_litter (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) (L : Litter) :\n    completeNearLitterPerm hÏ€f A â€¢ L = Ï€.completeLitterMap A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 789, 787], "def_path": "ConNF/FOA/Result.lean", "pos": [48, 51], "informalization": "In Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterPerm_smul_litter` asserts that the action of a `Î²`-structural approximation `Ï€` on a litter `L`, when lifted to the `NearLitterPerm` level, is equivalent to the completion of the litter map for `Ï€`, `A`, and `L`. This theorem demonstrates the consistency and commutativity of the `Î²`-structural approximation and its completion, ensuring that the construction of the natural numbers in ConNF is mathematically sound."}
{"full_name": "ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) :ConNF.StructApprox.completeNearLitterPermğŸ”—<|PREMISE|>ğŸ”— hÏ€f A â€¢ N = ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N", "code": "theorem completeNearLitterPerm_smul_nearLitter (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²)\n    (N : NearLitter) : completeNearLitterPerm hÏ€f A â€¢ N = Ï€.completeNearLitterMap A N := by\n  refine' SetLike.coe_injective _\n  rw [completeNearLitterMap_coe hÏ€f, NearLitterPerm.smul_nearLitter_coe]\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 789, 792], "def_path": "ConNF/FOA/Result.lean", "pos": [52, 57], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter` states that for any free `Î²`-structural approximation `Ï€`, any `Î²`-extended index `A`, and any near-litter `N`, the action of the near-litter permutation `ConNF.StructApprox.completeNearLitterPerm hÏ€f A` on `N` is equal to the near-litter map `ConNF.StructApprox.completeNearLitterMap Ï€ A N`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeNearLitterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†’ ConNF.NearLitter â†’ ConNF.NearLitter", "code": "noncomputable def completeNearLitterMap (Ï€ : StructApprox Î²) :\n    ExtendedIndex Î² â†’ NearLitter â†’ NearLitter :=\n  HypAction.fixNearLitter Ï€.atomCompletion Ï€.nearLitterCompletion\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.completeNearLitterMapğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMapğŸ”—  Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.HypAction.fixNearLitterğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/HypAction.html#ConNF.HypAction.fixNearLitterğŸ”—  (ğŸ—ŸConNF.StructApprox.atomCompletionğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/AtomCompletion.html#ConNF.StructApprox.atomCompletionğŸ”—  Ï€) (ğŸ—ŸConNF.StructApprox.nearLitterCompletionğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletionğŸ”—  Ï€)\n\n", "used_premises": [1, 402, 779, 781, 61], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [26, 29], "informalization": "Function `ConNF.StructApprox.completeNearLitterMap` takes a `Î²`-structural approximation `Ï€` and returns a function from `ConNF.ExtendedIndex Î²` to `ConNF.NearLitter` to `ConNF.NearLitter`. This function is used in the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.ofBot_toStructPerm", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.ofBot_toStructPerm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ofBot_toStructPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.Allowable âŠ¥ ) :ConNF.Tree.ofBot (ConNF.Allowable.toStructPerm Ï€) = Ï€", "code": "theorem ofBot_toStructPerm (Ï€ : Allowable âŠ¥) : Tree.ofBot (Allowable.toStructPerm Ï€) = Ï€ := by\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Result.lean", "pos": [65, 67], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.ofBot_toStructPerm` states that the `ConNF.Tree.ofBot` function, when applied to the result of the `ConNF.Allowable.toStructPerm` function, returns the original `ConNF.Allowable` object."}
{"full_name": "ConNF.StructApprox.allowableBelow_bot", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.allowableBelow_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.allowableBelow_bot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructApprox.AllowableBelowğŸ”—<|PREMISE|>ğŸ”— hÏ€f âŠ¥ A", "code": "theorem allowableBelow_bot (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) : AllowableBelow hÏ€f âŠ¥ A := by\n  refine' âŸ¨completeNearLitterPerm hÏ€f A, _âŸ©\n  intro B\n  obtain B | âŸ¨B, hâŸ© := B\n  Â· rfl\n  Â· -- TODO: Make this a lemma.\n    cases le_bot_iff.mp (le_of_path B)\n    change (âŠ¥ : TypeIndex) < âŠ¥ at h\n    simp only [lt_self_iff_false] at h\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 795], "def_path": "ConNF/FOA/Result.lean", "pos": [68, 77], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.allowableBelow_bot` states that for any free `Î²`-structural approximation `Ï€` and any `Î²`-extended index `A`, there exists an allowable permutation `Ï` such that for every `Î²`-extended index `B`, the complete near-litter permutation of `Ï€` applied to `B` is equal to the composition of `B` with `Ï`."}
{"full_name": "ConNF.StructApprox.AllowableBelow", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.AllowableBelow", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.AllowableBelow [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (Î³ : ConNF.TypeIndex) [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— (â†‘Î²) Î³) :Prop", "code": "def AllowableBelow (hÏ€f : Ï€.Free) (Î³ : TypeIndex) [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³) : Prop :=\n  âˆƒ Ï : Allowable Î³,\n    âˆ€ B : ExtendedIndex Î³,\n      Tree.ofBot (Tree.comp B (Allowable.toStructPerm Ï)) =\n        completeNearLitterPerm hÏ€f (A.comp B)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 782, 402, 76], "def_path": "ConNF/FOA/Result.lean", "pos": [58, 63], "informalization": "Function `ConNF.StructApprox.AllowableBelow` defines a condition for a `Î²`-structural approximation `Ï€` to be allowable below a path `A` in the context of Constructive Ordinal Notation (ConNF). It states that there exists an allowable permutation `Ï` such that for every `Î²`-extended index `B`, the complete near-litter permutation of `Ï€` applied to `B` is equal to the composition of `B` with `Ï`."}
{"full_name": "ConNF.StructApprox.exists_nil_cons_of_path'", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.exists_nil_cons_of_path'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.exists_nil_cons_of_path' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) (hA : Quiver.Path.lengthğŸ”—<|PREMISE|>ğŸ”— A â‰  0) :âˆƒ (Î´ : ConNF.TypeIndex) (h : Î´ < Î²) (B : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î´ Î³), A = Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— Quiver.Path.nil h) B", "code": "theorem exists_nil_cons_of_path' {Î² Î³ : TypeIndex} (A : Path (Î² : TypeIndex) Î³)\n    (hA : A.length â‰  0) :\n    âˆƒ Î´ : TypeIndex,\n      âˆƒ h : (Î´ : TypeIndex) < Î²,\n        âˆƒ B : Path Î´ Î³, A = ((Path.nil : Path (Î² : TypeIndex) Î²).cons h).comp B := by\n  set n := A.length with hn\n  clear_value n\n  induction' n with n ih generalizing Î³\n  Â· cases hA rfl\n  cases' A with Î´ _ A hÎ´\n  Â· cases hn\n  simp only [Path.length_cons, Nat.succ_eq_add_one, add_left_inj] at hn\n  obtain _ | n := n\n  Â· cases Path.eq_of_length_zero A hn.symm\n    cases path_eq_nil A\n    exact âŸ¨Î³, hÎ´, Path.nil, rflâŸ©\n  Â· obtain âŸ¨Îµ, hÎµ, B, rflâŸ© := ih A n.succ_ne_zero hn\n    exact âŸ¨Îµ, hÎµ, B.cons hÎ´, rflâŸ©\n", "additional_info": "", "used_premises": [1, 76, 137, 76, 135, 301], "def_path": "ConNF/FOA/Result.lean", "pos": [78, 96], "informalization": "The theorem `ConNF.StructApprox.exists_nil_cons_of_path'` states that for any non-trivial path `A` from vertex `Î²` to vertex `Î³` in a quiver, there exists a vertex `Î´` less than `Î²` and a path `B` from `Î´` to `Î³` such that `A` is the composition of a trivial path from `Î²` to `Î´` and `B`."}
{"full_name": "ConNF.StructApprox.exists_nil_cons_of_path", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.exists_nil_cons_of_path", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.exists_nil_cons_of_path [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :âˆƒ (Î³ : ConNF.TypeIndex) (_ : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— Î³) (h : Î³ < â†‘Î²) (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î³), A = Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— Quiver.Path.nil h) B", "code": "theorem exists_nil_cons_of_path {Î² : Î›} [LeLevel Î²] (A : ExtendedIndex Î²) :\n    âˆƒ Î³ : TypeIndex, âˆƒ _ : LtLevel Î³,\n      âˆƒ h : (Î³ : TypeIndex) < Î²,\n        âˆƒ B : ExtendedIndex Î³, A = ((Path.nil : Path (Î² : TypeIndex) Î²).cons h).comp B := by\n  have := exists_nil_cons_of_path' A ?_\n  obtain âŸ¨Î³, h, B, rflâŸ© := this\n  Â· refine' âŸ¨Î³, _, h, B, rflâŸ©\n    exact âŸ¨lt_of_lt_of_le h LeLevel.elimâŸ©\n  Â· intro h\n    cases Path.eq_of_length_zero A h\n", "additional_info": "", "used_premises": [1, 402, 61, 98, 61, 135, 301], "def_path": "ConNF/FOA/Result.lean", "pos": [97, 107], "informalization": "Given the `ConNF.Params` class and the `ConNF.Level` instance in the context of Constructive Ordinal Notation (ConNF), for any `Î²` which is less than or equal to the level `Î±`, and given a finite path `A` from `Î²` to the base type `âŠ¥`, there exists a type index `Î³` which is strictly less than `Î²`, and a finite path `B` from `Î³` to `âŠ¥` such that `A` can be decomposed into a single step from `Î²` to `Î³` followed by the path `B`. This theorem is central to understanding the construction of natural numbers in the context of ConNF, as it shows how paths can be broken down into individual steps and combined to form larger paths."}
{"full_name": "ConNF.StructApprox.completeAllowable_comp", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAllowable_comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAllowable_comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) :ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowableğŸ”—<|PREMISE|>ğŸ”— hÏ€f) = ConNF.StructApprox.completeNearLitterPermğŸ”—<|PREMISE|>ğŸ”— hÏ€f", "code": "theorem completeAllowable_comp (hÏ€f : Ï€.Free) :\n    Allowable.toStructPerm (completeAllowable hÏ€f) = completeNearLitterPerm hÏ€f := by\n  funext A\n  have := (allowableBelow_all hÏ€f Î² Path.nil).choose_spec A\n  rw [Path.nil_comp] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 799, 789], "def_path": "ConNF/FOA/Result.lean", "pos": [217, 223], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAllowable_comp` states that for any free `Î²`-structural approximation `Ï€`, the `Î²`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable hÏ€f)` is equal to the `Î²`-near-litter permutation `ConNF.StructApprox.completeNearLitterPerm hÏ€f`."}
{"full_name": "ConNF.StructApprox.completeAllowable", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAllowable", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeAllowable [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) :ConNF.Allowable â†‘Î²", "code": "noncomputable def completeAllowable (hÏ€f : Ï€.Free) : Allowable Î² :=\n  (allowableBelow_all hÏ€f Î² Path.nil).choose\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.completeAllowableğŸ—ŸğŸ”—../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeAllowableğŸ”—  hÏ€f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸExists.chooseğŸ—ŸğŸ”—../.././Init/Classical.html#Exists.chooseğŸ”—  â‹¯\n\n", "used_premises": [1, 402, 779, 781, 782], "def_path": "ConNF/FOA/Result.lean", "pos": [214, 216], "informalization": "Function `ConNF.StructApprox.completeAllowable` is a noncomputable definition in the context of Constructive Ordinal Notation (ConNF). It takes as input a `Î²`-structural approximation `Ï€` and a proof that `Ï€` is free, meaning that for every `Î²`-extended index `A`, the near-litter approximation `(Ï€ A)` is free with respect to `A`. The output is a `Î²`-allowable permutation, which is a product that assigns an allowable permutation to each `Î²`-extended index."}
{"full_name": "ConNF.StructApprox.complete_exception_mem", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.complete_exception_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.complete_exception_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom) (ha : ConNF.NearLitterPerm.IsExceptionğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeNearLitterPermğŸ”—<|PREMISE|>ğŸ”— hÏ€f A) a) :a âˆˆ (Ï€ A).atomPerm.domain", "code": "theorem complete_exception_mem (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) (a : Atom)\n    (ha : (completeNearLitterPerm hÏ€f A).IsException a) : a âˆˆ (Ï€ A).atomPerm.domain := by\n  unfold NearLitterPerm.IsException at ha\n  simp only [mem_litterSet, completeNearLitterPerm_smul_atom,\n    completeNearLitterPerm_smul_litter] at ha\n  obtain ha | ha := ha\n  Â· have := completeNearLitterMap_toNearLitter_eq (Ï€ := Ï€) A a.1\n    rw [completeNearLitterMap_coe hÏ€f, Set.ext_iff] at this\n    have := (this (Ï€.completeAtomMap A a)).mp âŸ¨_, rfl, rflâŸ©\n    obtain ha' | âŸ¨b, âŸ¨hbâ‚, hbâ‚‚âŸ©, hbâ‚ƒâŸ© := this\n    Â· cases ha ha'.1\n    dsimp only at hbâ‚ƒ\n    rw [â† completeAtomMap_eq_of_mem_domain hbâ‚‚] at hbâ‚ƒ\n    cases completeAtomMap_injective hÏ€f A hbâ‚ƒ\n    exact hbâ‚‚\n  Â· obtain âŸ¨a, rflâŸ© := completeAtomMap_surjective hÏ€f A a\n    rw [eq_inv_smul_iff, â† completeNearLitterPerm_smul_atom hÏ€f, inv_smul_smul] at ha\n    have := completeNearLitterMap_toNearLitter_eq (Ï€ := Ï€) A a.1\n    rw [completeNearLitterMap_coe hÏ€f, Set.ext_iff] at this\n    have := (this (Ï€.completeAtomMap A a)).mp âŸ¨_, rfl, rflâŸ©\n    obtain ha' | âŸ¨b, âŸ¨hbâ‚, hbâ‚‚âŸ©, hbâ‚ƒâŸ© := this\n    Â· cases ha ha'.1.symm\n    Â· dsimp only at hbâ‚ƒ\n      rw [â† completeAtomMap_eq_of_mem_domain hbâ‚‚] at hbâ‚ƒ\n      cases completeAtomMap_injective hÏ€f A hbâ‚ƒ\n      rw [completeAtomMap_eq_of_mem_domain hbâ‚‚]\n      exact (Ï€ A).atomPerm.map_domain hbâ‚‚\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 801, 789], "def_path": "ConNF/FOA/Result.lean", "pos": [224, 251], "informalization": "The theorem `ConNF.StructApprox.complete_exception_mem` states that if `Ï€` is a free `Î²`-structural approximation, `A` is a `Î²`-extended index, and `a` is an atom such that the near litter permutation `ConNF.StructApprox.completeNearLitterPerm hÏ€f A` is an exception with respect to `a`, then `a` is a member of the domain of the atom permutation of `Ï€ A`."}
{"full_name": "ConNF.NearLitterPerm.IsException", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterPerm.IsException", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterPerm.IsException [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (a : ConNF.Atom) :Prop", "code": "def ConNF.NearLitterPerm.IsException (Ï€ : NearLitterPerm) (a : Atom) : Prop :=\n  Ï€ â€¢ a âˆ‰ litterSet (Ï€ â€¢ a.1) âˆ¨ Ï€â»Â¹ â€¢ a âˆ‰ litterSet (Ï€â»Â¹ â€¢ a.1)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterPerm.IsExceptionğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterPerm.IsExceptionğŸ”—  Ï€ a ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (Ï€ ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  a âˆ‰ ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  (Ï€ ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  a.1) ğŸ—Ÿâˆ¨ğŸ—ŸğŸ”—../../.././Init/Prelude.html#OrğŸ”—  Ï€ğŸ—Ÿâ»Â¹ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#Inv.invğŸ”—  ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  a âˆ‰ ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  (Ï€ğŸ—Ÿâ»Â¹ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#Inv.invğŸ”—  ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  a.1))\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [152, 154], "informalization": "Function `ConNF.NearLitterPerm.IsException` checks if a near litter permutation `Ï€` is an exception with respect to an atom `a`. An exception occurs when either `Ï€ â€¢ a` or `Ï€â»Â¹ â€¢ a` is not in the corresponding litter set."}
{"full_name": "ConNF.StructApprox.completeAllowable_exactlyApproximates", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAllowable_exactlyApproximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAllowable_exactlyApproximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) :ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€ (ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowableğŸ”—<|PREMISE|>ğŸ”— hÏ€f))", "code": "theorem completeAllowable_exactlyApproximates (hÏ€f : Ï€.Free) :\n    Ï€.ExactlyApproximates (Allowable.toStructPerm <| completeAllowable hÏ€f) := by\n  intro A\n  refine' âŸ¨âŸ¨_, _âŸ©, _âŸ©\n  Â· intro a ha\n    rw [completeAllowable_comp, completeNearLitterPerm_smul_atom,\n      completeAtomMap_eq_of_mem_domain ha]\n  Â· intro L hL\n    rw [completeAllowable_comp, completeNearLitterPerm_smul_litter,\n      completeLitterMap_eq_of_flexible (hÏ€f A L hL),\n      NearLitterApprox.flexibleCompletion_smul_of_mem_domain _ A L hL]\n    rfl\n  Â· intro a ha\n    rw [completeAllowable_comp] at ha\n    exact complete_exception_mem hÏ€f A a ha\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 803, 799], "def_path": "ConNF/FOA/Result.lean", "pos": [252, 267], "informalization": "The theorem `ConNF.StructApprox.completeAllowable_exactlyApproximates` states that for any free `Î²`-structural approximation `Ï€`, the `Î²`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable hÏ€f)` exactly approximates `Ï€`."}
{"full_name": "ConNF.StructApprox.ExactlyApproximates", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.ExactlyApproximates", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.ExactlyApproximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Ï€â‚€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— Î²) (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def ExactlyApproximates {Î² : TypeIndex} (Ï€â‚€ : StructApprox Î²) (Ï€ : StructPerm Î²) : Prop :=\n  âˆ€ A, (Ï€â‚€ A).ExactlyApproximates (Ï€ A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.ExactlyApproximatesğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.ExactlyApproximatesğŸ”—  Ï€â‚€ Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (A : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  Î²), ğŸ—ŸConNF.NearLitterApprox.ExactlyApproximatesğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximatesğŸ”—  (Ï€â‚€ A) (Ï€ A)\n\n", "used_premises": [1, 781, 55], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [26, 28], "informalization": "Function `ConNF.StructApprox.ExactlyApproximates` checks if a `Î²`-structural approximation `Ï€â‚€` exactly approximates a `Î²`-structural permutation `Ï€`, meaning that for every `Î²`-extended index `A`, the near-litter approximation `Ï€â‚€ A` exactly approximates the near-litter permutation `Ï€ A`."}
{"full_name": "ConNF.StructApprox.freedom_of_action", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.freedom_of_action", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.freedom_of_action [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [i : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (Ï€â‚€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (h : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€) :âˆƒ (Ï€ : ConNF.Allowable â†‘Î²), ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ (ConNF.Allowable.toStructPerm Ï€)", "code": "theorem freedom_of_action {Î² : Î›} [i : LeLevel Î²] (Ï€â‚€ : StructApprox Î²) (h : Ï€â‚€.Free) :\n    âˆƒ Ï€ : Allowable Î², Ï€â‚€.ExactlyApproximates (Allowable.toStructPerm Ï€) := by\n  revert i\n  have := WellFounded.induction\n    (C := fun Î² => âˆ€ (i : LeLevel Î²) (Ï€â‚€ : StructApprox Î²),\n      Free Ï€â‚€ â†’ âˆƒ Ï€ : Allowable Î²,\n        ExactlyApproximates Ï€â‚€ (@Allowable.toStructPerm _ _ FOAData.tangleData Ï€))\n    (inferInstanceAs (IsWellFounded Î› (Â· < Â·))).wf Î²\n  refine fun i => this ?_ i Ï€â‚€ h\n  intro Î² ih _ Ï€â‚€ h\n  have : FreedomOfActionHypothesis Î²\n  Â· constructor\n    intro Î³ hÎ³\n    exact ih Î³ hÎ³ inferInstance\n  exact foa_extends Ï€â‚€ h\n", "additional_info": "", "used_premises": [1, 402, 781, 782, 803], "def_path": "ConNF/FOA/Result.lean", "pos": [271, 286], "informalization": "Given a `Î²`-structural approximation `Ï€â‚€` that is free, there exists a `Î²`-structural permutation `Ï€` such that `Ï€â‚€` exactly approximates `Ï€`."}
{"full_name": "ConNF.NearLitterAction.approximates_iff", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterAction.approximates_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.approximates_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ïˆ : ConNF.NearLitterAction) (Ï€ : ConNF.NearLitterPerm) :ConNF.NearLitterAction.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Ïˆ Ï€ â†” (âˆ€ (a : ConNF.Atom) (h : (Ïˆ.atomMap a).Dom), Ï€ â€¢ a = (Ïˆ.atomMap a).get h) âˆ§ âˆ€ (L : ConNF.Litter) (h : (Ïˆ.litterMap L).Dom), Ï€ â€¢ ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L = (Ïˆ.litterMap L).get h", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 806, 483], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [16, 17], "informalization": "The theorem `ConNF.NearLitterAction.approximates_iff` states that a near-litter action `Ïˆ` approximates a near-litter permutation `Ï€` if and only if the action of `Ï€` on atoms and litters is consistent with the mapping provided by `Ïˆ`."}
{"full_name": "ConNF.NearLitterAction.Approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterAction.Approximates", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.Approximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ïˆ : ConNF.NearLitterAction) (Ï€ : ConNF.NearLitterPerm) :Prop\n | map_atom : âˆ€ (a : ConNF.Atom) (h : (Ïˆ.atomMap a).Dom), Ï€ â€¢  a =  (Ïˆ.atomMap a).get h\n | map_litter : âˆ€ (L : ConNF.Litter) (h : (Ïˆ.litterMap L).Dom), Ï€ â€¢  ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”—  L =  (Ïˆ.litterMap L).get h", "code": "structure NearLitterAction.Approximates (Ïˆ : NearLitterAction) (Ï€ : NearLitterPerm) : Prop where\n  map_atom : âˆ€ a (h : (Ïˆ.atomMap a).Dom), Ï€ â€¢ a = (Ïˆ.atomMap a).get h\n  map_litter : âˆ€ L (h : (Ïˆ.litterMap L).Dom), Ï€ â€¢ L.toNearLitter = (Ïˆ.litterMap L).get h\n", "additional_info": "", "used_premises": [1, 483], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [17, 20], "informalization": "Structure `ConNF.NearLitterAction.Approximates` represents a property of a near-litter action in the context of Constructive Ordinal Notation (ConNF). Given a near-litter action `Ïˆ` and a near-litter permutation `Ï€`, this structure ensures that the action of `Ï€` on atoms and litters is consistent with the mapping provided by `Ïˆ`."}
{"full_name": "ConNF.StructAction.foaMotive_atom", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.foaMotive_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.foaMotive_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ïˆ) (Ï : ConNF.Allowable â†‘Î²) (hÏ : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— Ïˆ hâ‚) (ConNF.Allowable.toStructPerm Ï)) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom) (ha : ((Ïˆ A).atomMap a).Dom) :ConNF.Allowable.toStructPerm Ï A â€¢ a = ((Ïˆ A).atomMap a).get ha", "code": "theorem foaMotive_atom (Ïˆ : StructAction Î²) (hâ‚ : Ïˆ.Lawful)\n    (Ï : Allowable Î²) (hÏ : (Ïˆ.rc hâ‚).ExactlyApproximates (Allowable.toStructPerm Ï))\n    (A : ExtendedIndex Î²) (a : Atom)\n    (ha : ((Ïˆ A).atomMap a).Dom) :\n    Allowable.toStructPerm Ï A â€¢ a = ((Ïˆ A).atomMap a).get ha := by\n  have := (hÏ A).map_atom a ?_\n  Â· rw [â† this, rc_smul_atom_eq]\n  Â· exact Or.inl (Or.inl (Or.inl (Or.inl ha)))\n", "additional_info": "", "used_premises": [1, 402, 808, 809, 803, 810, 61], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [87, 95], "informalization": "This theorem is a part of the Constructive Ordinal Notation (ConNF) project. It is used to prove that for any Î²-structural action Ïˆ that is lawful, a Î²-structural approximation derived from Ïˆ exactly approximates a Î²-structural permutation Ï if and only if for every Î²-extended index A, the near-litter approximation derived from Ïˆ exactly approximates the near-litter permutation derived from Ï. A key step in this proof involves showing that for any atom a that is in the domain of the atom map of Ïˆ at A, the application of Ï at A to a is equal to the value of the atom map of Ïˆ at A at a."}
{"full_name": "ConNF.StructAction", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction", "code_src": "con-nf", "ptype": "abbrev", "header": "@[inline, reducible]abbrev ConNF.StructAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Type u", "code": "abbrev StructAction :=\n  Tree NearLitterAction\n", "additional_info": "A `Î²`-structural action is a product that assigns a near-litter action to each `Î²`-extended\nindex.\nEquations\n* ConNF.StructAction ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.TreeğŸ—ŸğŸ”—../../.././ConNF/Structural/Tree.html#ConNF.TreeğŸ”—  ConNF.NearLitterAction\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [20, 22], "informalization": "Function `ConNF.StructAction` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index."}
{"full_name": "ConNF.StructAction.Lawful", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Lawful", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.Lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def Lawful {Î² : TypeIndex} (Ï† : StructAction Î²) : Prop :=\n  âˆ€ B, (Ï† B).Lawful\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructAction.LawfulğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.LawfulğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (B : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  Î²), ğŸ—ŸConNF.NearLitterAction.LawfulğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.LawfulğŸ”—  (Ï† B)\n\n", "used_premises": [1, 808], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [25, 27], "informalization": "Function `ConNF.StructAction.Lawful` checks if a `Î²`-structural action `Ï†` satisfies the lawfulness condition for each `Î²`-extended index."}
{"full_name": "ConNF.StructAction.rc", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.rc", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.rc [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (h : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²", "code": "noncomputable def rc (Ï† : StructAction Î²) (h : Ï†.Lawful) : StructApprox Î² :=\n  (Ï†.refine h).complete refine_lawful\n", "additional_info": "Refine and complete this action into a structural approximation.\nEquations\n* ğŸ—ŸConNF.StructAction.rcğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Refine.html#ConNF.StructAction.rcğŸ”—  Ï† h ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.StructAction.completeğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.completeğŸ”—  (ğŸ—ŸConNF.StructAction.refineğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Refine.html#ConNF.StructAction.refineğŸ”—  Ï† h) â‹¯\n\n", "used_premises": [1, 808, 809, 781], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [92, 94], "informalization": "Function `ConNF.StructAction.rc` refines and completes a `Î²`-structural action into a `Î²`-structural approximation in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructAction.foaMotive_litter", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.foaMotive_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.foaMotive_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ïˆ) (hâ‚‚ : ConNF.StructAction.CoherentğŸ”—<|PREMISE|>ğŸ”— Ïˆ) (Ï : ConNF.Allowable â†‘Î²) (hÏ : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— Ïˆ hâ‚) (ConNF.Allowable.toStructPerm Ï)) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) (ih : âˆ€ c < { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) }, ConNF.StructAction.FOAMotiveğŸ”—<|PREMISE|>ğŸ”— Ïˆ Ï c) (hL : ((Ïˆ A).litterMap L).Dom) :ConNF.Allowable.toStructPerm Ï A â€¢ L = (((Ïˆ A).litterMap L).get hL).fst", "code": "theorem foaMotive_litter (Ïˆ : StructAction Î²) (hâ‚ : Ïˆ.Lawful) (hâ‚‚ : Ïˆ.Coherent)\n    (Ï : Allowable Î²) (hÏ : (Ïˆ.rc hâ‚).ExactlyApproximates (Allowable.toStructPerm Ï))\n    (A : ExtendedIndex Î²) (L : Litter)\n    (ih : âˆ€ (c : Address Î²), c < âŸ¨A, inr L.toNearLitterâŸ© â†’ FOAMotive Ïˆ Ï c)\n    (hL : ((Ïˆ A).litterMap L).Dom) :\n    Allowable.toStructPerm Ï A â€¢ L = (((Ïˆ A).litterMap L).get hL).fst := by\n  obtain (hL' | âŸ¨âŸ¨âŸ¨Î³, Îµ, hÎµ, A, rflâŸ©, a, rflâŸ©âŸ© |\n      âŸ¨âŸ¨âŸ¨Î³, Î´, Îµ, hÎ´, hÎµ, hÎ´Îµ, A, rflâŸ©, t, rflâŸ©âŸ©) := flexible_cases' A L\n  Â· rw [â† (hÏ A).map_litter L (Or.inl (Or.inl âŸ¨hL, hL'âŸ©)), rc_smul_litter_eq,\n      NearLitterAction.flexibleLitterPartialPerm_apply_eq _ (by exact hL) hL',\n      NearLitterAction.roughLitterMapOrElse,\n      NearLitterAction.litterMapOrElse_of_dom]\n    rfl\n  Â· have := hâ‚‚.coherent_bot A hÎµ hL (Allowable.comp A Ï) ?_\n    Â· rw [this]\n      simp only [Allowable.comp_comp_apply, Hom.comp_toPath, ofBot_smul,\n        Allowable.toStructPerm_apply]\n      rw [toStructPerm_smul_fuzz, comp_bot_smul_atom]\n    Â· have := ih âŸ¨A.cons (bot_lt_coe _), inl aâŸ©\n        (Relation.TransGen.single (Constrains.fuzz_bot hÎµ A a))\n        (hâ‚‚.atom_bot_dom A hÎµ hL)\n      simp only [Allowable.toStructPerm_comp, Tree.comp_apply, Hom.comp_toPath]\n      exact this.symm\n  Â· have := hâ‚‚.coherent_coe A hÎ´ hÎµ hÎ´Îµ hL (Allowable.comp A Ï) ?_ ?_ ?_\n    Â· rw [this, Allowable.comp_comp_apply, Hom.comp_toPath, toStructPerm_smul_fuzz]\n    Â· intro B a ha\n      have := ih âŸ¨(A.cons hÎ´).comp B, inl aâŸ©\n        (Relation.TransGen.single (Constrains.fuzz hÎ´ hÎµ hÎ´Îµ A t _ ha))\n        (hâ‚‚.atom_dom A hÎ´ hÎµ hÎ´Îµ ha hL)\n      simp only [Allowable.toStructPerm_comp, Tree.comp_apply, Hom.comp_toPath_comp]\n      exact this.symm\n    Â· intro B N hN\n      have := ih âŸ¨(A.cons hÎ´).comp B, inr N.1.toNearLitterâŸ©\n        (lt_nearLitter' (Relation.TransGen.single (Constrains.fuzz hÎ´ hÎµ hÎ´Îµ A t _ hN)))\n        (NearLitter.IsLitter.mk _) (hâ‚‚.nearLitter_dom A hÎ´ hÎµ hÎ´Îµ (N := N) hN hL)\n      simp only [Allowable.toStructPerm_comp, Tree.comp_apply, Hom.comp_toPath_comp]\n      exact this.symm\n    Â· intro B N a hN ha\n      have := ih âŸ¨(A.cons hÎ´).comp B, inl aâŸ©\n        ((Relation.TransGen.single (Constrains.symmDiff _ N a ha)).tail\n          (Constrains.fuzz hÎ´ hÎµ hÎ´Îµ A t _ hN))\n        (hâ‚‚.symmDiff_dom A hÎ´ hÎµ hÎ´Îµ hN ha hL)\n      simp only [Allowable.toStructPerm_comp, Tree.comp_apply, Hom.comp_toPath_comp]\n      exact this.symm\n", "additional_info": "", "used_premises": [1, 402, 808, 809, 812, 803, 810, 61, 65, 483, 816], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [96, 140], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a `Î²`-structural action `Ïˆ` that is lawful and coherent, an allowable `Ï`, and a `Î²`-extended index `A`, a litter `L`, and a proof `hL` that `L` is in the domain of the litter map of `Ïˆ` applied to `A`, if `L` is a flexible litter, then `((Ïˆ A).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `Ïˆ`, ensuring that these functions are defined for all necessary inputs."}
{"full_name": "ConNF.StructAction.Coherent", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.Coherent", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructAction.Coherent [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) extends ConNF.StructAction.CoherentDomğŸ”—<|PREMISE|>ğŸ”— :Prop\n | mapFlexible : ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”—  Ïˆ\n | atom_bot_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Îµ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎµ : â†‘Îµ <  â†‘Î³)\n {a : ConNF.Atom},\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ a)).Dom â†’\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A â‹¯)).atomMap a).Dom\n | atom_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {a : ConNF.Atom},\n { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)).Dom â†’\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).Dom\n | nearLitter_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {N : ConNF.NearLitter},\n { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)).Dom â†’\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).litterMap N.fst).Dom\n | symmDiff_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {N : ConNF.NearLitter} {a : ConNF.Atom},\n { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n a âˆˆ  symmDiffğŸ”—<|PREMISE|>ğŸ”—  (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”—  N.fst) â†‘N â†’\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)).Dom â†’\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).Dom\n | coherent_coe : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´]\n {Îµ : ConNF.Î›} [inst_2 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n (h : ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)).Dom) (Ï : ConNF.Allowable  â†‘Î³),\n (âˆ€ (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´) (a : ConNF.Atom)\n (ha : { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t),\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).get â‹¯ =  ConNF.Allowable.toStructPerm Ï (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  hÎ´) B) â€¢  a) â†’\n (âˆ€ (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´) (N : ConNF.NearLitter)\n (ha : { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t),\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).litterMap N.fst).get â‹¯ =  ConNF.Allowable.toStructPerm Ï (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  hÎ´) B) â€¢  ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”—  N.fst) â†’\n (âˆ€ (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´) (N : ConNF.NearLitter) (a : ConNF.Atom)\n (hN : { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t)\n (ha : a âˆˆ  symmDiffğŸ”—<|PREMISE|>ğŸ”—  (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”—  N.fst) â†‘N),\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).get â‹¯ =  ConNF.Allowable.toStructPerm Ï (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  hÎ´) B) â€¢  a) â†’\n (((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)).get h).fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ ((ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  hÎ´)) Ï â€¢  t)\n | coherent_bot : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Îµ : ConNF.Î›} [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ]\n (hÎµ : â†‘Îµ <  â†‘Î³) {a : ConNF.Atom}\n (h : ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ a)).Dom) (Ï : ConNF.Allowable  â†‘Î³),\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A â‹¯)).atomMap a).get â‹¯ =  ConNF.Allowable.toStructPerm Ï (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  â‹¯) â€¢  a â†’\n (((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ a)).get h).fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ ((ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  â‹¯)) Ï â€¢  a)", "code": "structure Coherent (Ïˆ : StructAction Î²) extends CoherentDom Ïˆ : Prop where\n  coherent_coe : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    {Î´ : Î›} [LtLevel Î´] {Îµ : Î›} [LtLevel Îµ]\n    (hÎ´ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ) {t : Tangle Î´}\n    (h : ((Ïˆ ((A.cons hÎµ).cons (bot_lt_coe _))).litterMap (fuzz hÎ´Îµ t)).Dom)\n    (Ï : Allowable Î³),\n    (âˆ€ (B : ExtendedIndex Î´) (a : Atom) (ha : âŸ¨B, inl aâŸ© âˆˆ t.support),\n      ((Ïˆ ((A.cons hÎ´).comp B)).atomMap a).get (atom_dom A hÎ´ hÎµ hÎ´Îµ ha h) =\n      Allowable.toStructPerm Ï ((Hom.toPath hÎ´).comp B) â€¢ a) â†’\n    (âˆ€ (B : ExtendedIndex Î´) (N : NearLitter) (ha : âŸ¨B, inr NâŸ© âˆˆ t.support),\n      ((Ïˆ ((A.cons hÎ´).comp B)).litterMap N.1).get (nearLitter_dom A hÎ´ hÎµ hÎ´Îµ ha h) =\n      Allowable.toStructPerm Ï ((Hom.toPath hÎ´).comp B) â€¢ N.1.toNearLitter) â†’\n    (âˆ€ (B : ExtendedIndex Î´) (N : NearLitter) (a : Atom)\n      (hN : âŸ¨B, inr NâŸ© âˆˆ t.support) (ha : a âˆˆ litterSet N.1 âˆ† N),\n      ((Ïˆ ((A.cons hÎ´).comp B)).atomMap a).get (symmDiff_dom A hÎ´ hÎµ hÎ´Îµ hN ha h) =\n      Allowable.toStructPerm Ï ((Hom.toPath hÎ´).comp B) â€¢ a) â†’\n    (((Ïˆ ((A.cons hÎµ).cons (bot_lt_coe _))).litterMap (fuzz hÎ´Îµ t)).get h).fst =\n      fuzz hÎ´Îµ (Allowable.comp (Hom.toPath hÎ´) Ï â€¢ t)\n  coherent_bot : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³) {Îµ : Î›} [LtLevel Îµ]\n    (hÎµ : (Îµ : TypeIndex) < Î³) {a : Atom}\n    (h : ((Ïˆ ((A.cons hÎµ).cons (bot_lt_coe _))).litterMap (fuzz bot_ne_coe a)).Dom)\n    (Ï : Allowable Î³),\n    ((Ïˆ (A.cons (bot_lt_coe _))).atomMap a).get (atom_bot_dom A hÎµ h) =\n      Allowable.toStructPerm Ï (Hom.toPath (bot_lt_coe _)) â€¢ a â†’\n    (((Ïˆ ((A.cons hÎµ).cons (bot_lt_coe _))).litterMap (fuzz bot_ne_coe a)).get h).fst =\n      fuzz (bot_ne_coe (a := Îµ)) (Allowable.comp (Hom.toPath (bot_lt_coe _)) Ï â€¢ a)\n", "additional_info": "", "used_premises": [1, 808, 813, 814, 402, 76, 98, 301, 301, 78, 301, 402, 76, 98, 98, 61, 67, 395, 301, 301, 78, 135, 301, 402, 76, 98, 98, 61, 65, 395, 301, 301, 78, 135, 301, 402, 76, 98, 98, 61, 65, 395, 62, 467, 301, 301, 78, 135, 301, 402, 76, 98, 98, 301, 301, 78, 61, 67, 395, 135, 301, 135, 74, 61, 65, 395, 135, 301, 135, 74, 483, 61, 65, 395, 62, 467, 135, 301, 135, 74, 301, 301, 78, 78, 815, 74, 402, 76, 98, 301, 301, 78, 301, 74, 301, 301, 78, 78, 815, 74], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [54, 80], "informalization": "The `ConNF.StructAction.Coherent` class in Lean 4 defines a property of a `Î²`-structural action `Ï†` in the context of Constructive Ordinal Notation (ConNF). It states that for any `Î²`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `Ï†` applied to `B`, if `L` is a flexible litter, then `((Ï† B).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `Ï†`, ensuring that these functions are defined for all necessary inputs."}
{"full_name": "ConNF.StructAction.CoherentDom", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.CoherentDom", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructAction.CoherentDom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Prop\n | mapFlexible : ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”—  Ïˆ\n | atom_bot_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Îµ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎµ : â†‘Îµ <  â†‘Î³)\n {a : ConNF.Atom},\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ a)).Dom â†’\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A â‹¯)).atomMap a).Dom\n | atom_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {a : ConNF.Atom},\n { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)).Dom â†’\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).Dom\n | nearLitter_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {N : ConNF.NearLitter},\n { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)).Dom â†’\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).litterMap N.fst).Dom\n | symmDiff_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {N : ConNF.NearLitter} {a : ConNF.Atom},\n { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n a âˆˆ  symmDiffğŸ”—<|PREMISE|>ğŸ”—  (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”—  N.fst) â†‘N â†’\n ((Ïˆ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).litterMap (ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)).Dom â†’\n ((Ïˆ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).Dom", "code": "structure CoherentDom (Ïˆ : StructAction Î²) : Prop where\n  mapFlexible : Ïˆ.MapFlexible\n  atom_bot_dom : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³) {Îµ : Î›} [LtLevel Îµ]\n    (hÎµ : (Îµ : TypeIndex) < Î³) {a : Atom},\n    ((Ïˆ ((A.cons hÎµ).cons (bot_lt_coe _))).litterMap (fuzz (bot_ne_coe (a := Îµ)) a)).Dom â†’\n    ((Ïˆ (A.cons (bot_lt_coe _))).atomMap a).Dom\n  atom_dom : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    {Î´ : Î›} [LtLevel Î´] {Îµ : Î›} [LtLevel Îµ]\n    (hÎ´ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ) {t : Tangle Î´}\n    {B : ExtendedIndex Î´} {a : Atom},\n    âŸ¨B, inl aâŸ© âˆˆ t.support â†’\n    ((Ïˆ ((A.cons hÎµ).cons (bot_lt_coe _))).litterMap (fuzz hÎ´Îµ t)).Dom â†’\n    ((Ïˆ ((A.cons hÎ´).comp B)).atomMap a).Dom\n  nearLitter_dom : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    {Î´ : Î›} [LtLevel Î´] {Îµ : Î›} [LtLevel Îµ]\n    (hÎ´ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ) {t : Tangle Î´}\n    {B : ExtendedIndex Î´} {N : NearLitter},\n    âŸ¨B, inr NâŸ© âˆˆ t.support â†’\n    ((Ïˆ ((A.cons hÎµ).cons (bot_lt_coe _))).litterMap (fuzz hÎ´Îµ t)).Dom â†’\n    ((Ïˆ ((A.cons hÎ´).comp B)).litterMap N.fst).Dom\n  symmDiff_dom : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    {Î´ : Î›} [LtLevel Î´] {Îµ : Î›} [LtLevel Îµ]\n    (hÎ´ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ) {t : Tangle Î´}\n    {B : ExtendedIndex Î´} {N : NearLitter} {a : Atom},\n    âŸ¨B, inr NâŸ© âˆˆ t.support â†’ a âˆˆ litterSet N.1 âˆ† N â†’\n    ((Ïˆ ((A.cons hÎµ).cons (bot_lt_coe _))).litterMap (fuzz hÎ´Îµ t)).Dom â†’\n    ((Ïˆ ((A.cons hÎ´).comp B)).atomMap a).Dom\n", "additional_info": "", "used_premises": [1, 808, 814, 402, 76, 98, 301, 301, 78, 301, 402, 76, 98, 98, 61, 67, 395, 301, 301, 78, 135, 301, 402, 76, 98, 98, 61, 65, 395, 301, 301, 78, 135, 301, 402, 76, 98, 98, 61, 65, 395, 62, 467, 301, 301, 78, 135, 301], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [26, 53], "informalization": "The `ConNF.StructAction.CoherentDom` class in Lean 4 defines a property of a `Î²`-structural action `Ï†` in the context of Constructive Ordinal Notation (ConNF). It states that for any `Î²`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `Ï†` applied to `B`, if `L` is a flexible litter, then `((Ï† B).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `Ï†`, ensuring that these functions are defined for all necessary inputs."}
{"full_name": "ConNF.StructAction.MapFlexible", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.MapFlexible", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.MapFlexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Prop", "code": "def MapFlexible [Level] [FOAAssumptions] {Î² : Î›} (Ï† : StructAction Î²) :\n    Prop :=\n  âˆ€ (B) (L : Litter) (hL), Flexible B L â†’ Flexible B (((Ï† B).litterMap L).get hL).1\n", "additional_info": "This structural action maps flexible litters to flexible litters.\nEquations\n* ğŸ—ŸConNF.StructAction.MapFlexibleğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.MapFlexibleğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (B : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  â†‘Î²) (L : ConNF.Litter) (hL : ((Ï† B).litterMap L).Dom),\n ğŸ—ŸConNF.FlexibleğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.FlexibleğŸ”—  B L â†’ ğŸ—ŸConNF.FlexibleğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.FlexibleğŸ”—  B (((Ï† B).litterMap L).get hL).fst\n\n", "used_premises": [1, 808], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [29, 32], "informalization": "Function `ConNF.StructAction.MapFlexible` is a property of a `Î²`-structural action `Ï†` in the context of Constructive Ordinal Notation (ConNF). It states that for any `Î²`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `Ï†` applied to `B`, if `L` is a flexible litter, then `((Ï† B).litterMap L).get hL` is also a flexible litter."}
{"full_name": "ConNF.Allowable.comp", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Allowable.comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) :ConNF.Allowable Î² â†’* ConNF.Allowable Î³", "code": "def Allowable.comp {Î² Î³ : TypeIndex} [LeLevel Î²] [LeLevel Î³] (A : Quiver.Path Î² Î³) :\n    Allowable Î² â†’* Allowable Î³ :=\n  Allowable.comp' A\n", "additional_info": "Define the full derivative map on allowable permutations by recursion along paths.\nThis agrees with `Tree.ğŸ—ŸcompğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.compğŸ”—` , but yields allowable permutations.\nNote that the `LeLevel Î³` hypothesis is technically redundant, but is used to give us more\ndirect access to `Allowable Î³`. In practice, we already have this assumption wherever we use\n`ğŸ—ŸAllowable.compğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.compğŸ”—` .\nEquations\n* ğŸ—ŸConNF.Allowable.compğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.compğŸ”—  A ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.Allowable.comp'ğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp'ğŸ”—  A\n\n", "used_premises": [1, 402, 402, 76], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [134, 137], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF), and `Î²` is less than or equal to `Î³`. The function is defined recursively along a path `A` from `Î²` to `Î³`."}
{"full_name": "ConNF.StructAction.FOAMotive", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.FOAMotive", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.FOAMotive [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (Ï : ConNF.Allowable â†‘Î²) :ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†’ Prop", "code": "def FOAMotive (Ïˆ : StructAction Î²) (Ï : Allowable Î²) : Address Î² â†’ Prop\n  | âŸ¨A, inl aâŸ© => (ha : ((Ïˆ A).atomMap a).Dom) â†’\n      Allowable.toStructPerm Ï A â€¢ a = ((Ïˆ A).atomMap a).get ha\n  | âŸ¨A, inr NâŸ© => N.IsLitter â†’ (hL : ((Ïˆ A).litterMap N.1).Dom) â†’\n      Allowable.toStructPerm Ï A â€¢ N = ((Ïˆ A).litterMap N.1).get hL\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 808, 60], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [81, 86], "informalization": "Function `ConNF.StructAction.FOAMotive` defines a motive for the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). Given a `Î²`-structural action `Ïˆ` and an allowable `Ï`, it checks if an address in the base type (the atom or near-litter) together with the path detailing how we descend from type `Î±` to type `âŠ¥` by looking at elements of elements and so on in the model satisfies the conditions specified for the `Î²`-structural action."}
{"full_name": "ConNF.StructAction.foaMotive_nearLitter", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.foaMotive_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.foaMotive_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ïˆ) (hâ‚‚ : ConNF.StructAction.CoherentğŸ”—<|PREMISE|>ğŸ”— Ïˆ) (Ï : ConNF.Allowable â†‘Î²) (hÏ : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— Ïˆ hâ‚) (ConNF.Allowable.toStructPerm Ï)) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) (ih : âˆ€ c < { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) }, ConNF.StructAction.FOAMotiveğŸ”—<|PREMISE|>ğŸ”— Ïˆ Ï c) (hL : ((Ïˆ A).litterMap L).Dom) :ConNF.Allowable.toStructPerm Ï A â€¢ ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L = ((Ïˆ A).litterMap L).get hL", "code": "theorem foaMotive_nearLitter (Ïˆ : StructAction Î²) (hâ‚ : Ïˆ.Lawful) (hâ‚‚ : Ïˆ.Coherent)\n    (Ï : Allowable Î²) (hÏ : (Ïˆ.rc hâ‚).ExactlyApproximates (Allowable.toStructPerm Ï))\n    (A : ExtendedIndex Î²) (L : Litter)\n    (ih : âˆ€ (c : Address Î²), c < âŸ¨A, inr L.toNearLitterâŸ© â†’ FOAMotive Ïˆ Ï c)\n    (hL : ((Ïˆ A).litterMap L).Dom) :\n    Allowable.toStructPerm Ï A â€¢ L.toNearLitter = ((Ïˆ A).litterMap L).get hL := by\n  refine NearLitter.ext ?_\n  rw [smul_nearLitter_eq_of_precise (Ïˆ.refine hâ‚) refine_precise hÏ\n    (by exact hL) (foaMotive_litter Ïˆ hâ‚ hâ‚‚ Ï hÏ A L ih hL)]\n  simp only [refine_apply, Litter.toNearLitter_fst, NearLitterAction.refine_litterMap,\n    Tree.comp_bot, Litter.coe_toNearLitter, symmDiff_self, bot_eq_empty, smul_set_empty,\n    symmDiff_empty]\n", "additional_info": "", "used_premises": [1, 402, 808, 809, 812, 803, 810, 61, 65, 483, 816, 483], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [141, 153], "informalization": "The theorem `ConNF.StructAction.foaMotive_nearLitter` is a part of the formalization of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any `Î²`-structural action `Ïˆ` that is lawful and coherent, any allowable `Ï`, any `Î²`-extended index `A`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `Ïˆ` applied to `A`, if `L` is a flexible litter, then `((Ïˆ A).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `Ïˆ`, ensuring that these functions are defined for all necessary inputs."}
{"full_name": "ConNF.StructAction.freedom_of_action", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.freedom_of_action", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.freedom_of_action [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ïˆ) (hâ‚‚ : ConNF.StructAction.CoherentğŸ”—<|PREMISE|>ğŸ”— Ïˆ) :âˆƒ (Ï : ConNF.Allowable â†‘Î²), ConNF.StructAction.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Ïˆ (ConNF.Allowable.toStructPerm Ï)", "code": "theorem freedom_of_action (Ïˆ : StructAction Î²) (hâ‚ : Ïˆ.Lawful) (hâ‚‚ : Ïˆ.Coherent) :\n    âˆƒ Ï : Allowable Î², Ïˆ.Approximates (Allowable.toStructPerm Ï) := by\n  obtain âŸ¨Ï, hÏâŸ© := (Ïˆ.rc hâ‚).freedom_of_action (rc_free _ _ hâ‚‚.mapFlexible)\n  refine âŸ¨Ï, ?_âŸ©\n  have := fun c => WellFounded.induction (constrains_wf _).transGen (C := FOAMotive Ïˆ Ï) c ?_\n  Â· intro A\n    constructor\n    Â· intro a ha\n      exact this âŸ¨A, inl aâŸ© ha\n    Â· intro L hL\n      exact this âŸ¨A, inr L.toNearLitterâŸ© (NearLitter.IsLitter.mk L) hL\n  Â· rintro âŸ¨A, a | NâŸ© ih\n    Â· exact foaMotive_atom Ïˆ hâ‚ Ï hÏ A a\n    Â· intro hL h\n      obtain âŸ¨L, rflâŸ© := hL.exists_litter_eq\n      exact foaMotive_nearLitter Ïˆ hâ‚ hâ‚‚ Ï hÏ A L ih h\n", "additional_info": "", "used_premises": [1, 402, 808, 809, 812, 819], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [155, 171], "informalization": "The theorem `ConNF.StructAction.freedom_of_action` asserts that, under the Constructive Ordinal Notation (ConNF) framework, given a `Î²`-structural action `Ïˆ` and certain conditions such as lawfulness and coherence, there exists a `Î²`-allowable permutation `Ï` that approximates `Ïˆ`. This theorem is a key step in proving the 'Freedom of Action' property, which is crucial for ConNF's construction of the natural numbers."}
{"full_name": "ConNF.StructAction.Approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.Approximates", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.Approximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.Î›} (Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Prop", "code": "def Approximates (Ïˆ : StructAction Î²) (Ï€ : StructPerm Î²) : Prop :=\n  âˆ€ A, (Ïˆ A).Approximates (Ï€ A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructAction.ApproximatesğŸ—ŸğŸ”—../.././ConNF/FOA/Corollaries.html#ConNF.StructAction.ApproximatesğŸ”—  Ïˆ Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ (A : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  â†‘Î²), ğŸ—ŸConNF.NearLitterAction.ApproximatesğŸ—ŸğŸ”—../.././ConNF/FOA/Corollaries.html#ConNF.NearLitterAction.ApproximatesğŸ”—  (Ïˆ A) (Ï€ A)\n\n", "used_premises": [1, 808, 55], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [23, 25], "informalization": "Function `ConNF.StructAction.Approximates` checks if a `Î²`-structural action `Ïˆ` approximates a `Î²`-structural permutation `Ï€`, meaning that for every `Î²`-extended index `A`, the near-litter action `Ïˆ A` approximates the near-litter permutation `Ï€ A`."}
{"full_name": "ConNF.NearLitterBehaviour.approximates_iff", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.approximates_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.approximates_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (Ï€ : ConNF.NearLitterPerm) :ConNF.NearLitterBehaviour.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Î¾ Ï€ â†” (âˆ€ (a : ConNF.Atom) (h : (Î¾.atomMap a).Dom), Ï€ â€¢ a = (Î¾.atomMap a).get h) âˆ§ âˆ€ (N : ConNF.NearLitter) (h : (Î¾.nearLitterMap N).Dom), Ï€ â€¢ N = (Î¾.nearLitterMap N).get h", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 821], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [174, 175], "informalization": "The theorem `ConNF.NearLitterBehaviour.approximates_iff` states that a `ConNF.NearLitterBehaviour` object `Î¾` approximates a `ConNF.NearLitterPerm` object `Ï€` if and only if for any `ConNF.Atom` `a` such that `Î¾.atomMap a` is defined, the action of `Ï€` on `a` is equal to the value of `Î¾.atomMap a`, and for any `ConNF.NearLitter` `N` such that `Î¾.nearLitterMap N` is defined, the action of `Ï€` on `N` is equal to the value of `Î¾.nearLitterMap N`."}
{"full_name": "ConNF.NearLitterBehaviour.Approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.Approximates", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterBehaviour.Approximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (Ï€ : ConNF.NearLitterPerm) :Prop\n | map_atom : âˆ€ (a : ConNF.Atom) (h : (Î¾.atomMap a).Dom), Ï€ â€¢  a =  (Î¾.atomMap a).get h\n | map_nearLitter : âˆ€ (N : ConNF.NearLitter) (h : (Î¾.nearLitterMap N).Dom), Ï€ â€¢  N =  (Î¾.nearLitterMap N).get h", "code": "structure NearLitterBehaviour.Approximates\n    (Î¾ : NearLitterBehaviour) (Ï€ : NearLitterPerm) : Prop where\n  map_atom : âˆ€ a (h : (Î¾.atomMap a).Dom), Ï€ â€¢ a = (Î¾.atomMap a).get h\n  map_nearLitter : âˆ€ N (h : (Î¾.nearLitterMap N).Dom), Ï€ â€¢ N = (Î¾.nearLitterMap N).get h\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [175, 179], "informalization": "The `ConNF.NearLitterBehaviour.Approximates` structure in Lean 4 defines a relationship between a `ConNF.NearLitterBehaviour` object `Î¾` and a `ConNF.NearLitterPerm` object `Ï€`. It consists of two properties: `map_atom` and `map_nearLitter`. The `map_atom` property states that for any `ConNF.Atom` `a` such that `Î¾.atomMap a` is defined, the action of `Ï€` on `a` is equal to the value of `Î¾.atomMap a`. Similarly, the `map_nearLitter` property states that for any `ConNF.NearLitter` `N` such that `Î¾.nearLitterMap N` is defined, the action of `Ï€` on `N` is equal to the value of `Î¾.nearLitterMap N`."}
{"full_name": "ConNF.NearLitterBehaviour.action_lawful", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.action_lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.actionğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾)", "code": "theorem ConNF.NearLitterBehaviour.action_lawful\n    (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) : (Î¾.action hÎ¾).Lawful := by\n  constructor\n  case atomMap_injective => exact (Î¾.withLitters_lawful hÎ¾).atomMap_injective\n  case litterMap_injective =>\n    rintro Lâ‚ Lâ‚‚ hLâ‚ hLâ‚‚ âŸ¨a, haâŸ©\n    by_contra hL\n    obtain âŸ¨a, ha', rflâŸ© := (Î¾.withLitters_lawful hÎ¾).ran_of_mem_inter a (by exact hL) hLâ‚ hLâ‚‚ ha\n    simp only [NearLitterBehaviour.action, mem_inter_iff,\n      SetLike.mem_coe, (Î¾.withLitters_lawful hÎ¾).atom_mem_iff] at ha\n    exact hL (ha.1.symm.trans ha.2)\n  case atom_mem =>\n    intro a ha L hL\n    exact ((Î¾.withLitters_lawful hÎ¾).atom_mem_iff ha hL).symm\n", "additional_info": "", "used_premises": [1, 823, 825, 826], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [244, 258], "informalization": "Given a lawful near-litter-behaviour in the context of Constructive Ordinal Notation (ConNF), the function `ConNF.NearLitterBehaviour.action` constructs a lawful near-litter-action, ensuring that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters."}
{"full_name": "ConNF.NearLitterBehaviour.Lawful", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.Lawful", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterBehaviour.Lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :Prop\n | atomMap_injective : âˆ€ â¦ƒa b : ConNF.Atomâ¦„ (ha : (Î¾.atomMap a).Dom) (hb : (Î¾.atomMap b).Dom),\n (Î¾.atomMap a).get ha =  (Î¾.atomMap b).get hb â†’ a =  b\n | atom_mem_iff : âˆ€ â¦ƒa : ConNF.Atomâ¦„ (ha : (Î¾.atomMap a).Dom) â¦ƒN : ConNF.NearLitterâ¦„ (hN : (Î¾.nearLitterMap N).Dom),\n (Î¾.atomMap a).get ha âˆˆ  (Î¾.nearLitterMap N).get hN â†”  a âˆˆ  N\n | dom_of_mem_symmDiff : âˆ€ (a : ConNF.Atom) â¦ƒNâ‚ Nâ‚‚ : ConNF.NearLitterâ¦„,\n Nâ‚.fst =  Nâ‚‚.fst â†’ (Î¾.nearLitterMap Nâ‚).Dom â†’ (Î¾.nearLitterMap Nâ‚‚).Dom â†’ a âˆˆ  symmDiffğŸ”—<|PREMISE|>ğŸ”—  â†‘Nâ‚ â†‘Nâ‚‚ â†’ (Î¾.atomMap a).Dom\n | dom_of_mem_inter : âˆ€ (a : ConNF.Atom) â¦ƒNâ‚ Nâ‚‚ : ConNF.NearLitterâ¦„,\n Nâ‚.fst â‰   Nâ‚‚.fst â†’ (Î¾.nearLitterMap Nâ‚).Dom â†’ (Î¾.nearLitterMap Nâ‚‚).Dom â†’ a âˆˆ  â†‘Nâ‚ âˆ©  â†‘Nâ‚‚ â†’ (Î¾.atomMap a).Dom\n | ran_of_mem_symmDiff : âˆ€ (a : ConNF.Atom) â¦ƒNâ‚ Nâ‚‚ : ConNF.NearLitterâ¦„,\n Nâ‚.fst =  Nâ‚‚.fst â†’\n âˆ€ (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom),\n a âˆˆ  symmDiffğŸ”—<|PREMISE|>ğŸ”—  â†‘((Î¾.nearLitterMap Nâ‚).get hNâ‚) â†‘((Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚) â†’ a âˆˆ  PFun.ranğŸ”—<|PREMISE|>ğŸ”—  Î¾.atomMap\n | ran_of_mem_inter : âˆ€ (a : ConNF.Atom) â¦ƒNâ‚ Nâ‚‚ : ConNF.NearLitterâ¦„,\n Nâ‚.fst â‰   Nâ‚‚.fst â†’\n âˆ€ (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom),\n a âˆˆ  â†‘((Î¾.nearLitterMap Nâ‚).get hNâ‚) âˆ©  â†‘((Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚) â†’ a âˆˆ  PFun.ranğŸ”—<|PREMISE|>ğŸ”—  Î¾.atomMap", "code": "structure Lawful (Î¾ : NearLitterBehaviour) : Prop where\n  atomMap_injective : âˆ€ â¦ƒa b : Atomâ¦„ (ha : (Î¾.atomMap a).Dom) (hb : (Î¾.atomMap b).Dom),\n    (Î¾.atomMap a).get ha = (Î¾.atomMap b).get hb â†’ a = b\n  atom_mem_iff : âˆ€ â¦ƒa : Atomâ¦„ (ha : (Î¾.atomMap a).Dom)\n    â¦ƒN : NearLitterâ¦„ (hN : (Î¾.nearLitterMap N).Dom),\n    (Î¾.atomMap a).get ha âˆˆ (Î¾.nearLitterMap N).get hN â†” a âˆˆ N\n  dom_of_mem_symmDiff : âˆ€ (a : Atom) â¦ƒNâ‚ Nâ‚‚ : NearLitterâ¦„,\n    Nâ‚.fst = Nâ‚‚.fst â†’ (Î¾.nearLitterMap Nâ‚).Dom â†’ (Î¾.nearLitterMap Nâ‚‚).Dom â†’\n    a âˆˆ (Nâ‚ : Set Atom) âˆ† Nâ‚‚ â†’ (Î¾.atomMap a).Dom\n  dom_of_mem_inter : âˆ€ (a : Atom) â¦ƒNâ‚ Nâ‚‚ : NearLitterâ¦„,\n    Nâ‚.fst â‰  Nâ‚‚.fst â†’ (Î¾.nearLitterMap Nâ‚).Dom â†’ (Î¾.nearLitterMap Nâ‚‚).Dom â†’\n    a âˆˆ (Nâ‚ : Set Atom) âˆ© Nâ‚‚ â†’ (Î¾.atomMap a).Dom\n  ran_of_mem_symmDiff : âˆ€ (a : Atom) â¦ƒNâ‚ Nâ‚‚ : NearLitterâ¦„,\n    Nâ‚.fst = Nâ‚‚.fst â†’ (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) â†’ (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) â†’\n    a âˆˆ ((Î¾.nearLitterMap Nâ‚).get hNâ‚ : Set Atom) âˆ† (Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚ â†’\n    a âˆˆ Î¾.atomMap.ran\n  ran_of_mem_inter : âˆ€ (a : Atom) â¦ƒNâ‚ Nâ‚‚ : NearLitterâ¦„,\n    Nâ‚.fst â‰  Nâ‚‚.fst â†’ (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) â†’ (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) â†’\n    a âˆˆ ((Î¾.nearLitterMap Nâ‚).get hNâ‚ : Set Atom) âˆ© (Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚ â†’\n    a âˆˆ Î¾.atomMap.ran\n", "additional_info": "", "used_premises": [1, 62, 62, 824, 824], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [21, 41], "informalization": "The structure `ConNF.NearLitterBehaviour.Lawful` defines the properties that a lawful near-litter-behaviour must satisfy, given the context of Constructive Ordinal Notation (ConNF) in Lean 4. It contains conditions for injectivity of the atom map, membership equivalence, domain and range conditions for the near-litter map, and properties related to symmetric differences and intersections."}
{"full_name": "PFun.ran", "url": "Mathlib/Data/PFun.html#PFun.ran", "code_src": "mathlib4", "ptype": "def", "header": "def PFun.ran {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’. Î²) :SetğŸ”—<|PREMISE|>ğŸ”— Î²", "code": "def ran (f : Î± â†’. Î²) : Set Î² :=\n  { b | âˆƒ a, b âˆˆ f a }\n", "additional_info": "The range of a partial function is the set of values\n`f x` where `x` is in the domain of `f`.\nEquations\n* ğŸ—ŸPFun.ranğŸ—ŸğŸ”—../.././Mathlib/Data/PFun.html#PFun.ranğŸ”—  f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  {b : Î² | âˆƒ (a : Î±), b ğŸ—ŸâˆˆğŸ—ŸğŸ”—../.././Init/Prelude.html#Membership.memğŸ”—  f a}\n\n", "used_premises": [69], "def_path": "Mathlib/Data/PFun.lean", "pos": [169, 171], "informalization": "Function `PFun.ran` returns the range of a partial function `f : Î± â†’. Î²`, which is the set of values `f x` where `x` is in the domain of `f`."}
{"full_name": "ConNF.NearLitterAction.Lawful", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Lawful", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.Lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Prop\n | atomMap_injective : âˆ€ â¦ƒa b : ConNF.Atomâ¦„ (ha : (Ï†.atomMap a).Dom) (hb : (Ï†.atomMap b).Dom),\n (Ï†.atomMap a).get ha =  (Ï†.atomMap b).get hb â†’ a =  b\n | litterMap_injective : âˆ€ â¦ƒLâ‚ Lâ‚‚ : ConNF.Litterâ¦„ (hLâ‚ : (Ï†.litterMap Lâ‚).Dom) (hLâ‚‚ : (Ï†.litterMap Lâ‚‚).Dom),\n Set.NonemptyğŸ”—<|PREMISE|>ğŸ”—  (â†‘((Ï†.litterMap Lâ‚).get hLâ‚) âˆ©  â†‘((Ï†.litterMap Lâ‚‚).get hLâ‚‚)) â†’ Lâ‚ =  Lâ‚‚\n | atom_mem : âˆ€ (a : ConNF.Atom) (ha : (Ï†.atomMap a).Dom) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom),\n a.1 =  L â†”  (Ï†.atomMap a).get ha âˆˆ  (Ï†.litterMap L).get hL", "code": "structure NearLitterAction.Lawful (Ï† : NearLitterAction) : Prop where\n  atomMap_injective : âˆ€ â¦ƒa bâ¦„ (ha hb),\n    (Ï†.atomMap a).get ha = (Ï†.atomMap b).get hb â†’ a = b\n  litterMap_injective : âˆ€ â¦ƒLâ‚ Lâ‚‚ : Litterâ¦„ (hLâ‚ hLâ‚‚),\n    (((Ï†.litterMap Lâ‚).get hLâ‚ : Set Atom) âˆ© (Ï†.litterMap Lâ‚‚).get hLâ‚‚).Nonempty â†’ Lâ‚ = Lâ‚‚\n  atom_mem : âˆ€ (a : Atom) (ha L hL), a.1 = L â†” (Ï†.atomMap a).get ha âˆˆ (Ï†.litterMap L).get hL\n", "additional_info": "A near litter action in which the atom and litter maps are injective (in suitable senses) and\ncohere in the sense that images of atoms in litters are mapped to atoms inside the corresponding\nnear-litters.\n", "used_premises": [1, 83], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [45, 51], "informalization": "Structure `ConNF.NearLitterAction.Lawful` represents a lawful near litter action in the context of Constructive Ordinal Notation (ConNF), ensuring that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters."}
{"full_name": "ConNF.NearLitterBehaviour.action", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterBehaviour.action [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.NearLitterAction", "code": "noncomputable def ConNF.NearLitterBehaviour.action\n    (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) : NearLitterAction where\n  atomMap := (Î¾.withLitters hÎ¾).atomMap\n  litterMap L := (Î¾.withLitters hÎ¾).nearLitterMap L.toNearLitter\n  atomMap_dom_small := (Î¾.withLitters hÎ¾).atomMap_dom_small\n  litterMap_dom_small :=\n    (Î¾.withLitters hÎ¾).nearLitterMap_dom_small.image (f := fun N => N.1).mono\n      (fun L hL => by exact âŸ¨L.toNearLitter, hL, rflâŸ©)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 823], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [232, 240], "informalization": "Function `ConNF.NearLitterBehaviour.action` constructs a lawful near-litter-action from a lawful near-litter-behaviour in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructBehaviour.action_lawful", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.action_lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.Î›} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hÎ¾ : ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructBehaviour.actionğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾)", "code": "theorem action_lawful (Î¾ : StructBehaviour Î²) (hÎ¾ : Î¾.Lawful) : (Î¾.action hÎ¾).Lawful :=\n  fun A => (Î¾ A).action_lawful (hÎ¾ A)\n", "additional_info": "", "used_premises": [1, 828, 829, 809, 830], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [259, 261], "informalization": "The theorem `ConNF.StructBehaviour.action_lawful` states that if `Î¾` is a lawful `Î²`-structural action, then the `Î²`-structural action `ConNF.StructBehaviour.action Î¾ hÎ¾` is also lawful. A `Î²`-structural action is a product that assigns a near-litter action to each `Î²`-extended index. For `Î¾` to be lawful, it must satisfy the condition that for every `Î²`-extended index `A`, the near-litter action assigned by `Î¾` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter."}
{"full_name": "ConNF.StructBehaviour", "url": "ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour", "code_src": "con-nf", "ptype": "abbrev", "header": "@[inline, reducible]abbrev ConNF.StructBehaviour [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î± : ConNF.TypeIndex) :Type u", "code": "abbrev StructBehaviour :=\n  Tree NearLitterBehaviour\n", "additional_info": "A `Î²`-structural action is a product that assigns a near-litter action to each `Î²`-extended\nindex.\nEquations\n* ConNF.StructBehaviour ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.TreeğŸ—ŸğŸ”—../../.././ConNF/Structural/Tree.html#ConNF.TreeğŸ”—  ConNF.NearLitterBehaviour\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/StructBehaviour.lean", "pos": [18, 20], "informalization": "A `Î²`-structural action is a product that assigns a near-litter action to each `Î²`-extended index."}
{"full_name": "ConNF.StructBehaviour.Lawful", "url": "ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.Lawful", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructBehaviour.Lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def Lawful (Î¾ : StructBehaviour Î²) : Prop :=\n  âˆ€ A, (Î¾ A).Lawful\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructBehaviour.LawfulğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.LawfulğŸ”—  Î¾ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (A : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  Î²), ğŸ—ŸConNF.NearLitterBehaviour.LawfulğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.LawfulğŸ”—  (Î¾ A)\n\n", "used_premises": [1, 828], "def_path": "ConNF/FOA/Behaviour/StructBehaviour.lean", "pos": [23, 25], "informalization": "Function `ConNF.StructBehaviour.Lawful` checks if a `Î²`-structural action `Î¾` is lawful. A `Î²`-structural action is a product that assigns a near-litter action to each `Î²`-extended index. For `Î¾` to be lawful, it must satisfy the condition that for every `Î²`-extended index `A`, the near-litter action assigned by `Î¾` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter."}
{"full_name": "ConNF.StructBehaviour.action", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructBehaviour.action [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.Î›} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hÎ¾ : ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²", "code": "noncomputable def action (Î¾ : StructBehaviour Î²) (hÎ¾ : Î¾.Lawful) : StructAction Î² :=\n  fun A => (Î¾ A).action (hÎ¾ A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructBehaviour.actionğŸ—ŸğŸ”—../.././ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.actionğŸ”—  Î¾ hÎ¾ A ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.NearLitterBehaviour.actionğŸ—ŸğŸ”—../.././ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.actionğŸ”—  (Î¾ A) â‹¯\n\n", "used_premises": [1, 828, 829, 808], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [241, 243], "informalization": "Function `ConNF.StructBehaviour.action` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index. For `Î¾` to be lawful, it must satisfy the condition that for every `Î²`-extended index `A`, the near-litter action assigned by `Î¾` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter."}
{"full_name": "ConNF.NearLitterBehaviour.action_atomMap", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterBehaviour.action_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :(ConNF.NearLitterBehaviour.actionğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾).atomMap = (ConNF.NearLitterBehaviour.withLittersğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾).atomMap", "code": "theorem ConNF.NearLitterBehaviour.action_atomMap\n    (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) :\n    (Î¾.action hÎ¾).atomMap = (Î¾.withLitters hÎ¾).atomMap :=\n  rfl\n", "additional_info": "", "used_premises": [1, 823, 826, 832], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [263, 267], "informalization": "The theorem `ConNF.NearLitterBehaviour.action_atomMap` states that the atom map of the lawful near-litter-action `ConNF.NearLitterBehaviour.action Î¾ hÎ¾` is equal to the atom map of the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters Î¾ hÎ¾`."}
{"full_name": "ConNF.NearLitterBehaviour.withLitters", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.withLitters", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterBehaviour.withLitters [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.NearLitterBehaviour", "code": "noncomputable def withLitters (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) : NearLitterBehaviour where\n  atomMap := Î¾.extraAtomMap hÎ¾\n  nearLitterMap N := âŸ¨(Î¾.nearLitterMap N).Dom âˆ¨ (N.IsLitter âˆ§ Î¾.LitterPresent N.1),\n    fun h => h.elim'\n      (Î¾.nearLitterMap N).get\n      (fun h => Î¾.extraLitterMap hÎ¾ h.2.choose h.2.choose_spec.1)âŸ©\n  atomMap_dom_small := Î¾.extraAtomMap_dom_small hÎ¾\n  nearLitterMap_dom_small := Small.union Î¾.nearLitterMap_dom_small Î¾.litterPresent_small'\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 823], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [681, 689], "informalization": "`ConNF.NearLitterBehaviour.withLitters` is a function that takes a `ConNF.NearLitterBehaviour` and a proof that it is lawful, and returns a modified version of the near-litter-behaviour. The modification involves changing the codomain of the atom map and the definition of the near-litter map to include the possibility of mapping onto the extra litter, if it exists. The function also ensures that the domain of the atom map and the near-litter map are small subsets of the relevant types."}
{"full_name": "ConNF.NearLitterBehaviour.action_litterMap", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterBehaviour.action_litterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :(ConNF.NearLitterBehaviour.actionğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾).litterMap = fun (L : ConNF.Litter) => (ConNF.NearLitterBehaviour.withLittersğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾).nearLitterMap (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L)", "code": "theorem ConNF.NearLitterBehaviour.action_litterMap\n    (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) :\n    (Î¾.action hÎ¾).litterMap = fun L => (Î¾.withLitters hÎ¾).nearLitterMap L.toNearLitter :=\n  rfl\n", "additional_info": "", "used_premises": [1, 823, 826, 832, 483], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [269, 273], "informalization": "The `ConNF.NearLitterBehaviour.action_litterMap` theorem states that the litter map of the lawful near-litter-action constructed from a lawful near-litter-behaviour `Î¾` is equal to the near-litter map of the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters Î¾ hÎ¾` applied to the near-litter formed by wrapping a litter `L` with its own litter set."}
{"full_name": "ConNF.NearLitterBehaviour.action_approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action_approximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.action_approximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (Ï€ : ConNF.NearLitterPerm) (h : ConNF.NearLitterAction.ApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.actionğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾) Ï€) :ConNF.NearLitterBehaviour.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Î¾ Ï€", "code": "theorem ConNF.NearLitterBehaviour.action_approximates\n    (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) (Ï€ : NearLitterPerm)\n    (h : (Î¾.action hÎ¾).Approximates Ï€) : Î¾.Approximates Ï€ := by\n  constructor\n  Â· intro a ha\n    simp only [h.map_atom a (Or.inl ha), NearLitterBehaviour.action_atomMap,\n      NearLitterBehaviour.withLitters, NearLitterBehaviour.extraAtomMap_eq_of_dom a ha]\n  Â· intro N hN\n    refine NearLitter.ext ?_\n    rw [NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul,\n      h.map_litter _ (Or.inr âŸ¨âŸ¨_âŸ©, N, hN, rflâŸ©)]\n    rw [â† symmDiff_right_inj, symmDiff_symmDiff_cancel_left]\n    ext a\n    simp only [NearLitterBehaviour.action_litterMap,\n      NearLitterBehaviour.withLitters_nearLitterMap_fst hÎ¾ hN, NearLitterBehaviour.extraLitterMap,\n      NearLitterBehaviour.extraLitterMap', NearLitter.coe_mk, symmDiff_symmDiff_self', mem_iUnion,\n      mem_singleton_iff]\n    constructor <;>\n    Â· rintro âŸ¨a, ha, rflâŸ©\n      refine âŸ¨a, ha, ?_âŸ©\n      dsimp only\n      rw [h.map_atom]\n      rfl\n", "additional_info": "", "used_premises": [1, 823, 806, 826, 821], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [284, 307], "informalization": "The theorem `ConNF.NearLitterBehaviour.action_approximates` states that if `Î¾` is a lawful near-litter-behaviour and `Ï€` is a near-litter-permutation that approximates the near-litter-action derived from `Î¾`, then `Î¾` approximates `Ï€` in the sense that the action of `Ï€` on atoms and litters is consistent with the mapping provided by `Î¾`."}
{"full_name": "ConNF.StructBehaviour.action_approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action_approximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.action_approximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.Î›} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hÎ¾ : ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (h : ConNF.StructAction.ApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructBehaviour.actionğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾) Ï€) :ConNF.StructBehaviour.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Î¾ Ï€", "code": "theorem action_approximates (Î¾ : StructBehaviour Î²) (hÎ¾ : Î¾.Lawful) (Ï€ : StructPerm Î²)\n    (h : (Î¾.action hÎ¾).Approximates Ï€) : Î¾.Approximates Ï€ :=\n  fun A => (Î¾ A).action_approximates (hÎ¾ A) (Ï€ A) (h A)\n", "additional_info": "", "used_premises": [1, 828, 829, 55, 819, 830, 836], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [308, 311], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `Î²`-structural action `Î¾` *approximates* a `Î²`-structural permutation `Ï€` if, for every `Î²`-extended index `A`, the `Î²`-extended near-litter action `Î¾ A` approximates the `Î²`-extended near-litter permutation `Ï€ A`. This approximation is defined by the `ConNF.NearLitterBehaviour.Approximates` relation between near-litter actions and permutations."}
{"full_name": "ConNF.StructBehaviour.Approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.Approximates", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructBehaviour.Approximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.Î›} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Prop", "code": "def Approximates (Î¾ : StructBehaviour Î²) (Ï€ : StructPerm Î²) : Prop :=\n  âˆ€ A, (Î¾ A).Approximates (Ï€ A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructBehaviour.ApproximatesğŸ—ŸğŸ”—../.././ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.ApproximatesğŸ”—  Î¾ Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ (A : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  â†‘Î²), ğŸ—ŸConNF.NearLitterBehaviour.ApproximatesğŸ—ŸğŸ”—../.././ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.ApproximatesğŸ”—  (Î¾ A) (Ï€ A)\n\n", "used_premises": [1, 828, 55], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [182, 184], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `Î²`-structural action `Î¾` *approximates* a `Î²`-structural permutation `Ï€` if, for every `Î²`-extended index `A`, the `Î²`-extended near-litter action `Î¾ A` approximates the `Î²`-extended near-litter permutation `Ï€ A`. This approximation is defined by the `ConNF.NearLitterBehaviour.Approximates` relation between near-litter actions and permutations."}
{"full_name": "ConNF.NearLitterBehaviour.litterPresent_of_dom", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.litterPresent_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.litterPresent_of_dom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) {L : ConNF.Litter} (h : ((ConNF.NearLitterBehaviour.withLittersğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾).nearLitterMap (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L)).Dom) :ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L", "code": "theorem ConNF.NearLitterBehaviour.litterPresent_of_dom\n    {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    {L : Litter} (h : ((Î¾.withLitters hÎ¾).nearLitterMap L.toNearLitter).Dom) :\n    Î¾.LitterPresent L := by\n  obtain (hL | hL) := h\n  Â· exact âŸ¨L.toNearLitter, hL, rflâŸ©\n  Â· exact hL.2\n", "additional_info": "", "used_premises": [1, 823, 832, 483, 838], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [312, 319], "informalization": "The theorem `ConNF.NearLitterBehaviour.litterPresent_of_dom` states that if there exists a near-litter `N` such that the near-litter map `Î¾.nearLitterMap N` is defined and the first component of `N` is equal to the given litter `L`, then there exists a near-litter `N` such that the near-litter map `Î¾.nearLitterMap N` is defined and the first component of `N` is equal to the given litter `L`."}
{"full_name": "ConNF.NearLitterBehaviour.LitterPresent", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.LitterPresent", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.LitterPresent [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (L : ConNF.Litter) :Prop", "code": "def LitterPresent (Î¾ : NearLitterBehaviour) (L : Litter) : Prop :=\n  âˆƒ N : NearLitter, (Î¾.nearLitterMap N).Dom âˆ§ N.1 = L\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterBehaviour.LitterPresentğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.LitterPresentğŸ”—  Î¾ L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆƒ (N : ConNF.NearLitter), (Î¾.nearLitterMap N).Dom ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  N.fst ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  L\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [147, 149], "informalization": "Function `ConNF.NearLitterBehaviour.LitterPresent` checks if there exists a near litter `N` such that the near litter map `Î¾.nearLitterMap N` is defined and the first component of `N` is equal to the given litter `L`."}
{"full_name": "ConNF.StructBehaviour.action_coherentDom", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action_coherentDom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.action_coherentDom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (hâ‚‚ : ConNF.StructBehaviour.CoherentğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.StructAction.CoherentDomğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructBehaviour.actionğŸ”—<|PREMISE|>ğŸ”— Î¾ hâ‚)", "code": "theorem action_coherentDom (Î¾ : StructBehaviour Î²) (hâ‚ : Î¾.Lawful) (hâ‚‚ : Î¾.Coherent) :\n    (Î¾.action hâ‚).CoherentDom := by\n  constructor\n  case mapFlexible =>\n    intro A L hLâ‚ hLâ‚‚\n    obtain âŸ¨N, hN, rflâŸ© := (Î¾ A).litterPresent_of_dom (hâ‚ A) hLâ‚\n    have := (NearLitterBehaviour.map_nearLitter_fst (Î¾.withLitters_lawful hâ‚ A)\n      (Or.inl hN) (Or.inr âŸ¨âŸ¨_âŸ©, N, hN, rflâŸ©)).mp rfl\n    erw [â† this]\n    simp only [withLitters, NearLitterBehaviour.withLitters_nearLitterMap_of_dom _ hN]\n    exact hâ‚‚.mapFlexible A N hN hLâ‚‚\n  case atom_bot_dom =>\n    intro Î³ _ A Îµ _ hÎµ a ha\n    obtain âŸ¨Nt, hNtâ‚, hNtâ‚‚âŸ© := (Î¾ _).litterPresent_of_dom (hâ‚ _) ha\n    exact Or.inl (hâ‚‚.atom_bot_dom A hÎµ hNtâ‚‚ hNtâ‚)\n  case atom_dom =>\n    intro Î³ _ A Î´ _ Îµ _ hÎ´ hÎµ hÎ´Îµ t B a hc ht\n    obtain âŸ¨Nt, hNtâ‚, hNtâ‚‚âŸ© := (Î¾ _).litterPresent_of_dom (hâ‚ _) ht\n    exact Or.inl (hâ‚‚.atom_dom A hÎ´ hÎµ hÎ´Îµ hNtâ‚‚ hc hNtâ‚)\n  case nearLitter_dom =>\n    intro Î³ _ A Î´ _ Îµ _ hÎ´ hÎµ hÎ´Îµ t B a hc ht\n    obtain âŸ¨Nt, hNtâ‚, hNtâ‚‚âŸ© := (Î¾ _).litterPresent_of_dom (hâ‚ _) ht\n    exact Or.inr âŸ¨âŸ¨_âŸ©, _, hâ‚‚.nearLitter_dom A hÎ´ hÎµ hÎ´Îµ hNtâ‚‚ hc hNtâ‚, rflâŸ©\n  case symmDiff_dom =>\n    intro Î³ _ A Î´ _ Îµ _ hÎ´ hÎµ hÎ´Îµ t B N a hc ha ht\n    obtain âŸ¨Nt, hNtâ‚, hNtâ‚‚âŸ© := (Î¾ _).litterPresent_of_dom (hâ‚ _) ht\n    simp only [action_atomMap, NearLitterBehaviour.withLitters]\n    have := hâ‚‚.nearLitter_dom A hÎ´ hÎµ hÎ´Îµ hNtâ‚‚ hc hNtâ‚\n    exact NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff (hâ‚ _) this ha\n", "additional_info": "", "used_premises": [1, 828, 829, 840, 813, 830], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [342, 371], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `Î²`-structural action is a product that assigns a near-litter action to each `Î²`-extended index. For a `Î²`-structural action `Î¾` to be lawful, it must satisfy the condition that for every `Î²`-extended index `A`, the near-litter action assigned by `Î¾` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter. Additionally, a `Î²`-structural action is coherent if it satisfies certain conditions that ensure the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.StructBehaviour.action_coherentDom` states that if `Î¾` is a lawful and coherent `Î²`-structural action, then the `Î²`-structural action `ConNF.StructBehaviour.action Î¾ hâ‚` is also coherent."}
{"full_name": "ConNF.StructBehaviour.Coherent", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.Coherent", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructBehaviour.Coherent [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) extends ConNF.StructBehaviour.CoherentDomğŸ”—<|PREMISE|>ğŸ”— :Prop\n | mapFlexible : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) (N : ConNF.NearLitter) (hN : ((Î¾ A).nearLitterMap N).Dom),\n ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”—  A N.fst â†’ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”—  A (((Î¾ A).nearLitterMap N).get hN).fst\n | atom_bot_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Îµ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎµ : â†‘Îµ <  â†‘Î³)\n {a : ConNF.Atom} {Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ a â†’\n ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).Dom â†’ ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A â‹¯)).atomMap a).Dom\n | atom_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {a : ConNF.Atom} {Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t â†’\n { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).Dom â†’\n ((Î¾ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).Dom\n | nearLitter_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {N Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t â†’\n { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).Dom â†’\n ((Î¾ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).nearLitterMap N).Dom\n | coherent_coe : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´]\n {Îµ : ConNF.Î›} [inst_2 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {Nt : ConNF.NearLitter} (hNt : Nt.fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t)\n (h : ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).Dom) (Ï : ConNF.Allowable  â†‘Î³),\n (âˆ€ (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´) (a : ConNF.Atom)\n (ha : { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t),\n ((Î¾ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).get â‹¯ =  ConNF.Allowable.toStructPerm Ï (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  hÎ´) B) â€¢  a) â†’\n (âˆ€ (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´) (N : ConNF.NearLitter)\n (ha : { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t),\n ((Î¾ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).nearLitterMap N).get â‹¯ =  ConNF.Allowable.toStructPerm Ï (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  hÎ´) B) â€¢  N) â†’\n (((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).get h).fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ ((ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  hÎ´)) Ï â€¢  t)\n | coherent_bot : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Îµ : ConNF.Î›} [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ]\n (hÎµ : â†‘Îµ <  â†‘Î³) {a : ConNF.Atom} {Nt : ConNF.NearLitter} (hNt : Nt.fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ a)\n (h : ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).Dom) (Ï : ConNF.Allowable  â†‘Î³),\n ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A â‹¯)).atomMap a).get â‹¯ =  ConNF.Allowable.toStructPerm Ï (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  â‹¯) â€¢  a â†’\n (((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).get h).fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ ((ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”—  â‹¯)) Ï â€¢  a)", "code": "structure Coherent (Î¾ : StructBehaviour Î²) extends CoherentDom Î¾ : Prop where\n  coherent_coe : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    {Î´ : Î›} [LtLevel Î´] {Îµ : Î›} [LtLevel Îµ]\n    (hÎ´ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ) {t : Tangle Î´}\n    {Nt : NearLitter} (hNt : Nt.1 = fuzz hÎ´Îµ t)\n    (h : ((Î¾ ((A.cons hÎµ).cons (bot_lt_coe _))).nearLitterMap Nt).Dom)\n    (Ï : Allowable Î³),\n    (âˆ€ (B : ExtendedIndex Î´) (a : Atom) (ha : âŸ¨B, inl aâŸ© âˆˆ t.support),\n      ((Î¾ ((A.cons hÎ´).comp B)).atomMap a).get (atom_dom A hÎ´ hÎµ hÎ´Îµ hNt ha h) =\n      Allowable.toStructPerm Ï ((Hom.toPath hÎ´).comp B) â€¢ a) â†’\n    (âˆ€ (B : ExtendedIndex Î´) (N : NearLitter) (ha : âŸ¨B, inr NâŸ© âˆˆ t.support),\n      ((Î¾ ((A.cons hÎ´).comp B)).nearLitterMap N).get (nearLitter_dom A hÎ´ hÎµ hÎ´Îµ hNt ha h) =\n      Allowable.toStructPerm Ï ((Hom.toPath hÎ´).comp B) â€¢ N) â†’\n    (((Î¾ ((A.cons hÎµ).cons (bot_lt_coe _))).nearLitterMap Nt).get h).fst =\n      fuzz hÎ´Îµ (Allowable.comp (Hom.toPath hÎ´) Ï â€¢ t)\n  coherent_bot : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³) {Îµ : Î›} [LtLevel Îµ]\n    (hÎµ : (Îµ : TypeIndex) < Î³) {a : Atom} {Nt : NearLitter} (hNt : Nt.1 = fuzz bot_ne_coe a)\n    (h : ((Î¾ ((A.cons hÎµ).cons (bot_lt_coe _))).nearLitterMap Nt).Dom)\n    (Ï : Allowable Î³),\n    ((Î¾ (A.cons (bot_lt_coe _))).atomMap a).get (atom_bot_dom A hÎµ hNt h) =\n      Allowable.toStructPerm Ï (Hom.toPath (bot_lt_coe _)) â€¢ a â†’\n    (((Î¾ ((A.cons hÎµ).cons (bot_lt_coe _))).nearLitterMap Nt).get h).fst =\n      fuzz (bot_ne_coe (a := Îµ)) (Allowable.comp (Hom.toPath (bot_lt_coe _)) Ï â€¢ a)\n", "additional_info": "", "used_premises": [1, 828, 841, 61, 842, 842, 402, 76, 98, 78, 301, 301, 301, 402, 76, 98, 98, 61, 78, 67, 395, 301, 301, 135, 301, 402, 76, 98, 98, 61, 78, 65, 395, 301, 301, 135, 301, 402, 76, 98, 98, 78, 301, 301, 61, 67, 395, 135, 301, 135, 74, 61, 65, 395, 135, 301, 135, 74, 301, 301, 78, 815, 74, 402, 76, 98, 78, 301, 301, 301, 74, 301, 301, 78, 815, 74], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [208, 231], "informalization": "The `ConNF.StructBehaviour.Coherent` class in Lean 4 represents the condition that a `Î²`-structural action is *coherent* in the context of Constructive Ordinal Notation (ConNF). This condition ensures that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructBehaviour.CoherentDom", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.CoherentDom", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructBehaviour.CoherentDom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Prop\n | mapFlexible : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) (N : ConNF.NearLitter) (hN : ((Î¾ A).nearLitterMap N).Dom),\n ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”—  A N.fst â†’ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”—  A (((Î¾ A).nearLitterMap N).get hN).fst\n | atom_bot_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Îµ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎµ : â†‘Îµ <  â†‘Î³)\n {a : ConNF.Atom} {Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ a â†’\n ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).Dom â†’ ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A â‹¯)).atomMap a).Dom\n | atom_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {a : ConNF.Atom} {Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t â†’\n { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).Dom â†’\n ((Î¾ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).atomMap a).Dom\n | nearLitter_dom : âˆ€ {Î³ : ConNF.Î›} [inst : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘Î³) {Î´ : ConNF.Î›} [inst : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´] {Îµ : ConNF.Î›}\n [inst_1 : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘Îµ] (hÎ´ : â†‘Î´ <  â†‘Î³) (hÎµ : â†‘Îµ <  â†‘Î³) (hÎ´Îµ : â†‘Î´ â‰   â†‘Îµ) {t : ConNF.Tangle  â†‘Î´}\n {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î´} {N Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  hÎ´Îµ t â†’\n { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } âˆˆ  ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”—  t â†’\n ((Î¾ (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎµ) â‹¯)).nearLitterMap Nt).Dom â†’\n ((Î¾ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  A hÎ´) B)).nearLitterMap N).Dom", "code": "structure CoherentDom (Î¾ : StructBehaviour Î²) : Prop where\n  mapFlexible : âˆ€ (A : ExtendedIndex Î²) (N : NearLitter) (hN : ((Î¾ A).nearLitterMap N).Dom),\n    Flexible A N.1 â†’ Flexible A (((Î¾ A).nearLitterMap N).get hN).1\n  atom_bot_dom : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³) {Îµ : Î›} [LtLevel Îµ]\n    (hÎµ : (Îµ : TypeIndex) < Î³) {a : Atom} {Nt : NearLitter},\n    Nt.1 = fuzz (bot_ne_coe (a := Îµ)) a â†’\n    ((Î¾ ((A.cons hÎµ).cons (bot_lt_coe _))).nearLitterMap Nt).Dom â†’\n    ((Î¾ (A.cons (bot_lt_coe _))).atomMap a).Dom\n  atom_dom : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    {Î´ : Î›} [LtLevel Î´] {Îµ : Î›} [LtLevel Îµ]\n    (hÎ´ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ) {t : Tangle Î´}\n    {B : ExtendedIndex Î´} {a : Atom} {Nt : NearLitter},\n    Nt.1 = fuzz hÎ´Îµ t â†’ âŸ¨B, inl aâŸ© âˆˆ t.support â†’\n    ((Î¾ ((A.cons hÎµ).cons (bot_lt_coe _))).nearLitterMap Nt).Dom â†’\n    ((Î¾ ((A.cons hÎ´).comp B)).atomMap a).Dom\n  nearLitter_dom : âˆ€ {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    {Î´ : Î›} [LtLevel Î´] {Îµ : Î›} [LtLevel Îµ]\n    (hÎ´ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ) {t : Tangle Î´}\n    {B : ExtendedIndex Î´} {N Nt : NearLitter},\n    Nt.1 = fuzz hÎ´Îµ t â†’ âŸ¨B, inr NâŸ© âˆˆ t.support â†’\n    ((Î¾ ((A.cons hÎµ).cons (bot_lt_coe _))).nearLitterMap Nt).Dom â†’\n    ((Î¾ ((A.cons hÎ´).comp B)).nearLitterMap N).Dom\n", "additional_info": "", "used_premises": [1, 828, 61, 842, 842, 402, 76, 98, 78, 301, 301, 301, 402, 76, 98, 98, 61, 78, 67, 395, 301, 301, 135, 301, 402, 76, 98, 98, 61, 78, 65, 395, 301, 301, 135, 301], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [185, 207], "informalization": "The `ConNF.StructBehaviour.CoherentDom` class in Lean 4 represents the condition that a `Î²`-structural action is *coherent* in the context of Constructive Ordinal Notation (ConNF). This condition ensures that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.Flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.Flexible", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) (L : ConNF.Litter) :Prop", "code": "def Flexible (A : ExtendedIndex Î²) (L : Litter) : Prop :=\n  Â¬Inflexible A L\n", "additional_info": "A litter is *flexible* if it is not the image of any f-map.\nEquations\n* ğŸ—ŸConNF.FlexibleğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.FlexibleğŸ”—  A L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸÂ¬ğŸ—ŸğŸ”—../../.././Init/Prelude.html#NotğŸ”— ğŸ—ŸConNF.InflexibleğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleğŸ”—  A L\n\n", "used_premises": [1, 61], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [24, 26], "informalization": "Function `ConNF.Flexible` checks if a given litter `L` is *flexible* in the context of Constructive Ordinal Notation (ConNF). A litter is considered *flexible* if it is not the image of any f-map. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructBehaviour.action_coherent", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action_coherent", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.action_coherent [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (hâ‚‚ : ConNF.StructBehaviour.CoherentğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.StructAction.CoherentğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructBehaviour.actionğŸ”—<|PREMISE|>ğŸ”— Î¾ hâ‚)", "code": "theorem action_coherent (Î¾ : StructBehaviour Î²) (hâ‚ : Î¾.Lawful) (hâ‚‚ : Î¾.Coherent) :\n    (Î¾.action hâ‚).Coherent := by\n  constructor\n  case toCoherentDom => exact action_coherentDom Î¾ hâ‚ hâ‚‚\n  case coherent_coe =>\n    intro Î³ _ A Î´ _ Îµ _ hÎ´ hÎµ hÎ´Îµ t ht Ï hta htN hts\n    obtain âŸ¨Nt, hNtâ‚, hNtâ‚‚âŸ© := (Î¾ _).litterPresent_of_dom (hâ‚ _) ht\n    have := hâ‚‚.coherent_coe A hÎ´ hÎµ hÎ´Îµ hNtâ‚‚ hNtâ‚ Ï ?_ ?_\n    Â· simp only [â† this, action_litterMap, â† hNtâ‚‚,\n        NearLitterBehaviour.withLitters_nearLitterMap_fst _ hNtâ‚]\n      rfl\n    Â· intro B a ha\n      simp only [â† hta B a ha, action_atomMap, NearLitterBehaviour.withLitters]\n      rw [NearLitterBehaviour.extraAtomMap_eq_of_dom]\n    Â· intro B N hN\n      refine NearLitter.ext ?_\n      rw [NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul, â† htN B N hN,\n        â† symmDiff_right_inj, symmDiff_symmDiff_cancel_left]\n      have hN' := (action_coherentDom Î¾ hâ‚ hâ‚‚).nearLitter_dom A hÎ´ hÎµ hÎ´Îµ hN\n        (Or.inr âŸ¨âŸ¨_âŸ©, Nt, hNtâ‚, hNtâ‚‚âŸ©)\n      have hN'' := hâ‚‚.nearLitter_dom A hÎ´ hÎµ hÎ´Îµ hNtâ‚‚ hN hNtâ‚\n      refine Eq.trans ?_ ((NearLitterBehaviour.symmDiff\n          ((Î¾ _).withLitters_lawful (hâ‚ _)) (by exact rfl) hN' (Or.inl hN'')).trans ?_)\n      Â· simp only [action_litterMap, symmDiff_right_inj, SetLike.coe_set_eq]\n        rw [NearLitterBehaviour.withLitters_nearLitterMap_of_dom]\n      Â· ext a\n        constructor\n        Â· simp only [Litter.coe_toNearLitter, mem_iUnion, mem_singleton_iff, forall_exists_index]\n          rintro a ha rfl\n          refine âŸ¨a, ha, ?_âŸ©\n          dsimp only\n          rw [â† hts _ N a hN ha]\n          rfl\n        Â· simp only [Litter.coe_toNearLitter, mem_iUnion, mem_singleton_iff]\n          rintro âŸ¨a, ha, rflâŸ©\n          refine âŸ¨a, ha, ?_âŸ©\n          dsimp only\n          rw [â† hts _ N a hN ha]\n          rfl\n  case coherent_bot =>\n    intro Î³ _ A Îµ _ hÎ´ a ha Ï hÏa\n    obtain âŸ¨Nt, hNtâ‚, hNtâ‚‚âŸ© := (Î¾ _).litterPresent_of_dom (hâ‚ _) ha\n    have := hâ‚‚.coherent_bot A hÎ´ hNtâ‚‚ hNtâ‚ Ï ?_\n    Â· simp only [â† hNtâ‚‚, action_litterMap, â† this]\n      rw [NearLitterBehaviour.withLitters_nearLitterMap_fst]\n      rfl\n    Â· rw [â† hÏa]\n      simp only [action_atomMap, NearLitterBehaviour.withLitters]\n      rw [NearLitterBehaviour.extraAtomMap_eq_of_dom]\n", "additional_info": "", "used_premises": [1, 828, 829, 840, 812, 830], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [372, 421], "informalization": "The theorem `ConNF.StructBehaviour.action_coherent` states that if `Î¾` is a `Î²`-structural action that is lawful and coherent, then the `Î²`-structural action `ConNF.StructBehaviour.action Î¾ hâ‚` is also coherent."}
{"full_name": "ConNF.StructBehaviour.freedom_of_action", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.freedom_of_action", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.freedom_of_action [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (hâ‚‚ : ConNF.StructBehaviour.CoherentğŸ”—<|PREMISE|>ğŸ”— Î¾) :âˆƒ (Ï : ConNF.Allowable â†‘Î²), ConNF.StructBehaviour.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Î¾ (ConNF.Allowable.toStructPerm Ï)", "code": "theorem freedom_of_action (Î¾ : StructBehaviour Î²) (hâ‚ : Î¾.Lawful) (hâ‚‚ : Î¾.Coherent) :\n    âˆƒ Ï : Allowable Î², Î¾.Approximates (Allowable.toStructPerm Ï) := by\n  obtain âŸ¨Ï, hÏâŸ© := (Î¾.action hâ‚).freedom_of_action (Î¾.action_lawful hâ‚) (Î¾.action_coherent hâ‚ hâ‚‚)\n  exact âŸ¨Ï, Î¾.action_approximates hâ‚ _ hÏâŸ©\n", "additional_info": "", "used_premises": [1, 402, 828, 829, 840, 836], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [422, 426], "informalization": "This is the theorem that establishes the \"Freedom of Action\" in the context of Constructive Ordinal Notation (ConNF). It states that for any lawful $\\beta$-structural action $\\xi$, there exists a $\\beta$-allowable $\\beta$-structural permutation $\\rho$ such that $\\xi$ approximates $\\rho$. This theorem is crucial in ensuring the consistency and well-definedness of the construction of natural numbers in ConNF."}
{"full_name": "ConNF.Allowable.comp_nil", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_nil", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_nil [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] :ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— Quiver.Path.nil = MonoidHom.idğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable Î²)", "code": "theorem Allowable.comp_nil {Î² : TypeIndex} [LeLevel Î²] :\n    Allowable.comp (Quiver.Path.nil : Quiver.Path Î² Î²) = MonoidHom.id _ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 815, 846], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [142, 145], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF), and `Î²` is less than or equal to `Î³`. The function is defined recursively along a path `A` from `Î²` to `Î³`. When the path `A` is empty (i.e., `Quiver.Path.nil`), the function `ConNF.Allowable.comp` simplifies to the identity monoid homomorphism `MonoidHom.id`, which maps each element to itself."}
{"full_name": "MonoidHom.id", "url": "Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.id", "code_src": "mathlib4", "ptype": "def", "header": "def MonoidHom.id (M : Type u_10) [MulOneClassğŸ”—<|PREMISE|>ğŸ”— M] :M â†’* M", "code": "def MonoidHom.id (M : Type*) [MulOneClass M] : M â†’* M where\n  toFun x := x\n  map_one' := rfl\n  map_mul' _ _ := rfl\n", "additional_info": "The identity map from a monoid to itself.\nEquations\n* ğŸ—ŸMonoidHom.idğŸ—ŸğŸ”—../../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.idğŸ”—  M ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toOneHom := { toFun := fun (x : M) => x, map_one' := â‹¯ }, map_mul' := â‹¯ }\n\n", "used_premises": [847], "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "pos": [881, 885], "informalization": "Function `MonoidHom.id` is a monoid homomorphism from a monoid `M` to itself, which maps each element to itself."}
{"full_name": "MulOneClass", "url": "Mathlib/Algebra/Group/Defs.html#MulOneClass", "code_src": "mathlib4", "ptype": "class", "header": "class MulOneClass (M : Type u) extends OneğŸ”—<|PREMISE|>ğŸ”— , MulğŸ”—<|PREMISE|>ğŸ”— :Type u\n | one : M\n | mul : M â†’ M â†’ M\n | one_mul : âˆ€ (a : M), 1 *  a =  a\n | mul_one : âˆ€ (a : M), a *  1 =  a", "code": "class MulOneClass (M : Type u) extends One M, Mul M where\n  /-- One is a left neutral element for multiplication -/\n  protected one_mul : âˆ€ a : M, 1 * a = a\n  /-- One is a right neutral element for multiplication -/\n  protected mul_one : âˆ€ a : M, a * 1 = a\n", "additional_info": "Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`.\n- MulOneClass.one_mul: One is a left neutral element for multiplication\n\n\n- MulOneClass.mul_one: One is a right neutral element for multiplication\n\n\n", "used_premises": [45, 44], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [440, 445], "informalization": "Class `MulOneClass` represents the concept of a type `M` that has both a multiplicative identity element (denoted as `1`) and a multiplication operation. This algebraic structure ensures that for any element `a` in `M`, the identity element `1` acts as a neutral element for multiplication, meaning `1 * a = a` and `a * 1 = a`. This is formalized through the properties `one_mul` and `mul_one`, which respectively assert that `1` is a left and right neutral element for multiplication. In essence, `MulOneClass` defines a type where multiplication is unital, i.e., it has an identity element that does not change the value of any element when multiplied by it, either on the left or the right. This class is foundational for many algebraic structures that require a multiplicative identity, such as monoids, groups, and rings."}
{"full_name": "ConNF.Allowable.comp_eq", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î³] (h : Î³ < Î²) :ConNF.allowableCons h = ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— Quiver.Path.nil h)", "code": "theorem Allowable.comp_eq {Î² Î³ : TypeIndex} [LeLevel Î²] [LeLevel Î³] (h : Î³ < Î²) :\n    allowableCons h = Allowable.comp (Quiver.Path.nil.cons h) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 815, 301], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [147, 150], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF), and `Î²` is less than or equal to `Î³`. The function is defined recursively along a path `A` from `Î²` to `Î³`. The theorem `ConNF.Allowable.comp_eq` states that when `Î³ < Î²`, the function `ConNF.allowableCons` is equal to `ConNF.Allowable.comp` applied to the path consisting of a single arrow from `Î³` to `Î²`."}
{"full_name": "ConNF.Allowable.comp_cons", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_cons", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_cons [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {Î´ : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î´] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) (h : Î´ < Î³) :MonoidHom.compğŸ”—<|PREMISE|>ğŸ”— (ConNF.allowableCons h) (ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— A) = ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— A h)", "code": "theorem Allowable.comp_cons {Î² Î³ Î´ : TypeIndex} [LeLevel Î²] [LeLevel Î³] [LeLevel Î´]\n    (A : Quiver.Path Î² Î³) (h : Î´ < Î³) :\n    (allowableCons h).comp (Allowable.comp A) = Allowable.comp (A.cons h) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 402, 76, 850, 815, 815, 301], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [152, 156], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of ConNF, and `Î²` is less than or equal to `Î³`. This function is defined recursively along a path `A` from `Î²` to `Î³`. The theorem `ConNF.Allowable.comp_cons` states that the composition of the monoid homomorphism `ConNF.Allowable.comp` with the monoid homomorphism `ConNF.allowableCons` is equal to the monoid homomorphism `ConNF.Allowable.comp` applied to the path `A` extended by the arrow `h`."}
{"full_name": "MonoidHom.comp", "url": "Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp", "code_src": "mathlib4", "ptype": "def", "header": "def MonoidHom.comp {M : Type u_4} {N : Type u_5} {P : Type u_6} [MulOneClassğŸ”—<|PREMISE|>ğŸ”— M] [MulOneClassğŸ”—<|PREMISE|>ğŸ”— N] [MulOneClassğŸ”—<|PREMISE|>ğŸ”— P] (hnp : N â†’* P) (hmn : M â†’* N) :M â†’* P", "code": "def MonoidHom.comp [MulOneClass M] [MulOneClass N] [MulOneClass P] (hnp : N â†’* P) (hmn : M â†’* N) :\n    M â†’* P where\n  toFun := hnp âˆ˜ hmn\n  map_one' := by simp\n  map_mul' := by simp\n", "additional_info": "Composition of monoid morphisms as a monoid morphism.\nEquations\n* ğŸ—ŸMonoidHom.compğŸ—ŸğŸ”—../../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.compğŸ”—  hnp hmn ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toOneHom := { toFun := â‡‘hnp ğŸ—Ÿâˆ˜ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#Function.compğŸ”—  â‡‘hmn, map_one' := â‹¯ }, map_mul' := â‹¯ }\n\n", "used_premises": [847, 847, 847], "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "pos": [908, 913], "informalization": "Function `MonoidHom.comp` defines the composition of two monoid homomorphisms. Given two monoid homomorphisms `hnp : N â†’* P` and `hmn : M â†’* N`, the composition `hnp.comp hmn` is a monoid homomorphism from `M` to `P`."}
{"full_name": "ConNF.Allowable.comp_cons_apply", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_cons_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_cons_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {Î´ : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î³] [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î´] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) (h : Î´ < Î³) (Ï€ : ConNF.Allowable Î²) :(ConNF.allowableCons h) ((ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— A) Ï€) = (ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— A h)) Ï€", "code": "theorem Allowable.comp_cons_apply {Î² Î³ Î´ : TypeIndex} [LeLevel Î²] [LeLevel Î³] [LeLevel Î´]\n    (A : Quiver.Path Î² Î³) (h : Î´ < Î³) (Ï€ : Allowable Î²) :\n    allowableCons h (Allowable.comp A Ï€) = Allowable.comp (A.cons h) Ï€ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 402, 76, 815, 815, 301], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [158, 162], "informalization": "The function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF), and `Î²` is less than or equal to `Î³`. The function is defined recursively along a path `A` from `Î²` to `Î³`. The theorem `ConNF.Allowable.comp_cons_apply` states that for a path `A` from `Î²` to `Î³` and an arrow `h` from `Î³` to `Î´`, the composition of `ConNF.Allowable.comp A` with `ConNF.Allowable.cons h` is equal to `ConNF.Allowable.comp (Quiver.Path.cons A h)`."}
{"full_name": "ConNF.Allowable.comp_comp_apply", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_comp_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_comp_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {Î´ : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î³] [i : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î´] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) (B : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î³ Î´) (Ï€ : ConNF.Allowable Î²) :(ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— B) ((ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— A) Ï€) = (ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B)) Ï€", "code": "theorem Allowable.comp_comp_apply {Î² Î³ Î´ : TypeIndex} [LeLevel Î²] [LeLevel Î³] [i : LeLevel Î´]\n    (A : Quiver.Path Î² Î³) (B : Quiver.Path Î³ Î´) (Ï€ : Allowable Î²) :\n    Allowable.comp B (Allowable.comp A Ï€) = Allowable.comp (A.comp B) Ï€ := by\n  revert i\n  induction B with\n  | nil =>\n      intro\n      rfl\n  | cons B h ih =>\n      intro\n      have : LeLevel _ := âŸ¨(le_of_path B).trans LeLevel.elimâŸ©\n      simp_rw [Quiver.Path.comp_cons, â† comp_cons_apply (A.comp B) h, â† ih]\n      rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 402, 76, 76, 815, 815, 815, 135], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [164, 177], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF), and `Î²` is less than or equal to `Î³`. The function is defined recursively along a path `A` from `Î²` to `Î³`. The theorem `ConNF.Allowable.comp_comp_apply` states that the composition of two such homomorphisms, corresponding to paths `A` and `B` respectively, is equal to the homomorphism corresponding to the composition of the paths `A` and `B`."}
{"full_name": "ConNF.Allowable.toStructPerm_comp", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.toStructPerm_comp", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.toStructPerm_comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] [i : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) (Ï€ : ConNF.Allowable Î²) :ConNF.Allowable.toStructPerm ((ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— A) Ï€) = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.Allowable.toStructPerm Ï€)", "code": "theorem Allowable.toStructPerm_comp {Î² Î³ : TypeIndex} [LeLevel Î²] [i : LeLevel Î³]\n    (A : Quiver.Path Î² Î³) (Ï€ : Allowable Î²) :\n    Allowable.toStructPerm (Allowable.comp A Ï€) = Tree.comp A (Allowable.toStructPerm Ï€) := by\n  revert i\n  induction A with\n  | nil =>\n      intro i\n      rw [Tree.comp_nil, Allowable.comp_nil, MonoidHom.id_apply]\n  | cons A h ih =>\n      intro i\n      have : LeLevel _ := âŸ¨(le_of_path A).trans LeLevel.elimâŸ©\n      change toStructPerm (allowableCons _ (comp _ Ï€)) = _\n      rw [Tree.comp_cons, â† allowableCons_eq, ih]\n      rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 76, 815, 304], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [179, 193], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF), and `Î²` is less than or equal to `Î³`. The function is defined recursively along a path `A` from `Î²` to `Î³`. Given a path `A` from type index `Î²` to type index `Î³` and an `Î±`-tree `a` of type `Ï„`, it returns a `Î²`-tree of type `Ï„` by applying `a` to the composition of `A` with any `Î²`-extended type index `B`."}
{"full_name": "ConNF.Allowable.toStructPerm_apply", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.toStructPerm_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.toStructPerm_apply [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² âŠ¥ ) (Ï€ : ConNF.Allowable Î²) :NearLitterPerm.ofBot ((ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— A) Ï€) = ConNF.Allowable.toStructPerm Ï€ A", "code": "theorem Allowable.toStructPerm_apply {Î² : TypeIndex} [LeLevel Î²]\n    (A : Quiver.Path Î² âŠ¥) (Ï€ : Allowable Î²) :\n    NearLitterPerm.ofBot (Allowable.comp A Ï€) = Allowable.toStructPerm Ï€ A :=\n  congr_fun (Allowable.toStructPerm_comp A Ï€) Quiver.Path.nil\n", "additional_info": "", "used_premises": [1, 402, 76, 815], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [195, 199], "informalization": "The function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF), and `Î²` is less than or equal to `Î³`. The function is defined recursively along a path `A` from `Î²` to `Î³`. The theorem `ConNF.Allowable.toStructPerm_apply` states that the application of the function `ConNF.Allowable.comp` to an allowable permutation `Ï€` at level `Î²` and a path `A` from `Î²` to `Î³` is equal to the application of the function `ConNF.Allowable.toStructPerm` to `Ï€` and `A`."}
{"full_name": "ConNF.Allowable.comp_bot", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.comp_bot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² âŠ¥ ) (Ï : ConNF.Allowable Î²) :(ConNF.Allowable.compğŸ”—<|PREMISE|>ğŸ”— A) Ï = ConNF.Allowable.toStructPerm Ï A", "code": "theorem Allowable.comp_bot {Î² : TypeIndex} [LeLevel Î²] (A : Quiver.Path Î² âŠ¥) (Ï : Allowable Î²) :\n    Allowable.comp A Ï = Allowable.toStructPerm Ï A := by\n  refine NearLitterPerm.ext ?_\n  ext a : 1\n  change NearLitterPerm.ofBot (Allowable.comp A Ï) â€¢ a = Allowable.toStructPerm Ï A â€¢ a\n  simp only [Allowable.toStructPerm_apply]\n", "additional_info": "", "used_premises": [1, 402, 76, 815], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [200, 206], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `Î²` to the set of allowable permutations at level `Î³`, where `Î²` and `Î³` are type indices in the context of Constructive Ordinal Notation (ConNF), and `Î²` is less than or equal to `Î³`. The function is defined recursively along a path `A` from `Î²` to `Î³`. The theorem `ConNF.Allowable.comp_bot` states that for a path `A` from `Î²` to the bottom level `âŠ¥`, the function `ConNF.Allowable.comp A` applied to an allowable permutation `Ï` at level `Î²` is equal to the structure permutation of `Ï` along the path `A`."}
{"full_name": "ConNF.smul_mem_support", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.smul_mem_support", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.smul_mem_support [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {t : ConNF.Tangle â†‘Î²} (h : c âˆˆ ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”— t) (Ï€ : ConNF.Allowable â†‘Î²) :Ï€ â€¢ c âˆˆ ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”— (Ï€ â€¢ t)", "code": "theorem smul_mem_support {Î² : Î›} [LtLevel Î²] {c : Address Î²} {t : Tangle Î²}\n    (h : c âˆˆ t.support) (Ï€ : Allowable Î²) : Ï€ â€¢ c âˆˆ (Ï€ â€¢ t).support := by\n  rw [smul_support]\n  simp only [Support.mem_iff, Allowable.smul_support_f, smul_left_cancel_iff,\n    Allowable.smul_support_max] at h âŠ¢\n  exact h\n", "additional_info": "", "used_premises": [1, 98, 60, 395, 395], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [207, 213], "informalization": "The theorem `ConNF.smul_mem_support` is a result in the context of Constructive Ordinal Notation (ConNF), which represents a specific type of ordinal notation. It states that if an element `c` is in the support of a tangle `t`, then applying a permutation `Ï€` to both `c` and `t` results in the permuted element being in the support of the permuted tangle. This theorem is crucial for ensuring that the set of addresses being enumerated by each tangle is closed under permutations, which is a key property for proving the correctness of the ConNF system."}
{"full_name": "ConNF.NearLitterPerm.ofBot_comp'", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.NearLitterPerm.ofBot_comp'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.ofBot_comp' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— Î²] {hÎ² : âŠ¥ < Î²} {Ï : ConNF.Allowable Î²} :NearLitterPerm.ofBot ((ConNF.allowableCons hÎ²) Ï) = ConNF.Allowable.toStructPerm Ï (Quiver.Hom.toPathğŸ”—<|PREMISE|>ğŸ”— hÎ²)", "code": "theorem NearLitterPerm.ofBot_comp' {Î² : TypeIndex} [LeLevel Î²] {hÎ² : âŠ¥ < Î²} {Ï : Allowable Î²} :\n    NearLitterPerm.ofBot (allowableCons hÎ² Ï) = Allowable.toStructPerm Ï (Quiver.Hom.toPath hÎ²) :=\n  (congr_fun (allowableCons_eq Î² âŠ¥ hÎ² Ï) Quiver.Path.nil).symm\n", "additional_info": "", "used_premises": [1, 402, 74], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [215, 218], "informalization": "Function `ConNF.NearLitterPerm.ofBot_comp'` simplifies the composition of `ConNF.NearLitterPerm.ofBot` with `ConNF.Allowable.toStructPerm` and `Quiver.Hom.toPath` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.exists_cons_of_length_ne_zero", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.exists_cons_of_length_ne_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.exists_cons_of_length_ne_zero {V : Type u_1} [QuiverğŸ”—<|PREMISE|>ğŸ”— V] {x : V} {y : V} (p : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— x y) (h : Quiver.Path.lengthğŸ”—<|PREMISE|>ğŸ”— p â‰  0) :âˆƒ (t : V) (q : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— x t) (e : t âŸ¶ y), p = Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— q e", "code": "theorem exists_cons_of_length_ne_zero {V : Type _} [Quiver V] {x y : V}\n    (p : Quiver.Path x y) (h : p.length â‰  0) :\n    âˆƒ t : V, âˆƒ q : Quiver.Path x t, âˆƒ e : t âŸ¶ y, p = q.cons e := by\n  cases p\n  Â· cases h rfl\n  Â· exact âŸ¨_, _, _, rflâŸ©\n", "additional_info": "", "used_premises": [75, 76, 137, 76, 301], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [219, 225], "informalization": "Given a path `p` from `x` to `y` in a quiver `V`, if the length of `p` is not zero, then there exists a vertex `t`, a path `q` from `x` to `t`, and an arrow `e` from `t` to `y` such that `p` is the concatenation of `q` and `e`."}
{"full_name": "ConNF.ofBot_smul", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.ofBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.ofBot_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {X : Type u_1} [MulActionğŸ”—<|PREMISE|>ğŸ”— ConNF.NearLitterPerm X] (Ï€ : ConNF.Allowable âŠ¥ ) (x : X) :Ï€ â€¢ x = NearLitterPerm.ofBot Ï€ â€¢ x", "code": "theorem ofBot_smul {X : Type _} [MulAction NearLitterPerm X] (Ï€ : Allowable âŠ¥) (x : X) :\n    Ï€ â€¢ x = NearLitterPerm.ofBot Ï€ â€¢ x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 56], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [227, 230], "informalization": "The theorem `ConNF.ofBot_smul` states that in the context of Constructive Ordinal Notation (ConNF), the action of a `ConNF.Allowable` element `Ï€` on an element `x` of a type `X` that is a `MulAction` of `ConNF.NearLitterPerm` is equivalent to the action of `NearLitterPerm.ofBot Ï€` on `x`."}
{"full_name": "ConNF.Sublitter.mk_S_eq_Îº", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mk_S_eq_Îº", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.mk_S_eq_Îº [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (S : ConNF.Sublitter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘S.carrier = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem mk_S_eq_Îº (S : Sublitter) : #S.carrier = #Îº := by\n  have := mk_le_mk_of_subset S.subset\n  rw [mk_litterSet] at this\n  obtain (h | h) := lt_or_eq_of_le this\n  Â· have := mk_diff_add_mk S.subset\n    rw [mk_litterSet] at this\n    cases (add_lt_of_lt Params.Îº_isRegular.aleph0_le S.diff_small h).ne this\n  Â· exact h\n", "additional_info": "Use sublitter.mk_eq_Îº instead if possible.", "used_premises": [1, 29, 29], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [24, 32], "informalization": "The theorem `ConNF.Sublitter.mk_S_eq_Îº` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set `S.carrier` is equal to the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.Sublitter.mk_eq_Îº", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mk_eq_Îº", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.mk_eq_Îº [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (S : ConNF.Sublitter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†¥S = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem mk_eq_Îº (S : Sublitter) : #S = #Îº :=\n  S.mk_S_eq_Îº\n", "additional_info": "", "used_premises": [1, 29, 29], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [46, 48], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a sublitter `S`, the cardinality of `S` is equal to the cardinality of `Îº`."}
{"full_name": "ConNF.Sublitter.mk_eq_Îº'", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mk_eq_Îº'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.mk_eq_Îº' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (S : ConNF.Sublitter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘â†‘S = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem mk_eq_Îº' (S : Sublitter) : #(S : Set Atom) = #Îº :=\n  S.mk_S_eq_Îº\n", "additional_info": "", "used_premises": [1, 29, 29], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [50, 52], "informalization": "The theorem `ConNF.Sublitter.mk_eq_Îº'` states that the cardinality of any sublitter `S` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.Sublitter.carrier_eq_coe", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.carrier_eq_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.carrier_eq_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {S : ConNF.Sublitter} :S.carrier = â†‘S", "code": "theorem carrier_eq_coe {S : Sublitter} : S.carrier = S :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [54, 56], "informalization": "The `ConNF.Params` class in Lean 4 defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Î›`, `Îº`, and `Î¼`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities. The theorem `ConNF.Sublitter.carrier_eq_coe` states that the carrier of a sublitter `S` is equal to the coercion of `S`."}
{"full_name": "ConNF.Sublitter.ext", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.ext [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Sâ‚ : ConNF.Sublitter} {Sâ‚‚ : ConNF.Sublitter} (h : â†‘Sâ‚ = â†‘Sâ‚‚) :Sâ‚ = Sâ‚‚", "code": "theorem ext (h : (Sâ‚ : Set Atom) = Sâ‚‚) : Sâ‚ = Sâ‚‚ :=\n  SetLike.coe_injective h\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [63, 65], "informalization": "Function `ConNF.Sublitter.ext` is an extensionality theorem for the `ConNF.Sublitter` structure in Lean 4. It states that two `ConNF.Sublitter` objects are equal if their underlying sets are equal."}
{"full_name": "ConNF.Sublitter.fst_eq_of_mem", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.fst_eq_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.fst_eq_of_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {S : ConNF.Sublitter} {a : ConNF.Atom} (h : a âˆˆ S) :a.1 = S.litter", "code": "theorem fst_eq_of_mem {a : Atom} (h : a âˆˆ S) : a.1 = S.litter :=\n  S.subset h\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [66, 68], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a sublitter `S` and an atom `a` that belongs to `S`, the first component of `a` is equal to the litter of `S`."}
{"full_name": "ConNF.Sublitter.mem_litterSet_of_mem", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mem_litterSet_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.mem_litterSet_of_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {S : ConNF.Sublitter} {a : ConNF.Atom} (h : a âˆˆ S) :a âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— S.litter", "code": "theorem mem_litterSet_of_mem {a : Atom} (h : a âˆˆ S) : a âˆˆ litterSet S.litter :=\n  S.subset h\n", "additional_info": "", "used_premises": [1, 467], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [69, 71], "informalization": "The theorem `ConNF.Sublitter.mem_litterSet_of_mem` states that if an atom `a` belongs to a sublitter `S`, then `a` also belongs to the litter set of `S`."}
{"full_name": "ConNF.Sublitter.litter_diff_eq", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.litter_diff_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.litter_diff_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (S : ConNF.Sublitter) :â†‘S \\ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— S.litter = âˆ…", "code": "theorem litter_diff_eq (S : Sublitter) : (S : Set Atom) \\ litterSet S.litter = âˆ… :=\n  Set.eq_empty_of_forall_not_mem fun _ ha => ha.2 (S.subset ha.1)\n", "additional_info": "", "used_premises": [1, 467], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [78, 80], "informalization": "The theorem `ConNF.Sublitter.litter_diff_eq` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the set difference between `S` and the litter set corresponding to `S`'s litter is the empty set."}
{"full_name": "ConNF.Sublitter.isNearLitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.isNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.isNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (S : ConNF.Sublitter) :ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— S.litter â†‘S", "code": "theorem isNearLitter (S : Sublitter) : IsNearLitter S.litter S := by\n  refine Small.union S.diff_small ?_\n  rw [litter_diff_eq]\n  exact small_empty\n", "additional_info": "", "used_premises": [1, 466], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [81, 85], "informalization": "The theorem `ConNF.Sublitter.isNearLitter` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the set `S` is near the litter `S.litter`. This means that the set `S` has a small symmetric difference with the litter set of `S.litter`."}
{"full_name": "ConNF.Sublitter.toNearLitter_litter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.toNearLitter_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.toNearLitter_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (S : ConNF.Sublitter) :(ConNF.Sublitter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— S).fst = S.litter", "code": "theorem toNearLitter_litter (S : Sublitter) : S.toNearLitter.1 = S.litter :=\n  rfl\n", "additional_info": "", "used_premises": [1, 870], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [90, 92], "informalization": "The function `ConNF.Sublitter.toNearLitter` converts a `ConNF.Sublitter` to a `ConNF.NearLitter`. A `ConNF.Sublitter` represents a subset of a `ConNF.Litter`, and a `ConNF.NearLitter` is a pair consisting of a `ConNF.Litter` and a `ConNF.Sublitter` such that the `ConNF.Sublitter` is near the `ConNF.Litter`. The theorem `ConNF.Sublitter.toNearLitter_litter` states that the `ConNF.Litter` component of the resulting `ConNF.NearLitter` is equal to the `ConNF.Litter` component of the original `ConNF.Sublitter`."}
{"full_name": "ConNF.Sublitter.toNearLitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.toNearLitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Sublitter.toNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (S : ConNF.Sublitter) :ConNF.NearLitter", "code": "def toNearLitter (S : Sublitter) : NearLitter :=\n  âŸ¨S.litter, S, S.isNearLitterâŸ©\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Sublitter.toNearLitterğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.toNearLitterğŸ”—  S ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { fst := S.litter, snd := { val := â†‘S, property := â‹¯ } }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [86, 88], "informalization": "Function `ConNF.Sublitter.toNearLitter` converts a `ConNF.Sublitter` to a `ConNF.NearLitter`. A `ConNF.Sublitter` represents a subset of a `ConNF.Litter`, and a `ConNF.NearLitter` is a pair consisting of a `ConNF.Litter` and a `ConNF.Sublitter` such that the `ConNF.Sublitter` is near the `ConNF.Litter`."}
{"full_name": "ConNF.Sublitter.mem_toNearLitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mem_toNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.mem_toNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {S : ConNF.Sublitter} (a : ConNF.Atom) :a âˆˆ ConNF.Sublitter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— S â†” a âˆˆ S", "code": "theorem mem_toNearLitter (a : Atom) : a âˆˆ S.toNearLitter â†” a âˆˆ S :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 870], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [98, 100], "informalization": "Function `ConNF.Sublitter.toNearLitter` converts a `ConNF.Sublitter` to a `ConNF.NearLitter`. A `ConNF.Sublitter` represents a subset of a `ConNF.Litter`, and a `ConNF.NearLitter` is a pair consisting of a `ConNF.Litter` and a `ConNF.Sublitter` such that the `ConNF.Sublitter` is near the `ConNF.Litter`. The theorem `ConNF.Sublitter.mem_toNearLitter` states that for any `ConNF.Atom` `a`, `a` is an element of `ConNF.Sublitter.toNearLitter S` if and only if `a` is an element of `S`."}
{"full_name": "ConNF.Litter.litter_toSublitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Litter.litter_toSublitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Litter.litter_toSublitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :(ConNF.Litter.toSublitterğŸ”—<|PREMISE|>ğŸ”— L).litter = L", "code": "theorem Litter.litter_toSublitter (L : Litter) : L.toSublitter.litter = L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 873], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [123, 125], "informalization": "Function `ConNF.Litter.toSublitter` converts a `ConNF.Litter` object `L` into a `ConNF.Sublitter` object, which represents a subset of a `ConNF.Litter`. The resulting `ConNF.Sublitter` has `L` as its `litter` field."}
{"full_name": "ConNF.Litter.toSublitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Litter.toSublitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Litter.toSublitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :ConNF.Sublitter", "code": "def Litter.toSublitter (L : Litter) : Sublitter :=\n  âŸ¨L, litterSet L, subset_rfl, by\n    rw [sdiff_self]\n    exact small_emptyâŸ©\n", "additional_info": "Equations\n* ğŸ—ŸConNF.Litter.toSublitterğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Litter.toSublitterğŸ”—  L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { litter := L, carrier := ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  L, subset := â‹¯, diff_small := â‹¯ }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [117, 121], "informalization": "Function `ConNF.Litter.toSublitter` converts a `ConNF.Litter` object `L` into a `ConNF.Sublitter` object, which represents a subset of a `ConNF.Litter`. The resulting `ConNF.Sublitter` has `L` as its `litter` field, `ConNF.litterSet L` as its `carrier` field, and proofs that the `carrier` is a subset of the `litter` and that the difference between the `litter` and the `carrier` is a small set."}
{"full_name": "ConNF.Litter.coe_toSublitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Litter.coe_toSublitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Litter.coe_toSublitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (L : ConNF.Litter) :â†‘(ConNF.Litter.toSublitterğŸ”—<|PREMISE|>ğŸ”— L) = ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L", "code": "theorem Litter.coe_toSublitter (L : Litter) : (L.toSublitter : Set Atom) = litterSet L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 873, 467], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [127, 129], "informalization": "Function `ConNF.Litter.coe_toSublitter` converts a `ConNF.Litter` object `L` into a `ConNF.Sublitter` object, which represents a subset of a `ConNF.Litter`. The resulting `ConNF.Sublitter` has `L` as its `litter` field, `ConNF.litterSet L` as its `carrier` field, and proofs that the `carrier` is a subset of the `litter` and that the difference between the `litter` and the `carrier` is a small set. The function `ConNF.litterSet` defines a set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set contains all atoms `a` such that the first projection of `a` is equal to `L`."}
{"full_name": "ConNF.Sublitter.equiv_apply_mem", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equiv_apply_mem", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.equiv_apply_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} (a : â†¥S) :â†‘((ConNF.Sublitter.equivğŸ”—<|PREMISE|>ğŸ”— S T) a) âˆˆ T", "code": "theorem equiv_apply_mem {S T : Sublitter} (a : S) : (S.equiv T a : Atom) âˆˆ T :=\n  (S.equiv T a).prop\n", "additional_info": "", "used_premises": [1, 876], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [140, 142], "informalization": "Function `ConNF.Sublitter.equiv` establishes an equivalence between any two sublitters in the context of Constructive Ordinal Notation. The theorem `ConNF.Sublitter.equiv_apply_mem` states that if `a` is an element of sublitter `S`, then the image of `a` under the equivalence `ConNF.Sublitter.equiv S T` is indeed an element of sublitter `T`."}
{"full_name": "ConNF.Sublitter.equiv", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equiv", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.Sublitter.equiv [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (S : ConNF.Sublitter) (T : ConNF.Sublitter) :â†¥S â‰ƒ â†¥T", "code": "noncomputable def equiv (S T : Sublitter) : S â‰ƒ T :=\n  S.equivÎº.trans T.equivÎº.symm\n", "additional_info": "There is an equivalence between any two sublitters.\nEquations\n* ğŸ—ŸConNF.Sublitter.equivğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equivğŸ”—  S T ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸConNF.Sublitter.equivÎºğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equivÎºğŸ”—  S).trans (ğŸ—ŸConNF.Sublitter.equivÎºğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equivÎºğŸ”—  T).symm\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [136, 138], "informalization": "Function `ConNF.Sublitter.equiv` establishes an equivalence between any two sublitters in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.Sublitter.equiv_symm_apply_mem", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equiv_symm_apply_mem", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.equiv_symm_apply_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} (a : â†¥T) :â†‘((ConNF.Sublitter.equivğŸ”—<|PREMISE|>ğŸ”— S T).symm a) âˆˆ S", "code": "theorem equiv_symm_apply_mem {S T : Sublitter} (a : T) : ((S.equiv T).symm a : Atom) âˆˆ S :=\n  ((S.equiv T).symm a).prop\n", "additional_info": "", "used_premises": [1, 876], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [144, 146], "informalization": "The theorem `ConNF.Sublitter.equiv_symm_apply_mem` states that for any two sublitters `S` and `T` in the context of Constructive Ordinal Notation, the inverse of the equivalence `ConNF.Sublitter.equiv S T` maps any element of `T` to an element of `S`."}
{"full_name": "ConNF.flexible_cases", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_cases", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.flexible_cases [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) (L : ConNF.Litter) :ConNF.InflexibleğŸ”—<|PREMISE|>ğŸ”— A L âˆ¨ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem flexible_cases (A : ExtendedIndex Î²) (L : Litter) : Inflexible A L âˆ¨ Flexible A L :=\n  or_not\n", "additional_info": "", "used_premises": [1, 61, 879, 842], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [27, 29], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a finite path `A` from a type `Î²` to the base type `âŠ¥`, and a litter `L`, the theorem `ConNF.flexible_cases` states that `L` is either inflexible (the image of an f-map) or flexible (not the image of any f-map)."}
{"full_name": "ConNF.Inflexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.Inflexible", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Inflexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} :ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î² â†’ ConNF.Litter â†’ Prop", "code": "inductive Inflexible : ExtendedIndex Î² â†’ Litter â†’ Prop\n  | mk_coe â¦ƒÎ³ : Î›â¦„ [LeLevel Î³] â¦ƒÎ´ : Î›â¦„ [LtLevel Î´] â¦ƒÎµ : Î›â¦„ [LtLevel Îµ]\n    (hÎ´ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ)\n    (A : Quiver.Path (Î² : TypeIndex) Î³) (t : Tangle Î´) :\n    Inflexible ((A.cons hÎµ).cons (bot_lt_coe _)) (fuzz hÎ´Îµ t)\n  | mk_bot â¦ƒÎ³ : Î›â¦„ [LeLevel Î³] â¦ƒÎµ : Î›â¦„ [LtLevel Îµ] (hÎµ : (Îµ : TypeIndex) < Î³)\n    (A : Quiver.Path (Î² : TypeIndex) Î³) (a : Atom) :\n    Inflexible ((A.cons hÎµ).cons (bot_lt_coe _)) (fuzz (bot_ne_coe (a := Îµ)) a)\n", "additional_info": "A litter is *inflexible* if it is the image of some f-map.\n", "used_premises": [1, 61], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [14, 22], "informalization": "The `Inflexible` inductive type in the context of Constructive Ordinal Notation (ConNF) represents a property of litters that are derived from the f-maps. These litters are considered inflexible because they are images of f-maps, which are used to define the structure of the ConNF natural numbers and other related ordinals."}
{"full_name": "ConNF.not_constrains_flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.not_constrains_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.not_constrains_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (hL : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) :Â¬ c â‰º { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) }", "code": "theorem not_constrains_flexible {Î² : Î›} (c : Address Î²)\n    {A : ExtendedIndex Î²} {L : Litter} (hL : Flexible A L) :\n    Â¬c â‰º âŸ¨A, inr L.toNearLitterâŸ© := by\n  rintro (âŸ¨A, aâŸ© | âŸ¨A, N, hNâŸ© | âŸ¨A, N, a, haâŸ© | âŸ¨hÎ´, hÎµ, hÎ´Îµ, A, t, c, hcâŸ© | âŸ¨hÎµ, A, aâŸ©)\n  Â· exact hN (NearLitter.IsLitter.mk _)\n  Â· obtain (ha | ha) := ha\n    Â· cases ha.2 ha.1\n    Â· cases ha.2 ha.1\n  Â· exact hL (Inflexible.mk_coe hÎ´ hÎµ hÎ´Îµ _ _)\n  Â· exact hL (Inflexible.mk_bot hÎµ _ _)\n", "additional_info": "", "used_premises": [1, 60, 61, 842, 65, 483], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [30, 40], "informalization": "In Constructive Ordinal Notation (ConNF), `ConNF.not_constrains_flexible` is a theorem that states that a ConNF address `c` does not constrain a flexible litter `L` to be in its near-litter. This theorem is crucial for ensuring the consistency of the ConNF construction of natural numbers, where flexibility ensures that no two elements of a given litter are considered equal."}
{"full_name": "ConNF.not_transConstrains_flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.not_transConstrains_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.not_transConstrains_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (hL : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) :Â¬ c < { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) }", "code": "theorem not_transConstrains_flexible {Î² : Î›} (c : Address Î²)\n    {A : ExtendedIndex Î²} {L : Litter} (hL : Flexible A L) :\n    Â¬c < âŸ¨A, inr L.toNearLitterâŸ© := by\n  intro h\n  obtain âŸ¨d, _, hdâŸ© := Relation.TransGen.tail'_iff.mp h\n  exact not_constrains_flexible d hL hd\n", "additional_info": "", "used_premises": [1, 60, 61, 842, 65, 483], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [41, 47], "informalization": "The theorem `ConNF.not_transConstrains_flexible` states that in the context of Constructive Ordinal Notation (ConNF), for a given address `c` and an extended index `A`, if `L` is a *flexible* litter, then `c` does not transitively constrain the near-litter formed by wrapping `L` with its litter set. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.mk_flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.mk_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L} = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_flexible (A : ExtendedIndex Î²) : #{L | Flexible A L} = #Î¼ := by\n  refine le_antisymm ((Cardinal.mk_subtype_le _).trans mk_litter.le) ?_\n  refine âŸ¨âŸ¨fun Î½ => âŸ¨âŸ¨Î½, âŠ¥, Î±, bot_ne_coeâŸ©, ?_âŸ©, ?_âŸ©âŸ©\n  Â· intro h\n    rw [inflexible_iff] at h\n    obtain âŸ¨Î³, _, Î´, _, Îµ, _, _, hÎµ, hÎ´Îµ, A, t, rfl, hâŸ© | âŸ¨Î³, _, Îµ, _, hÎµ, A, t, rfl, hâŸ© := h\n    all_goals\n      apply_fun Litter.Î³ at h\n      rw [fuzz_Î³ _ _] at h\n      exact ne_of_lt (coe_lt_coe.mp LtLevel.elim) h.symm\n  Â· intro Î½â‚ Î½â‚‚ h\n    simp only [coe_setOf, mem_setOf_eq, Subtype.mk.injEq, Litter.mk.injEq, and_self, and_true] at h\n    exact h\n", "additional_info": "", "used_premises": [1, 61, 29, 842, 29], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [48, 61], "informalization": "The theorem `ConNF.mk_flexible` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set of all *flexible* litters (litters that are not the image of any f-map) is equal to the cardinality of the base type `Î¼`. This result is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.Inflexible.comp", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.Inflexible.comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Inflexible.comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î³} (h : ConNF.InflexibleğŸ”—<|PREMISE|>ğŸ”— A L) (B : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) :ConNF.InflexibleğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— B A) L", "code": "theorem Inflexible.comp {Î³ : TypeIndex} {L : Litter} {A : ExtendedIndex Î³} (h : Inflexible A L)\n    (B : Quiver.Path Î² Î³) : Inflexible (B.comp A) L := by\n  induction h with\n  | mk_coe => exact Inflexible.mk_coe â€¹_â€º â€¹_â€º â€¹_â€º _ _\n  | mk_bot => exact Inflexible.mk_bot â€¹_â€º _ _\n", "additional_info": "", "used_premises": [1, 61, 879, 76, 879, 135], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [62, 67], "informalization": "The `ConNF.Inflexible.comp` theorem in the context of Constructive Ordinal Notation (ConNF) states that if a litter `L` is inflexible with respect to an extended index `A`, and `B` is a path from a type `Î²` to a type `Î³`, then `L` is also inflexible with respect to the composition of `B` and `A`."}
{"full_name": "ConNF.not_flexible_iff", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.not_flexible_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.not_flexible_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²} :Â¬ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L â†” ConNF.InflexibleğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem not_flexible_iff {L : Litter} {A : ExtendedIndex Î²} : Â¬Flexible A L â†” Inflexible A L :=\n  Classical.not_not\n", "additional_info": "", "used_premises": [1, 61, 842, 879], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [69, 71], "informalization": "The theorem `ConNF.not_flexible_iff` states that in the context of Constructive Ordinal Notation (ConNF), a litter `L` is not *flexible* (i.e., not the image of any f-map) if and only if it is *inflexible* (i.e., an image of an f-map)."}
{"full_name": "ConNF.flexible_of_comp_flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_of_comp_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.flexible_of_comp_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î³} {B : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³} (h : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— B A) L) :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem flexible_of_comp_flexible {Î³ : TypeIndex} {L : Litter} {A : ExtendedIndex Î³}\n    {B : Quiver.Path Î² Î³} (h : Flexible (B.comp A) L) : Flexible A L := fun h' => h (h'.comp B)\n", "additional_info": "", "used_premises": [1, 61, 76, 842, 135, 842], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [72, 74], "informalization": "To prove that if a litter `L` is *flexible* with respect to a composition of paths `B.comp A`, then `L` is also *flexible* with respect to `A`, we can use the `ConNF.flexible_of_comp_flexible` theorem in the context of Constructive Ordinal Notation (ConNF). This theorem is a key result in the ConNF project that ensures the well-definedness and consistency of the construction of the natural numbers, crucial for establishing the power of ConNF as a system of ordinal notation."}
{"full_name": "ConNF.inflexibleBot_inflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleBot_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexibleBot_inflexibleCoe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} :ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L â†’ ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L â†’ FalseğŸ”—<|PREMISE|>ğŸ”—", "code": "theorem inflexibleBot_inflexibleCoe {Î² : Î›} {A : ExtendedIndex Î²} {L : Litter} :\n    InflexibleBot A L â†’ InflexibleCoe A L â†’ False := by\n  rintro âŸ¨âŸ¨Î³â‚, Îµâ‚, hÎµâ‚, Bâ‚, rflâŸ©, aâ‚, rflâŸ© âŸ¨âŸ¨_, Î´â‚‚, Îµâ‚‚, _, _, hÎ´Îµâ‚‚, _, _âŸ©, tâ‚‚, hLâ‚‚âŸ©\n  cases fuzz_congr_Î² hLâ‚‚\n", "additional_info": "", "used_premises": [1, 61, 887, 889, 891], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [133, 137], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleBot_inflexibleCoe` states that if `L` is `A`-inflexible when `Î´ = âŠ¥` (denoted as `ConNF.InflexibleBot A L`), and `L` is also `A`-inflexible when `Îµ â‰  âŠ¥` (denoted as `ConNF.InflexibleCoe A L`), then there is a contradiction, represented by the type `False`. This theorem is used to handle the case where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.InflexibleBot", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleBot", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.InflexibleBot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) :Type u\n | path : ConNF.InflexibleBotPathğŸ”—<|PREMISE|>ğŸ”—  A\n | a : ConNF.Atom\n | hL : L =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ self.a", "code": "structure InflexibleBot {Î² : Î›} (A : ExtendedIndex Î²) (L : Litter) where\n  path : InflexibleBotPath A\n  a : Atom\n  hL : L = fuzz (bot_ne_coe (a := path.Îµ)) a\n", "additional_info": "A proof-relevant statement that `L` is `A`-inflexible, where `ğŸ—ŸÎ´ğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoePath.Î´ğŸ”—  = âŠ¥`.\n", "used_premises": [1, 61, 888, 78], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [108, 112], "informalization": "The structure `ConNF.InflexibleBot` represents a proof-relevant statement that `L` is `A`-inflexible, where `Î´ = âŠ¥`."}
{"full_name": "ConNF.InflexibleBotPath", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleBotPath", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.InflexibleBotPath [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.Î›} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Type u\n | Î³ : ConNF.Î›\n | Îµ : ConNF.Î›\n | inst_Î³ : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘self.Î³\n | inst_Îµ : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘self.Îµ\n | hÎµ : â†‘self.Îµ <  â†‘self.Î³\n | B : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘self.Î³\n | hA : A =  Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  self.B â‹¯) â‹¯", "code": "structure InflexibleBotPath {Î² : Î›} (A : ExtendedIndex Î²) where\n  (Î³ Îµ : Î›)\n  [inst_Î³ : LeLevel Î³]\n  [inst_Îµ : LtLevel Îµ]\n  hÎµ : (Îµ : TypeIndex) < Î³\n  B : Quiver.Path (Î² : TypeIndex) Î³\n  hA : A = (B.cons hÎµ).cons (bot_lt_coe _)\n", "additional_info": "", "used_premises": [1, 61, 402, 98, 76, 301, 301], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [96, 103], "informalization": "The `ConNF.InflexibleBotPath` structure in Lean 4 represents a finite path from a type index `Î²` to the base type `âŠ¥` in the context of Constructive Ordinal Notation (ConNF). This path is constructed by iteratively descending to lower types in the hierarchy until reaching the base type. Since `Î›` is well-ordered, there are no infinite descending paths."}
{"full_name": "ConNF.InflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoe", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.InflexibleCoe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) :Type u\n | path : ConNF.InflexibleCoePathğŸ”—<|PREMISE|>ğŸ”—  A\n | t : ConNF.Tangle  â†‘self.path.Î´\n | hL : L =  ConNF.fuzzğŸ”—<|PREMISE|>ğŸ”—  â‹¯ self.t", "code": "structure InflexibleCoe {Î² : Î›} (A : ExtendedIndex Î²) (L : Litter) where\n  path : InflexibleCoePath A\n  t : Tangle path.Î´\n  hL : L = fuzz path.hÎ´Îµ t\n", "additional_info": "A proof-relevant statement that `L` is `A`-inflexible (excluding `ğŸ—ŸÎµğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoePath.ÎµğŸ”—  = âŠ¥`).\n", "used_premises": [1, 61, 890, 78], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [91, 95], "informalization": "The structure `ConNF.InflexibleCoe` represents a proof-relevant statement that `L` is `A`-inflexible (excluding `Îµ = âŠ¥`). This structure is used in the context of Constructive Ordinal Notation (ConNF) to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.InflexibleCoePath", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoePath", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.InflexibleCoePath [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.Î›} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Type u\n | Î³ : ConNF.Î›\n | Î´ : ConNF.Î›\n | Îµ : ConNF.Î›\n | inst_Î³ : ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘self.Î³\n | inst_Î´ : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘self.Î´\n | inst_Îµ : ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”—  â†‘self.Îµ\n | hÎ´ : â†‘self.Î´ <  â†‘self.Î³\n | hÎµ : â†‘self.Îµ <  â†‘self.Î³\n | hÎ´Îµ : â†‘self.Î´ â‰   â†‘self.Îµ\n | B : Quiver.PathğŸ”—<|PREMISE|>ğŸ”—  â†‘Î² â†‘self.Î³\n | hA : A =  Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”—  self.B â‹¯) â‹¯", "code": "structure InflexibleCoePath {Î² : Î›} (A : ExtendedIndex Î²) where\n  (Î³ Î´ Îµ : Î›)\n  [inst_Î³ : LeLevel Î³]\n  [inst_Î´ : LtLevel Î´]\n  [inst_Îµ : LtLevel Îµ]\n  hÎ´ : (Î´ : TypeIndex) < Î³\n  hÎµ : (Îµ : TypeIndex) < Î³\n  hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ\n  B : Quiver.Path (Î² : TypeIndex) Î³\n  hA : A = (B.cons hÎµ).cons (bot_lt_coe _)\n", "additional_info": "", "used_premises": [1, 61, 402, 98, 98, 76, 301, 301], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [75, 85], "informalization": "The `InflexibleCoePath` structure represents a finite path from a higher type index to the base type index in the context of Constructive Ordinal Notation (ConNF). This path is specifically designed to handle cases where a type index is equal to another type index due to extensionality, such as `Î² = Î³`, by ensuring that the path retains its inflexibility and validity. The structure includes several properties and conditions related to the type indices involved, such as their linear and well-orders, and subtraction operations. The `Quiver.Path` used in the structure represents a path in a quiver, and is used here to track the descent of type indices in the context of ConNF. The `InflexibleCoePath` structure ensures that the path is well-defined and valid, adhering to the principles of Constructive Ordinal Notation."}
{"full_name": "False", "url": "Init/Prelude.html#False", "code_src": "lean4", "ptype": "inductive", "header": "inductive False :Prop", "code": "inductive False : Prop\n", "additional_info": "`ğŸ—ŸFalseğŸ—ŸğŸ”—.././Init/Prelude.html#FalseğŸ”—`  is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `ğŸ—ŸFalseğŸ—ŸğŸ”—.././Init/Prelude.html#FalseğŸ”—`  elimination rule, `ğŸ—ŸFalse.recğŸ—ŸğŸ”—.././Init/Prelude.html#False.recğŸ”—` ,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: ğŸ—ŸPropositional LogicğŸ—ŸğŸ”—https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logicğŸ”— \n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [201, 202], "informalization": "Type `False` represents the logical contradiction, having no introduction rules and serving as a basis for the principle of explosion, stating that anything can be derived from a contradiction."}
{"full_name": "ConNF.InflexibleCoePath.Î´_lt_Î²", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoePath.Î´_lt_Î²", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.InflexibleCoePath.Î´_lt_Î² [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : ConNF.InflexibleCoePathğŸ”—<|PREMISE|>ğŸ”— A) :â†‘h.Î´ < â†‘Î²", "code": "theorem InflexibleCoePath.Î´_lt_Î² {Î² : Î›} {A : ExtendedIndex Î²}\n    (h : InflexibleCoePath A) : (h.Î´ : TypeIndex) < Î² :=\n  h.hÎ´.trans_le (le_of_path h.B)\n", "additional_info": "", "used_premises": [1, 61, 890], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [138, 141], "informalization": "The theorem `ConNF.InflexibleCoePath.Î´_lt_Î²` states that in the context of Constructive Ordinal Notation (ConNF), if `A` is an `InflexibleCoePath` from a type index `Î²` to the base type index `âŠ¥`, then the type index `Î´` in the path is strictly less than `Î²`."}
{"full_name": "ConNF.InflexibleCoe.Î´_lt_Î²", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoe.Î´_lt_Î²", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.InflexibleCoe.Î´_lt_Î² [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L) :â†‘h.path.Î´ < â†‘Î²", "code": "theorem InflexibleCoe.Î´_lt_Î² {Î² : Î›} {A : ExtendedIndex Î²} {L : Litter}\n    (h : InflexibleCoe A L) : (h.path.Î´ : TypeIndex) < Î² :=\n  h.path.Î´_lt_Î²\n", "additional_info": "", "used_premises": [1, 61, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [142, 145], "informalization": "The theorem `ConNF.InflexibleCoe.Î´_lt_Î²` states that in the context of Constructive Ordinal Notation (ConNF), if `L` is `A`-inflexible (excluding `Îµ = âŠ¥`), then the `Î´` of the path `h.path` is strictly less than `Î²`."}
{"full_name": "ConNF.inflexible_of_inflexibleBot", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexible_of_inflexibleBot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexible_of_inflexibleBot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L) :ConNF.InflexibleğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem inflexible_of_inflexibleBot {Î² : Î›} {A : ExtendedIndex Î²} {L : Litter}\n    (h : InflexibleBot A L) : Inflexible A L := by\n  have := Inflexible.mk_bot h.path.hÎµ h.path.B h.a\n  rw [â† h.hL, â† h.path.hA] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 61, 887, 879], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [239, 244], "informalization": "The theorem states that if L is A-inflexible at the bottom, then L is A-inflexible. This is a result of the fact that A-inflexibility at the bottom implies A-inflexibility at all levels, due to the well-founded nature of the ConNF hierarchy and the properties of the f-maps."}
{"full_name": "ConNF.inflexible_of_inflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexible_of_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexible_of_inflexibleCoe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L) :ConNF.InflexibleğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem inflexible_of_inflexibleCoe {Î² : Î›} {A : ExtendedIndex Î²} {L : Litter}\n    (h : InflexibleCoe A L) : Inflexible A L := by\n  have := Inflexible.mk_coe h.path.hÎ´ h.path.hÎµ h.path.hÎ´Îµ h.path.B h.t\n  rw [â† h.hL, â† h.path.hA] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 61, 889, 879], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [246, 251], "informalization": "The theorem `ConNF.inflexible_of_inflexibleCoe` states that if `L` is `A`-inflexible (excluding `Îµ = âŠ¥`), then `L` is inflexible. This theorem is used in the context of Constructive Ordinal Notation (ConNF) to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.inflexibleBot_or_inflexibleCoe_of_inflexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleBot_or_inflexibleCoe_of_inflexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexibleBot_or_inflexibleCoe_of_inflexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleğŸ”—<|PREMISE|>ğŸ”— A L) :NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L) âˆ¨ NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L)", "code": "theorem inflexibleBot_or_inflexibleCoe_of_inflexible {Î² : Î›} {A : ExtendedIndex Î²} {L : Litter}\n    (h : Inflexible A L) : Nonempty (InflexibleBot A L) âˆ¨ Nonempty (InflexibleCoe A L) := by\n  obtain âŸ¨hÎ´, hÎµ, hÎ´Îµ, B, tâŸ© | âŸ¨hÎµ, B, aâŸ© := h\n  Â· exact Or.inr âŸ¨âŸ¨âŸ¨_, _, _, hÎ´, hÎµ, hÎ´Îµ, _, rflâŸ©, t, rflâŸ©âŸ©\n  Â· exact Or.inl âŸ¨âŸ¨âŸ¨_, _, hÎµ, _, rflâŸ©, a, rflâŸ©âŸ©\n", "additional_info": "", "used_premises": [1, 61, 879, 212, 887, 212, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [252, 257], "informalization": "Given a litter `L` and an extended index `A` in the context of Constructive Ordinal Notation (ConNF), if `L` is `A`-inflexible, then either `L` is `A`-inflexible at the bottom (i.e., when `Î´ = âŠ¥`) or `L` is `A`-inflexible through coe (i.e., excluding `Îµ = âŠ¥`)."}
{"full_name": "ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} :ConNF.InflexibleğŸ”—<|PREMISE|>ğŸ”— A L â†” NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L) âˆ¨ NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L)", "code": "theorem inflexible_iff_inflexibleBot_or_inflexibleCoe {Î² : Î›} {A : ExtendedIndex Î²}\n    {L : Litter} :\n    Inflexible A L â†” Nonempty (InflexibleBot A L) âˆ¨ Nonempty (InflexibleCoe A L) := by\n  constructor\n  exact inflexibleBot_or_inflexibleCoe_of_inflexible\n  rintro (âŸ¨âŸ¨hâŸ©âŸ© | âŸ¨âŸ¨hâŸ©âŸ©)\n  exact inflexible_of_inflexibleBot h\n  exact inflexible_of_inflexibleCoe h\n", "additional_info": "", "used_premises": [1, 61, 879, 212, 887, 212, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [258, 266], "informalization": "The theorem `ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe` in Lean 4 states that a litter `L` is `A`-inflexible if and only if there exists a proof that `L` is `A`-inflexible at the bottom of the hierarchy (`ConNF.InflexibleBot A L`) or there exists a proof that `L` is `A`-inflexible at the coe level (`ConNF.InflexibleCoe A L`). This theorem is crucial in the context of Constructive Ordinal Notation (ConNF) to ensure that the path from a type `Î±` to the base type `âŠ¥` retains its inflexibility throughout the construction."}
{"full_name": "ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L â†” IsEmptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L) âˆ§ IsEmptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L)", "code": "theorem flexible_iff_not_inflexibleBot_inflexibleCoe {Î² : Î›} {A : ExtendedIndex Î²}\n    {L : Litter} :\n    Flexible A L â†” IsEmpty (InflexibleBot A L) âˆ§ IsEmpty (InflexibleCoe A L) := by\n  constructor\n  Â· intro h\n    exact âŸ¨âŸ¨fun h' => h (inflexible_of_inflexibleBot h')âŸ©,\n      âŸ¨fun h' => h (inflexible_of_inflexibleCoe h')âŸ©âŸ©\n  Â· intro hâ‚ hâ‚‚\n    obtain h | h := inflexibleBot_or_inflexibleCoe_of_inflexible hâ‚‚\n    Â· exact hâ‚.1.false h.some\n    Â· exact hâ‚.2.false h.some\n", "additional_info": "", "used_premises": [1, 61, 842, 899, 887, 899, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [268, 279], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a litter `L` is considered *flexible* if it is not the image of any f-map. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe` states that a litter `L` is *flexible* if and only if it is not `A`-inflexible at the base type (`ConNF.InflexibleBot A L`) and it is not `A`-inflexible at any other type (`ConNF.InflexibleCoe A L`)."}
{"full_name": "IsEmpty", "url": "Mathlib/Logic/IsEmpty.html#IsEmpty", "code_src": "mathlib4", "ptype": "class", "header": "class IsEmpty (Î± : Sort u_4) :Prop\n | false : Î± â†’ FalseğŸ”—<|PREMISE|>ğŸ”— ", "code": "class IsEmpty (Î± : Sort*) : Prop where\n  protected false : Î± â†’ False\n", "additional_info": "`ğŸ—ŸIsEmptyğŸ—ŸğŸ”—../.././Mathlib/Logic/IsEmpty.html#IsEmptyğŸ”—  Î±` expresses that `Î±` is empty.\n", "used_premises": [891], "def_path": "Mathlib/Logic/IsEmpty.lean", "pos": [25, 27], "informalization": "Class `IsEmpty` represents the property that a type `Î±` has no elements, meaning any attempt to construct an element of `Î±` leads to a logical contradiction (`False`)."}
{"full_name": "ConNF.flexible_cases'", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_cases'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.flexible_cases' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L âˆ¨ NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L) âˆ¨ NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L)", "code": "theorem flexible_cases' {Î² : Î›} (A : ExtendedIndex Î²) (L : Litter) :\n    Flexible A L âˆ¨ Nonempty (InflexibleBot A L) âˆ¨ Nonempty (InflexibleCoe A L) := by\n  rw [â† inflexible_iff_inflexibleBot_or_inflexibleCoe, or_comm]\n  exact flexible_cases A L\n", "additional_info": "", "used_premises": [1, 61, 842, 212, 887, 212, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [280, 284], "informalization": "For a given type index `Î²` in the context of Constructive Ordinal Notation (ConNF), and a litter `L`, there are three cases to consider when determining the flexibility of `L` relative to `A`, an extended index of `Î²`: either `L` is flexible, `L` is inflexible due to `Î´ = âŠ¥`, or `L` is inflexible due to `Î´` being equal to another type index due to extensionality. This theorem establishes that one of these cases must be true, indicating the overall flexibility of `L` in the context provided by `A`."}
{"full_name": "ConNF.inflexibleCoe_smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleCoe_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.inflexibleCoe_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} {Ï : ConNF.Allowable â†‘Î²} :NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A (ConNF.Allowable.toStructPerm Ï A â€¢ L)) â†” NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L)", "code": "theorem inflexibleCoe_smul {Î² : Î›} [LeLevel Î²]\n    {A : ExtendedIndex Î²} {L : Litter} {Ï : Allowable Î²} :\n    Nonempty (InflexibleCoe A (Allowable.toStructPerm Ï A â€¢ L)) â†” Nonempty (InflexibleCoe A L) := by\n  constructor\n  Â· rintro âŸ¨hâŸ©\n    have := h.smul Ïâ»Â¹\n    simp only [map_inv, Tree.inv_apply, inv_smul_smul] at this\n    exact âŸ¨thisâŸ©\n  Â· rintro âŸ¨hâŸ©\n    exact âŸ¨h.smul ÏâŸ©\n", "additional_info": "", "used_premises": [1, 402, 61, 212, 889, 212, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [294, 304], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleCoe_smul` states that if `L` is `A`-inflexible (excluding `Îµ = âŠ¥`), then `ConNF.Allowable.toStructPerm Ï A â€¢ L` is also `A`-inflexible, where `ConNF.Allowable.toStructPerm Ï A â€¢ L` represents the action of the permutation `ConNF.Allowable.toStructPerm Ï A` on `L`."}
{"full_name": "ConNF.inflexibleBot_smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.inflexibleBot_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} {Ï : ConNF.Allowable â†‘Î²} :NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A (ConNF.Allowable.toStructPerm Ï A â€¢ L)) â†” NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L)", "code": "theorem inflexibleBot_smul {Î² : Î›} [LeLevel Î²]\n    {A : ExtendedIndex Î²} {L : Litter} {Ï : Allowable Î²} :\n    Nonempty (InflexibleBot A (Allowable.toStructPerm Ï A â€¢ L)) â†” Nonempty (InflexibleBot A L) := by\n  constructor\n  Â· rintro âŸ¨hâŸ©\n    have := h.smul Ïâ»Â¹\n    simp only [map_inv, Tree.inv_apply, inv_smul_smul] at this\n    exact âŸ¨thisâŸ©\n  Â· rintro âŸ¨hâŸ©\n    exact âŸ¨h.smul ÏâŸ©\n", "additional_info": "", "used_premises": [1, 402, 61, 212, 887, 212, 887], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [314, 324], "informalization": "The theorem `ConNF.inflexibleBot_smul` is a result in the context of Constructive Ordinal Notation (ConNF), which is a formalization of an extension of the Constructive Ordinals by allowing for 'literals' and 'structures' that can be manipulated under a carefully defined set of rules. The theorem states that if `L` is inflexible with respect to `A` and `Ï` is a permutation of `L` that respects the `A`-inflexibility of `L`, then the permutation `Ï` applied to `L` results in another inflexible structure with respect to `A`. This result is crucial in establishing the recursive properties of the ConNF system."}
{"full_name": "ConNF.Flexible.smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.Flexible.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Flexible.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) (Ï : ConNF.Allowable â†‘Î²) :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A (ConNF.Allowable.toStructPerm Ï A â€¢ L)", "code": "theorem Flexible.smul {Î² : Î›} [LeLevel Î²] {A : ExtendedIndex Î²} {L : Litter}\n    (h : Flexible A L) (Ï : Allowable Î²) :\n    Flexible A (Allowable.toStructPerm Ï A â€¢ L) := by\n  rw [flexible_iff_not_inflexibleBot_inflexibleCoe, â† not_nonempty_iff, â† not_nonempty_iff,\n    inflexibleBot_smul, inflexibleCoe_smul, not_nonempty_iff, not_nonempty_iff,\n    â† flexible_iff_not_inflexibleBot_inflexibleCoe]\n  exact h\n", "additional_info": "", "used_premises": [1, 402, 61, 842, 842], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [325, 332], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a litter `L` is considered *flexible* if it is not the image of any f-map. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.Flexible.smul` states that if `L` is a *flexible* litter and `Ï` is an allowable permutation, then the action of `Ï` on `L` results in another *flexible* litter."}
{"full_name": "ConNF.flexible_smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.flexible_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} {Ï : ConNF.Allowable â†‘Î²} :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A (ConNF.Allowable.toStructPerm Ï A â€¢ L) â†” ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem flexible_smul {Î² : Î›} [LeLevel Î²]\n    {A : ExtendedIndex Î²} {L : Litter} {Ï : Allowable Î²} :\n    Flexible A (Allowable.toStructPerm Ï A â€¢ L) â†” Flexible A L :=\n  by simp only [flexible_iff_not_inflexibleBot_inflexibleCoe, â† not_nonempty_iff,\n    inflexibleBot_smul, inflexibleCoe_smul]\n", "additional_info": "", "used_premises": [1, 402, 61, 842, 842], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [334, 339], "informalization": "The theorem `ConNF.flexible_smul` states that in the context of Constructive Ordinal Notation (ConNF), a litter `L` is *flexible* if and only if its image under the action of any allowable permutation is also *flexible*. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.inflexibleCoe_smul_path", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleCoe_smul_path", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.inflexibleCoe_smul_path [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} {Ï : ConNF.Allowable â†‘Î²} (h : ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L) :(ConNF.InflexibleCoe.smulğŸ”—<|PREMISE|>ğŸ”— h Ï).path = h.path", "code": "theorem inflexibleCoe_smul_path {Î² : Î›} [LeLevel Î²]\n    {A : ExtendedIndex Î²} {L : Litter} {Ï : Allowable Î²} (h : InflexibleCoe A L) :\n    (h.smul Ï).path = h.path :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 61, 889, 906], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [341, 345], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleCoe_smul_path` states that the path of a proof-relevant statement that `L` is `A`-inflexible (excluding `Îµ = âŠ¥`) remains unchanged after applying the `ConNF.InflexibleCoe.smul` method. This method is used to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.InflexibleCoe.smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoe.smul", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.InflexibleCoe.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L) (Ï : ConNF.Allowable â†‘Î²) :ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A (ConNF.Allowable.toStructPerm Ï A â€¢ L)", "code": "def InflexibleCoe.smul {Î² : Î›} [LeLevel Î²] {A : ExtendedIndex Î²} {L : Litter}\n    (h : InflexibleCoe A L) (Ï : Allowable Î²) :\n    InflexibleCoe A (Allowable.toStructPerm Ï A â€¢ L) :=\n  âŸ¨h.path,\n    Allowable.comp (h.path.B.cons h.path.hÎ´) Ï â€¢ h.t, by\n      rw [â† toStructPerm_smul_fuzz h.path.hÎ´ h.path.hÎµ]\n      simp only [h.path.hA, h.hL]âŸ©\n", "additional_info": "Equations\n* ğŸ—ŸConNF.InflexibleCoe.smulğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoe.smulğŸ”—  h Ï ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { path := h.path, t := (ğŸ—ŸConNF.Allowable.compğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.compğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  h.path.B â‹¯)) Ï ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  h.t, hL := â‹¯ }\n\n", "used_premises": [1, 402, 61, 889, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [285, 292], "informalization": "Function `ConNF.InflexibleCoe.smul` is a method in the `ConNF.InflexibleCoe` structure, which represents a proof-relevant statement that `L` is `A`-inflexible (excluding `Îµ = âŠ¥`). This structure is used in the context of Constructive Ordinal Notation (ConNF) to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.inflexibleBot_smul_path", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleBot_smul_path", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.inflexibleBot_smul_path [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} {Ï : ConNF.Allowable â†‘Î²} (h : ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L) :(ConNF.InflexibleBot.smulğŸ”—<|PREMISE|>ğŸ”— h Ï).path = h.path", "code": "theorem inflexibleBot_smul_path {Î² : Î›} [LeLevel Î²]\n    {A : ExtendedIndex Î²} {L : Litter} {Ï : Allowable Î²} (h : InflexibleBot A L) :\n    (h.smul Ï).path = h.path :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 61, 887, 908], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [353, 357], "informalization": "The theorem `ConNF.inflexibleBot_smul_path` states that if `L` is `A`-inflexible and `Ï` is an allowable permutation, then the path of `Ï â€¢ L` is the same as the path of `L`."}
{"full_name": "ConNF.InflexibleBot.smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleBot.smul", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.InflexibleBot.smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L) (Ï : ConNF.Allowable â†‘Î²) :ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A (ConNF.Allowable.toStructPerm Ï A â€¢ L)", "code": "def InflexibleBot.smul {Î² : Î›} [LeLevel Î²] {A : ExtendedIndex Î²} {L : Litter}\n    (h : InflexibleBot A L) (Ï : Allowable Î²) :\n    InflexibleBot A (Allowable.toStructPerm Ï A â€¢ L) :=\n  âŸ¨h.path,\n    Allowable.comp (h.path.B.cons (bot_lt_coe _)) Ï â€¢ h.a, by\n      rw [â† toStructPerm_smul_fuzz (bot_lt_coe _) h.path.hÎµ]\n      simp only [h.path.hA, h.hL]âŸ©\n", "additional_info": "Equations\n* ğŸ—ŸConNF.InflexibleBot.smulğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleBot.smulğŸ”—  h Ï ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { path := h.path, a := (ğŸ—ŸConNF.Allowable.compğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.compğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  h.path.B â‹¯)) Ï ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  h.a, hL := â‹¯ }\n\n", "used_premises": [1, 402, 61, 887, 887], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [305, 312], "informalization": "Function `ConNF.InflexibleBot.smul` proves that if `L` is `A`-inflexible and `Ï` is an allowable permutation, then `Ï â€¢ L` is also `A`-inflexible in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.hasPosition_subsingleton", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.hasPosition_subsingleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.hasPosition_subsingleton [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {L : ConNF.Litter} {Î½â‚ : ConNF.Î¼} {Î½â‚‚ : ConNF.Î¼} (hâ‚ : ConNF.HasPositionğŸ”—<|PREMISE|>ğŸ”— L Î½â‚) (hâ‚‚ : ConNF.HasPositionğŸ”—<|PREMISE|>ğŸ”— L Î½â‚‚) :Î½â‚ = Î½â‚‚", "code": "theorem hasPosition_subsingleton {L : Litter} {Î½â‚ Î½â‚‚ : Î¼}\n    (hâ‚ : HasPosition L Î½â‚) (hâ‚‚ : HasPosition L Î½â‚‚) : Î½â‚ = Î½â‚‚ := by\n  rw [hasPosition_iff] at hâ‚ hâ‚‚\n  cases hâ‚ with\n  | inl hâ‚ =>\n      obtain âŸ¨Î´, _, Îµ, _, hÎ´Îµ, t, rfl, rflâŸ© := hâ‚\n      cases hâ‚‚ with\n      | inl hâ‚‚ =>\n          obtain âŸ¨_, _, _, _, _, t, ht, rflâŸ© := hâ‚‚\n          cases fuzz_congr_Î² ht\n          cases fuzz_congr_Î³ ht\n          cases fuzz_injective _ ht\n          rfl\n      | inr hâ‚‚ =>\n          obtain âŸ¨_, _, a, ha, rflâŸ© := hâ‚‚\n          cases fuzz_congr_Î² ha\n  | inr hâ‚ =>\n      obtain âŸ¨_, _, a, rfl, rflâŸ© := hâ‚\n      cases hâ‚‚ with\n      | inl hâ‚‚ =>\n          obtain âŸ¨_, _, _, _, _, t, ht, rflâŸ© := hâ‚‚\n          cases fuzz_congr_Î² ht\n      | inr hâ‚‚ =>\n          obtain âŸ¨_, _, a, ha, rflâŸ© := hâ‚‚\n          cases fuzz_congr_Î³ ha\n          cases fuzz_injective _ ha\n          rfl\n", "additional_info": "", "used_premises": [1, 910, 910], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [74, 101], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a `ConNF.Litter` `L` and two `ConNF.Î¼` elements `Î½â‚` and `Î½â‚‚`, if both `Î½â‚` and `Î½â‚‚` are related to `L` by the `ConNF.HasPosition` relation, then `Î½â‚` and `Î½â‚‚` must be equal. This means that for a given `ConNF.Litter`, there is at most one `ConNF.Î¼` element that can be related to it by the `ConNF.HasPosition` relation."}
{"full_name": "ConNF.HasPosition", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.HasPosition", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.HasPosition [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] :ConNF.Litter â†’ ConNF.Î¼ â†’ Prop", "code": "inductive HasPosition : Litter â†’ Î¼ â†’ Prop\n  | fuzz â¦ƒÎ´ : Î›â¦„ [LtLevel Î´] â¦ƒÎµ : Î›â¦„ [LtLevel Îµ] (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ) (t : Tangle Î´) :\n    HasPosition (fuzz hÎ´Îµ t) (pos t)\n  | fuzz_bot â¦ƒÎµ : Î›â¦„ [LtLevel Îµ] (a : Atom) :\n    HasPosition (fuzz (bot_ne_coe (a := Îµ)) a) (pos a)\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [68, 73], "informalization": "Type `ConNF.HasPosition` represents the relation between a `ConNF.Litter` and an element of `ConNF.Î¼`. It is defined inductively, with two constructors: `fuzz` and `fuzz_bot`. The `fuzz` constructor relates a `ConNF.Litter` of the form `fuzz hÎ´Îµ t` to the `ConNF.Î¼` element `pos t`, where `t` is a `ConNF.Tangle`. The `fuzz_bot` constructor relates a `ConNF.Litter` of the form `fuzz (bot_ne_coe (a := Îµ)) a` to the `ConNF.Î¼` element `pos a`, where `a` is a `ConNF.Atom`."}
{"full_name": "ConNF.hasPosition_of_litterConstrains", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.hasPosition_of_litterConstrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.hasPosition_of_litterConstrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} (h : ConNF.LitterConstrainsğŸ”—<|PREMISE|>ğŸ”— Lâ‚ Lâ‚‚) :âˆƒ (Î½ : ConNF.Î¼), ConNF.HasPositionğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚ Î½", "code": "theorem hasPosition_of_litterConstrains {Lâ‚ Lâ‚‚ : Litter} (h : LitterConstrains Lâ‚ Lâ‚‚) :\n    âˆƒ Î½, HasPosition Lâ‚‚ Î½ := by\n  cases h\n  Â· exact âŸ¨_, HasPosition.fuzz _ _âŸ©\n  Â· exact âŸ¨_, HasPosition.fuzz _ _âŸ©\n  Â· exact âŸ¨_, HasPosition.fuzz_bot _âŸ©\n", "additional_info": "", "used_premises": [1, 912, 910], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [102, 108], "informalization": "The theorem `ConNF.hasPosition_of_litterConstrains` states that for any two `ConNF.Litter` objects `Lâ‚` and `Lâ‚‚`, if `Lâ‚` constrains `Lâ‚‚`, then there exists a `ConNF.Î¼` element `Î½` such that `Lâ‚‚` has position `Î½`."}
{"full_name": "ConNF.LitterConstrains", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.LitterConstrains", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.LitterConstrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] :ConNF.Litter â†’ ConNF.Litter â†’ Prop", "code": "inductive LitterConstrains : Litter â†’ Litter â†’ Prop\n  | fuzz_atom â¦ƒÎ´ : Î›â¦„ [LtLevel Î´] â¦ƒÎµ : Î›â¦„ [LtLevel Îµ] (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ)\n    (t : Tangle Î´) {B : ExtendedIndex Î´} {a : Atom} : âŸ¨B, inl aâŸ© âˆˆ t.support â†’\n    LitterConstrains a.1 (fuzz hÎ´Îµ t)\n  | fuzz_nearLitter â¦ƒÎ´ : Î›â¦„ [LtLevel Î´] â¦ƒÎµ : Î›â¦„ [LtLevel Îµ] (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ)\n    (t : Tangle Î´) {B : ExtendedIndex Î´} {N : NearLitter} (h : âŸ¨B, inr NâŸ© âˆˆ t.support)\n    {a : Atom} (ha : a âˆˆ N) :\n    LitterConstrains a.1 (fuzz hÎ´Îµ t)\n  | fuzz_bot â¦ƒÎµ : Î›â¦„ [LtLevel Îµ] (a : Atom) :\n    LitterConstrains a.1 (fuzz (bot_ne_coe (a := Îµ)) a)\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [56, 66], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the `ConNF.LitterConstrains` relation is an inductively defined relation on `ConNF.Litter` objects. It is used to express the constraints that one `Litter` object imposes on another. The relation is defined by three constructors: `fuzz_atom`, `fuzz_nearLitter`, and `fuzz_bot`. Each constructor represents a different way in which a `Litter` object can be constrained by another."}
{"full_name": "ConNF.hasPosition_lt_of_litterConstrains", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.hasPosition_lt_of_litterConstrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.hasPosition_lt_of_litterConstrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} (h : ConNF.LitterConstrainsğŸ”—<|PREMISE|>ğŸ”— Lâ‚ Lâ‚‚) {Î½â‚ : ConNF.Î¼} {Î½â‚‚ : ConNF.Î¼} (hâ‚ : ConNF.HasPositionğŸ”—<|PREMISE|>ğŸ”— Lâ‚ Î½â‚) (hâ‚‚ : ConNF.HasPositionğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚ Î½â‚‚) :Î½â‚ < Î½â‚‚", "code": "theorem hasPosition_lt_of_litterConstrains {Lâ‚ Lâ‚‚ : Litter} (h : LitterConstrains Lâ‚ Lâ‚‚)\n    {Î½â‚ Î½â‚‚ : Î¼} (hâ‚ : HasPosition Lâ‚ Î½â‚) (hâ‚‚ : HasPosition Lâ‚‚ Î½â‚‚) :\n    Î½â‚ < Î½â‚‚ := by\n  rw [hasPosition_iff] at hâ‚ hâ‚‚\n  cases h with\n  | fuzz_atom hÎ´Îµ t ht =>\n      cases hâ‚‚ with\n      | inr h =>\n          obtain âŸ¨_, _, _, h, rflâŸ© := h\n          cases fuzz_congr_Î² h\n      | inl h =>\n          obtain âŸ¨Î´, _, Îµ, _, _, t', ht', rflâŸ© := h\n          cases fuzz_congr_Î² ht'\n          cases fuzz_congr_Î³ ht'\n          cases fuzz_injective _ ht'\n          cases hâ‚ with\n          | inl h =>\n              obtain âŸ¨Î´, _, Îµ, _, hÎ´Îµ, t', ht', rflâŸ© := h\n              exact pos_lt_pos_atom t ht t' hÎ´Îµ ht'\n          | inr h =>\n              obtain âŸ¨Îµ, _, a, h, rflâŸ© := h\n              exact pos_lt_pos_atom t ht (show Tangle âŠ¥ from a) bot_ne_coe h\n  | fuzz_nearLitter hÎ´Îµ t ht ha =>\n      cases hâ‚‚ with\n      | inr h =>\n          obtain âŸ¨_, _, _, h, rflâŸ© := h\n          cases fuzz_congr_Î² h\n      | inl h =>\n          obtain âŸ¨Î´, _, Îµ, _, _, t', ht', rflâŸ© := h\n          cases fuzz_congr_Î² ht'\n          cases fuzz_congr_Î³ ht'\n          cases fuzz_injective _ ht'\n          cases hâ‚ with\n          | inl h =>\n              obtain âŸ¨Î´, _, Îµ, _, hÎ´Îµ, t', ht', rflâŸ© := h\n              exact pos_lt_pos_nearLitter t ht t' hÎ´Îµ âŸ¨_, ha, ht'âŸ©\n          | inr h =>\n              obtain âŸ¨Îµ, _, a, h, rflâŸ© := h\n              exact pos_lt_pos_nearLitter t ht (show Tangle âŠ¥ from a) bot_ne_coe âŸ¨_, ha, hâŸ©\n  | fuzz_bot a =>\n      cases hâ‚‚ with\n      | inl h =>\n          obtain âŸ¨_, _, _, _, _, _, h, rflâŸ© := h\n          cases fuzz_congr_Î² h\n      | inr h =>\n          obtain âŸ¨Îµ, _, a, ha, rflâŸ© := h\n          cases fuzz_congr_Î³ ha\n          cases fuzz_injective _ ha\n          cases hâ‚ with\n          | inl h =>\n              obtain âŸ¨Î´, _, Îµ, _, hÎ´Îµ, t', ht', rflâŸ© := h\n              exact pos_lt_pos_fuzz _ t' a ht'\n          | inr h =>\n              obtain âŸ¨Îµ, _, a', ha', rflâŸ© := h\n              exact pos_lt_pos_fuzz _ (show Tangle âŠ¥ from a') a ha'\n", "additional_info": "", "used_premises": [1, 912, 910, 910], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [109, 164], "informalization": "In Constructive Ordinal Notation (ConNF), the `ConNF.LitterConstrains` relation is used to express the constraints that one `Litter` object imposes on another. The `ConNF.HasPosition` relation describes the position of a `Litter` object within the `ConNF.Î¼` type. The theorem `ConNF.hasPosition_lt_of_litterConstrains` states that if `Lâ‚` is constrained by `Lâ‚‚` and both have positions in `ConNF.Î¼`, then the position of `Lâ‚` is less than the position of `Lâ‚‚` in `ConNF.Î¼`."}
{"full_name": "ConNF.litterConstrains_subrelation", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.litterConstrains_subrelation", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.litterConstrains_subrelation [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] :SubrelationğŸ”—<|PREMISE|>ğŸ”— ConNF.LitterConstrains (InvImageğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : WithBotğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼) => x < x_1) ConNF.positionOrBot)", "code": "theorem litterConstrains_subrelation :\n    Subrelation LitterConstrains (InvImage (Â· < Â·) positionOrBot) := by\n  intro Lâ‚ Lâ‚‚ h\n  obtain âŸ¨Î½â‚‚, hÎ½â‚‚âŸ© := hasPosition_of_litterConstrains h\n  by_cases hâ‚ : âˆƒ Î½â‚, HasPosition Lâ‚ Î½â‚\n  Â· obtain âŸ¨Î½â‚, hÎ½â‚âŸ© := hâ‚\n    rw [InvImage, positionOrBot, positionOrBot, dif_pos âŸ¨Î½â‚, hÎ½â‚âŸ©, dif_pos âŸ¨Î½â‚‚, hÎ½â‚‚âŸ©,\n      hasPosition_subsingleton (Exists.choose_spec âŸ¨Î½â‚, hÎ½â‚âŸ©) hÎ½â‚,\n      hasPosition_subsingleton (Exists.choose_spec âŸ¨Î½â‚‚, hÎ½â‚‚âŸ©) hÎ½â‚‚]\n    exact WithBot.coe_lt_coe.mpr (hasPosition_lt_of_litterConstrains h hÎ½â‚ hÎ½â‚‚)\n  Â· rw [InvImage, positionOrBot, positionOrBot, dif_neg hâ‚, dif_pos âŸ¨Î½â‚‚, hÎ½â‚‚âŸ©]\n    exact bot_lt_coe _\n", "additional_info": "", "used_premises": [1, 122, 96, 915], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [169, 181], "informalization": "The theorem `ConNF.litterConstrains_subrelation` states that the relation `ConNF.LitterConstrains` is a subrelation of the relation `InvImage (fun (x x_1 : WithBot ConNF.Î¼) => x < x_1) ConNF.positionOrBot`. This means that if `ConNF.LitterConstrains` holds between two elements, then so does `InvImage (fun (x x_1 : WithBot ConNF.Î¼) => x < x_1) ConNF.positionOrBot`."}
{"full_name": "WithBot", "url": "Mathlib/Order/WithBot.html#WithBot", "code_src": "mathlib4", "ptype": "def", "header": "def WithBot (Î± : Type u_5) :Type u_5", "code": "def WithBot (Î± : Type*) :=\n  Option Î±\n", "additional_info": "Attach `âŠ¥` to a type.\nEquations\n* ğŸ—ŸWithBotğŸ—ŸğŸ”—../.././Mathlib/Order/WithBot.html#WithBotğŸ”—  Î± ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸOptionğŸ—ŸğŸ”—../.././Init/Prelude.html#OptionğŸ”—  Î±\n\n", "used_premises": [], "def_path": "Mathlib/Order/WithBot.lean", "pos": [28, 30], "informalization": "Function `WithBot` augments a type `Î±` with an additional element `âŠ¥` (representing \"bottom\"), effectively forming a new type where each element is either `âŠ¥` or an element of `Î±`."}
{"full_name": "ConNF.litterConstrains_wf", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.litterConstrains_wf", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.litterConstrains_wf [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] :WellFoundedğŸ”—<|PREMISE|>ğŸ”— ConNF.LitterConstrains", "code": "theorem litterConstrains_wf : WellFounded LitterConstrains :=\n  Subrelation.wf litterConstrains_subrelation IsWellFounded.wf\n", "additional_info": "", "used_premises": [1, 19], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [182, 184], "informalization": "The theorem `ConNF.litterConstrains_wf` states that the relation `ConNF.LitterConstrains` is well-founded. This means that every non-empty set of `ConNF.Litter`s has a minimal element with respect to the relation `ConNF.LitterConstrains`."}
{"full_name": "ConNF.constrains_atom", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.constrains_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.constrains_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} :c â‰º { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } â†” c = { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) }", "code": "theorem constrains_atom {c : Address Î²} {A : ExtendedIndex Î²} {a : Atom} :\n    c â‰º âŸ¨A, inl aâŸ© â†” c = âŸ¨A, inr a.1.toNearLitterâŸ© := by\n  constructor\n  Â· rintro âŸ¨âŸ©\n    rfl\n  Â· rintro rfl\n    exact Constrains.atom A a\n", "additional_info": "", "used_premises": [1, 60, 61, 67, 65, 483], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [186, 193], "informalization": "The theorem `ConNF.constrains_atom` states that in the context of Constructive Ordinal Notation (ConNF), for a given address `c` and an extended index `A`, the condition `c â‰º { path := A, value := Sum.inl a }` holds if and only if `c` is equal to `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }`, where `a` is an atom and `ConNF.Litter.toNearLitter` converts a litter to its corresponding near-litter."}
{"full_name": "ConNF.constrains_nearLitter", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.constrains_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.constrains_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} (hN : Â¬ ConNF.NearLitter.IsLitterğŸ”—<|PREMISE|>ğŸ”— N) :c â‰º { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } â†” c = { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst) } âˆ¨ âˆƒ a âˆˆ symmDiffğŸ”—<|PREMISE|>ğŸ”— (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— N.fst) â†‘N.snd, c = { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a }", "code": "theorem constrains_nearLitter {c : Address Î²} {A : ExtendedIndex Î²}\n    {N : NearLitter} (hN : Â¬N.IsLitter) :\n    c â‰º âŸ¨A, inr NâŸ© â†” c = âŸ¨A, inr N.1.toNearLitterâŸ© âˆ¨\n      âˆƒ a âˆˆ litterSet N.fst âˆ† N.snd, c = âŸ¨A, inl aâŸ© := by\n  constructor\n  Â· intro h\n    rw [constrains_iff] at h\n    obtain âŸ¨A, a, rfl, hcâŸ© | âŸ¨A, N, hN, rfl, hcâŸ© | âŸ¨A, N, a, ha, rfl, hcâŸ© |\n        âŸ¨Î³, _, Î´, _, Îµ, _, hÎ´, hÎµ, hÎ´Îµ, A, t, c, _, rfl, hc'âŸ© |\n        âŸ¨Î³, _, Îµ, _, hÎ³, A, a, rfl, hcâŸ© := h\n    Â· cases hc\n    Â· cases hc\n      exact Or.inl rfl\n    Â· cases hc\n      exact Or.inr âŸ¨a, ha, rflâŸ©\n    Â· cases hc'\n      cases hN (NearLitter.IsLitter.mk _)\n    Â· cases hc\n      cases hN (NearLitter.IsLitter.mk _)\n  Â· rintro (rfl | âŸ¨a, ha, rflâŸ©)\n    Â· exact Constrains.nearLitter A N hN\n    Â· exact Constrains.symmDiff A N a ha\n", "additional_info": "", "used_premises": [1, 60, 61, 495, 65, 65, 483, 62, 467, 67], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [194, 216], "informalization": "The theorem `ConNF.constrains_nearLitter` in Constructive Ordinal Notation (ConNF) formalism, specifically defined for proving the consistency of `AD^+` using the determinacy of games on the ordinals, provides a condition for a constraint imposed by a near-litter that is not a litter. It states that for a constraint `c` to be less than a near-litter `N` that is not a litter, either `c` must be equal to the near-litter formed from the litter part of `N`, or `c` must be an atom that is an element of the symmetric difference between the litter set of `N` and the subset of the litter set that forms `N`. This theorem is crucial for understanding the relationship between constraints and near-litters in the context of ConNF."}
{"full_name": "ConNF.acc_atom", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.acc_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.acc_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {a : ConNF.Atom} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : AccğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) => x â‰º x_1) { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) }) :AccğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) => x â‰º x_1) { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a }", "code": "theorem acc_atom {a : Atom} {A : ExtendedIndex Î²}\n    (h : Acc ((Â· â‰º Â·) : Address Î² â†’ _ â†’ Prop) âŸ¨A, inr a.1.toNearLitterâŸ©) :\n    Acc ((Â· â‰º Â·) : Address Î² â†’ _ â†’ Prop) âŸ¨A, inl aâŸ© := by\n  constructor\n  intro c\n  rw [constrains_atom]\n  rintro rfl\n  exact h\n", "additional_info": "", "used_premises": [1, 61, 920, 60, 65, 483, 920, 60, 67], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [217, 225], "informalization": "The theorem `ConNF.acc_atom` is a part of the Constructive Ordinal Notation (ConNF) formalization in Lean 4. It states that if a certain relation `â‰º` (which represents a well-founded relation in the context of ConNF) is accessible for a specific element of type `ConNF.Address â†‘Î²` that has a `Sum.inr` constructor (which means it represents a near-litter), then the relation `â‰º` is also accessible for a similar element but with a `Sum.inl` constructor (which represents an atom). This result is crucial for proving the well-foundedness of the relation `â‰º` in the context of ConNF, which is essential for the correctness of the model of ordinals and cardinals in the formalization."}
{"full_name": "Acc", "url": "Init/WF.html#Acc", "code_src": "lean4", "ptype": "inductive", "header": "inductive Acc {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop ) :Î± â†’ Prop", "code": "inductive Acc {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) : Î± â†’ Prop where\n  | intro (x : Î±) (h : (y : Î±) â†’ r y x â†’ Acc r y) : Acc r x\n", "additional_info": "", "used_premises": [], "def_path": "Init/WF.lean", "pos": [11, 13], "informalization": "Type `Acc` represents the accessibility of an element in a well-founded relation. It is used to define well-founded induction and recursion."}
{"full_name": "ConNF.acc_nearLitter", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.acc_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.acc_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {N : ConNF.NearLitter} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : âˆ€ a âˆˆ N, AccğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) => x â‰º x_1) { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) }) :AccğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) => x â‰º x_1) { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N }", "code": "theorem acc_nearLitter {N : NearLitter} {A : ExtendedIndex Î²}\n    (h : âˆ€ a âˆˆ N, Acc ((Â· â‰º Â·) : Address Î² â†’ _ â†’ Prop) âŸ¨A, inr a.1.toNearLitterâŸ©) :\n    Acc ((Â· â‰º Â·) : Address Î² â†’ _ â†’ Prop) âŸ¨A, inr NâŸ© := by\n  by_cases hN : N.IsLitter\n  Â· obtain âŸ¨L, rflâŸ© := hN.exists_litter_eq\n    obtain âŸ¨âŸ¨a, rflâŸ©âŸ© := litterSet_nonempty L\n    exact h _ rfl\n  constructor\n  intro d hd\n  rw [constrains_nearLitter hN] at hd\n  obtain (rfl | âŸ¨a, ha, rflâŸ©) := hd\n  Â· obtain âŸ¨a, haâŸ© := NearLitter.inter_nonempty_of_fst_eq_fst (Nâ‚ := N) (Nâ‚‚ := N.1.toNearLitter) rfl\n    have := h a ha.1\n    rw [ha.2] at this\n    exact this\n  Â· refine acc_atom ?_\n    obtain (ha | ha) := ha\n    Â· obtain âŸ¨b, hbâŸ© := NearLitter.inter_nonempty_of_fst_eq_fst (Nâ‚ := N) (Nâ‚‚ := N.1.toNearLitter) rfl\n      have := h b hb.1\n      rw [hb.2, â† ha.1] at this\n      exact this\n    Â· exact h a ha.1\n", "additional_info": "", "used_premises": [1, 61, 920, 60, 65, 483, 920, 60, 65], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [226, 248], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.acc_nearLitter` states that if for every element `a` in a near-litter `N`, the address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }` is accessible under the relation `â‰º`, then the address `{ path := A, value := Sum.inr N }` is also accessible under the same relation."}
{"full_name": "ConNF.constrains_wf", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.constrains_wf", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.constrains_wf [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] (Î² : ConNF.Î›) :WellFoundedğŸ”—<|PREMISE|>ğŸ”— fun (x x_1 : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) => x â‰º x_1", "code": "theorem constrains_wf (Î² : Î›) : WellFounded ((Â· â‰º Â·) : Address Î² â†’ _ â†’ Prop) := by\n  have : âˆ€ L : Litter, âˆ€ A : ExtendedIndex Î²,\n      Acc ((Â· â‰º Â·) : Address Î² â†’ _ â†’ Prop) âŸ¨A, inr L.toNearLitterâŸ©\n  Â· intro L\n    refine litterConstrains_wf.induction\n      (C := fun L => âˆ€ A : ExtendedIndex Î², Acc (Â· â‰º Â·) âŸ¨A, inr L.toNearLitterâŸ©) L ?_\n    clear L\n    intro L ih A\n    constructor\n    intro c hc\n    rw [constrains_iff] at hc\n    obtain âŸ¨A, a, rfl, hcâŸ© | âŸ¨A, N, hN, rfl, hcâŸ© | âŸ¨A, N, a, ha, rfl, hcâŸ© |\n        âŸ¨Î³, _, Î´, _, Îµ, _, hÎ´, hÎµ, hÎ´Îµ, A, t, c, hc, rfl, hc'âŸ© |\n        âŸ¨Î³, _, Îµ, _, hÎ³, A, a, rfl, hcâŸ© := hc\n    Â· cases hc\n    Â· cases hc\n      cases hN (NearLitter.IsLitter.mk _)\n    Â· cases hc\n      cases ha with\n      | inl ha => cases ha.2 ha.1\n      | inr ha => cases ha.2 ha.1\n    Â· simp only [Address.mk.injEq, inr.injEq, Litter.toNearLitter_injective.eq_iff] at hc'\n      cases hc'.1\n      cases hc'.2\n      obtain âŸ¨B, a | NâŸ© := c\n      Â· exact acc_atom (ih a.1 (LitterConstrains.fuzz_atom _ _ hc) _)\n      Â· refine acc_nearLitter ?_\n        intro a ha\n        exact ih _ (LitterConstrains.fuzz_nearLitter hÎ´Îµ t hc ha) _\n    Â· simp only [Address.mk.injEq, inr.injEq, Litter.toNearLitter_injective.eq_iff] at hc\n      cases hc.1\n      cases hc.2\n      refine acc_atom (ih _ (LitterConstrains.fuzz_bot _) _)\n  constructor\n  intro c\n  obtain âŸ¨B, a | NâŸ© := c\n  Â· exact acc_atom (this _ _)\n  Â· exact acc_nearLitter (fun _ _ => this _ _)\n", "additional_info": "The `â‰º` relation is well-founded.", "used_premises": [1, 19, 60], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [250, 288], "informalization": "Function `ConNF.constrains_wf` proves that the `â‰º` relation on `ConNF.Address` is well-founded. This means that every non-empty subset of `ConNF.Address` has a minimal element with respect to the relation `â‰º`."}
{"full_name": "ConNF.Address.le_iff", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.Address.le_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Address.le_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :c â‰¤ d â†” Relation.ReflTransGenğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) => x â‰º x_1) c d", "code": "theorem Address.le_iff {c d : Address Î²} :\n    c â‰¤ d â†” Relation.ReflTransGen (Â· â‰º Â·) c d :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 60, 60, 924, 60], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [330, 333], "informalization": "The theorem `ConNF.Address.le_iff` in Lean 4 states that for two addresses `c` and `d` in the same level `Î²`, `c` is less than or equal to `d` if and only if `c` is related to `d` by the reflexive transitive closure of the relation `â‰º`."}
{"full_name": "Relation.ReflTransGen", "url": "Mathlib/Logic/Relation.html#Relation.ReflTransGen", "code_src": "mathlib4", "ptype": "inductive", "header": "inductive Relation.ReflTransGen {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop ) (a : Î±) :Î± â†’ Prop", "code": "inductive ReflTransGen (r : Î± â†’ Î± â†’ Prop) (a : Î±) : Î± â†’ Prop\n  | refl : ReflTransGen r a a\n  | tail {b c} : ReflTransGen r a b â†’ r b c â†’ ReflTransGen r a c\n", "additional_info": "`ğŸ—ŸReflTransGenğŸ—ŸğŸ”—../.././Mathlib/Logic/Relation.html#Relation.ReflTransGenğŸ”—  r`: reflexive transitive closure of `r`\n", "used_premises": [], "def_path": "Mathlib/Logic/Relation.lean", "pos": [249, 252], "informalization": "Type `Relation.ReflTransGen` represents the reflexive transitive closure of a relation `r`, meaning it is the smallest relation that includes `r` and is both reflexive and transitive."}
{"full_name": "ConNF.Address.lt_iff", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.Address.lt_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Address.lt_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :c < d â†” Relation.TransGenğŸ”—<|PREMISE|>ğŸ”— (fun (x x_1 : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) => x â‰º x_1) c d", "code": "theorem Address.lt_iff {c d : Address Î²} :\n    c < d â†” Relation.TransGen (Â· â‰º Â·) c d :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 60, 60, 926, 60], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [334, 337], "informalization": "The theorem `ConNF.Address.lt_iff` in Lean 4 states that for two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF), `c` is less than `d` if and only if `c` is related to `d` by the transitive closure of the relation `â‰º`."}
{"full_name": "Relation.TransGen", "url": "Mathlib/Logic/Relation.html#Relation.TransGen", "code_src": "mathlib4", "ptype": "inductive", "header": "inductive Relation.TransGen {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop ) (a : Î±) :Î± â†’ Prop", "code": "inductive TransGen (r : Î± â†’ Î± â†’ Prop) (a : Î±) : Î± â†’ Prop\n  | single {b} : r a b â†’ TransGen r a b\n  | tail {b c} : TransGen r a b â†’ r b c â†’ TransGen r a c\n", "additional_info": "`ğŸ—ŸTransGenğŸ—ŸğŸ”—../.././Mathlib/Logic/Relation.html#Relation.TransGenğŸ”—  r`: transitive closure of `r`\n", "used_premises": [], "def_path": "Mathlib/Logic/Relation.lean", "pos": [267, 270], "informalization": "Type `Relation.TransGen` represents the transitive closure of a relation `r`, which is the smallest transitive relation containing `r`."}
{"full_name": "ConNF.le_nearLitter", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.le_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.le_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } â‰¤ c) :{ path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst) } â‰¤ c", "code": "theorem le_nearLitter {Î² : Î›} {N : NearLitter} {B : ExtendedIndex Î²}\n    {c : Address Î²} (h : âŸ¨B, inr NâŸ© â‰¤ c) : âŸ¨B, inr N.1.toNearLitterâŸ© â‰¤ c := by\n  by_cases h' : N.IsLitter\n  Â· obtain âŸ¨L, rflâŸ© := h'.exists_litter_eq\n    exact h\n  Â· exact Relation.ReflTransGen.head (Constrains.nearLitter B N h') h\n", "additional_info": "", "used_premises": [1, 61, 60, 65, 65, 483], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [352, 358], "informalization": "`ConNF.le_nearLitter` is a theorem in Constructive Ordinal Notation (ConNF) that states that if a near-litter `N` (a pair consisting of a litter and a subset of that litter) is less than or equal to an address `c` in the context of a parameter `Î²` of the ConNF hierarchy, then the near-litter formed by wrapping the litter of `N` with its litter set is also less than or equal to `c`. This theorem is crucial to establishing the well-foundedness of the ConNF hierarchy and proving the consistency of the natural numbers with the ZFC axioms."}
{"full_name": "ConNF.lt_nearLitter", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.lt_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.lt_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : c < { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst) }) :c < { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N }", "code": "theorem lt_nearLitter {Î² : Î›} {N : NearLitter} {B : ExtendedIndex Î²}\n    {c : Address Î²} (h : c < âŸ¨B, inr N.1.toNearLitterâŸ©) : c < âŸ¨B, inr NâŸ© := by\n  by_cases h' : N.IsLitter\n  Â· obtain âŸ¨L, rflâŸ© := h'.exists_litter_eq\n    exact h\n  Â· exact Relation.TransGen.tail h (Constrains.nearLitter B N h')\n", "additional_info": "", "used_premises": [1, 61, 60, 65, 483, 65], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [359, 365], "informalization": "The theorem `ConNF.lt_nearLitter` states that if `c` is an address in the near-litter of `N`, and `c` is less than an address that points to the near-litter of `N`, then `c` is also less than the near-litter of `N` itself. This makes sense because the near-litter of `N` is a more specific address than the near-litter of `N`, and thus any address less than the near-litter of `N` will also be less than the near-litter of `N`."}
{"full_name": "ConNF.lt_nearLitter'", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.lt_nearLitter'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.lt_nearLitter' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } < c) :{ path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst) } < c", "code": "theorem lt_nearLitter' {Î² : Î›} {N : NearLitter} {B : ExtendedIndex Î²}\n    {c : Address Î²} (h : âŸ¨B, inr NâŸ© < c) : âŸ¨B, inr N.1.toNearLitterâŸ© < c := by\n  by_cases h' : N.IsLitter\n  Â· obtain âŸ¨L, rflâŸ© := h'.exists_litter_eq\n    exact h\n  Â· exact Relation.TransGen.head (Constrains.nearLitter B N h') h\n", "additional_info": "", "used_premises": [1, 61, 60, 65, 65, 483], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [366, 372], "informalization": "`ConNF.lt_nearLitter'` is a theorem that helps one prove that if a certain element is less than another element in the context of Constructive Ordinal Notation (ConNF), then another related element is also less than the second element. This theorem is used in the proof of `ConNF.lt_base` to establish the fact that the base type is well-ordered, which is a crucial property for constructing the natural numbers in the ConNF context."}
{"full_name": "ConNF.small_constrains", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.small_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_constrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î² | d â‰º c}", "code": "theorem small_constrains {Î² : Î›} (c : Address Î²) : Small {d | d â‰º c} := by\n  obtain âŸ¨A, a | NâŸ© := c\n  Â· simp only [constrains_atom, setOf_eq_eq_singleton, small_singleton]\n  simp_rw [constrains_iff]\n  refine Small.union ?_ (Small.union ?_ (Small.union ?_ (Small.union ?_ ?_))) <;>\n    rw [small_setOf]\n  Â· change Small {c | âˆƒ b B, _ âˆ§ _ = _}\n    simp only [Address.mk.injEq, false_and, and_false, exists_false,\n      setOf_false, small_empty]\n  Â· change Small {c | âˆƒ B N', _}\n    refine Set.Subsingleton.small ?_\n    rintro c âŸ¨_, _, _, âŸ¨rfl, rflâŸ©, hâ‚âŸ© d âŸ¨_, _, _, âŸ¨rfl, rflâŸ©, hâ‚‚âŸ©\n    cases hâ‚\n    cases hâ‚‚\n    rfl\n  Â· change Small {c | âˆƒ B N' a, _}\n    convert (show Small (litterSet N.fst âˆ† N) from N.2.prop).image\n      (f := fun a : Atom => (âŸ¨A, inl aâŸ© : Address Î²)) using 1\n    ext c : 1\n    simp only [mem_setOf_eq, mem_image]\n    constructor\n    Â· rintro âŸ¨B, N', a, hâ‚, hâ‚‚, hâ‚ƒâŸ©\n      cases hâ‚ƒ\n      exact âŸ¨a, hâ‚, hâ‚‚.symmâŸ©\n    Â· rintro âŸ¨a, hâ‚, hâ‚‚âŸ©\n      exact âŸ¨A, N, a, hâ‚, hâ‚‚.symm, rflâŸ©\n  Â· by_cases h :\n      âˆƒ (Î³ : Î›) (_ : LeLevel Î³) (Î´ : Î›) (_ : LtLevel Î´) (Îµ : Î›) (_ : LtLevel Îµ)\n        (_ : (Î´ : TypeIndex) < Î³) (hÎµ : (Îµ : TypeIndex) < Î³) (hÎ´Îµ : (Î´ : TypeIndex) â‰  Îµ)\n        (B : Path (Î² : TypeIndex) Î³) (t : Tangle Î´),\n        N = (fuzz hÎ´Îµ t).toNearLitter âˆ§ A = (B.cons hÎµ).cons (bot_lt_coe _)\n    Â· obtain âŸ¨Î³, _, Î´, _, Îµ, _, hÎ´, hÎµ, hÎ´Îµ, B, t, rfl, rflâŸ© := h\n      refine lt_of_le_of_lt ?_ t.support.small\n      suffices\n        #{a : Address Î² | âˆƒ c : (t.support : Set (Address Î´)),\n            a = âŸ¨(B.cons hÎ´).comp c.val.path, c.val.valueâŸ©} â‰¤\n          #(t.support : Set (Address Î´)) by\n        refine le_trans (Cardinal.mk_subtype_le_of_subset ?_) this\n        rintro x âŸ¨_, _, _, _, _, _, _, _, _, _, _, c, hc, rfl, hâŸ©\n        rw [Address.mk.injEq] at h\n        simp only [inr.injEq, Litter.toNearLitter_injective.eq_iff] at h\n        cases WithBot.coe_injective (fuzz_congr_Î² h.2)\n        cases fuzz_congr_Î³ h.2\n        cases fuzz_injective _ h.2\n        cases coe_inj.mp (Path.obj_eq_of_cons_eq_cons (Path.heq_of_cons_eq_cons h.1).eq)\n        cases (Path.heq_of_cons_eq_cons (Path.heq_of_cons_eq_cons h.1).eq).eq\n        exact âŸ¨âŸ¨c, hcâŸ©, rflâŸ©\n      refine âŸ¨âŸ¨fun a => a.prop.choose, ?_âŸ©âŸ©\n      intro a b h\n      refine Subtype.coe_inj.mp ?_\n      rw [a.prop.choose_spec, b.prop.choose_spec]\n      simp only [h]\n    Â· refine small_of_forall_not_mem ?_\n      rintro x âŸ¨Î³, _, Î´, _, Îµ, _, hÎ´, hÎµ, hÎ´Îµ, B, t, c, _, rfl, hAâŸ©\n      rw [Address.mk.injEq] at hA\n      simp only [inr.injEq] at hA\n      exact h âŸ¨Î³, inferInstance, Î´, inferInstance, Îµ, inferInstance, hÎ´, hÎµ, hÎ´Îµ, B, t, hA.2, hA.1âŸ©\n  Â· refine Set.Subsingleton.small ?_\n    rintro âŸ¨c, CâŸ© âŸ¨Î³, _, Îµ, _, hÎµ, C', a, hcâ‚, hcâ‚‚âŸ© âŸ¨d, DâŸ© âŸ¨Î³, _, Îµ, _, hÎµ, D', b, hdâ‚, hdâ‚‚âŸ©\n    rw [Address.mk.injEq] at hcâ‚ hcâ‚‚ hdâ‚ hdâ‚‚\n    simp only [inr.injEq] at hcâ‚‚ hdâ‚‚\n    rw [hcâ‚.1, hcâ‚.2, hdâ‚.1, hdâ‚.2]\n    rw [hcâ‚‚.1, hcâ‚‚.2, Litter.toNearLitter_injective.eq_iff] at hdâ‚‚\n    cases coe_inj.mp (Path.obj_eq_of_cons_eq_cons hdâ‚‚.1)\n    cases coe_inj.mp (Path.obj_eq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hdâ‚‚.1).eq)\n    cases (Path.heq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hdâ‚‚.1).eq).eq\n    rw [(fuzz_injective bot_ne_coe).eq_iff] at hdâ‚‚\n    cases hdâ‚‚.2\n    rfl\n", "additional_info": "", "used_premises": [1, 60, 233, 60], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [373, 442], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_constrains` asserts that for any address `c` in the base type `Î²`, the set of addresses `d` that are constrained by `c` (denoted as `d â‰º c`) has a cardinality that is strictly less than the cardinality of the type `ConNF.Îº`. This theorem is crucial for establishing the well-foundedness of the `â‰º` relation on addresses within the ConNF framework."}
{"full_name": "ConNF.reduced_iff", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduced_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reduced_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :âˆ€ (a : ConNF.Atom âŠ• ConNF.NearLitter), ConNF.ReducedğŸ”—<|PREMISE|>ğŸ”— a â†” (âˆƒ (a_1 : ConNF.Atom), a = Sum.inlğŸ”—<|PREMISE|>ğŸ”— a_1) âˆ¨ âˆƒ (L : ConNF.Litter), a = Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L)", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 932, 67, 65, 483], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [31, 32], "informalization": "The theorem `ConNF.reduced_iff` states that an address in Constructive Ordinal Notation (ConNF) is reduced (either an atom or a litter) if and only if it is either the left injection of an atom or the right injection of a litter."}
{"full_name": "ConNF.Reduced", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.Reduced", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Reduced [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :ConNF.Atom âŠ• ConNF.NearLitter â†’ Prop", "code": "inductive Reduced : Atom âŠ• NearLitter â†’ Prop\n  | mkAtom (a : Atom) : Reduced (inl a)\n  | mkLitter (L : Litter) : Reduced (inr L.toNearLitter)\n", "additional_info": "An address is *reduced* if it is an atom or a litter.\n", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [32, 35], "informalization": "Type `ConNF.Reduced` represents the property that an address in Constructive Ordinal Notation (ConNF) is reduced, meaning it is either an atom or a litter."}
{"full_name": "ConNF.isLitter_of_reduced", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.isLitter_of_reduced", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isLitter_of_reduced [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {N : ConNF.NearLitter} (h : ConNF.ReducedğŸ”—<|PREMISE|>ğŸ”— (Sum.inrğŸ”—<|PREMISE|>ğŸ”— N)) :ConNF.NearLitter.IsLitterğŸ”—<|PREMISE|>ğŸ”— N", "code": "theorem isLitter_of_reduced {N : NearLitter} (h : Reduced (inr N)) : N.IsLitter := by\n  cases h\n  exact NearLitter.IsLitter.mk _\n", "additional_info": "", "used_premises": [1, 932, 65, 495], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [36, 39], "informalization": "The theorem `ConNF.isLitter_of_reduced` states that if a near-litter `N` is reduced in the context of Constructive Ordinal Notation (ConNF), then `N` is of the form `L.toNearLitter` for some litter `L`."}
{"full_name": "ConNF.mem_reflTransClosure_of_mem", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.mem_reflTransClosure_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mem_reflTransClosure_of_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hc : c âˆˆ S) :c âˆˆ ConNF.reflTransClosureğŸ”—<|PREMISE|>ğŸ”— S", "code": "theorem mem_reflTransClosure_of_mem (S : Set (Address Î²)) (c : Address Î²)\n    (hc : c âˆˆ S) : c âˆˆ reflTransClosure S :=\n  âŸ¨c, hc, Relation.ReflTransGen.reflâŸ©\n", "additional_info": "", "used_premises": [1, 69, 60, 60, 935], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [44, 47], "informalization": "The theorem `ConNF.mem_reflTransClosure_of_mem` states that if `c` is an element of a set `S` of addresses in the context of Constructive Ordinal Notation (ConNF), then `c` is also an element of the reflexive transitive closure of `S`. This means that `c` can be reached from the addresses in `S` through a finite series of descents."}
{"full_name": "ConNF.reflTransClosure", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.reflTransClosure [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)", "code": "def reflTransClosure (S : Set (Address Î²)) : Set (Address Î²) :=\n  {c | âˆƒ d âˆˆ S, c â‰¤ d}\n", "additional_info": "The reflexive transitive closure of a set of addresses.\nEquations\n* ğŸ—ŸConNF.reflTransClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosureğŸ”—  S ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  {c : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | âˆƒ d âˆˆ S, c ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LE.leğŸ”—  d}\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [41, 43], "informalization": "Function `ConNF.reflTransClosure` computes the reflexive transitive closure of a set of addresses in the context of Constructive Ordinal Notation (ConNF). The reflexive transitive closure of a set `S` of addresses is the set of all addresses `c` such that there exists an address `d` in `S` for which `c` is less than or equal to `d`. This function is crucial in the context of ConNF because it allows us to determine the set of all addresses that can be reached from the addresses in `S` through a finite series of descents."}
{"full_name": "ConNF.mem_reduction_of_reduced", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.mem_reduction_of_reduced", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mem_reduction_of_reduced [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hcâ‚ : ConNF.ReducedğŸ”—<|PREMISE|>ğŸ”— c.value) (hcâ‚‚ : c âˆˆ S) :c âˆˆ ConNF.reductionğŸ”—<|PREMISE|>ğŸ”— S", "code": "theorem mem_reduction_of_reduced (S : Set (Address Î²)) (c : Address Î²)\n    (hcâ‚ : Reduced c.value) (hcâ‚‚ : c âˆˆ S) : c âˆˆ reduction S :=\n  âŸ¨mem_reflTransClosure_of_mem S c hcâ‚‚, hcâ‚âŸ©\n", "additional_info": "", "used_premises": [1, 69, 60, 60, 932, 937], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [57, 60], "informalization": "The theorem `mem_reduction_of_reduced` in Constructive Ordinal Notation (ConNF) states that if an address `c` is reduced and belongs to a set of addresses `S`, then `c` also belongs to the reduction of `S`. The reduction of a set of addresses is the intersection of the reflexive transitive closure of the set under the constraints relation and the set of reduced conditions."}
{"full_name": "ConNF.reduction", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduction", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.reduction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)", "code": "def reduction (S : Set (Address Î²)) : Set (Address Î²) :=\n  reflTransClosure S âˆ© {c | Reduced c.value}\n", "additional_info": "The *reduction* of a set of addresses is the downward closure of the set under\nthe constrains relation, but we only keep reduced conditions.\nEquations\n* ğŸ—ŸConNF.reductionğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reductionğŸ”—  S ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.reflTransClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosureğŸ”—  S ğŸ—Ÿâˆ©ğŸ—ŸğŸ”—../../.././Init/Core.html#Inter.interğŸ”—  {c : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | ğŸ—ŸConNF.ReducedğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.ReducedğŸ”—  c.value}\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [54, 56], "informalization": "Function `ConNF.reduction` computes the reduction of a set of addresses, which is the intersection of the reflexive transitive closure of the set under the constraints relation and the set of reduced conditions."}
{"full_name": "ConNF.mem_reduction_of_reduced_constrains", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.mem_reduction_of_reduced_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mem_reduction_of_reduced_constrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hc : ConNF.ReducedğŸ”—<|PREMISE|>ğŸ”— c.value) (hcd : c â‰º d) (hd : d âˆˆ S) :c âˆˆ ConNF.reductionğŸ”—<|PREMISE|>ğŸ”— S", "code": "theorem mem_reduction_of_reduced_constrains (S : Set (Address Î²))\n    (c d : Address Î²) (hc : Reduced c.value) (hcd : c â‰º d) (hd : d âˆˆ S) :\n    c âˆˆ reduction S :=\n  âŸ¨âŸ¨d, hd, Relation.ReflTransGen.single hcdâŸ©, hcâŸ©\n", "additional_info": "", "used_premises": [1, 69, 60, 60, 60, 932, 937], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [61, 65], "informalization": "The theorem `mem_reduction_of_reduced_constrains` in Constructive Ordinal Notation (ConNF) states that if `c` is a reduced condition, `c` is constrained by `d`, and `d` is in the set `S`, then `c` is in the reduction of `S`."}
{"full_name": "ConNF.small_nthReduction", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.small_nthReduction", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_nthReduction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} {n : â„• } (h : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— S) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.nthClosureğŸ”—<|PREMISE|>ğŸ”— S n)", "code": "theorem small_nthReduction {S : Set (Address Î²)} {n : â„•} (h : Small S) :\n    Small (nthClosure S n) := by\n  induction' n with n hn\n  exact h\n  rw [nthClosure]\n  simp_rw [â† exists_prop, Subtype.exists', setOf_exists]\n  refine' small_iUnion hn _\n  rintro âŸ¨c, _âŸ©\n  exact small_constrains c\n", "additional_info": "The `ğŸ—ŸnthClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.nthClosureğŸ”—`  of a small set is small.", "used_premises": [1, 69, 60, 233, 233, 940], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [72, 81], "informalization": "The `nthClosure` of a small set is small."}
{"full_name": "ConNF.nthClosure", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.nthClosure", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.nthClosure [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) :â„• â†’ SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)", "code": "def nthClosure (S : Set (Address Î²)) : â„• â†’ Set (Address Î²)\n  | 0 => S\n  | n + 1 => {c | âˆƒ d, d âˆˆ nthClosure S n âˆ§ c â‰º d}\n", "additional_info": "Gadget that helps us prove that the `ğŸ—ŸreflTransClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosureğŸ”—`  of a small set is small.\nEquations\n* ğŸ—ŸConNF.nthClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.nthClosureğŸ”—  S 0 ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  S\n* ğŸ—ŸConNF.nthClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.nthClosureğŸ”—  S (ğŸ—ŸNat.succğŸ—ŸğŸ”—../../.././Init/Prelude.html#Nat.succğŸ”—  n) ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  {c : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | âˆƒ d âˆˆ ğŸ—ŸConNF.nthClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.nthClosureğŸ”—  S n, c ğŸ—Ÿâ‰ºğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Constrains.html#ConNF.ConstrainsğŸ”—  d}\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [67, 70], "informalization": "Function `ConNF.nthClosure` is a gadget used in the context of Constructive Ordinal Notation (ConNF) to prove that the reflexive transitive closure of a small set is small. It takes a set `S` of `ConNF.Address` objects and a natural number `n`, and returns the set of all `ConNF.Address` objects that can be reached from `S` in at most `n` steps using the `â‰º` relation, which represents a descent in the ConNF model."}
{"full_name": "ConNF.reflTransClosure_eq_iUnion_nthClosure", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure_eq_iUnion_nthClosure", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reflTransClosure_eq_iUnion_nthClosure [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} :ConNF.reflTransClosureğŸ”—<|PREMISE|>ğŸ”— S = â‹ƒ (n : â„• ), ConNF.nthClosureğŸ”—<|PREMISE|>ğŸ”— S n", "code": "theorem reflTransClosure_eq_iUnion_nthClosure {S : Set (Address Î²)} :\n    reflTransClosure S = â‹ƒ n, nthClosure S n := by\n  refine' subset_antisymm _ _\n  Â· rintro c âŸ¨d, hdS, hdâŸ©\n    obtain âŸ¨l, hl, rflâŸ© := List.exists_chain_of_relationReflTransGen hd\n    rw [mem_iUnion]\n    refine' âŸ¨l.length, _âŸ©\n    rw [mem_nthClosure_iff]\n    refine' âŸ¨l, hl, rfl, hdSâŸ©\n  Â· intro c hc\n    rw [mem_iUnion] at hc\n    obtain âŸ¨i, hcâŸ© := hc\n    rw [mem_nthClosure_iff] at hc\n    obtain âŸ¨l, hlâ‚, _hlâ‚‚, hlâ‚ƒâŸ© := hc\n    exact\n      âŸ¨(c::l).getLast (List.cons_ne_nil _ _), hlâ‚ƒ,\n        List.relationReflTransGen_of_exists_chain l hlâ‚ rflâŸ©\n", "additional_info": "The `ğŸ—ŸreflTransClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosureğŸ”—`  of a set is the `â„•`-indexed union of the `n`th closures.", "used_premises": [1, 69, 60, 935, 940], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [111, 128], "informalization": "Function `ConNF.reflTransClosure` computes the reflexive transitive closure of a set of addresses in the context of Constructive Ordinal Notation (ConNF). The reflexive transitive closure of a set `S` of addresses is the set of all addresses `c` such that there exists an address `d` in `S` for which `c` is less than or equal to `d`. This function is crucial in the context of ConNF because it allows us to determine the set of all addresses that can be reached from the addresses in `S` through a finite series of descents. The theorem `ConNF.reflTransClosure_eq_iUnion_nthClosure` states that the reflexive transitive closure of a set `S` is equal to the `â„•`-indexed union of the `n`th closures of `S`."}
{"full_name": "ConNF.reflTransClosure_small", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reflTransClosure_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} (h : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— S) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.reflTransClosureğŸ”—<|PREMISE|>ğŸ”— S)", "code": "theorem reflTransClosure_small {S : Set (Address Î²)} (h : Small S) :\n    Small (reflTransClosure S) := by\n  rw [reflTransClosure_eq_iUnion_nthClosure]\n  have : Small (â‹ƒ n : ULift â„•, nthClosure S n.down)\n  Â· refine' small_iUnion _ fun _ => small_nthReduction h\n    rw [Cardinal.mk_denumerable]\n    exact aleph0_le_mk_Î›.trans_lt Params.Î›_lt_Îº\n  convert this using 1\n  ext x : 1\n  simp only [mem_iUnion, ULift.exists]\n", "additional_info": "The `ğŸ—ŸreflTransClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosureğŸ”—`  of a small set is small.", "used_premises": [1, 69, 60, 233, 233, 935], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [130, 140], "informalization": "The theorem `ConNF.reflTransClosure_small` states that the reflexive transitive closure of a small set of addresses in the context of Constructive Ordinal Notation (ConNF) is also small. This result is crucial because it ensures that the set of all addresses that can be reached from a small set of addresses through a finite series of descents remains small."}
{"full_name": "ConNF.transClosure_small", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.transClosure_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.transClosure_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} (h : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— S) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.transClosureğŸ”—<|PREMISE|>ğŸ”— S)", "code": "theorem transClosure_small {S : Set (Address Î²)} (h : Small S) :\n    Small (transClosure S) := by\n  refine' lt_of_le_of_lt (Cardinal.mk_le_mk_of_subset _) (reflTransClosure_small h)\n  rintro c âŸ¨d, hdâ‚, hdâ‚‚âŸ©\n  exact âŸ¨d, hdâ‚, hdâ‚‚.to_reflTransGenâŸ©\n", "additional_info": "The `ğŸ—ŸtransClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.transClosureğŸ”—`  of a small set is small.", "used_premises": [1, 69, 60, 233, 233, 944], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [142, 147], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the transitive closure of a small set is also small."}
{"full_name": "ConNF.transClosure", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.transClosure", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.transClosure [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)", "code": "def transClosure (S : Set (Address Î²)) : Set (Address Î²) :=\n  {c | âˆƒ d âˆˆ S, c < d}\n", "additional_info": "The transitive closure of a set of addresses.\nEquations\n* ğŸ—ŸConNF.transClosureğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.transClosureğŸ”—  S ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  {c : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | âˆƒ d âˆˆ S, c ğŸ—Ÿ<ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LT.ltğŸ”—  d}\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [49, 51], "informalization": "Function `ConNF.transClosure` computes the transitive closure of a set of addresses in the context of Constructive Ordinal Notation (ConNF). The transitive closure of a set `S` is the set of all addresses that are strictly less than some address in `S`."}
{"full_name": "ConNF.reduction_small", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduction_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reduction_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} (h : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— S) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.reductionğŸ”—<|PREMISE|>ğŸ”— S)", "code": "theorem reduction_small {S : Set (Address Î²)} (h : Small S) : Small (reduction S) :=\n  lt_of_le_of_lt (Cardinal.mk_subtype_le_of_subset fun _c hc => hc.1) (reflTransClosure_small h)\n", "additional_info": "The `ğŸ—ŸreductionğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reductionğŸ”—`  of a small set is small.", "used_premises": [1, 69, 60, 233, 233, 937], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [149, 151], "informalization": "Function `ConNF.reduction_small` proves that the reduction of a small set is also small in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.reduction_supports", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduction_supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reduction_supports [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (S : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hc : c âˆˆ S) :MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (ConNF.reductionğŸ”—<|PREMISE|>ğŸ”— S) c", "code": "theorem reduction_supports (S : Set (Address Î²)) (c : Address Î²) (hc : c âˆˆ S) :\n    Supports (StructPerm Î²) (reduction S) c := by\n  intro Ï€ hc'\n  obtain âŸ¨B, a | NâŸ© := c\n  Â· exact hc' (mem_reduction_of_reduced _ _ (Reduced.mkAtom a) hc)\n  by_cases h : N.IsLitter\n  Â· obtain âŸ¨L, rflâŸ© := h.exists_litter_eq\n    exact hc' (mem_reduction_of_reduced _ _ (Reduced.mkLitter L) hc)\n  simp only [StructPerm.smul_address_eq_iff, smul_inr, inr.injEq] at hc' âŠ¢\n  have hâ‚ƒ := hc' (mem_reduction_of_reduced_constrains _ âŸ¨B, inr N.fst.toNearLitterâŸ© _\n    (Reduced.mkLitter N.fst) (Constrains.nearLitter B N h) hc)\n  have hâ‚„ := fun a ha => hc' (mem_reduction_of_reduced_constrains _ âŸ¨B, inl aâŸ© _\n    (Reduced.mkAtom a) (Constrains.symmDiff B N a ha) hc)\n  simp only [smul_inr, inr.injEq, smul_inl, inl.injEq] at hâ‚ƒ hâ‚„\n  refine' SetLike.coe_injective _\n  refine' (NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul _ N).trans _\n  rw [hâ‚ƒ]\n  refine' Eq.trans _ (symmDiff_symmDiff_cancel_left (litterSet N.fst) _)\n  refine' congr_arg _ _\n  ext a : 1\n  constructor\n  Â· rintro âŸ¨b, hb, rflâŸ©\n    dsimp only\n    rw [hâ‚„ b hb]\n    exact hb\n  Â· intro ha\n    refine' âŸ¨a, ha, _âŸ©\n    exact hâ‚„ a ha\n", "additional_info": "The reduction of a set supports every element in its domain under the action of structural\npermutations.", "used_premises": [1, 69, 60, 60, 68, 55, 937], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [154, 182], "informalization": "Given the Lean 4 object `ConNF.reduction_supports`, which is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4, it states that the reduction of a set of addresses supports every element in its domain under the action of structural permutations. This theorem is useful in proving the existence of a permutation that normalizes the addresses within the set."}
{"full_name": "ConNF.reduction_support_supports", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduction_support_supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reduction_support_supports [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.TangleDatağŸ”—<|PREMISE|>ğŸ”— â†‘Î²] (t : ConNF.Tangle â†‘Î²) :MulAction.SupportsğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable â†‘Î²) (ConNF.reductionğŸ”—<|PREMISE|>ğŸ”— (ConNF.Enumeration.carrierğŸ”—<|PREMISE|>ğŸ”— (ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”— t).enum)) t", "code": "theorem reduction_support_supports [TangleData Î²] (t : Tangle Î²) :\n    Supports (Allowable Î²) (reduction (t.support : Set (Address Î²))) t := by\n  intro Ï h\n  refine support_supports t Ï ?_\n  intros c hc'\n  exact reduction_supports t.support c hc' (Allowable.toStructPerm Ï) h\n", "additional_info": "", "used_premises": [1, 39, 68, 937, 70, 395], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [183, 189], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.reduction_support_supports` asserts that for any tangle `t` at level `Î²`, the reduction of the carrier set of the small support of `t` supports `t` under the action of the allowable permutations at level `Î²`. This means that if an allowable permutation acts trivially on every element in the reduction of the small support of `t`, then it also acts trivially on `t`."}
{"full_name": "PartialPerm.exists_sandbox_subset", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.exists_sandbox_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.exists_sandbox_subset {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (â„• Ã— â†‘(s \\ f '' s) âŠ• â„• Ã— â†‘(f '' s \\ s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t", "code": "theorem exists_sandbox_subset (hs : #(s âˆ† (f '' s) : Set Î±) â‰¤ #t) (ht : â„µâ‚€ â‰¤ #t) :\n    #((â„• Ã— (s \\ f '' s : Set Î±)) âŠ• (â„• Ã— (f '' s \\ s : Set Î±))) â‰¤ #t := by\n  rw [Set.symmDiff_def, mk_union_of_disjoint] at hs\n  Â· simp only [mk_sum, mk_prod, mk_denumerable, lift_aleph0, lift_uzero, lift_id, â† mul_add] at hs âŠ¢\n    exact le_trans (mul_le_max_of_aleph0_le_left le_rfl) (max_le ht hs)\n  Â· rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem]\n    exact fun x hx => hx.1.2 hx.2.1\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 29, 29], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [31, 38], "informalization": "Given a type Î± and a function f : Î± â†’ Î±, the symmetric difference of two sets s and f '' s is defined as the union of the relative complements s \\ f '' s and f '' s \\ s. This theorem states that if the cardinality of this symmetric difference is at most the cardinality of a set t (hypothesis hs), and the set t has at least the cardinality of the natural numbers (hypothesis ht), then the cardinality of the disjoint union of the natural numbers and the relative complements s \\ f '' s and f '' s \\ s is also at most the cardinality of the set t."}
{"full_name": "PartialPerm.sandboxSubset_subset", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.sandboxSubset_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.sandboxSubset_subset {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) :PartialPerm.sandboxSubsetğŸ”—<|PREMISE|>ğŸ”— hs ht âŠ† t", "code": "theorem sandboxSubset_subset : sandboxSubset hs ht âŠ† t :=\n  (le_mk_iff_exists_subset.mp <| exists_sandbox_subset hs ht).choose_spec.1\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 950], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [43, 45], "informalization": "`PartialPerm.sandboxSubset_subset` is a theorem stating that if the symmetric difference of a set `s` and its image under a function `f` is at most as large as a set `t`, and `t` has at least the cardinality of the natural numbers (denoted as `â„µâ‚€`), then the sandbox subset of `t` created by `PartialPerm.sandboxSubset` is a subset of `t`."}
{"full_name": "PartialPerm.sandboxSubset", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.sandboxSubset", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.sandboxSubset {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) :SetğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def sandboxSubset : Set Î± :=\n  (le_mk_iff_exists_subset.mp <| exists_sandbox_subset hs ht).choose\n", "additional_info": "Creates a \"sandbox\" subset of `t` on which we will define an extension of `f`.\nEquations\n* ğŸ—ŸPartialPerm.sandboxSubsetğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.sandboxSubsetğŸ”—  hs ht ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸExists.chooseğŸ—ŸğŸ”—../../.././Init/Classical.html#Exists.chooseğŸ”—  â‹¯\n\n", "used_premises": [69, 69, 29, 62, 29, 510, 29, 69], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [40, 42], "informalization": "Function `PartialPerm.sandboxSubset` creates a \"sandbox\" subset of `t` on which we will define an extension of `f`."}
{"full_name": "PartialPerm.completeToFun_domain", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeToFun_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.completeToFun_domain {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (x : Î±) (h : x âˆˆ PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht) :PartialPerm.completeToFunğŸ”—<|PREMISE|>ğŸ”— hs ht x âˆˆ PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht", "code": "theorem completeToFun_domain (x : Î±) (h : x âˆˆ completeDomain hs ht) :\n    completeToFun hs ht x âˆˆ completeDomain hs ht := by\n  unfold completeToFun completeDomain\n  split_ifs with hâ‚ hâ‚‚\n  case pos =>\n    cases sandboxSubsetEquiv hs ht âŸ¨x, hâ‚âŸ© with\n    | inl val =>\n      obtain âŸ¨_ | n, xâŸ© := val\n      Â· exact Or.inl (Or.inl x.prop.1)\n      Â· exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n    | inr val =>\n      obtain âŸ¨n, xâŸ© := val\n      exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n  case pos =>\n    exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n  case neg =>\n    rw [mem_diff, not_and_or, Classical.not_not] at hâ‚‚\n    refine Or.inl (Or.inr âŸ¨x, ?_, rflâŸ©)\n    obtain (hâ‚‚ | hâ‚‚) := hâ‚‚\n    Â· obtain (h | h) | h := h\n      exact h\n      cases hâ‚‚ h\n      cases hâ‚ h\n    Â· exact hâ‚‚\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 952, 953, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [84, 108], "informalization": "Function `CompleteToFun` is an internal implementation detail used in the `Equiv` construction to complete a permutation. It is used only as a stepping stone to complete the permutation by placing the remaining elements in their correct positions. The final result of this function is a permutation that extends the given partial permutation to a full permutation, and hence is not relevant for a high-level understanding of the mathematical concepts involved. Instead, one should focus on the lemmas and theorems surrounding `Complete`, which are the actual mathematical components of the `PartialPerm` theory."}
{"full_name": "PartialPerm.completeDomain", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeDomain", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.completeDomain {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) :SetğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def completeDomain : Set Î± :=\n  s âˆª f '' s âˆª sandboxSubset hs ht\n", "additional_info": "The domain on which we will define the completion of a function to a local permutation.\nEquations\n* ğŸ—ŸPartialPerm.completeDomainğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeDomainğŸ”—  hs ht ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  s ğŸ—ŸâˆªğŸ—ŸğŸ”—../../.././Init/Core.html#Union.unionğŸ”—  f ğŸ—Ÿ''ğŸ—ŸğŸ”—../../.././Mathlib/Init/Set.html#Set.imageğŸ”—  s ğŸ—ŸâˆªğŸ—ŸğŸ”—../../.././Init/Core.html#Union.unionğŸ”—  ğŸ—ŸPartialPerm.sandboxSubsetğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.sandboxSubsetğŸ”—  hs ht\n\n", "used_premises": [69, 69, 29, 62, 29, 510, 29, 69], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [81, 83], "informalization": "Function `PartialPerm.completeDomain` defines the domain on which we will define the completion of a function to a local permutation. This domain is the union of three sets: the original set `s`, the image of `s` under the function `f`, and an additional set `sandboxSubset hs ht` which depends on the given conditions `hs` and `ht`."}
{"full_name": "PartialPerm.completeToFun", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeToFun", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def PartialPerm.completeToFun {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (a : Î±) :Î±", "code": "noncomputable def completeToFun (a : Î±) : Î± :=\n  if h : a âˆˆ sandboxSubset hs ht then\n    shiftRight hs ht (sandboxSubsetEquiv hs ht âŸ¨a, hâŸ©)\n  else if h : a âˆˆ f '' s \\ s then\n    (sandboxSubsetEquiv hs ht).symm (Sum.inr âŸ¨0, a, hâŸ©)\n  else\n    f a\n", "additional_info": "Considered an implementation detail; use lemmas about `ğŸ—ŸcompleteğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeğŸ”—`  instead.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [69, 69, 29, 62, 29, 510, 29], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [57, 64], "informalization": "Function `CompleteToFun` is an internal implementation detail used in the `Equiv` construction to complete a permutation. It is used only as a stepping stone to complete the permutation by placing the remaining elements in their correct positions. The final result of this function is a permutation that extends the given partial permutation to a full permutation, and hence is not relevant for a high-level understanding of the mathematical concepts involved. Instead, one should focus on the lemmas and theorems surrounding `Complete`, which are the actual mathematical components of the `PartialPerm` theory."}
{"full_name": "PartialPerm.completeInvFun_domain", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeInvFun_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.completeInvFun_domain {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (x : Î±) (h : x âˆˆ PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht) :PartialPerm.completeInvFunğŸ”—<|PREMISE|>ğŸ”— hs ht x âˆˆ PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht", "code": "theorem completeInvFun_domain [Nonempty Î±] (x : Î±) (h : x âˆˆ completeDomain hs ht) :\n    completeInvFun hs ht x âˆˆ completeDomain hs ht := by\n  unfold completeInvFun completeDomain\n  split_ifs with hâ‚ hâ‚‚\n  case pos =>\n    cases sandboxSubsetEquiv hs ht âŸ¨x, hâ‚âŸ© with\n    | inl val =>\n      obtain âŸ¨n, xâŸ© := val\n      exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n    | inr val =>\n      obtain âŸ¨_ | n, xâŸ© := val\n      Â· exact Or.inl (Or.inr x.prop.1)\n      Â· exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n  case pos =>\n    exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n  case neg =>\n    rw [mem_diff, not_and_or, Classical.not_not] at hâ‚‚\n    obtain (hâ‚‚ | hâ‚‚) := hâ‚‚\n    Â· rw [completeDomain] at h\n      obtain (h | h) | h := h\n      cases hâ‚‚ h\n      Â· refine Or.inl (Or.inl ?_)\n        simp only [mem_image] at h\n        exact invFunOn_mem h\n      cases hâ‚ h\n    simp only [mem_image] at hâ‚‚\n    exact Or.inl (Or.inl (invFunOn_mem hâ‚‚))\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 952, 955, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [109, 136], "informalization": "Function `PartialPerm.completeInvFun` is a noncomputable function that completes the inverse of a partial permutation `f` defined on a subset `s` of a type `Î±`, where `s` and `t` are subsets of `Î±` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` has a cardinality greater than or equal to the smallest infinite cardinal number `â„µâ‚€`. The function returns an element of `Î±` based on the conditions provided."}
{"full_name": "PartialPerm.completeInvFun", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeInvFun", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def PartialPerm.completeInvFun {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (a : Î±) :Î±", "code": "noncomputable def completeInvFun [Nonempty Î±] (a : Î±) : Î± :=\n  if h : a âˆˆ sandboxSubset hs ht then\n    shiftLeft hs ht (sandboxSubsetEquiv hs ht âŸ¨a, hâŸ©)\n  else if h : a âˆˆ s \\ f '' s then\n    (sandboxSubsetEquiv hs ht).symm (Sum.inl âŸ¨0, a, hâŸ©)\n  else\n    invFunOn f s a\n", "additional_info": "Considered an implementation detail; use lemmas about `ğŸ—ŸcompleteğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeğŸ”—`  instead.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [72, 79], "informalization": "Function `PartialPerm.completeInvFun` is a noncomputable function that completes the inverse of a partial permutation `f` defined on a subset `s` of a type `Î±`, where `s` and `t` are subsets of `Î±` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` has a cardinality greater than or equal to the smallest infinite cardinal number `â„µâ‚€`. The function returns an element of `Î±` based on the conditions provided."}
{"full_name": "PartialPerm.complete_left_inv", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete_left_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.complete_left_inv {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (hst : DisjointğŸ”—<|PREMISE|>ğŸ”— (s âˆª f '' s) t) (hf : Set.InjOnğŸ”—<|PREMISE|>ğŸ”— f s) (x : Î±) (h : x âˆˆ PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht) :PartialPerm.completeInvFunğŸ”—<|PREMISE|>ğŸ”— hs ht (PartialPerm.completeToFunğŸ”—<|PREMISE|>ğŸ”— hs ht x) = x", "code": "theorem complete_left_inv [Nonempty Î±] (hst : Disjoint (s âˆª f '' s) t) (hf : InjOn f s) (x : Î±)\n    (h : x âˆˆ completeDomain hs ht) : completeInvFun hs ht (completeToFun hs ht x) = x := by\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem] at hst\n  by_cases hâ‚ : x âˆˆ s\n  Â· rw [completeToFun, dif_neg, dif_neg, completeInvFun, dif_neg, dif_neg]\n    Â· exact hf (invFunOn_apply_mem hâ‚) hâ‚\n          (show f (invFunOn f s (f x)) = f x from invFunOn_apply_eq hâ‚)\n    Â· exact fun h' => h'.2 âŸ¨x, hâ‚, rflâŸ©\n    Â· exact fun hx => hst (f x) âŸ¨Or.inr âŸ¨x, hâ‚, rflâŸ©, sandboxSubset_subset hs ht hxâŸ©\n    Â· exact fun h' => h'.2 hâ‚\n    Â· exact fun hx => hst x âŸ¨Or.inl hâ‚, sandboxSubset_subset hs ht hxâŸ©\n  by_cases hâ‚‚ : x âˆˆ f '' s\n  Â· rw [completeToFun, dif_neg, dif_pos, completeInvFun, dif_pos]\n    simp only [Subtype.coe_prop, Subtype.coe_eta, Equiv.apply_symm_apply]\n    rfl\n    Â· exact ((sandboxSubsetEquiv hs ht).symm _).prop\n    Â· exact âŸ¨hâ‚‚, hâ‚âŸ©\n    Â· exact fun h => hst x âŸ¨Or.inr hâ‚‚, sandboxSubset_subset hs ht hâŸ©\n  obtain (h | h) | h := h\n  Â· cases hâ‚ h\n  Â· cases hâ‚‚ h\n  rw [completeToFun, dif_pos h, completeInvFun]\n  by_cases hâ‚ƒ : âˆƒ a, sandboxSubsetEquiv hs ht âŸ¨x, hâŸ© = Sum.inl âŸ¨0, aâŸ©\n  Â· obtain âŸ¨a, haâŸ© := hâ‚ƒ\n    rw [dif_neg, dif_pos, Subtype.coe_eq_iff]\n    refine' âŸ¨h, _âŸ©\n    simp only [ha]\n    Â· rw [Equiv.symm_apply_eq]\n      Â· simp only [ha, Sum.inl.injEq, Prod.mk.injEq, true_and]\n        rfl\n      Â· rw [ha]\n        exact a.prop\n    Â· rw [ha]\n      exact fun h => hst _ âŸ¨Or.inl a.prop.1, sandboxSubset_subset hs ht hâŸ©\n  have hâ‚„ :\n    (âˆƒ n a, sandboxSubsetEquiv hs ht âŸ¨x, hâŸ© = Sum.inl âŸ¨n + 1, aâŸ©) âˆ¨\n      âˆƒ n a, sandboxSubsetEquiv hs ht âŸ¨x, hâŸ© = Sum.inr âŸ¨n, aâŸ©\n  Â· set val := sandboxSubsetEquiv hs ht âŸ¨x, hâŸ©\n    clear_value val\n    obtain âŸ¨_ | n, bâŸ© | âŸ¨n, bâŸ© := val\n    cases hâ‚ƒ âŸ¨b, rflâŸ©\n    exact Or.inl âŸ¨n, b, rflâŸ©\n    exact Or.inr âŸ¨n, b, rflâŸ©\n  obtain (hâ‚„ | hâ‚„) := hâ‚„ <;>\n    Â· obtain âŸ¨n, a, haâŸ© := hâ‚„\n      rw [dif_pos]\n      simp only [ha]\n      unfold shiftRight\n      simp only [Subtype.coe_eta, Equiv.apply_symm_apply]\n      exact Subtype.coe_inj.mpr ((Equiv.symm_apply_eq _).mpr ha.symm)\n      rw [ha]\n      exact ((sandboxSubsetEquiv hs ht).symm _).prop\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 952, 955, 953], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [137, 189], "informalization": "Given a partial permutation `f` defined on a subset `s` of a type `Î±`, where `s` and `t` are subsets of `Î±` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` has a cardinality greater than or equal to the smallest infinite cardinal number `â„µâ‚€`, and the union of `s` and the image of `s` under `f` is disjoint from `t`, and `f` is injective on `s`, then the completion of `f` to a local permutation is a left inverse."}
{"full_name": "PartialPerm.complete_right_inv", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete_right_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.complete_right_inv {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (hst : DisjointğŸ”—<|PREMISE|>ğŸ”— (s âˆª f '' s) t) (hf : Set.InjOnğŸ”—<|PREMISE|>ğŸ”— f s) (x : Î±) (h : x âˆˆ PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht) :PartialPerm.completeToFunğŸ”—<|PREMISE|>ğŸ”— hs ht (PartialPerm.completeInvFunğŸ”—<|PREMISE|>ğŸ”— hs ht x) = x", "code": "theorem complete_right_inv [Nonempty Î±] (hst : Disjoint (s âˆª f '' s) t) (hf : InjOn f s) (x : Î±)\n    (h : x âˆˆ completeDomain hs ht) : completeToFun hs ht (completeInvFun hs ht x) = x := by\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem] at hst\n  by_cases hâ‚ : x âˆˆ f '' s\n  Â· rw [completeInvFun, dif_neg, dif_neg, completeToFun, dif_neg, dif_neg]\n    Â· exact invFunOn_eq hâ‚\n    Â· exact fun h' => h'.2 (invFunOn_mem hâ‚)\n    Â· exact fun hx => hst _ âŸ¨Or.inl (invFunOn_mem hâ‚), sandboxSubset_subset hs ht hxâŸ©\n    Â· exact fun h' => h'.2 hâ‚\n    Â· exact fun hx => hst x âŸ¨Or.inr hâ‚, sandboxSubset_subset hs ht hxâŸ©\n  by_cases hâ‚‚ : x âˆˆ s\n  Â· rw [completeInvFun, dif_neg, dif_pos, completeToFun, dif_pos]\n    simp only [Subtype.coe_prop, Subtype.coe_eta, Equiv.apply_symm_apply]\n    rfl\n    Â· exact ((sandboxSubsetEquiv hs ht).symm _).prop\n    Â· exact âŸ¨hâ‚‚, hâ‚âŸ©\n    Â· exact fun h => hst x âŸ¨Or.inl hâ‚‚, sandboxSubset_subset hs ht hâŸ©\n  obtain (h | h) | h := h\n  Â· cases hâ‚‚ h\n  Â· cases hâ‚ h\n  rw [completeInvFun, dif_pos h, completeToFun]\n  by_cases hâ‚ƒ : âˆƒ a, sandboxSubsetEquiv hs ht âŸ¨x, hâŸ© = Sum.inr âŸ¨0, aâŸ©\n  Â· obtain âŸ¨a, haâŸ© := hâ‚ƒ\n    rw [dif_neg, dif_pos, Subtype.coe_eq_iff]\n    refine' âŸ¨h, _âŸ©\n    simp only [ha]\n    Â· rw [Equiv.symm_apply_eq]\n      Â· simp only [ha, Sum.inr.injEq, Prod.mk.injEq, true_and]\n        rfl\n      Â· rw [ha]\n        exact a.prop\n    Â· rw [ha]\n      exact fun h => hst _ âŸ¨Or.inr a.prop.1, sandboxSubset_subset hs ht hâŸ©\n  have hâ‚„ :\n    (âˆƒ n a, sandboxSubsetEquiv hs ht âŸ¨x, hâŸ© = Sum.inr âŸ¨n + 1, aâŸ©) âˆ¨\n      âˆƒ n a, sandboxSubsetEquiv hs ht âŸ¨x, hâŸ© = Sum.inl âŸ¨n, aâŸ©\n  Â· set val := sandboxSubsetEquiv hs ht âŸ¨x, hâŸ©\n    clear_value val\n    obtain âŸ¨n, bâŸ© | âŸ¨_ | n, bâŸ© := val\n    exact Or.inr âŸ¨n, b, rflâŸ©\n    cases hâ‚ƒ âŸ¨b, rflâŸ©\n    exact Or.inl âŸ¨n, b, rflâŸ©\n  obtain (hâ‚„ | hâ‚„) := hâ‚„ <;>\n    Â· obtain âŸ¨n, a, haâŸ© := hâ‚„\n      rw [dif_pos]\n      simp only [ha]\n      unfold shiftLeft\n      simp only [Subtype.coe_eta, Equiv.apply_symm_apply]\n      exact Subtype.coe_inj.mpr ((Equiv.symm_apply_eq _).mpr ha.symm)\n      rw [ha]\n      exact ((sandboxSubsetEquiv hs ht).symm _).prop\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 952, 953, 955], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [190, 241], "informalization": "The `PartialPerm.complete_right_inv` theorem in Lean 4 states that for a partial permutation `f` defined on a subset `s` of a type `Î±`, with `s` and `t` being subsets of `Î±` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` having a cardinality greater than or equal to the smallest infinite cardinal number `â„µâ‚€`, if `s âˆª f '' s` and `t` are disjoint, and `f` is injective on `s`, then the completion of `f` to a local permutation, when applied to the completion of its inverse, returns the original element."}
{"full_name": "PartialPerm.completeDomain_eq", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeDomain_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.completeDomain_eq {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] {hst : DisjointğŸ”—<|PREMISE|>ğŸ”— (s âˆª f '' s) t} {hf : Set.InjOnğŸ”—<|PREMISE|>ğŸ”— f s} :(PartialPerm.completeğŸ”—<|PREMISE|>ğŸ”— f s t hs ht hst hf).domain = PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht", "code": "theorem completeDomain_eq : (complete f s t hs ht hst hf).domain = completeDomain hs ht :=\n  rfl\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 959, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [259, 261], "informalization": "Function `PartialPerm.complete` completes a function `f` on a domain `s` into a local permutation that agrees with `f` on `s`, with domain contained in `s âˆª (f '' s) âˆª t`, where `t` is a set that is disjoint from `s âˆª (f '' s)` and has at least the cardinality of the natural numbers `â„µâ‚€`. The function `f` must be injective on `s`. Function `PartialPerm.completeDomain` defines the domain on which we will define the completion of a function to a local permutation. This domain is the union of three sets: the original set `s`, the image of `s` under the function `f`, and an additional set `sandboxSubset hs ht` which depends on the given conditions `hs` and `ht`."}
{"full_name": "PartialPerm.complete", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def PartialPerm.complete {Î± : Type u_1} [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] (f : Î± â†’ Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (t : SetğŸ”—<|PREMISE|>ğŸ”— Î±) (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (hst : DisjointğŸ”—<|PREMISE|>ğŸ”— (s âˆª f '' s) t) (hf : Set.InjOnğŸ”—<|PREMISE|>ğŸ”— f s) :PartialPermğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "noncomputable def complete [Nonempty Î±] (f : Î± â†’ Î±) (s : Set Î±) (t : Set Î±)\n    (hs : #(s âˆ† (f '' s) : Set Î±) â‰¤ #t) (ht : â„µâ‚€ â‰¤ #t) (hst : Disjoint (s âˆª f '' s) t)\n    (hf : InjOn f s) : PartialPerm Î±\n    where\n  toFun := completeToFun hs ht\n  invFun := completeInvFun hs ht\n  domain := completeDomain hs ht\n  toFun_domain' := completeToFun_domain hs ht\n  invFun_domain' := completeInvFun_domain hs ht\n  left_inv' := complete_left_inv hs ht hst hf\n  right_inv' := complete_right_inv hs ht hst hf\n", "additional_info": "Completes a function `f` on a domain `s` into a local permutation that agrees with `f` on `s`,\nwith domain contained in `s âˆª (f '' s) âˆª t`.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [212, 69, 69, 29, 62, 29, 510, 29, 757, 111, 645], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [244, 255], "informalization": "Function `PartialPerm.complete` completes a function `f` on a domain `s` into a local permutation that agrees with `f` on `s`, with domain contained in `s âˆª (f '' s) âˆª t`, where `t` is a set that is disjoint from `s âˆª (f '' s)` and has at least the cardinality of the natural numbers `â„µâ‚€`. The function `f` must be injective on `s`."}
{"full_name": "PartialPerm.mem_completeDomain_of_mem", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.mem_completeDomain_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mem_completeDomain_of_mem {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (x : Î±) (hx : x âˆˆ s) :x âˆˆ PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht", "code": "theorem mem_completeDomain_of_mem (x : Î±) (hx : x âˆˆ s) : x âˆˆ completeDomain hs ht :=\n  Or.inl (Or.inl hx)\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [262, 264], "informalization": "Function `mem_completeDomain_of_mem` proves that if `x` is an element of `s`, then `x` is also an element of `PartialPerm.completeDomain hs ht`."}
{"full_name": "PartialPerm.mem_completeDomain_of_mem_image", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.mem_completeDomain_of_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mem_completeDomain_of_mem_image {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (x : Î±) (hx : x âˆˆ f '' s) :x âˆˆ PartialPerm.completeDomainğŸ”—<|PREMISE|>ğŸ”— hs ht", "code": "theorem mem_completeDomain_of_mem_image (x : Î±) (hx : x âˆˆ f '' s) : x âˆˆ completeDomain hs ht :=\n  Or.inl (Or.inr hx)\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [265, 267], "informalization": "The theorem `mem_completeDomain_of_mem_image` states that if the cardinality of the symmetric difference between a set `s` and its image under a function `f` is less than or equal to the cardinality of a set `t`, and the cardinality of `t` is greater than or equal to the cardinality of the natural numbers, then for any element `x` in the image of `s` under `f`, `x` also belongs to the complete domain of the partial permutation."}
{"full_name": "PartialPerm.not_mem_sandbox_of_mem", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.not_mem_sandbox_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.not_mem_sandbox_of_mem {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (hst : DisjointğŸ”—<|PREMISE|>ğŸ”— (s âˆª f '' s) t) (x : Î±) (hx : x âˆˆ s) :x âˆ‰ PartialPerm.sandboxSubsetğŸ”—<|PREMISE|>ğŸ”— hs ht", "code": "theorem not_mem_sandbox_of_mem (hst : Disjoint (s âˆª f '' s) t) (x : Î±) (hx : x âˆˆ s) :\n    x âˆ‰ sandboxSubset hs ht := by\n  intro h\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem] at hst\n  exact hst x âŸ¨Or.inl hx, sandboxSubset_subset hs ht hâŸ©\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 757, 950], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [268, 273], "informalization": "`PartialPerm.not_mem_sandbox_of_mem` is a theorem in Lean 4 that states that if the cardinality of the symmetric difference between a set `s` and the image of `s` under a function `f` is less than or equal to the cardinality of a set `t`, and if the cardinality of `t` is infinite, and if the union of `s` and the image of `s` under `f` is disjoint from `t`, then for any element `x` in `s`, `x` is not in the sandbox subset of `t`."}
{"full_name": "PartialPerm.not_mem_sandbox_of_mem_image", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.not_mem_sandbox_of_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.not_mem_sandbox_of_mem_image {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (hst : DisjointğŸ”—<|PREMISE|>ğŸ”— (s âˆª f '' s) t) (x : Î±) (hx : x âˆˆ f '' s) :x âˆ‰ PartialPerm.sandboxSubsetğŸ”—<|PREMISE|>ğŸ”— hs ht", "code": "theorem not_mem_sandbox_of_mem_image (hst : Disjoint (s âˆª f '' s) t) (x : Î±) (hx : x âˆˆ f '' s) :\n    x âˆ‰ sandboxSubset hs ht := by\n  intro h\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem] at hst\n  exact hst x âŸ¨Or.inr hx, sandboxSubset_subset hs ht hâŸ©\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 757, 950], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [274, 279], "informalization": "The theorem `not_mem_sandbox_of_mem_image` states that if the symmetric difference between a set `s` and its image under a function `f` has a cardinality less than or equal to the cardinality of a set `t`, and `t` is disjoint from the union of `s` and its image under `f`, then any element in the image of `s` under `f` does not belong to the sandbox subset of `t`."}
{"full_name": "PartialPerm.complete_apply_eq", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.complete_apply_eq {Î± : Type u_1} {f : Î± â†’ Î±} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î±} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î±} (hs : Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— s (f '' s)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) (ht : Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘t) [NonemptyğŸ”—<|PREMISE|>ğŸ”— Î±] {hst : DisjointğŸ”—<|PREMISE|>ğŸ”— (s âˆª f '' s) t} {hf : Set.InjOnğŸ”—<|PREMISE|>ğŸ”— f s} (x : Î±) (hx : x âˆˆ s) :(PartialPerm.completeğŸ”—<|PREMISE|>ğŸ”— f s t hs ht hst hf).toFun x = f x", "code": "theorem complete_apply_eq (x : Î±) (hx : x âˆˆ s) : complete f s t hs ht hst hf x = f x := by\n  rw [complete, coe_mk, completeToFun, dif_neg, dif_neg]\n  exact fun h' => h'.2 hx\n  exact not_mem_sandbox_of_mem hs ht hst x hx\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 959], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [281, 285], "informalization": "The `partialPerm.complete_apply_eq` theorem in Lean 4 shows that, given a function `f` that is injective on a set `s`, and a set `t` such that the symmetric difference between `s` and `f '' s` (the image of `s` under `f`) is smaller than or equal to `t` and `t` has at least the cardinality of the natural numbers, the function `f` itself is equal to the complete function `partialPerm.complete f s t hs ht hst hf` when restricted to `s`."}
{"full_name": "ConNF.StructApprox.atom_injective_extends", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.atom_injective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.atom_injective_extends [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {a : ConNF.Atom} {b : ConNF.Atom} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hac : { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hbc : { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— b } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (h : ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a = ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A b) :a = b", "code": "theorem atom_injective_extends {c d : Address Î²} (hcd : (ihsAction Ï€ c d).Lawful)\n    {a b : Atom} {A : ExtendedIndex Î²} (hac : âŸ¨A, inl aâŸ© âˆˆ reflTransConstrained c d)\n    (hbc : âŸ¨A, inl bâŸ© âˆˆ reflTransConstrained c d)\n    (h : Ï€.completeAtomMap A a = Ï€.completeAtomMap A b) : a = b :=\n  by\n  by_cases ha : a âˆˆ (Ï€ A).atomPerm.domain <;> by_cases hb : b âˆˆ (Ï€ A).atomPerm.domain\n  Â· rw [completeAtomMap_eq_of_mem_domain ha, completeAtomMap_eq_of_mem_domain hb] at h\n    exact (Ï€ A).atomPerm.injOn ha hb h\n  Â· rw [completeAtomMap_eq_of_mem_domain ha, completeAtomMap_eq_of_not_mem_domain hb] at h\n    cases\n      (Ï€ A).not_mem_domain_of_mem_largestSublitter (Subtype.coe_eq_iff.mp h.symm).choose\n        ((Ï€ A).atomPerm.map_domain ha)\n  Â· rw [completeAtomMap_eq_of_not_mem_domain ha, completeAtomMap_eq_of_mem_domain hb] at h\n    cases\n      (Ï€ A).not_mem_domain_of_mem_largestSublitter (Subtype.coe_eq_iff.mp h).choose\n        ((Ï€ A).atomPerm.map_domain hb)\n  Â· rw [completeAtomMap_eq_of_not_mem_domain ha, completeAtomMap_eq_of_not_mem_domain hb] at h\n    have hâ‚ := (Subtype.coe_eq_iff.mp h).choose.1\n    have hâ‚‚ :=\n      (((Ï€ A).largestSublitter b.1).equiv ((Ï€ A).largestSublitter (Ï€.completeLitterMap A b.1))\n            âŸ¨b, (Ï€ A).mem_largestSublitter_of_not_mem_domain b hbâŸ©).prop.1\n    have := (hcd A).litterMap_injective (fst_transConstrained hac) (fst_transConstrained hbc) ?_\n    Â· have := eq_of_sublitter_bijection_apply_eq h this (by rw [this])\n      exact this\n    Â· refine' NearLitter.inter_nonempty_of_fst_eq_fst _\n      simp only [ihsAction_litterMap, completeNearLitterMap_fst_eq]\n      exact eq_of_mem_litterSet_of_mem_litterSet hâ‚ hâ‚‚\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 60, 60, 809, 966, 61, 67, 967, 67, 967, 784, 784], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [15, 42], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.atom_injective_extends` states that, given a `Î²`-structural approximation `Ï€` and two addresses `c` and `d` such that the `Î²`-structural action `ConNF.StructApprox.ihsAction Ï€ c d` is lawful, if two atoms `a` and `b` are mapped to the same atom by the function `ConNF.StructApprox.completeAtomMap Ï€ A` for some `Î²`-extended index `A`, then `a` must be equal to `b`."}
{"full_name": "ConNF.StructApprox.ihsAction", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.ihsAction", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.ihsAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²", "code": "noncomputable def ihsAction (Ï€ : StructApprox Î²) (c d : Address Î²) : StructAction Î² :=\n  fun B =>\n  { atomMap := fun a => âŸ¨âŸ¨B, inl aâŸ© âˆˆ transConstrained c d,\n      fun _ => Ï€.completeAtomMap B aâŸ©\n    litterMap := fun L => âŸ¨âŸ¨B, inr L.toNearLitterâŸ© âˆˆ transConstrained c d,\n      fun _ => Ï€.completeNearLitterMap B L.toNearLitterâŸ©\n    atomMap_dom_small := by\n      exact Small.union (ihAction Ï€.foaHypothesis B).atomMap_dom_small\n        (ihAction Ï€.foaHypothesis B).atomMap_dom_small\n    litterMap_dom_small := by\n      exact Small.union (ihAction Ï€.foaHypothesis B).litterMap_dom_small\n        (ihAction Ï€.foaHypothesis B).litterMap_dom_small }\n", "additional_info": "An object like `ih_action` that can take two addresses.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 60, 60, 808], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [173, 185], "informalization": "Function `ConNF.StructApprox.ihsAction` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.reflTransConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.reflTransConstrained [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)", "code": "def reflTransConstrained (c d : Address Î²) : Set (Address Î²) :=\n  {e | e â‰¤ c} âˆª {e | e â‰¤ d}\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.reflTransConstrainedğŸ—ŸğŸ”—../../.././ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrainedğŸ”—  c d ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  {e : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | e ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LE.leğŸ”—  c} ğŸ—ŸâˆªğŸ—ŸğŸ”—../../.././Init/Core.html#Union.unionğŸ”—  {e : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | e ğŸ—Ÿâ‰¤ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LE.leğŸ”—  d}\n\n", "used_premises": [1, 60, 60, 69, 60], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [18, 20], "informalization": "Function `ConNF.StructApprox.reflTransConstrained` defines a set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.inOut_def", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.inOut_def", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.inOut_def [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€ : ConNF.NearLitterPerm} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.InOutğŸ”—<|PREMISE|>ğŸ”— Ï€ a L â†” Xor'ğŸ”—<|PREMISE|>ğŸ”— (a.1 = L) ((Ï€ â€¢ a).1 = Ï€ â€¢ L)", "code": "theorem inOut_def {Ï€ : NearLitterPerm} {a : Atom} {L : Litter} :\n    InOut Ï€ a L â†” Xor' (a.1 = L) ((Ï€ â€¢ a).1 = Ï€ â€¢ L) :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 969, 970], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [46, 49], "informalization": "The theorem `ConNF.StructApprox.inOut_def` states that for a near litter permutation `Ï€`, an atom `a`, and a litter `L`, the predicate `ConNF.StructApprox.InOut Ï€ a L` holds if and only if either `a` is equal to `L` or `Ï€ â€¢ a` is equal to `Ï€ â€¢ L`, but not both."}
{"full_name": "ConNF.StructApprox.InOut", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.InOut", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.InOut [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterPerm) (a : ConNF.Atom) (L : ConNF.Litter) :Prop", "code": "def InOut (Ï€ : NearLitterPerm) (a : Atom) (L : Litter) : Prop :=\n  Xor' (a.1 = L) ((Ï€ â€¢ a).1 = Ï€ â€¢ L)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.InOutğŸ—ŸğŸ”—../../.././ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.InOutğŸ”—  Ï€ a L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸXor'ğŸ—ŸğŸ”—../../.././Mathlib/Init/Logic.html#Xor'ğŸ”—  (a.1 ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  L) ((Ï€ ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  a).1 ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  Ï€ ğŸ—Ÿâ€¢ğŸ—ŸğŸ”—../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMulğŸ”—  L)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [43, 45], "informalization": "Function `ConNF.StructApprox.InOut` is a predicate used in the context of Constructive Ordinal Notation (ConNF) to determine the relationship between an atom `a`, a litter `L`, and a near litter permutation `Ï€`. It checks if either `a` is equal to `L` or `Ï€ â€¢ a` is equal to `Ï€ â€¢ L`, but not both."}
{"full_name": "Xor'", "url": "Mathlib/Init/Logic.html#Xor'", "code_src": "mathlib4", "ptype": "def", "header": "def Xor' (a : Prop ) (b : Prop ) :Prop", "code": "def Xor' (a b : Prop) := (a âˆ§ Â¬ b) âˆ¨ (b âˆ§ Â¬ a)\n", "additional_info": "Equations\n* ğŸ—ŸXor'ğŸ—ŸğŸ”—../.././Mathlib/Init/Logic.html#Xor'ğŸ”—  a b ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  (a ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../.././Init/Prelude.html#AndğŸ”—  ğŸ—ŸÂ¬ğŸ—ŸğŸ”—../.././Init/Prelude.html#NotğŸ”— b ğŸ—Ÿâˆ¨ğŸ—ŸğŸ”—../.././Init/Prelude.html#OrğŸ”—  b ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../.././Init/Prelude.html#AndğŸ”—  ğŸ—ŸÂ¬ğŸ—ŸğŸ”—../.././Init/Prelude.html#NotğŸ”— a)\n\n", "used_premises": [], "def_path": "Mathlib/Init/Logic.lean", "pos": [95, 96], "informalization": "Function `Xor'` defines the exclusive or operation between two propositions `a` and `b`, asserting that exactly one of them is true."}
{"full_name": "ConNF.StructApprox.isException_of_inOut", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.isException_of_inOut", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.isException_of_inOut [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€ : ConNF.NearLitterPerm} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.InOutğŸ”—<|PREMISE|>ğŸ”— Ï€ a L â†’ ConNF.NearLitterPerm.IsExceptionğŸ”—<|PREMISE|>ğŸ”— Ï€ a âˆ¨ ConNF.NearLitterPerm.IsExceptionğŸ”—<|PREMISE|>ğŸ”— Ï€ (Ï€ â€¢ a)", "code": "theorem isException_of_inOut {Ï€ : NearLitterPerm} {a : Atom} {L : Litter} :\n    InOut Ï€ a L â†’ Ï€.IsException a âˆ¨ Ï€.IsException (Ï€ â€¢ a) := by\n  rintro (âŸ¨rfl, haâŸ© | ha)\n  Â· refine' Or.inr (Or.inr _)\n    intro h\n    rw [mem_litterSet, eq_inv_smul_iff] at h\n    rw [â† h, inv_smul_smul] at ha\n    exact ha rfl\n  Â· refine' Or.inl (Or.inl _)\n    rw [mem_litterSet, ha.1, smul_left_cancel_iff]\n    exact Ne.symm ha.2\n", "additional_info": "", "used_premises": [1, 969, 801, 801], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [52, 63], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a near litter permutation `Ï€`, an atom `a`, and a litter `L`, if either `a` is equal to `L` or `Ï€ â€¢ a` is equal to `Ï€ â€¢ L`, but not both, then either `Ï€` is an exception with respect to `a` or `Ï€` is an exception with respect to `Ï€ â€¢ a`."}
{"full_name": "ConNF.StructApprox.Biexact.constrains", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.Biexact.constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Biexact.constrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Ï€' : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : ConNF.StructApprox.BiexactğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' c) (h' : d â‰¤ c) :ConNF.StructApprox.BiexactğŸ”—<|PREMISE|>ğŸ”— Ï€ Ï€' d", "code": "theorem Biexact.constrains {Î² : Î›} {Ï€ Ï€' : StructPerm Î²} {c d : Address Î²}\n    (h : Biexact Ï€ Ï€' c) (h' : d â‰¤ c) : Biexact Ï€ Ï€' d :=\n  âŸ¨fun A a ha => h.smul_eq_smul_atom A a (ha.trans h'), fun A L hL =>\n    h.smul_eq_smul_litter A L (hL.trans h'), fun A L hL => h.exact A L (hL.trans h')âŸ©\n", "additional_info": "", "used_premises": [1, 55, 55, 60, 60, 973, 973], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [80, 84], "informalization": "The theorem `ConNF.StructApprox.Biexact.constrains` states that if two structural permutations `Ï€` and `Ï€'` are biexact with respect to an address `c`, and `d` is an address that is less than or equal to `c`, then `Ï€` and `Ï€'` are also biexact with respect to `d`."}
{"full_name": "ConNF.StructApprox.Biexact", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.Biexact", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructApprox.Biexact [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (Ï€' : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Prop\n | smul_eq_smul_atom : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) (a : ConNF.Atom), { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } â‰¤  c â†’ Ï€ A â€¢  a =  Ï€' A â€¢  a\n | smul_eq_smul_litter : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) (L : ConNF.Litter),\n { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”—  L) } â‰¤  c â†’ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”—  A L â†’ Ï€ A â€¢  L =  Ï€' A â€¢  L\n | exact : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) (L : ConNF.Litter),\n { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”—  L) } â‰¤  c â†’\n Ï€ A â€¢  L =  Ï€' A â€¢  L â†’ Ï€ A â€¢  ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”—  L =  Ï€' A â€¢  ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”—  L", "code": "structure Biexact {Î² : Î›} (Ï€ Ï€' : StructPerm Î²) (c : Address Î²) : Prop where\n  smul_eq_smul_atom :\n    âˆ€ A : ExtendedIndex Î²,\n      âˆ€ a : Atom, âŸ¨A, inl aâŸ© â‰¤ c â†’ Ï€ A â€¢ a = Ï€' A â€¢ a\n  smul_eq_smul_litter :\n    âˆ€ A : ExtendedIndex Î²,\n      âˆ€ L : Litter,\n        âŸ¨A, inr L.toNearLitterâŸ© â‰¤ c â†’\n          Flexible A L â†’ Ï€ A â€¢ L = Ï€' A â€¢ L\n  exact :\n    âˆ€ A : ExtendedIndex Î²,\n      âˆ€ L : Litter,\n        âŸ¨A, inr L.toNearLitterâŸ© â‰¤ c â†’\n          Ï€ A â€¢ L = Ï€' A â€¢ L â†’\n            Ï€ A â€¢ L.toNearLitter = Ï€' A â€¢ L.toNearLitter\n", "additional_info": "", "used_premises": [1, 55, 55, 60, 61, 67, 61, 65, 483, 842, 61, 65, 483, 483, 483], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [64, 79], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the structure `ConNF.StructApprox.Biexact` defines a property of two structural permutations `Ï€` and `Ï€'` being *biexact* with respect to a given address `c`. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. Specifically, it requires that for any extended index `A` and any atom `a`, if `âŸ¨A, inl aâŸ© â‰¤ c`, then `Ï€ A â€¢ a = Ï€' A â€¢ a`. Additionally, for any extended index `A` and any litter `L`, if `âŸ¨A, inr L.toNearLitterâŸ© â‰¤ c` and `L` is flexible, then `Ï€ A â€¢ L = Ï€' A â€¢ L`. Lastly, for any extended index `A` and any litter `L`, if `âŸ¨A, inr L.toNearLitterâŸ© â‰¤ c` and `Ï€ A â€¢ L = Ï€' A â€¢ L`, then `Ï€ A â€¢ L.toNearLitter = Ï€' A â€¢ L.toNearLitter`."}
{"full_name": "ConNF.StructApprox.Biexact.smul_eq_smul", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.Biexact.smul_eq_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Biexact.smul_eq_smul [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï€ : ConNF.Allowable â†‘Î²} {Ï€' : ConNF.Allowable â†‘Î²} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : ConNF.StructApprox.BiexactğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable.toStructPerm Ï€) (ConNF.Allowable.toStructPerm Ï€') c) :Ï€ â€¢ c = Ï€' â€¢ c", "code": "theorem Biexact.smul_eq_smul {Î² : Î›} [LeLevel Î²] {Ï€ Ï€' : Allowable Î²} {c : Address Î²}\n    (h : Biexact (Allowable.toStructPerm Ï€) (Allowable.toStructPerm Ï€') c) :\n    Ï€ â€¢ c = Ï€' â€¢ c := by\n  revert h\n  refine' WellFounded.induction (C := fun c => Biexact _ _ c â†’ Ï€ â€¢ c = Ï€' â€¢ c)\n    (constrains_wf Î²) c _\n  clear c\n  intro c ih h\n  simp only [Allowable.smul_address_eq_smul_iff] at ih âŠ¢\n  obtain âŸ¨A, a | NâŸ© := c\n  Â· simp only [smul_inl, inl.injEq]\n    exact h.smul_eq_smul_atom A a Relation.ReflTransGen.refl\n  simp only [smul_inr, inr.injEq]\n  by_cases hL : N.IsLitter\n  swap\n  Â· have := ih _ (Constrains.nearLitter A N hL)\n      (h.constrains (le_nearLitter Relation.ReflTransGen.refl))\n    simp only [smul_inr, inr.injEq] at this\n    refine' SetLike.coe_injective _\n    refine' (NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul _ _).trans _\n    refine' Eq.trans _ (NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul _ _).symm\n    refine' congr_argâ‚‚ _ (congr_arg SetLike.coe this) _\n    ext a : 1\n    constructor\n    Â· rintro âŸ¨b, hb, rflâŸ©\n      have := ih _ (Constrains.symmDiff A N b hb)\n        (h.constrains (Relation.ReflTransGen.single <| Constrains.symmDiff A N b hb))\n      simp only [smul_inl, inl.injEq] at this\n      exact âŸ¨b, hb, this.symmâŸ©\n    Â· rintro âŸ¨b, hb, rflâŸ©\n      have := ih _ (Constrains.symmDiff A N b hb)\n        (h.constrains (Relation.ReflTransGen.single <| Constrains.symmDiff A N b hb))\n      simp only [smul_inl, inl.injEq] at this\n      exact âŸ¨b, hb, thisâŸ©\n  obtain âŸ¨L, rflâŸ© := hL.exists_litter_eq\n  suffices\n    Allowable.toStructPerm Ï€ A â€¢ L =\n    Allowable.toStructPerm Ï€' A â€¢ L\n    from h.exact _ _ Relation.ReflTransGen.refl this\n  obtain hL | hL := flexible_cases A L\n  swap\n  Â· exact h.smul_eq_smul_litter A L Relation.ReflTransGen.refl hL\n  induction' hL with Î³ _ Î´ _ Îµ _ hÎ´ hÎµ hÎ´Îµ B t Î³ _ Îµ _ hÎµ B a\n  Â· have := toStructPerm_smul_fuzz' hÎ´ hÎµ hÎ´Îµ\n    have hâ‚ := this (Allowable.comp B Ï€) t\n    have hâ‚‚ := this (Allowable.comp B Ï€') t\n    rw [Allowable.toStructPerm_comp, Allowable.comp_eq] at hâ‚ hâ‚‚\n    refine hâ‚.trans (hâ‚‚.trans ?_).symm\n    refine' congr_arg _ _\n    rw [â† inv_smul_eq_iff, smul_smul]\n    refine' support_supports t _ _\n    intro c hc\n    rw [mul_smul, inv_smul_eq_iff]\n    simp only [Allowable.toStructPerm_smul, Allowable.toStructPerm_comp, Tree.comp_comp]\n    have := ih âŸ¨(B.cons hÎ´).comp c.path, c.valueâŸ© ?_ ?_\n    Â· simp only [Path.comp_cons, Path.comp_nil, StructPerm.smul_address_eq_smul_iff,\n        Tree.comp_apply]\n      exact this.symm\n    Â· exact Constrains.fuzz hÎ´ hÎµ hÎ´Îµ _ _ _ hc\n    Â· refine' h.constrains (Relation.ReflTransGen.single _)\n      exact Constrains.fuzz hÎ´ hÎµ hÎ´Îµ _ _ _ hc\n  Â· have := toStructPerm_smul_fuzz' (bot_lt_coe _) hÎµ bot_ne_coe\n    have hâ‚ := this (Allowable.comp B Ï€) a\n    have hâ‚‚ := this (Allowable.comp B Ï€') a\n    rw [Allowable.toStructPerm_comp, Allowable.comp_eq] at hâ‚ hâ‚‚\n    refine hâ‚.trans (hâ‚‚.trans ?_).symm\n    refine' congr_arg _ _\n    refine (comp_bot_smul_atom _ _ _).trans ?_\n    refine ((comp_bot_smul_atom _ _ _).trans ?_).symm\n    simp only [Allowable.toStructPerm_comp, Tree.comp_apply]\n    have := ih âŸ¨B.cons <| bot_lt_coe _, inl aâŸ© ?_ ?_\n    Â· simp only [smul_inl, inl.injEq] at this\n      exact this\n    Â· exact Constrains.fuzz_bot hÎµ _ _\n    Â· refine' h.constrains (Relation.ReflTransGen.single _)\n      exact Constrains.fuzz_bot hÎµ _ _\n", "additional_info": "", "used_premises": [1, 402, 60, 973], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [85, 161], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.Biexact.smul_eq_smul` states that if two structural permutations `Ï€` and `Ï€'` are biexact with respect to a given address `c`, then `Ï€ â€¢ c = Ï€' â€¢ c`. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. Specifically, it requires that for any extended index `A` and any atom `a`, if `âŸ¨A, inl aâŸ© â‰¤ c`, then `Ï€ A â€¢ a = Ï€' A â€¢ a`. Additionally, for any extended index `A` and any litter `L`, if `âŸ¨A, inr L.toNearLitterâŸ© â‰¤ c` and `L` is flexible, then `Ï€ A â€¢ L = Ï€' A â€¢ L`. Lastly, for any extended index `A` and any litter `L`, if `âŸ¨A, inr L.toNearLitterâŸ© â‰¤ c` and `Ï€ A â€¢ L = Ï€' A â€¢ L`, then `Ï€ A â€¢ L.toNearLitter = Ï€' A â€¢ L.toNearLitter`."}
{"full_name": "ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï€ : ConNF.Allowable â†‘Î²} {Ï€' : ConNF.Allowable â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} (h : ConNF.StructApprox.BiexactğŸ”—<|PREMISE|>ğŸ”— (ConNF.Allowable.toStructPerm Ï€) (ConNF.Allowable.toStructPerm Ï€') { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N }) :ConNF.Allowable.toStructPerm Ï€ A â€¢ N = ConNF.Allowable.toStructPerm Ï€' A â€¢ N", "code": "theorem Biexact.smul_eq_smul_nearLitter {Î² : Î›} [LeLevel Î²]\n    {Ï€ Ï€' : Allowable Î²} {A : ExtendedIndex Î²} {N : NearLitter}\n    (h : Biexact (Allowable.toStructPerm Ï€) (Allowable.toStructPerm Ï€') âŸ¨A, inr NâŸ©) :\n    Allowable.toStructPerm Ï€ A â€¢ N =\n    Allowable.toStructPerm Ï€' A â€¢ N := by\n  have := h.smul_eq_smul\n  simp only [Allowable.toStructPerm_smul, StructPerm.smul_address_eq_smul_iff, smul_inr,\n    inr.injEq] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 402, 61, 973, 65], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [162, 171], "informalization": "The theorem `ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter` states that, within the context of Constructive Ordinal Notation (ConNF), for two structural permutations `Ï€` and `Ï€'` that are *biexact* with respect to a given address `c`, and for any extended index `A` and any near litter `N` such that `âŸ¨A, inr NâŸ© â‰¤ c`, the result of applying `Ï€ A` to `N` is equal to the result of applying `Ï€' A` to `N`. This is a key property in ensuring the consistency of the construction of the natural numbers in ConNF."}
{"full_name": "ConNF.StructApprox.mem_dom_of_exactlyApproximates", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.mem_dom_of_exactlyApproximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.mem_dom_of_exactlyApproximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï€â‚€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€ : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} {L : ConNF.Litter} (h : ConNF.StructApprox.InOutğŸ”—<|PREMISE|>ğŸ”— (Ï€ A) a L) :a âˆˆ (Ï€â‚€ A).atomPerm.domain", "code": "theorem mem_dom_of_exactlyApproximates {Î² : Î›} [LeLevel Î²] {Ï€â‚€ : StructApprox Î²} {Ï€ : StructPerm Î²}\n    (hÏ€ : Ï€â‚€.ExactlyApproximates Ï€) {A : ExtendedIndex Î²} {a : Atom} {L : Litter}\n    (h : InOut (Ï€ A) a L) :\n    a âˆˆ (Ï€â‚€ A).atomPerm.domain := by\n  obtain h | h := isException_of_inOut h\n  Â· exact (hÏ€ A).exception_mem _ h\n  Â· have hâ‚ := (hÏ€ A).exception_mem _ h\n    have := (hÏ€ A).symm_map_atom _ hâ‚\n    rw [inv_smul_smul] at this\n    rw [â† this]\n    exact (Ï€â‚€ A).atomPerm.symm.map_domain hâ‚\n", "additional_info": "", "used_premises": [1, 402, 781, 55, 803, 61, 969], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [172, 183], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem establishes that if a `Î²`-structural approximation exactly approximates a `Î²`-structural permutation, then for any given `Î²`-extended index `A` and elements `a`, `L` such that `a` is not equal to `L` and the permutation of `a` is not equal to the permutation of `L`, `a` must be in the domain of the near-litter permutation assigned to `A` by the `Î²`-structural approximation."}
{"full_name": "ConNF.StructApprox.constrainedAction_comp_mapFlexible", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.constrainedAction_comp_mapFlexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_comp_mapFlexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {Î³ : ConNF.Î›} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} {hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s} (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) :ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs))", "code": "theorem constrainedAction_comp_mapFlexible (hÏ€f : Ï€.Free) {Î³ : Î›} {s : Set (Address Î²)}\n    {hs : Small s} (A : Path (Î² : TypeIndex) Î³) :\n    StructAction.MapFlexible ((constrainedAction Ï€ s hs).comp A) := by\n  rintro B L âŸ¨c, hc, hLâ‚âŸ© hLâ‚‚\n  simp only [Tree.comp_apply, constrainedAction_litterMap,\n    foaHypothesis_nearLitterImage]\n  rw [completeNearLitterMap_fst_eq]\n  obtain hLâ‚ƒ | (âŸ¨âŸ¨hLâ‚ƒâŸ©âŸ© | âŸ¨âŸ¨hLâ‚ƒâŸ©âŸ©) := flexible_cases' (A.comp B) L\n  Â· rw [completeLitterMap_eq_of_flexible hLâ‚ƒ]\n    refine' NearLitterApprox.flexibleCompletion_smul_flexible _ _ _ _ hLâ‚‚\n    intro L' hL'\n    exact flexible_of_comp_flexible (hÏ€f (A.comp B) L' hL')\n  Â· rw [completeLitterMap_eq_of_inflexibleBot hLâ‚ƒ]\n    obtain âŸ¨âŸ¨Î´, Îµ, hÎµ, C, hCâŸ©, a, rflâŸ© := hLâ‚ƒ\n    contrapose hLâ‚‚\n    rw [not_flexible_iff] at hLâ‚‚ âŠ¢\n    rw [inflexible_iff] at hLâ‚‚\n    obtain âŸ¨Î´', _, Îµ', _, Î¶', _, _, hÎ¶', hÎµÎ¶', C', t', rfl, h'âŸ© |\n        âŸ¨Î´', _, Îµ', _, hÎµ', C', a', rfl, h'âŸ© := hLâ‚‚\n    Â· have := congr_arg Litter.Î² h'\n      simp only [fuzz_Î², bot_ne_coe] at this\n    Â· rw [Path.comp_cons, Path.comp_cons] at hC\n      cases coe_eq_coe.mp (Path.obj_eq_of_cons_eq_cons hC)\n      have hC := (Path.heq_of_cons_eq_cons hC).eq\n      cases coe_eq_coe.mp (Path.obj_eq_of_cons_eq_cons hC)\n      exact Inflexible.mk_bot hÎµ _ _\n  Â· rw [completeLitterMap_eq_of_inflexible_coe' hLâ‚ƒ]\n    split_ifs\n    swap\n    Â· exact hLâ‚‚\n    obtain âŸ¨âŸ¨Î´, Îµ, Î¶, hÎµ, hÎ¶, hÎµÎ¶, C, hCâŸ©, t, rflâŸ© := hLâ‚ƒ\n    contrapose hLâ‚‚\n    rw [not_flexible_iff] at hLâ‚‚ âŠ¢\n    rw [inflexible_iff] at hLâ‚‚\n    obtain âŸ¨Î´', _, Îµ', _, Î¶', _, hÎµ', hÎ¶', hÎµÎ¶', C', t', rfl, h'âŸ© |\n        âŸ¨Î´', _, Îµ', _, hÎµ', C', a', rfl, h'âŸ© := hLâ‚‚\n    Â· rw [Path.comp_cons, Path.comp_cons] at hC\n      cases coe_eq_coe.mp (Path.obj_eq_of_cons_eq_cons hC)\n      have hC := (Path.heq_of_cons_eq_cons hC).eq\n      cases coe_eq_coe.mp (Path.obj_eq_of_cons_eq_cons hC)\n      refine' Inflexible.mk_coe hÎµ hÎ¶ hÎµÎ¶ _ _\n    Â· have := congr_arg Litter.Î² h'\n      simp only [fuzz_Î², bot_ne_coe] at this\n      cases this\n", "additional_info": "We can prove that `map_flexible` holds at any `constrained_action` without any `lawful` hypothesis.", "used_premises": [1, 402, 779, 781, 782, 69, 60, 233, 76, 814, 304, 978], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [187, 231], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.constrainedAction_comp_mapFlexible` states that for any `Î²`-structural action `Ï€` that is free, any path `A` from type index `Î²` to type index `Î³`, and any set `s` with small cardinality, the `Î²`-structural action `ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction Ï€ s hs)` satisfies the `map_flexible` property. The `free` hypothesis implies that for every `Î²`-extended index `B`, the near-litter approximation `(Ï€ B)` is free with respect to `B`. The `small` hypothesis ensures that the cardinality of `s` is strictly less than the cardinality of `ConNF.Îº`. This theorem is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.constrainedAction", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.constrainedAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) :ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²", "code": "noncomputable def constrainedAction (Ï€ : StructApprox Î²) (s : Set (Address Î²))\n    (hs : Small s) : StructAction Î² := fun B =>\n  { atomMap := fun a =>\n      âŸ¨âˆƒ c : Address Î², c âˆˆ s âˆ§ âŸ¨B, inl aâŸ© â‰¤ c,\n        fun _ => Ï€.completeAtomMap B aâŸ©\n    litterMap := fun L =>\n      âŸ¨âˆƒ c : Address Î², c âˆˆ s âˆ§ âŸ¨B, inr L.toNearLitterâŸ© â‰¤ c,\n        fun _ => Ï€.completeNearLitterMap B L.toNearLitterâŸ©\n    atomMap_dom_small := by\n      change Small ((fun a : Atom => âŸ¨B, inl aâŸ©) â»Â¹'\n        {c : Address Î² | âˆƒ d : Address Î², d âˆˆ s âˆ§ c â‰¤ d})\n      refine' Small.preimage _ (reflTransClosure_small hs)\n      intro a b h\n      cases h\n      rfl\n    litterMap_dom_small := by\n      change Small ((fun L : Litter => âŸ¨B, inr L.toNearLitterâŸ©) â»Â¹'\n        {c : Address Î² | âˆƒ d : Address Î², d âˆˆ s âˆ§ c â‰¤ d})\n      refine' Small.preimage _ (reflTransClosure_small hs)\n      intro a b h\n      cases h\n      rfl }\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 69, 60, 233, 808], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [148, 170], "informalization": "Function `ConNF.StructApprox.constrainedAction` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index, under the condition that the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.StructApprox.ihsAction_comp_mapFlexible", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_comp_mapFlexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_comp_mapFlexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {Î³ : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) :ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d))", "code": "theorem ihsAction_comp_mapFlexible (hÏ€f : Ï€.Free) {Î³ : Î›} (c d : Address Î²)\n    (A : Path (Î² : TypeIndex) Î³) :\n    StructAction.MapFlexible ((ihsAction Ï€ c d).comp A) := by\n  rw [ihsAction_eq_constrainedAction]\n  exact constrainedAction_comp_mapFlexible hÏ€f A\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 76, 814, 304, 966], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [238, 243], "informalization": "The theorem `ConNF.StructApprox.ihsAction_comp_mapFlexible` is a property of a `Î²`-structural action `Ï†` in the context of Constructive Ordinal Notation (ConNF). It states that for any `Î²`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `Ï†` applied to `B`, if `L` is a flexible litter, then `((Ï† B).litterMap L).get hL` is also a flexible litter."}
{"full_name": "ConNF.StructApprox.completeLitterMap_flexible", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L)", "code": "theorem completeLitterMap_flexible (hÏ€f : Ï€.Free) {A : ExtendedIndex Î²} {L : Litter}\n    (h : Flexible A L) : Flexible A (Ï€.completeLitterMap A L) := by\n  rw [completeLitterMap_eq_of_flexible h]\n  exact NearLitterApprox.flexibleCompletion_smul_flexible _ _ (hÏ€f A) _ h\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 842, 842, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [244, 248], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeLitterMap_flexible` states that for any free `Î²`-structural approximation `Ï€`, any `Î²`-extended index `A`, and any flexible litter `L`, the litter `ConNF.StructApprox.completeLitterMap Ï€ A L` is also flexible. This property ensures that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleBot", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleBot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleBot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L) :ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L)", "code": "theorem completeLitterMap_inflexibleBot {A : ExtendedIndex Î²} {L : Litter}\n    (h : InflexibleBot A L) : InflexibleBot A (Ï€.completeLitterMap A L) := by\n  rw [completeLitterMap_eq_of_inflexibleBot h]\n  obtain âŸ¨âŸ¨Î³, Îµ, hÎ³Îµ, B, rflâŸ©, a, rflâŸ© := h\n  exact âŸ¨âŸ¨Î³, Îµ, hÎ³Îµ, B, rflâŸ©, _, rflâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 887, 887, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [249, 254], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot` states that if `L` is `A`-inflexible, then the litter `ConNF.StructApprox.completeLitterMap Ï€ A L` is also `A`-inflexible. This theorem is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleCoe", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleCoe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L) (hL : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L)", "code": "theorem completeLitterMap_inflexibleCoe (hÏ€f : Ï€.Free) {c d : Address Î²}\n    (hcd : (ihsAction Ï€ c d).Lawful) {A : ExtendedIndex Î²} {L : Litter} (h : InflexibleCoe A L)\n    (hL : âŸ¨A, inr L.toNearLitterâŸ© âˆˆ reflTransConstrained c d) :\n    InflexibleCoe A (Ï€.completeLitterMap A L) := by\n  rw [completeLitterMap_eq_of_inflexibleCoe h]\n  swap\n  Â· refine' (hcd.le _).comp _\n    obtain hL | hL := hL\n    Â· exact (ihAction_le hL).trans (ihAction_le_ihsAction _ _ _)\n    Â· rw [ihsAction_symm]\n      exact (ihAction_le hL).trans (ihAction_le_ihsAction _ _ _)\n  swap\n  Â· exact ihAction_comp_mapFlexible hÏ€f _ _\n  obtain âŸ¨P, t, htâŸ© := h\n  constructor\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 889, 65, 483, 967, 889, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [255, 271], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleCoe` states that if `Ï€` is a free `Î²`-structural approximation, `c` and `d` are lawful `Î²`-structural actions, `A` is a `Î²`-extended index, `L` is a litter, and `L` is `A`-inflexible, then `ConNF.StructApprox.completeLitterMap Ï€ A L` is also `A`-inflexible."}
{"full_name": "ConNF.StructApprox.completeLitterMap_flexible'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_flexible'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_flexible' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (hL : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (h : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L)) :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem completeLitterMap_flexible' (hÏ€f : Ï€.Free) {c d : Address Î²}\n    (hcd : (ihsAction Ï€ c d).Lawful) {A : ExtendedIndex Î²} {L : Litter}\n    (hL : âŸ¨A, inr L.toNearLitterâŸ© âˆˆ reflTransConstrained c d)\n    (h : Flexible A (Ï€.completeLitterMap A L)) : Flexible A L := by\n  obtain h' | h' | h' := flexible_cases' A L\n  Â· exact h'\n  Â· have := completeLitterMap_inflexibleBot (Ï€ := Ï€) h'.some\n    rw [flexible_iff_not_inflexibleBot_inflexibleCoe] at h\n    cases h.1.false this\n  Â· have := completeLitterMap_inflexibleCoe hÏ€f hcd h'.some hL\n    rw [flexible_iff_not_inflexibleBot_inflexibleCoe] at h\n    cases h.2.false this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 842, 787, 842], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [272, 284], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_flexible'` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that if a `Î²`-structural approximation `Ï€` is free, and the `Î²`-extended index `A` and the litter `L` satisfy certain conditions, then the litter `L` is also flexible. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.completeLitterMap_flexible_iff", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_flexible_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_flexible_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (hL : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L) â†” ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem completeLitterMap_flexible_iff (hÏ€f : Ï€.Free) {c d : Address Î²}\n    (hcd : (ihsAction Ï€ c d).Lawful) {A : ExtendedIndex Î²} {L : Litter}\n    (hL : âŸ¨A, inr L.toNearLitterâŸ© âˆˆ reflTransConstrained c d) :\n    Flexible A (Ï€.completeLitterMap A L) â†” Flexible A L :=\n  âŸ¨completeLitterMap_flexible' hÏ€f hcd hL, completeLitterMap_flexible hÏ€fâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 842, 787, 842], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [285, 290], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_flexible_iff` states that for any `Î²`-structural approximation `Ï€` that is free, any `Î²`-extended index `A`, and any litter `L`, the litter `ConNF.StructApprox.completeLitterMap Ï€ A L` is flexible if and only if `L` itself is flexible. This property is crucial in ensuring that the construction of the natural numbers in Constructive Ordinal Notation (ConNF) is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleBot'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleBot'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleBot' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (hL : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (h : ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L)) :ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem completeLitterMap_inflexibleBot' (hÏ€f : Ï€.Free) {c d : Address Î²}\n    (hcd : (ihsAction Ï€ c d).Lawful) {A : ExtendedIndex Î²} {L : Litter}\n    (hL : âŸ¨A, inr L.toNearLitterâŸ© âˆˆ reflTransConstrained c d)\n    (h : InflexibleBot A (Ï€.completeLitterMap A L)) : InflexibleBot A L := by\n  refine' Nonempty.some _\n  obtain h' | h' | h' := flexible_cases' A L\n  Â· have := completeLitterMap_flexible hÏ€f h'\n    rw [flexible_iff_not_inflexibleBot_inflexibleCoe] at this\n    cases this.1.false h\n  Â· exact h'\n  Â· have := completeLitterMap_inflexibleCoe hÏ€f hcd h'.some hL\n    cases inflexibleBot_inflexibleCoe h this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 887, 787, 887], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [291, 303], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot'` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It states that if a `Î²`-structural approximation `Ï€` is free, a `Î²`-extended index `A`, and a litter `L` satisfy certain conditions, then `L` is `A`-inflexible."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleBot_iff", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleBot_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleBot_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (hL : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L)) â†” NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— A L)", "code": "theorem completeLitterMap_inflexibleBot_iff (hÏ€f : Ï€.Free) {c d : Address Î²}\n    (hcd : (ihsAction Ï€ c d).Lawful) {A : ExtendedIndex Î²} {L : Litter}\n    (hL : âŸ¨A, inr L.toNearLitterâŸ© âˆˆ reflTransConstrained c d) :\n    Nonempty (InflexibleBot A (Ï€.completeLitterMap A L)) â†” Nonempty (InflexibleBot A L) :=\n  âŸ¨fun âŸ¨hâŸ© => âŸ¨completeLitterMap_inflexibleBot' hÏ€f hcd hL hâŸ©, fun âŸ¨hâŸ© =>\n    âŸ¨completeLitterMap_inflexibleBot hâŸ©âŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 212, 887, 787, 212, 887], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [304, 310], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot_iff` states that for any `Î²`-structural approximation `Ï€` that is free, any `Î²`-extended index `A`, and any litter `L`, the litter `ConNF.StructApprox.completeLitterMap Ï€ A L` is `A`-inflexible if and only if `L` is `A`-inflexible."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleCoe'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleCoe'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleCoe' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L)) :ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L", "code": "theorem completeLitterMap_inflexibleCoe' (hÏ€f : Ï€.Free) {A : ExtendedIndex Î²} {L : Litter}\n    (h : InflexibleCoe A (Ï€.completeLitterMap A L)) : InflexibleCoe A L := by\n  refine' Nonempty.some _\n  obtain h' | h' | h' := flexible_cases' A L\n  Â· have := completeLitterMap_flexible hÏ€f h'\n    rw [flexible_iff_not_inflexibleBot_inflexibleCoe] at this\n    cases this.2.false h\n  Â· have := completeLitterMap_inflexibleBot (Ï€ := Ï€) h'.some\n    cases inflexibleBot_inflexibleCoe this h\n  Â· exact h'\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 889, 787, 889], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [311, 321], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleCoe'` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It states that if a `Î²`-structural approximation `Ï€` is free and `L` is `A`-inflexible (excluding `Îµ = âŠ¥`), then `L` itself is `A`-inflexible."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (hL : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L)) â†” NonemptyğŸ”—<|PREMISE|>ğŸ”— (ConNF.InflexibleCoeğŸ”—<|PREMISE|>ğŸ”— A L)", "code": "theorem completeLitterMap_inflexibleCoe_iff (hÏ€f : Ï€.Free) {c d : Address Î²}\n    (hcd : (ihsAction Ï€ c d).Lawful) {A : ExtendedIndex Î²} {L : Litter}\n    (hL : âŸ¨A, inr L.toNearLitterâŸ© âˆˆ reflTransConstrained c d) :\n    Nonempty (InflexibleCoe A (Ï€.completeLitterMap A L)) â†” Nonempty (InflexibleCoe A L) :=\n  âŸ¨fun âŸ¨hâŸ© => âŸ¨completeLitterMap_inflexibleCoe' hÏ€f hâŸ©, fun âŸ¨hâŸ© =>\n    âŸ¨completeLitterMap_inflexibleCoe hÏ€f hcd h hLâŸ©âŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 212, 889, 787, 212, 889], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [322, 328], "informalization": "`ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF) that relates the inflexibility of a litter `L` to the inflexibility of the litter `ConNF.StructApprox.completeLitterMap Ï€ A L`, where `Ï€` is a `Î²`-structural approximation, `A` is a `Î²`-extended index, and `L` is a litter. The theorem states that the existence of a proof that `L` is `A`-inflexible (excluding `Îµ = âŠ¥`) is equivalent to the existence of a proof that `ConNF.StructApprox.completeLitterMap Ï€ A L` is `A`-inflexible (excluding `Îµ = âŠ¥`)."}
{"full_name": "ConNF.StructApprox.supports", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.supports [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] {Ï€ : ConNF.Allowable â†‘Î²} {Ï€' : ConNF.Allowable â†‘Î²} {t : ConNF.Tangle â†‘Î²} (ha : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom), { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } âˆˆ ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”— t â†’ ConNF.Allowable.toStructPerm Ï€ A â€¢ a = ConNF.Allowable.toStructPerm Ï€' A â€¢ a) (hN : âˆ€ (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter), { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } âˆˆ ConNF.TangleData.Tangle.supportğŸ”—<|PREMISE|>ğŸ”— t â†’ ConNF.Allowable.toStructPerm Ï€ A â€¢ N = ConNF.Allowable.toStructPerm Ï€' A â€¢ N) :Ï€ â€¢ t = Ï€' â€¢ t", "code": "theorem supports {Î² : Î›} [LeLevel Î²] {Ï€ Ï€' : Allowable Î²} {t : Tangle Î²}\n    (ha : âˆ€ A a, âŸ¨A, inl aâŸ© âˆˆ t.support â†’\n      Allowable.toStructPerm Ï€ A â€¢ a =\n      Allowable.toStructPerm Ï€' A â€¢ a)\n    (hN : âˆ€ A N, âŸ¨A, inr NâŸ© âˆˆ t.support â†’\n      Allowable.toStructPerm Ï€ A â€¢ N =\n      Allowable.toStructPerm Ï€' A â€¢ N) :\n    Ï€ â€¢ t = Ï€' â€¢ t := by\n  rw [â† inv_smul_eq_iff, smul_smul]\n  refine' support_supports t _ _\n  intro c hc\n  rw [mul_smul, inv_smul_eq_iff]\n  simp only [Allowable.smul_address_eq_smul_iff]\n  obtain âŸ¨A, a | NâŸ© := c\n  Â· simp only [smul_inl, inl.injEq]\n    exact ha A a hc\n  Â· simp only [smul_inr, inr.injEq]\n    exact hN A N hc\n", "additional_info": "", "used_premises": [1, 402, 61, 67, 395, 61, 65, 395], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [331, 349], "informalization": "The `ConNF.StructApprox.supports` theorem in Lean 4 is a part of the system designed to construct natural numbers using Constructive Ordinal Notation (ConNF), which includes a specific construction of the natural numbers utilizing a combination of finite and infinite paths through a transfinite hierarchy of types. The theorem asserts that for any two allowable permutations of the same type `Î²` within the context of ConNF, if these permutations leave each element (either an atom or a near-litter) unchanged when applied to the respective elements within the support of a given tangle at type `Î²`, then these permutations must in fact be identical when applied to the tangle itself. This property is crucial for ensuring that the construction of the natural numbers is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.ConNF.StructApprox.extracted_1", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ConNF.StructApprox.extracted_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ConNF.StructApprox.extracted_1 [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Î³ : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (hÏ€ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs))) (Ï : ConNF.Allowable â†‘Î³) (h : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs)) hÏ€) (ConNF.Allowable.toStructPerm Ï)) (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î³) (N : ConNF.NearLitter) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hcâ‚ : c âˆˆ s) (hcâ‚‚ : { path := Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } â‰¤ c) (L : ConNF.Litter) (hcâ‚‚' : { path := Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } â‰¤ c) (hNL : N.fst = L) (hL : ConNF.InflexibleBotğŸ”—<|PREMISE|>ğŸ”— B L) :ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B) L = ConNF.Allowable.toStructPerm Ï B â€¢ L", "code": "theorem ConNF.StructApprox.extracted_1\n    {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    (s : Set (Address Î²)) (hs : Small s)\n    (hÏ€ : StructAction.Lawful (Tree.comp A (constrainedAction Ï€ s hs)))\n    (Ï : Allowable Î³)\n    (h : ExactlyApproximates\n      (StructAction.rc (Tree.comp A (constrainedAction Ï€ s hs)) hÏ€)\n      (Allowable.toStructPerm Ï))\n    (B : ExtendedIndex Î³) (N : NearLitter)\n    (c : Address Î²) (hcâ‚ : c âˆˆ s)\n    (hcâ‚‚ : âŸ¨A.comp B, inr NâŸ© â‰¤ c)\n    (L : Litter)\n    (hcâ‚‚' : âŸ¨A.comp B, inr (Litter.toNearLitter L)âŸ© â‰¤ c)\n    (hNL : N.1 = L)\n    (hL : InflexibleBot B L) :\n    completeLitterMap Ï€ (Path.comp A B) L = Allowable.toStructPerm Ï B â€¢ L := by\n  rw [completeLitterMap_eq_of_inflexibleBot (hL.comp A)]\n  obtain âŸ¨âŸ¨Î´, Îµ, hÎµ, C, rflâŸ©, a, rflâŸ© := hL\n  rw [toStructPerm_smul_fuzz (bot_lt_coe Î´)]\n  refine' congr_arg _ _\n  have := comp_bot_smul_atom Ï (C.cons (bot_lt_coe _)) a\n  refine Eq.trans ?_ this.symm\n  rw [â† (h <| C.cons (bot_lt_coe _)).map_atom a\n        (Or.inl (Or.inl (Or.inl (Or.inl\n          âŸ¨c, hcâ‚, Relation.ReflTransGen.head (Constrains.fuzz_bot hÎµ _ _) hcâ‚‚'âŸ©))))]\n  rw [StructAction.rc_smul_atom_eq]\n  Â· rfl\n  Â· simp only [Tree.comp_apply, constrainedAction_atomMap]\n    exact âŸ¨c, hcâ‚, Relation.ReflTransGen.head (Constrains.fuzz_bot hÎµ _ _) hcâ‚‚'âŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 402, 76, 69, 60, 233, 809, 304, 978, 803, 810, 304, 978, 61, 60, 135, 65, 135, 65, 483, 887, 787, 135], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [350, 379], "informalization": "The object `ConNF.StructApprox.ConNF.StructApprox.extracted_1` is a theorem in the Lean 4 library that is used in the context of Constructive Ordinal Notation (ConNF). The theorem is a key step in the proof of Freedom of Action, which is a statement about the action of a structured permutation on a litter. The theorem states that if a structured action exactly approximates a structured permutation, then a certain construction involving the structured action and the permutation results in the same litter. The theorem is a crucial part of the proof of Freedom of Action in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.StructApprox.constrainedAction_coherent'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.constrainedAction_coherent'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_coherent' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {Î³ : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) (N : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î³ Ã— ConNF.NearLitter) (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (hc : âˆƒ c âˆˆ s, { path := Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A N.1, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N.2 } â‰¤ c) (hÏ€ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs))) (Ï : ConNF.Allowable â†‘Î³) (h : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs)) hÏ€) (ConNF.Allowable.toStructPerm Ï)) :ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A N.1) N.2 = ConNF.Allowable.toStructPerm Ï N.1 â€¢ N.2", "code": "theorem constrainedAction_coherent' (hÏ€f : Ï€.Free) {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    (N : ExtendedIndex Î³ Ã— NearLitter) (s : Set (Address Î²)) (hs : Small s)\n    (hc : âˆƒ c : Address Î², c âˆˆ s âˆ§ âŸ¨A.comp N.1, inr N.2âŸ© â‰¤ c)\n    (hÏ€ : StructAction.Lawful ((constrainedAction Ï€ s hs).comp A)) (Ï : Allowable Î³)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((constrainedAction Ï€ s hs).comp A) hÏ€)\n      (Allowable.toStructPerm Ï)) :\n    completeNearLitterMap Ï€ (A.comp N.1) N.2 =\n    Allowable.toStructPerm Ï N.1 â€¢ N.2 := by\n  revert hc\n  refine' WellFounded.induction\n    (C := fun N : ExtendedIndex Î³ Ã— NearLitter => (âˆƒ c : Address Î², c âˆˆ s âˆ§\n      âŸ¨A.comp N.fst, inr N.sndâŸ© â‰¤ c) â†’\n      completeNearLitterMap Ï€ (Path.comp A N.fst) N.snd =\n      Allowable.toStructPerm Ï N.fst â€¢ N.snd)\n    (InvImage.wf (fun N => âŸ¨N.1, inr N.2âŸ©) (WellFounded.transGen (constrains_wf Î³))) N _\n  clear N\n  rintro âŸ¨B, NâŸ© ih âŸ¨c, hcâ‚, hcâ‚‚âŸ©\n  dsimp only at *\n  have hdom : ((((constrainedAction Ï€ s hs).comp A B).refine (hÏ€ B)).litterMap N.fst).Dom :=\n    âŸ¨c, hcâ‚, le_nearLitter hcâ‚‚âŸ©\n  suffices completeLitterMap Ï€ (A.comp B) N.fst = Allowable.toStructPerm Ï B â€¢ N.fst by\n    refine' SetLike.coe_injective _\n    refine'\n      Eq.trans _\n        (NearLitterAction.smul_nearLitter_eq_of_preciseAt _ (h B) hdom\n            (NearLitterAction.refine_precise _) this.symm).symm\n    rw [completeNearLitterMap_eq' (A.comp B) N]\n    simp only [StructAction.refine_apply, StructAction.refine_litterMap,\n      foaHypothesis_nearLitterImage, Tree.ofBot_smul]\n    simp only [Tree.comp_apply, constrainedAction_litterMap, symmDiff_right_inj]\n    ext a : 1\n    constructor\n    Â· rintro âŸ¨a, ha, rflâŸ©\n      refine' âŸ¨a, ha, _âŸ©\n      refine' ((h B).map_atom a _).symm.trans _\n      Â· refine' Or.inl (Or.inl (Or.inl (Or.inl _)))\n        exact âŸ¨c, hcâ‚, Relation.ReflTransGen.head (Constrains.symmDiff _ N a ha) hcâ‚‚âŸ©\n      Â· rw [StructAction.rc_smul_atom_eq]\n        rfl\n        exact âŸ¨c, hcâ‚, Relation.ReflTransGen.head (Constrains.symmDiff _ N a ha) hcâ‚‚âŸ©\n    Â· rintro âŸ¨a, ha, rflâŸ©\n      refine' âŸ¨a, ha, _âŸ©\n      refine' Eq.trans _ ((h B).map_atom a _)\n      Â· rw [StructAction.rc_smul_atom_eq]\n        rfl\n        exact âŸ¨c, hcâ‚, Relation.ReflTransGen.head (Constrains.symmDiff _ N a ha) hcâ‚‚âŸ©\n      Â· refine' Or.inl (Or.inl (Or.inl (Or.inl _)))\n        exact âŸ¨c, hcâ‚, Relation.ReflTransGen.head (Constrains.symmDiff _ N a ha) hcâ‚‚âŸ©\n  have hcâ‚‚' := le_nearLitter hcâ‚‚\n  generalize hNL : N.fst = L\n  rw [hNL] at hdom hcâ‚‚'\n  obtain hL | âŸ¨âŸ¨hLâŸ©âŸ© | âŸ¨âŸ¨hLâŸ©âŸ© := flexible_cases' B L\n  Â· refine' Eq.trans _ ((h B).map_litter L _)\n    Â· rw [StructAction.rc_smul_litter_eq]\n      rw [NearLitterAction.flexibleLitterPartialPerm_apply_eq]\n      swap; exact hdom\n      swap; exact hL\n      exact (NearLitterAction.roughLitterMapOrElse_of_dom _ hdom).symm\n    Â· refine' Or.inl (Or.inl _)\n      refine' âŸ¨hdom, hLâŸ©\n  Â· exact ConNF.StructApprox.extracted_1 A s hs hÏ€ Ï h B N c hcâ‚ hcâ‚‚ L hcâ‚‚' hNL hL\n  Â· refine ConNF.StructApprox.extracted_2 hÏ€f A s hs hÏ€ Ï h B N ?_ c hcâ‚ hcâ‚‚ L hcâ‚‚' hNL hL\n    intro C M h\n    exact ih (C, M) h âŸ¨c, hcâ‚, trans (lt_comp h A).to_reflTransGen hcâ‚‚âŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 402, 76, 61, 69, 60, 233, 135, 65, 809, 304, 978, 803, 810, 304, 978, 792, 135], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [550, 615], "informalization": "The theorem `ConNF.StructApprox.constrainedAction_coherent'` is a key step in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any `Î²`-structural approximation `Ï€` that is free, any `Î²`-extended index `A`, and any near-litter `N`, the function `ConNF.StructApprox.completeNearLitterMap Ï€ A N` is equal to the action of the allowable permutation `Ï` on `N`."}
{"full_name": "ConNF.StructApprox.constrainedAction_coherent", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.constrainedAction_coherent", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_coherent [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {Î³ : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î³) (N : ConNF.NearLitter) (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (hc : âˆƒ c âˆˆ s, { path := Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } â‰¤ c) (hÏ€ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs))) (Ï : ConNF.Allowable â†‘Î³) (h : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs)) hÏ€) (ConNF.Allowable.toStructPerm Ï)) :ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B) N = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— B (ConNF.Allowable.toStructPerm Ï) â€¢ N", "code": "theorem constrainedAction_coherent (hÏ€f : Ï€.Free) {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    (B : ExtendedIndex Î³) (N : NearLitter) (s : Set (Address Î²)) (hs : Small s)\n    (hc : âˆƒ c : Address Î², c âˆˆ s âˆ§ âŸ¨A.comp B, inr NâŸ© â‰¤ c)\n    (hÏ€ : StructAction.Lawful ((constrainedAction Ï€ s hs).comp A)) (Ï : Allowable Î³)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((constrainedAction Ï€ s hs).comp A) hÏ€)\n      (Allowable.toStructPerm Ï)) :\n    completeNearLitterMap Ï€ (A.comp B) N = Tree.comp B (Allowable.toStructPerm Ï) â€¢ N :=\n  constrainedAction_coherent' hÏ€f A (B, N) s hs hc hÏ€ Ï h\n", "additional_info": "**Coherence lemma**: The action of the complete litter map, below a given address `c`,\nis equal to the action of any allowable permutation that exactly approximates it.\nThis condition can only be applied for `Î³ < Î±` as we're dealing with lower allowable permutations.", "used_premises": [1, 402, 779, 781, 782, 402, 76, 61, 69, 60, 233, 135, 65, 809, 304, 978, 803, 810, 304, 978, 792, 135, 304], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [620, 629], "informalization": "The theorem `ConNF.StructApprox.constrainedAction_coherent` is a coherence lemma in the context of Constructive Ordinal Notation (ConNF). It states that the action of the complete litter map, below a given address `c`, is equal to the action of any allowable permutation that exactly approximates it. This condition can only be applied for `Î³ < Î±` as we're dealing with lower allowable permutations."}
{"full_name": "ConNF.StructApprox.constrainedAction_coherent_atom", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.constrainedAction_coherent_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_coherent_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Î³ : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î³) (a : ConNF.Atom) (s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)) (hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s) (hc : âˆƒ c âˆˆ s, { path := Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } â‰¤ c) (hÏ€ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs))) (Ï : ConNF.Allowable â†‘Î³) (h : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs)) hÏ€) (ConNF.Allowable.toStructPerm Ï)) :ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B) a = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— B (ConNF.Allowable.toStructPerm Ï) â€¢ a", "code": "theorem constrainedAction_coherent_atom {Î³ : Î›} [LeLevel Î³]\n    (A : Path (Î² : TypeIndex) Î³) (B : ExtendedIndex Î³) (a : Atom) (s : Set (Address Î²))\n    (hs : Small s) (hc : âˆƒ c : Address Î², c âˆˆ s âˆ§ âŸ¨A.comp B, inl aâŸ© â‰¤ c)\n    (hÏ€ : StructAction.Lawful ((constrainedAction Ï€ s hs).comp A)) (Ï : Allowable Î³)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((constrainedAction Ï€ s hs).comp A) hÏ€)\n      (Allowable.toStructPerm Ï)) :\n    completeAtomMap Ï€ (A.comp B) a = Tree.comp B (Allowable.toStructPerm Ï) â€¢ a := by\n  refine' Eq.trans _ ((h B).map_atom a (Or.inl (Or.inl (Or.inl (Or.inl hc)))))\n  rw [StructAction.rc_smul_atom_eq]\n  rfl\n  exact hc\n", "additional_info": "The coherence lemma for atoms, which is much easier to prove.\nThe statement is here for symmetry.", "used_premises": [1, 402, 779, 781, 402, 76, 61, 69, 60, 233, 135, 67, 809, 304, 978, 803, 810, 304, 978, 784, 135, 304], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [633, 645], "informalization": "The coherence lemma for atoms, which is much easier to prove. The statement is here for symmetry."}
{"full_name": "ConNF.StructApprox.ihsAction_coherent", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_coherent", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_coherent [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {Î³ : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î³) (N : ConNF.NearLitter) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hc : { path := Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hÏ€ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d))) (Ï : ConNF.Allowable â†‘Î³) (h : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) hÏ€) (ConNF.Allowable.toStructPerm Ï)) :ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B) N = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— B (ConNF.Allowable.toStructPerm Ï) â€¢ N", "code": "theorem ihsAction_coherent (hÏ€f : Ï€.Free) {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    (B : ExtendedIndex Î³) (N : NearLitter) (c d : Address Î²)\n    (hc : âŸ¨A.comp B, inr NâŸ© âˆˆ transConstrained c d)\n    (hÏ€ : StructAction.Lawful ((ihsAction Ï€ c d).comp A))\n    (Ï : Allowable Î³)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((ihsAction Ï€ c d).comp A) hÏ€)\n      (Allowable.toStructPerm Ï)) :\n    completeNearLitterMap Ï€ (A.comp B) N =\n    Tree.comp B (Allowable.toStructPerm Ï) â€¢ N := by\n  simp_rw [ihsAction_eq_constrainedAction] at hÏ€\n  refine constrainedAction_coherent hÏ€f A B N _ _ ?_ hÏ€ Ï ?_\n  obtain hc | hc := hc\n  Â· simp only [Address.lt_iff, Relation.TransGen.tail'_iff] at hc\n    obtain âŸ¨d, hdâ‚, hdâ‚‚âŸ© := hc\n    exact âŸ¨d, Or.inl hdâ‚‚, hdâ‚âŸ©\n  Â· simp only [Address.lt_iff, Relation.TransGen.tail'_iff] at hc\n    obtain âŸ¨d, hdâ‚, hdâ‚‚âŸ© := hc\n    exact âŸ¨d, Or.inr hdâ‚‚, hdâ‚âŸ©\n  Â· convert h\n    rw [ihsAction_eq_constrainedAction]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 402, 76, 61, 60, 60, 135, 65, 995, 809, 304, 966, 803, 810, 304, 966, 792, 135, 304], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [646, 667], "informalization": "The theorem `ConNF.StructApprox.ihsAction_coherent` states that in the context of Constructive Ordinal Notation (ConNF), given a `Î²`-structural approximation `Ï€` that is free, a path `A` from `Î²` to `Î³`, a `Î³`-extended index `B`, a near-litter `N`, addresses `c` and `d` such that the composition of `A` and `B` is in the transitive closure of `c` and `d`, and a lawful `Î²`-structural action that exactly approximates a `Î³`-allowable permutation `Ï`, the `Î²`-structural approximation `Ï€` applied to the composition of `A` and `B` and `N` is equal to the `Î³`-allowable permutation `Ï` applied to `N`."}
{"full_name": "ConNF.StructApprox.transConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.transConstrained [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)", "code": "def transConstrained (c d : Address Î²) : Set (Address Î²) :=\n  {e | e < c} âˆª {e | e < d}\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.transConstrainedğŸ—ŸğŸ”—../../.././ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrainedğŸ”—  c d ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  {e : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | e ğŸ—Ÿ<ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LT.ltğŸ”—  c} ğŸ—ŸâˆªğŸ—ŸğŸ”—../../.././Init/Core.html#Union.unionğŸ”—  {e : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | e ğŸ—Ÿ<ğŸ—ŸğŸ”—../../.././Init/Prelude.html#LT.ltğŸ”—  d}\n\n", "used_premises": [1, 60, 60, 69, 60], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [15, 17], "informalization": "Function `ConNF.StructApprox.transConstrained` takes two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF) and returns a set of addresses that are either strictly less than `c` or strictly less than `d`. This set represents the transitive closure of the relation defined by `c` and `d`."}
{"full_name": "ConNF.StructApprox.ihsAction_coherent_atom", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_coherent_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_coherent_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Î³ : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î³) (a : ConNF.Atom) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hc : { path := Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } < c) (hÏ€ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d))) (Ï : ConNF.Allowable â†‘Î³) (h : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) hÏ€) (ConNF.Allowable.toStructPerm Ï)) :ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ (Quiver.Path.compğŸ”—<|PREMISE|>ğŸ”— A B) a = ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— B (ConNF.Allowable.toStructPerm Ï) â€¢ a", "code": "theorem ihsAction_coherent_atom {Î³ : Î›} [LeLevel Î³] (A : Path (Î² : TypeIndex) Î³)\n    (B : ExtendedIndex Î³) (a : Atom) (c d : Address Î²) (hc : âŸ¨A.comp B, inl aâŸ© < c)\n    (hÏ€ : StructAction.Lawful ((ihsAction Ï€ c d).comp A)) (Ï : Allowable Î³)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((ihsAction Ï€ c d).comp A) hÏ€)\n      (Allowable.toStructPerm Ï)) :\n    completeAtomMap Ï€ (A.comp B) a = Tree.comp B (Allowable.toStructPerm Ï) â€¢ a := by\n  refine' Eq.trans _ ((h B).map_atom a (Or.inl (Or.inl (Or.inl (Or.inl (Or.inl hc))))))\n  rw [StructAction.rc_smul_atom_eq]\n  rfl\n  exact Or.inl hc\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 402, 76, 61, 60, 60, 135, 67, 809, 304, 966, 803, 810, 304, 966, 784, 135, 304], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [668, 679], "informalization": "The theorem `ConNF.StructApprox.ihsAction_coherent_atom` states that in the context of Constructive Ordinal Notation (ConNF), given a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, a `Î³`-extended index `B`, an atom `a`, a `Î²`-address `c`, and a `Î²`-address `d`, if `A` composed with `B` is less than `c`, the `Î²`-structural action `ConNF.StructApprox.ihsAction Ï€ c d` is lawful, and the `Î²`-structural approximation `ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction Ï€ c d)) hÏ€` exactly approximates the `Î²`-structural permutation `ConNF.Allowable.toStructPerm Ï`, then the function `ConNF.StructApprox.completeAtomMap Ï€ (Quiver.Path.comp A B) a` is equal to `ConNF.Tree.comp B (ConNF.Allowable.toStructPerm Ï) â€¢ a`."}
{"full_name": "ConNF.StructApprox.litter_injective_extends", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.litter_injective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.litter_injective_extends [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} (hâ‚ : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— Lâ‚) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hâ‚‚ : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (h : ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A Lâ‚ = ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A Lâ‚‚) :Lâ‚ = Lâ‚‚", "code": "theorem litter_injective_extends (hÏ€f : Ï€.Free) {c d : Address Î²}\n    (hcd : (ihsAction Ï€ c d).Lawful) {A : ExtendedIndex Î²} {Lâ‚ Lâ‚‚ : Litter}\n    (hâ‚ : âŸ¨A, inr Lâ‚.toNearLitterâŸ© âˆˆ reflTransConstrained c d)\n    (hâ‚‚ : âŸ¨A, inr Lâ‚‚.toNearLitterâŸ© âˆˆ reflTransConstrained c d)\n    (h : completeLitterMap Ï€ A Lâ‚ = completeLitterMap Ï€ A Lâ‚‚) : Lâ‚ = Lâ‚‚ := by\n  obtain hâ‚' | hâ‚' | hâ‚' := flexible_cases' A Lâ‚\n  Â· have hâ‚‚' : Flexible A Lâ‚‚\n    Â· have := completeLitterMap_flexible hÏ€f hâ‚'\n      rw [h] at this\n      exact completeLitterMap_flexible' hÏ€f hcd hâ‚‚ this\n    rw [completeLitterMap_eq_of_flexible hâ‚', completeLitterMap_eq_of_flexible hâ‚‚'] at h\n    refine' PartialPerm.injOn _ _ _ h\n    all_goals\n      rw [NearLitterApprox.flexibleCompletion_litterPerm_domain_free _ _ (hÏ€f A)]\n      assumption\n  Â· obtain âŸ¨hâ‚'âŸ© := hâ‚'\n    have hâ‚‚' : InflexibleBot A Lâ‚‚\n    Â· have := completeLitterMap_inflexibleBot (Ï€ := Ï€) hâ‚'\n      rw [h] at this\n      exact completeLitterMap_inflexibleBot' hÏ€f hcd hâ‚‚ this\n    rw [completeLitterMap_eq_of_inflexibleBot hâ‚',\n      completeLitterMap_eq_of_inflexibleBot hâ‚‚'] at h\n    obtain âŸ¨âŸ¨Î³â‚, Îµâ‚, hÎ³Îµâ‚, Bâ‚, rflâŸ©, aâ‚, rflâŸ© := hâ‚'\n    obtain âŸ¨âŸ¨Î³â‚‚, Îµâ‚‚, hÎ³Îµâ‚‚, Bâ‚‚, hBâŸ©, aâ‚‚, rflâŸ© := hâ‚‚'\n    cases coe_injective (Path.obj_eq_of_cons_eq_cons hB)\n    cases coe_injective (Path.obj_eq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hB).eq)\n    cases (Path.heq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hB).eq).eq\n    refine' congr_arg _ ((hcd _).atomMap_injective _ _ (fuzz_injective bot_ne_coe h))\n    Â· have := Constrains.fuzz_bot hÎ³Îµâ‚ Bâ‚ aâ‚\n      exact transConstrained_of_reflTransConstrained_of_trans_constrains hâ‚\n        (Relation.TransGen.single this)\n    Â· have := Constrains.fuzz_bot hÎ³Îµâ‚ Bâ‚ aâ‚‚\n      exact transConstrained_of_reflTransConstrained_of_trans_constrains hâ‚‚\n        (Relation.TransGen.single this)\n  Â· obtain âŸ¨hâ‚'âŸ© := hâ‚'\n    have hâ‚‚' : InflexibleCoe A Lâ‚‚\n    Â· have := completeLitterMap_inflexibleCoe hÏ€f hcd hâ‚' hâ‚\n      rw [h] at this\n      exact completeLitterMap_inflexibleCoe' hÏ€f this\n    rw [completeLitterMap_eq_of_inflexibleCoe hâ‚'] at h\n    swap\n    Â· refine' (hcd.le _).comp _\n      obtain hâ‚ | hâ‚ := hâ‚\n      Â· exact (ihAction_le hâ‚).trans (ihAction_le_ihsAction _ _ _)\n      Â· rw [ihsAction_symm]\n        exact (ihAction_le hâ‚).trans (ihAction_le_ihsAction _ _ _)\n    swap\n    Â· exact ihAction_comp_mapFlexible hÏ€f _ _\n    rw [completeLitterMap_eq_of_inflexibleCoe hâ‚‚'] at h\n    swap\n    Â· refine' (hcd.le _).comp _\n      obtain hâ‚‚ | hâ‚‚ := hâ‚‚\n      Â· exact (ihAction_le hâ‚‚).trans (ihAction_le_ihsAction _ _ _)\n      Â· rw [ihsAction_symm]\n        exact (ihAction_le hâ‚‚).trans (ihAction_le_ihsAction _ _ _)\n    swap\n    Â· exact ihAction_comp_mapFlexible hÏ€f _ _\n    obtain âŸ¨âŸ¨Î³â‚, Î´â‚, Îµâ‚, hÎ´â‚, hÎµâ‚, hÎ´Îµâ‚, Bâ‚, rflâŸ©, tâ‚, rflâŸ© := hâ‚'\n    obtain âŸ¨âŸ¨Î³â‚‚, Î´â‚‚, Îµâ‚‚, hÎ´â‚‚, hÎµâ‚‚, hÎ´Îµâ‚‚, Bâ‚‚, hBâŸ©, tâ‚‚, rflâŸ© := hâ‚‚'\n    cases coe_injective (Path.obj_eq_of_cons_eq_cons hB)\n    cases coe_injective (Path.obj_eq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hB).eq)\n    cases (Path.heq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hB).eq).eq\n    have := congr_arg Litter.Î² h\n    cases coe_injective this\n    clear this\n    refine' congr_arg _ _\n    have h' := fuzz_injective _ h\n    rw [ihAction_smul_tangle hÏ€f c d _ _ hâ‚ _ _ (hcd.comp _)] at h'\n    rw [ihAction_smul_tangle hÏ€f c d _ _ hâ‚‚ _ _ (hcd.comp _)] at h'\n    rw [smul_left_cancel_iff] at h'\n    exact h'\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 65, 483, 967, 787, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [766, 837], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.litter_injective_extends` states that for a free `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, and two litters `Lâ‚` and `Lâ‚‚`, if both `Lâ‚` and `Lâ‚‚` are within the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, and if the complete litter map of `Ï€` applied to `A` and `Lâ‚` equals the complete litter map of `Ï€` applied to `A` and `Lâ‚‚`, then `Lâ‚` must equal `Lâ‚‚`."}
{"full_name": "ConNF.StructApprox.splitLt_wellFounded", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.splitLt_wellFounded", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.splitLt_wellFounded {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop } (hr : WellFoundedğŸ”—<|PREMISE|>ğŸ”— r) :WellFoundedğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.SplitLtğŸ”—<|PREMISE|>ğŸ”— r)", "code": "theorem splitLt_wellFounded {Î± : Type _} {r : Î± â†’ Î± â†’ Prop} (hr : WellFounded r) :\n    WellFounded (SplitLt r) := by\n  refine' Subrelation.wf @(lex_lt_of_splitLt hr) _\n  refine' InvImage.wf _ (InvImage.wf _ _)\n  refine' WellFounded.prod_lex _ _ <;>\n    exact (WellFounded.wellOrderExtension.isWellFounded_lt hr).wf\n", "additional_info": "", "used_premises": [19, 19, 999], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [920, 926], "informalization": "Given a well-founded relation `r` on a type `Î±`, the split relation `ConNF.StructApprox.SplitLt r` on `Î± Ã— Î±` is also well-founded."}
{"full_name": "ConNF.StructApprox.SplitLt", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.SplitLt", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.StructApprox.SplitLt {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop ) :Î± Ã— Î± â†’ Î± Ã— Î± â†’ Prop", "code": "inductive SplitLt {Î± : Type _} (r : Î± â†’ Î± â†’ Prop) : Î± Ã— Î± â†’ Î± Ã— Î± â†’ Prop\n  | left_lt â¦ƒa b c : Î±â¦„ : r a b â†’ SplitLt r (a, c) (b, c)\n  | right_lt â¦ƒa b c : Î±â¦„ : r b c â†’ SplitLt r (a, b) (a, c)\n  | left_split â¦ƒa b c d : Î±â¦„ : r a c â†’ r b c â†’ SplitLt r (a, b) (c, d)\n  | right_split â¦ƒa b c d : Î±â¦„ : r a d â†’ r b d â†’ SplitLt r (a, b) (c, d)\n", "additional_info": "**Split relation**\nLet `<` denote a relation on `Î±`.\nThe split relation `<â‚›` defined on `Î± Ã— Î±` is defined by:\n* `a < b â†’ (a, c) <â‚› (b, c)` (left `<`)\n* `b < c â†’ (a, b) <â‚› (a, c)` (right `<`)\n* `a < c â†’ b < c â†’ (a, b) <â‚› (c, d)` (left split)\n* `a < d â†’ b < d â†’ (a, b) <â‚› (c, d)` (right split)\n\nThis is more granular than the standard product of relations,\nwhich would be given by just the first two constructors.\nThe splitting constructors allow one to \"split\" either `c` or `d` into two lower values `a` and `b`.\nSplitting has applications with well-founded relations; in particular, `<â‚›` is well-founded whenever\n`<` is, so this relation can simplify certain inductive steps.\n", "used_premises": [], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [854, 859], "informalization": "Type `ConNF.StructApprox.SplitLt` represents the split relation on `Î± Ã— Î±`, which is more granular than the standard product of relations, allowing one to \"split\" either `c` or `d` into two lower values `a` and `b`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hcd : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} {L : ConNF.Litter} (ha : a.1 = L) (hL : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a âˆˆ ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L)", "code": "theorem completeAtomMap_mem_completeNearLitterMap_toNearLitter' (hÏ€f : Ï€.Free)\n    {c d : Address Î²} (hcd : (ihsAction Ï€ c d).Lawful) {A : ExtendedIndex Î²} {a : Atom}\n    {L : Litter} (ha : a.1 = L) (hL : âŸ¨A, inr L.toNearLitterâŸ© âˆˆ reflTransConstrained c d) :\n    Ï€.completeAtomMap A a âˆˆ Ï€.completeNearLitterMap A L.toNearLitter := by\n  subst ha\n  rw [completeNearLitterMap_eq]\n  by_cases ha : a âˆˆ (Ï€ A).atomPerm.domain\n  Â· rw [completeAtomMap_eq_of_mem_domain ha]\n    refine' Or.inl âŸ¨Or.inr âŸ¨a, âŸ¨rfl, haâŸ©, rflâŸ©, _âŸ©\n    rintro âŸ¨_, âŸ¨b, rflâŸ©, _, âŸ¨hb, rflâŸ©, habâŸ©\n    simp only [foaHypothesis_atomImage, mem_singleton_iff] at hab\n    rw [completeAtomMap_eq_of_not_mem_domain hb.2] at hab\n    have := Sublitter.equiv_apply_mem (S := (Ï€ A).largestSublitter b.fst)\n      (T := (Ï€ A).largestSublitter (completeLitterMap Ï€ A b.fst)) âŸ¨b, rfl, hb.2âŸ©\n    rw [â† hab] at this\n    exact this.2 ((Ï€ A).atomPerm.map_domain ha)\n  rw [completeAtomMap_eq_of_not_mem_domain ha]\n  refine' Or.inl âŸ¨Or.inl _, _âŸ©\n  Â· rw [SetLike.mem_coe]\n    convert Sublitter.equiv_apply_mem _ using 1\n    rw [nearLitterHypothesis_eq, completeLitterMap_eq]\n    rfl\n  Â· rintro âŸ¨_, âŸ¨b, rflâŸ©, _, âŸ¨hb, rflâŸ©, habâŸ©\n    simp only [foaHypothesis_atomImage, mem_singleton_iff] at hab\n    rw [completeAtomMap_eq_of_not_mem_domain hb.2] at hab\n    have := litter_injective_extends hÏ€f hcd hL\n      (fst_mem_reflTransConstrained_of_mem_symmDiff hb.1 hL) ?_\n    Â· rw [Sublitter.equiv_congr_left (congr_arg _ this) _,\n        Sublitter.equiv_congr_right (congr_arg _ (congr_argâ‚‚ _ rfl this)) _,\n        Subtype.coe_inj] at hab\n      cases (EquivLike.apply_eq_iff_eq _).mp hab\n      exact hb.1.elim (fun h' => h'.2 rfl) fun h' => h'.2 rfl\n    exact equiv_apply_eq hab\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 784, 792, 483], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [928, 961], "informalization": "The Lean 4 object `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter'` is a theorem in the context of Constructive Ordinal Notation (ConNF). It states that for any `Î²`-structural approximation `Ï€` that is free, and any `Î²`-extended indices `c` and `d` such that the `Î²`-structural action `ConNF.StructApprox.ihsAction Ï€ c d` is lawful, and any `Î²`-extended index `A` and atom `a` such that `a.1 = L` and the address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }` is in the set `ConNF.StructApprox.reflTransConstrained c d`, then `ConNF.StructApprox.completeAtomMap Ï€ A a` is in `ConNF.StructApprox.completeNearLitterMap Ï€ A (ConNF.Litter.toNearLitter L)`."}
{"full_name": "ConNF.StructApprox.ihsAction_lawful_extends", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_lawful_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_lawful_extends [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hÏ€ : âˆ€ (e f : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²), ConNF.StructApprox.SplitLtğŸ”—<|PREMISE|>ğŸ”— (fun (c d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) => c < d) (e, f) (c, d) â†’ ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ e f)) :ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)", "code": "theorem ihsAction_lawful_extends (hÏ€f : Ï€.Free) (c d : Address Î²)\n    (hÏ€ : âˆ€ e f, SplitLt (fun c d => c < d) (e, f) (c, d) â†’ (ihsAction Ï€ e f).Lawful) :\n    (ihsAction Ï€ c d).Lawful := by\n  intro A\n  have litter_map_injective :\n    âˆ€ â¦ƒLâ‚ Lâ‚‚ : Litterâ¦„,\n      âŸ¨A, inr Lâ‚.toNearLitterâŸ© âˆˆ transConstrained c d â†’\n      âŸ¨A, inr Lâ‚‚.toNearLitterâŸ© âˆˆ transConstrained c d â†’\n      ((Ï€.completeNearLitterMap A Lâ‚.toNearLitter : Set Atom) âˆ©\n        (Ï€.completeNearLitterMap A Lâ‚‚.toNearLitter : Set Atom)).Nonempty â†’\n      Lâ‚ = Lâ‚‚ := by\n    intro Lâ‚ Lâ‚‚ hâ‚ hâ‚‚ hâ‚â‚‚\n    have := eq_of_completeLitterMap_inter_nonempty hâ‚â‚‚\n    obtain hâ‚ | hâ‚ := hâ‚ <;> obtain hâ‚‚ | hâ‚‚ := hâ‚‚\n    Â· specialize hÏ€ âŸ¨A, inr Lâ‚.toNearLitterâŸ© âŸ¨A, inr Lâ‚‚.toNearLitterâŸ© (SplitLt.left_split hâ‚ hâ‚‚)\n      exact litter_injective_extends hÏ€f hÏ€ (Or.inl Relation.ReflTransGen.refl)\n        (Or.inr Relation.ReflTransGen.refl) this\n    Â· specialize hÏ€ âŸ¨A, inr Lâ‚.toNearLitterâŸ© d (SplitLt.left_lt hâ‚)\n      exact litter_injective_extends hÏ€f hÏ€\n        (Or.inl Relation.ReflTransGen.refl) (Or.inr hâ‚‚.to_reflTransGen) this\n    Â· specialize hÏ€ c âŸ¨A, inr Lâ‚.toNearLitterâŸ© (SplitLt.right_lt hâ‚)\n      exact litter_injective_extends hÏ€f hÏ€\n        (Or.inr Relation.ReflTransGen.refl) (Or.inl hâ‚‚.to_reflTransGen) this\n    Â· specialize hÏ€ âŸ¨A, inr Lâ‚.toNearLitterâŸ© âŸ¨A, inr Lâ‚‚.toNearLitterâŸ© (SplitLt.right_split hâ‚ hâ‚‚)\n      exact litter_injective_extends hÏ€f hÏ€ (Or.inl Relation.ReflTransGen.refl)\n        (Or.inr Relation.ReflTransGen.refl) this\n  constructor\n  Â· intro a b ha hb hab\n    simp only [ihsAction_atomMap] at ha hb hab\n    obtain ha | ha := ha <;> obtain hb | hb := hb\n    Â· specialize hÏ€ âŸ¨A, inl aâŸ© âŸ¨A, inl bâŸ© (SplitLt.left_split ha hb)\n      exact atom_injective_extends hÏ€ (Or.inl Relation.ReflTransGen.refl)\n        (Or.inr Relation.ReflTransGen.refl) hab\n    Â· specialize hÏ€ âŸ¨A, inl aâŸ© d (SplitLt.left_lt ha)\n      exact atom_injective_extends hÏ€\n        (Or.inl Relation.ReflTransGen.refl) (Or.inr hb.to_reflTransGen) hab\n    Â· specialize hÏ€ c âŸ¨A, inl aâŸ© (SplitLt.right_lt ha)\n      exact atom_injective_extends hÏ€\n        (Or.inr Relation.ReflTransGen.refl) (Or.inl hb.to_reflTransGen) hab\n    Â· specialize hÏ€ âŸ¨A, inl aâŸ© âŸ¨A, inl bâŸ© (SplitLt.right_split ha hb)\n      exact atom_injective_extends hÏ€ (Or.inl Relation.ReflTransGen.refl)\n        (Or.inr Relation.ReflTransGen.refl) hab\n  Â· exact litter_map_injective\n  Â· intro a ha L hL\n    simp only [ihsAction_atomMap, ihsAction_litterMap]\n    have : Ï€.completeAtomMap A a âˆˆ Ï€.completeNearLitterMap A a.fst.toNearLitter := by\n      obtain ha | ha := ha <;> obtain hL | hL := hL\n      Â· specialize hÏ€ âŸ¨A, inl aâŸ© âŸ¨A, inr L.toNearLitterâŸ© (SplitLt.left_split ha hL)\n        exact completeAtomMap_mem_completeNearLitterMap_toNearLitter' hÏ€f hÏ€ rfl\n          (fst_mem_refl_trans_constrained' (Or.inl Relation.ReflTransGen.refl))\n      Â· specialize hÏ€ âŸ¨A, inl aâŸ© d (SplitLt.left_lt ha)\n        exact completeAtomMap_mem_completeNearLitterMap_toNearLitter' hÏ€f hÏ€ rfl\n          (fst_mem_refl_trans_constrained' (Or.inl Relation.ReflTransGen.refl))\n      Â· specialize hÏ€ c âŸ¨A, inl aâŸ© (SplitLt.right_lt ha)\n        exact completeAtomMap_mem_completeNearLitterMap_toNearLitter' hÏ€f hÏ€ rfl\n          (fst_mem_refl_trans_constrained' (Or.inr Relation.ReflTransGen.refl))\n      Â· specialize hÏ€ âŸ¨A, inl aâŸ© âŸ¨A, inr L.toNearLitterâŸ© (SplitLt.right_split ha hL)\n        exact\n          completeAtomMap_mem_completeNearLitterMap_toNearLitter' hÏ€f hÏ€ rfl\n            (fst_mem_refl_trans_constrained' (Or.inl Relation.ReflTransGen.refl))\n    constructor\n    Â· rintro rfl\n      exact this\n    Â· intro h\n      exact litter_map_injective (fst_mem_trans_constrained' ha) hL âŸ¨_, this, hâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 60, 999, 60, 809, 966, 809, 966], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [962, 1027], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.ihsAction_lawful_extends` states that if a `Î²`-structural approximation `Ï€` is free and satisfies the lawfulness condition for all pairs of addresses `e` and `f` that split `c` and `d` under the split relation, then the `Î²`-structural action defined by `Ï€` is lawful for the pair `c` and `d`."}
{"full_name": "ConNF.StructApprox.ihsAction_lawful", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d)", "code": "theorem ihsAction_lawful (hÏ€f : Ï€.Free) (c d : Address Î²) : (ihsAction Ï€ c d).Lawful := by\n  refine WellFounded.induction (C := fun c => (ihsAction Ï€ c.1 c.2).Lawful)\n    (splitLt_wellFounded WellFoundedRelation.wf) (c, d) ?_\n  rintro âŸ¨c, dâŸ© ih\n  exact ihsAction_lawful_extends hÏ€f c d fun e f hef => ih (e, f) hef\n", "additional_info": "Every `ihs_action` is lawful. This is a consequence of all of the previous lemmas.", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1029, 1034], "informalization": "The theorem `ConNF.StructApprox.ihsAction_lawful` states that every `ihs_action` defined in the context of Constructive Ordinal Notation (ConNF) satisfies the lawfulness condition for each `Î²`-extended index."}
{"full_name": "ConNF.StructApprox.completeAtomMap_injective", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeAtomMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeAtomMap_injective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Injective (Ï€.completeAtomMap A) := fun a b =>\n  atom_injective_extends (ihsAction_lawful hÏ€f âŸ¨A, inl aâŸ© âŸ¨A, inl bâŸ©)\n    (Or.inl Relation.ReflTransGen.refl) (Or.inr Relation.ReflTransGen.refl)\n", "additional_info": "The complete atom map is injective.", "used_premises": [1, 402, 779, 781, 782, 61, 89, 784], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1045, 1049], "informalization": "In Constructive Ordinal Notation (ConNF), given a free Î²-structural approximation Ï€, the function that maps each Î²-extended index to an atom, known as the complete atom map, is injective. This means that for any two Î²-extended indices A and B, if the complete atom maps of A and B are equal, then A and B are equal as well."}
{"full_name": "ConNF.StructApprox.completeLitterMap_injective", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeLitterMap_injective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Injective (Ï€.completeLitterMap A) := fun Lâ‚ Lâ‚‚ =>\n  litter_injective_extends hÏ€f\n    (ihsAction_lawful hÏ€f âŸ¨A, inr Lâ‚.toNearLitterâŸ© âŸ¨A, inr Lâ‚‚.toNearLitterâŸ©)\n    (Or.inl Relation.ReflTransGen.refl) (Or.inr Relation.ReflTransGen.refl)\n", "additional_info": "The complete litter map is injective.", "used_premises": [1, 402, 779, 781, 782, 61, 89, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1051, 1056], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_injective` states that the function `ConNF.StructApprox.completeLitterMap`, which takes a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, and a litter `L`, and returns a litter, is injective. This means that for any two litters `Lâ‚` and `Lâ‚‚`, if `ConNF.StructApprox.completeLitterMap Ï€ A Lâ‚ = ConNF.StructApprox.completeLitterMap Ï€ A Lâ‚‚`, then `Lâ‚ = Lâ‚‚`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a âˆˆ ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) â†” a.1 = L", "code": "theorem completeAtomMap_mem_completeNearLitterMap_toNearLitter (hÏ€f : Ï€.Free) {A : ExtendedIndex Î²}\n    {a : Atom} {L : Litter} :\n    Ï€.completeAtomMap A a âˆˆ Ï€.completeNearLitterMap A L.toNearLitter â†” a.1 = L := by\n  have := completeAtomMap_mem_completeNearLitterMap_toNearLitter' hÏ€f\n    (ihsAction_lawful hÏ€f âŸ¨A, inl aâŸ© âŸ¨A, inl aâŸ©) rfl\n    (fst_mem_refl_trans_constrained' (Or.inl Relation.ReflTransGen.refl))\n  constructor\n  Â· intro h\n    exact completeLitterMap_injective hÏ€f _ (eq_of_completeLitterMap_inter_nonempty âŸ¨_, this, hâŸ©)\n  Â· rintro rfl\n    exact this\n", "additional_info": "Atoms inside litters are mapped inside the corresponding image near-litter.", "used_premises": [1, 402, 779, 781, 782, 61, 784, 792, 483], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1058, 1069], "informalization": "The theorem `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter` states that in the context of Constructive Ordinal Notation (ConNF), if a `Î²`-structural approximation `Ï€` is free (meaning that for every `Î²`-extended index `A`, the near-litter approximation `(Ï€ A)` is free with respect to `A`), and `A` is a `Î²`-extended index, `a` is an atom, and `L` is a litter, then the condition `ConNF.StructApprox.completeAtomMap Ï€ A a âˆˆ ConNF.StructApprox.completeNearLitterMap Ï€ A (ConNF.Litter.toNearLitter L)` holds if and only if `a.1 = L`. This means that atoms inside litters are mapped inside the corresponding image near-litter."}
{"full_name": "ConNF.StructApprox.mem_image_iff", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.mem_image_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.mem_image_iff {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} (hf : Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— f) (x : Î±) (s : SetğŸ”—<|PREMISE|>ğŸ”— Î±) :f x âˆˆ f '' s â†” x âˆˆ s", "code": "theorem mem_image_iff {Î± Î² : Type _} {f : Î± â†’ Î²} (hf : Injective f) (x : Î±) (s : Set Î±) :\n    f x âˆˆ f '' s â†” x âˆˆ s :=\n  Set.InjOn.mem_image_iff (hf.injOn Set.univ) (subset_univ _) (mem_univ _)\n", "additional_info": "", "used_premises": [89, 69], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1070, 1073], "informalization": "The theorem `ConNF.StructApprox.mem_image_iff` states that for an injective function `f` and a set `s`, an element `f x` is in the image of `s` under `f` if and only if `x` is in `s`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} {N : ConNF.NearLitter} :ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a âˆˆ ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N â†” a âˆˆ N", "code": "theorem completeAtomMap_mem_completeNearLitterMap (hÏ€f : Ï€.Free) {A : ExtendedIndex Î²} {a : Atom}\n    {N : NearLitter} : Ï€.completeAtomMap A a âˆˆ Ï€.completeNearLitterMap A N â†” a âˆˆ N := by\n  rw [â† SetLike.mem_coe, completeNearLitterMap_eq', Set.symmDiff_def]\n  simp only [mem_union, mem_diff, SetLike.mem_coe, not_exists, not_and,\n    symmDiff_symmDiff_cancel_left]\n  rw [completeAtomMap_mem_completeNearLitterMap_toNearLitter hÏ€f]\n  rw [mem_image_iff (completeAtomMap_injective hÏ€f A)]\n  simp only [â† mem_litterSet, â† mem_diff, â† mem_union]\n  rw [â† Set.symmDiff_def, symmDiff_symmDiff_cancel_left]\n  rw [SetLike.mem_coe]\n", "additional_info": "Atoms inside near litters are mapped inside the corresponding image near-litter.", "used_premises": [1, 402, 779, 781, 782, 61, 784, 792], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1075, 1085], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap` states that if a `Î²`-structural approximation `Ï€` is free, meaning that for every `Î²`-extended index `A`, the near-litter approximation `(Ï€ A)` is free with respect to `A`, then an atom `a` is inside a near-litter `N` if and only if the image of `a` under the function `ConNF.StructApprox.completeAtomMap Ï€ A` is inside the image near-litter `ConNF.StructApprox.completeNearLitterMap Ï€ A N`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_injective", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeNearLitterMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeNearLitterMap_injective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Injective (Ï€.completeNearLitterMap A) := by\n  intro Nâ‚ Nâ‚‚ h\n  rw [â† SetLike.coe_set_eq, Set.ext_iff] at h âŠ¢\n  intro a\n  specialize h (Ï€.completeAtomMap A a)\n  simp only [SetLike.mem_coe, completeAtomMap_mem_completeNearLitterMap hÏ€f] at h âŠ¢\n  exact h\n", "additional_info": "The complete near-litter map is injective.", "used_premises": [1, 402, 779, 781, 782, 61, 89, 792], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1087, 1095], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_injective` states that the function `ConNF.StructApprox.completeNearLitterMap` is injective. This function is used in the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.completeAtomMap_bijective", "url": "ConNF/FOA/Properties/Bijective.html#ConNF.StructApprox.completeAtomMap_bijective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_bijective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.BijectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeAtomMap_bijective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Bijective (Ï€.completeAtomMap A) :=\n  âŸ¨completeAtomMap_injective hÏ€f A, completeAtomMap_surjective hÏ€f AâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1010, 784], "def_path": "ConNF/FOA/Properties/Bijective.lean", "pos": [16, 19], "informalization": "The theorem `ConNF.StructApprox.completeAtomMap_bijective` states that the function `ConNF.StructApprox.completeAtomMap`, which maps each `Î²`-extended index to an atom, is bijective. This means that the function is both injective (one-to-one) and surjective (onto)."}
{"full_name": "Function.Bijective", "url": "Mathlib/Init/Function.html#Function.Bijective", "code_src": "mathlib4", "ptype": "def", "header": "def Function.Bijective {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) :Prop", "code": "def Bijective (f : Î± â†’ Î²) :=\n  Injective f âˆ§ Surjective f\n", "additional_info": "A function is called bijective if it is both injective and surjective.\nEquations\n* ğŸ—ŸFunction.BijectiveğŸ—ŸğŸ”—../.././Mathlib/Init/Function.html#Function.BijectiveğŸ”—  f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸFunction.InjectiveğŸ—ŸğŸ”—../.././Mathlib/Init/Function.html#Function.InjectiveğŸ”—  f ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../.././Init/Prelude.html#AndğŸ”—  ğŸ—ŸFunction.SurjectiveğŸ—ŸğŸ”—../.././Mathlib/Init/Function.html#Function.SurjectiveğŸ”—  f)\n\n", "used_premises": [], "def_path": "Mathlib/Init/Function.lean", "pos": [137, 139], "informalization": "Function `Function.Bijective` checks if a function `f` is bijective, meaning it is both injective (one-to-one) and surjective (onto)."}
{"full_name": "ConNF.StructApprox.completeLitterMap_bijective", "url": "ConNF/FOA/Properties/Bijective.html#ConNF.StructApprox.completeLitterMap_bijective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_bijective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.BijectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeLitterMap_bijective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Bijective (Ï€.completeLitterMap A) :=\n  âŸ¨completeLitterMap_injective hÏ€f A, completeLitterMap_surjective hÏ€f AâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1010, 787], "def_path": "ConNF/FOA/Properties/Bijective.lean", "pos": [20, 23], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_bijective` states that the function `ConNF.StructApprox.completeLitterMap` is bijective, meaning it is both injective (one-to-one) and surjective (onto). This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_bijective", "url": "ConNF/FOA/Properties/Bijective.html#ConNF.StructApprox.completeNearLitterMap_bijective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_bijective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.BijectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeNearLitterMap_bijective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Bijective (Ï€.completeNearLitterMap A) :=\n  âŸ¨completeNearLitterMap_injective hÏ€f A, completeNearLitterMap_surjective hÏ€f AâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1010, 792], "def_path": "ConNF/FOA/Properties/Bijective.lean", "pos": [24, 27], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_bijective` states that the function `ConNF.StructApprox.completeNearLitterMap Ï€ A` is bijective, meaning it is both injective (one-to-one) and surjective (onto), for any free `Î²`-structural approximation `Ï€` and any `Î²`-extended index `A`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_subset_range", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeNearLitterMap_subset_range", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_subset_range [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) :â†‘(ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L)) âŠ† Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeNearLitterMap_subset_range (A : ExtendedIndex Î²) (L : Litter) :\n    (Ï€.completeNearLitterMap A L.toNearLitter : Set Atom) âŠ† range (Ï€.completeAtomMap A) := by\n  rw [completeNearLitterMap_toNearLitter_eq]\n  rintro a (âŸ¨haâ‚, haâ‚‚âŸ© | âŸ¨a, âŸ¨_, haâ‚‚âŸ©, rflâŸ©)\n  Â· refine' âŸ¨(((Ï€ A).largestSublitter L).equiv ((Ï€ A).largestSublitter a.1)).symm\n      âŸ¨a, (Ï€ A).mem_largestSublitter_of_not_mem_domain a haâ‚‚âŸ©, _âŸ©\n    rw [completeAtomMap_eq_of_not_mem_domain]\n    swap\n    Â· exact NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n        (Sublitter.equiv_symm_apply_mem âŸ¨a, _âŸ©)\n    Â· rw [mem_litterSet] at haâ‚\n      have : ((((Ï€ A).largestSublitter L).equiv\n        ((Ï€ A).largestSublitter a.fst)).symm âŸ¨a, rfl, haâ‚‚âŸ© : Atom).fst =\n          L :=\n        Sublitter.equiv_symm_apply_fst_eq âŸ¨a, _âŸ©\n      rw [Sublitter.equiv_congr_left (congr_arg _ this),\n        Sublitter.equiv_congr_right (congr_arg _ (congr_arg _ this)),\n        Sublitter.equiv_congr_right (congr_arg _ haâ‚.symm)]\n      simp only [SetLike.eta, Equiv.apply_symm_apply]\n  Â· refine' âŸ¨a, _âŸ©\n    rw [completeAtomMap_eq_of_mem_domain haâ‚‚]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 483, 1014, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [15, 36], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterMap_subset_range` states that for any `Î²`-extended index `A` and litter `L`, the near-litter `ConNF.StructApprox.completeNearLitterMap Ï€ A (ConNF.Litter.toNearLitter L)` is a subset of the range of the function `ConNF.StructApprox.completeAtomMap Ï€ A`, which maps each `Î²`-extended index to an atom."}
{"full_name": "Set.range", "url": "Mathlib/Data/Set/Defs.html#Set.range", "code_src": "mathlib4", "ptype": "def", "header": "def Set.range {Î± : Type u} {Î¹ : Sort u_1} (f : Î¹ â†’ Î±) :SetğŸ”—<|PREMISE|>ğŸ”— Î±", "code": "def range (f : Î¹ â†’ Î±) : Set Î± := {x | âˆƒ y, f y = x}\n", "additional_info": "Range of a function.\nThis function is more flexible than `f '' univ`, as the image requires that the domain is in Type\nand not an arbitrary Sort.\nEquations\n* ğŸ—ŸSet.rangeğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.rangeğŸ”—  f ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  {x : Î± | âˆƒ (y : Î¹), f y ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  x}\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [156, 157], "informalization": "Function `Set.range` computes the set of all output values of a function `f`, representing the image of the function's domain."}
{"full_name": "ConNF.StructApprox.completeAtomMap_surjective_extends", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAtomMap_surjective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_surjective_extends [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom) (h : a.1 âˆˆ Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)) :a âˆˆ Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeAtomMap_surjective_extends (A : ExtendedIndex Î²) (a : Atom)\n    (h : a.1 âˆˆ range (Ï€.completeLitterMap A)) : a âˆˆ range (Ï€.completeAtomMap A) := by\n  obtain âŸ¨L, hLâŸ© := h\n  by_cases ha : a âˆˆ (Ï€ A).atomPerm.domain\n  Â· refine' âŸ¨(Ï€ A).atomPerm.symm a, _âŸ©\n    rw [completeAtomMap_eq_of_mem_domain ((Ï€ A).atomPerm.symm.map_domain ha)]\n    exact (Ï€ A).atomPerm.right_inv ha\n  Â· have := completeNearLitterMap_toNearLitter_eq (Ï€ := Ï€) A L\n    rw [hL] at this\n    have := Eq.subset this.symm (Or.inl âŸ¨rfl, haâŸ©)\n    exact completeNearLitterMap_subset_range A L this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1014, 787, 1014, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [37, 48], "informalization": "`ConNF.StructApprox.completeAtomMap_surjective_extends` is a theorem in the Lean proof assistant that is used in the context of Constructive Ordinal Notation (ConNF). It states that if a given atom is a member of the range of the litter map generated by a Î²-structural approximation, then it must also be a member of the range of the atom map generated by the same Î²-structural approximation. This theorem is crucial in establishing the \"Freedom of Action\" principle in ConNF, ensuring that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.completeAddressMap_atom_eq", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.completeAddressMap_atom_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :ConNF.StructApprox.completeAddressMapğŸ”—<|PREMISE|>ğŸ”— Ï€ { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } = { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ B a) }", "code": "theorem completeAddressMap_atom_eq {Ï€ : StructApprox Î²} {a : Atom} {B : ExtendedIndex Î²} :\n    Ï€.completeAddressMap âŸ¨B, inl aâŸ© = âŸ¨B, inl (Ï€.completeAtomMap B a)âŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1017, 67, 67, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [55, 58], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.completeAddressMap` takes a `Î²`-structural approximation `Ï€` and returns a function that maps each `Î²`-address to another `Î²`-address. This function is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation. The theorem `ConNF.StructApprox.completeAddressMap_atom_eq` states that for a `Î²`-extended index `B` and an atom `a`, the function `ConNF.StructApprox.completeAddressMap Ï€` maps the `Î²`-address `{ path := B, value := Sum.inl a }` to the `Î²`-address `{ path := B, value := Sum.inl (ConNF.StructApprox.completeAtomMap Ï€ B a) }`."}
{"full_name": "ConNF.StructApprox.completeAddressMap", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeAddressMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†’ ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²", "code": "noncomputable def completeAddressMap (Ï€ : StructApprox Î²) :\n    Address Î² â†’ Address Î²\n  | âŸ¨B, inl aâŸ© => âŸ¨B, inl (Ï€.completeAtomMap B a)âŸ©\n  | âŸ¨B, inr NâŸ© => âŸ¨B, inr (Ï€.completeNearLitterMap B N)âŸ©\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 60, 60], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [49, 53], "informalization": "Function `ConNF.StructApprox.completeAddressMap` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF). It takes as input a `Î²`-structural approximation `Ï€` and returns a function that maps each `Î²`-address to another `Î²`-address. This function is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.completeAddressMap_nearLitter_eq", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap_nearLitter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.completeAddressMap_nearLitter_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :ConNF.StructApprox.completeAddressMapğŸ”—<|PREMISE|>ğŸ”— Ï€ { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } = { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ B N) }", "code": "theorem completeAddressMap_nearLitter_eq {Ï€ : StructApprox Î²} {N : NearLitter}\n    {B : ExtendedIndex Î²} :\n    Ï€.completeAddressMap âŸ¨B, inr NâŸ© = âŸ¨B, inr (Ï€.completeNearLitterMap B N)âŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1017, 65, 65, 792], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [60, 64], "informalization": "The theorem `ConNF.StructApprox.completeAddressMap_nearLitter_eq` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for a `Î²`-structural approximation `Ï€`, the function `ConNF.StructApprox.completeAddressMap Ï€` applied to a `Î²`-address of the form `{ path := B, value := Sum.inr N }` (where `B` is a `Î²`-extended index and `N` is a `Î²`-near-litter) returns a `Î²`-address of the form `{ path := B, value := Sum.inr (ConNF.StructApprox.completeNearLitterMap Ï€ B N) }`."}
{"full_name": "ConNF.StructApprox.completeAddressMap_injective", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAddressMap_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) :Function.InjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAddressMapğŸ”—<|PREMISE|>ğŸ”— Ï€)", "code": "theorem completeAddressMap_injective (hÏ€f : Ï€.Free) :\n    Injective Ï€.completeAddressMap := by\n  rintro âŸ¨Bâ‚, aâ‚ | Nâ‚âŸ© âŸ¨Bâ‚‚, aâ‚‚ | Nâ‚‚âŸ© h <;>\n    rw [Address.ext_iff] at h <;>\n    simp only [completeAddressMap_atom_eq,\n      completeAddressMap_nearLitter_eq,\n      inl.injEq, inr.injEq, and_false] at h\n  Â· cases h.1\n    cases completeAtomMap_injective hÏ€f Bâ‚ h.2\n    rfl\n  Â· cases h.1\n    cases completeNearLitterMap_injective hÏ€f Bâ‚ h.2\n    rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 89, 1017], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [65, 78], "informalization": "Function `ConNF.StructApprox.completeAddressMap` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF). It takes as input a `Î²`-structural approximation `Ï€` and returns a function that maps each `Î²`-address to another `Î²`-address. This function is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.preimageConstrained_small", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageConstrained_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.preimageConstrained_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.preimageConstrainedğŸ”—<|PREMISE|>ğŸ”— Ï€ c)", "code": "theorem preimageConstrained_small (hÏ€f : Ï€.Free) (c : Address Î²) :\n    Small (preimageConstrained Ï€ c) :=\n  Small.preimage (completeAddressMap_injective hÏ€f) (small_constrains c)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 233, 1021], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [82, 85], "informalization": "The theorem `ConNF.StructApprox.preimageConstrained_small` states that the preimage of the set of `Î²`-addresses `d` such that `d â‰º c` under the map `ConNF.StructApprox.completeAddressMap Ï€` is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.preimageConstrained", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageConstrained", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.preimageConstrained [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)", "code": "def preimageConstrained (Ï€ : StructApprox Î²) (c : Address Î²) : Set (Address Î²) :=\n  Ï€.completeAddressMap â»Â¹' {d | d â‰º c}\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.preimageConstrainedğŸ—ŸğŸ”—../../.././ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageConstrainedğŸ”—  Ï€ c ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.StructApprox.completeAddressMapğŸ—ŸğŸ”—../../.././ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMapğŸ”—  Ï€ ğŸ—Ÿâ»Â¹'ğŸ—ŸğŸ”—../../.././Mathlib/Data/Set/Defs.html#Set.preimageğŸ”—  {d : ğŸ—ŸConNF.AddressğŸ—ŸğŸ”—../../.././ConNF/Structural/Support.html#ConNF.AddressğŸ”—  â†‘Î² | d ğŸ—Ÿâ‰ºğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Constrains.html#ConNF.ConstrainsğŸ”—  c}\n\n", "used_premises": [1, 402, 779, 781, 60, 69, 60], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [79, 81], "informalization": "Function `ConNF.StructApprox.preimageConstrained` takes a `Î²`-structural approximation `Ï€` and a `Î²`-address `c`, and returns the preimage of the set of `Î²`-addresses `d` such that `d â‰º c` under the map `ConNF.StructApprox.completeAddressMap Ï€`."}
{"full_name": "ConNF.StructApprox.preimageAction_lawful", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageAction_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.preimageAction_lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.preimageActionğŸ”—<|PREMISE|>ğŸ”— hÏ€f c)", "code": "theorem preimageAction_lawful (hÏ€f : Ï€.Free) {c : Address Î²} :\n    (preimageAction hÏ€f c).Lawful := by\n  intro A\n  constructor\n  Â· intro a b ha hb hab\n    exact completeAtomMap_injective hÏ€f A hab\n  Â· intro Lâ‚ Lâ‚‚ hLâ‚ hLâ‚‚ hL\n    exact completeLitterMap_injective hÏ€f A (eq_of_completeLitterMap_inter_nonempty hL)\n  Â· intro a _ L _\n    exact (completeAtomMap_mem_completeNearLitterMap_toNearLitter hÏ€f).symm\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 809, 1023], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [95, 105], "informalization": "Function `ConNF.StructApprox.preimageAction` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index, under the condition that the `Î²`-structural approximation `Ï€` is free, meaning that for every `Î²`-extended index `A`, the near-litter approximation `(Ï€ A)` is free with respect to `A`. The theorem `ConNF.StructApprox.preimageAction_lawful` proves that this `Î²`-structural action satisfies the lawfulness condition for each `Î²`-extended index."}
{"full_name": "ConNF.StructApprox.preimageAction", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageAction", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.preimageAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²", "code": "noncomputable def preimageAction (hÏ€f : Ï€.Free) (c : Address Î²) : StructAction Î² :=\n  constrainedAction Ï€ (preimageConstrained Ï€ c) (preimageConstrained_small hÏ€f c)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.preimageActionğŸ—ŸğŸ”—../../.././ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageActionğŸ”—  hÏ€f c ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.StructApprox.constrainedActionğŸ—ŸğŸ”—../../.././ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedActionğŸ”—  Ï€ (ğŸ—ŸConNF.StructApprox.preimageConstrainedğŸ—ŸğŸ”—../../.././ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageConstrainedğŸ”—  Ï€ c) â‹¯\n\n", "used_premises": [1, 402, 779, 781, 782, 60, 808], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [86, 88], "informalization": "Function `ConNF.StructApprox.preimageAction` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index, under the condition that the `Î²`-structural approximation `Ï€` is free, meaning that for every `Î²`-extended index `A`, the near-litter approximation `(Ï€ A)` is free with respect to `A`."}
{"full_name": "ConNF.StructApprox.preimageAction_comp_mapFlexible", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageAction_comp_mapFlexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.preimageAction_comp_mapFlexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€} {Î³ : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†‘Î³) :ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A (ConNF.StructApprox.preimageActionğŸ”—<|PREMISE|>ğŸ”— hÏ€f c))", "code": "theorem preimageAction_comp_mapFlexible {hÏ€f : Ï€.Free} {Î³ : Î›} {c : Address Î²}\n    (A : Path (Î² : TypeIndex) Î³) :\n    StructAction.MapFlexible ((preimageAction hÏ€f c).comp A) :=\n  constrainedAction_comp_mapFlexible hÏ€f A\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 76, 814, 304, 1023], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [106, 110], "informalization": "The theorem `ConNF.StructApprox.preimageAction_comp_mapFlexible` in Constructive Ordinal Notation (ConNF) establishes a property of a `Î²`-structural action `Ï†`, specifically that for any path `A` from type index `Î²` to type index `Î³`, if `Ï†` is a free `Î²`-structural action (which ensures that for every `Î²`-extended index `A`, the near-litter approximation `(Ï€ A)` is free with respect to `A`), then the `Î³`-structural action obtained by composing `A` with `Ï†` is such that for any `Î³`-extended index `B`, if `L` is a flexible litter in the domain of the litter map of `Ï†` applied to `B`, then `((Ï† B).litterMap L).get hL` is also a flexible litter. This property is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.Relation.reflTransGen_of_eq", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.Relation.reflTransGen_of_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Relation.reflTransGen_of_eq {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop } {x : Î±} {y : Î±} (h : x = y) :Relation.ReflTransGenğŸ”—<|PREMISE|>ğŸ”— r x y", "code": "theorem Relation.reflTransGen_of_eq {Î± : Type _} {r : Î± â†’ Î± â†’ Prop} {x y : Î±} (h : x = y) :\n    Relation.ReflTransGen r x y := by\n  cases h\n  rfl\n", "additional_info": "", "used_premises": [924], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [111, 115], "informalization": "The theorem `ConNF.StructApprox.Relation.reflTransGen_of_eq` states that for any relation `r` on a type `Î±`, if `x` and `y` are equal, then `x` is related to `y` by the reflexive transitive closure of `r`."}
{"full_name": "ConNF.StructApprox.completeLitterMap_surjective_extends", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeLitterMap_surjective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_surjective_extends [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) (ha : âˆ€ (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom), { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } â‰º { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } â†’ a âˆˆ Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ B)) (hN : âˆ€ (B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter), { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } â‰º { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } â†’ N âˆˆ Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ B)) :L âˆˆ Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeLitterMap_surjective_extends (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) (L : Litter)\n    (ha : âˆ€ (B : ExtendedIndex Î²) (a : Atom),\n      âŸ¨B, inl aâŸ© â‰º âŸ¨A, inr L.toNearLitterâŸ© â†’ a âˆˆ range (Ï€.completeAtomMap B))\n    (hN : âˆ€ (B : ExtendedIndex Î²) (N : NearLitter),\n      âŸ¨B, inr NâŸ© â‰º âŸ¨A, inr L.toNearLitterâŸ© â†’ N âˆˆ range (Ï€.completeNearLitterMap B)) :\n    L âˆˆ range (Ï€.completeLitterMap A) := by\n  obtain h | âŸ¨âŸ¨hâŸ©âŸ© | âŸ¨âŸ¨hâŸ©âŸ© := flexible_cases' A L\n  Â· refine' âŸ¨(NearLitterApprox.flexibleCompletion (Ï€ A) A).symm â€¢ L, _âŸ©\n    rw [completeLitterMap_eq_of_flexible, NearLitterApprox.right_inv_litter]\n    Â· rw [NearLitterApprox.flexibleCompletion_litterPerm_domain_free (Ï€ A) A (hÏ€f A)]\n      exact h\n    Â· exact NearLitterApprox.flexibleCompletion_symm_smul_flexible (Ï€ A) A (hÏ€f A) L h\n  Â· obtain âŸ¨âŸ¨Î³, Îµ, hÎµ, C, rflâŸ©, a, rflâŸ© := h\n    obtain âŸ¨b, rflâŸ© := ha _ a (Constrains.fuzz_bot hÎµ _ a)\n    refine' âŸ¨fuzz (show âŠ¥ â‰  (Îµ : TypeIndex) from bot_ne_coe) b, _âŸ©\n    rw [completeLitterMap_eq_of_inflexibleBot âŸ¨âŸ¨Î³, Îµ, hÎµ, C, rflâŸ©, b, rflâŸ©]\n  Â· obtain âŸ¨âŸ¨Î³, Î´, Îµ, hÎ´, hÎµ, hÎ´Îµ, B, rflâŸ©, t, rflâŸ© := h\n    refine' âŸ¨fuzz hÎ´Îµ\n      (((preimageAction hÏ€f\n            âŸ¨(B.cons hÎµ).cons (bot_lt_coe _),\n              inr (fuzz hÎ´Îµ t).toNearLitterâŸ©).hypothesisedAllowable\n          âŸ¨Î³, Î´, Îµ, hÎ´, hÎµ, hÎ´Îµ, B, rflâŸ©\n          ((preimageAction_lawful hÏ€f).comp _) (preimageAction_comp_mapFlexible _))â»Â¹ â€¢ t), _âŸ©\n    rw [completeLitterMap_eq_of_inflexibleCoe âŸ¨âŸ¨Î³, Î´, Îµ, hÎ´, hÎµ, hÎ´Îµ, B, rflâŸ©, _, rflâŸ©\n        ((ihAction_lawful hÏ€f _).comp _) (ihAction_comp_mapFlexible hÏ€f _ _)]\n    refine' congr_arg _ _\n    dsimp only\n    rw [smul_eq_iff_eq_inv_smul]\n    refine supports (t := t) ?_ ?_\n    Â· intros A a hc\n      have hac := Constrains.fuzz hÎ´ hÎµ hÎ´Îµ B t _ hc\n      specialize ha _ a hac\n      obtain âŸ¨b, haâŸ© := ha\n      have : (Tree.comp A\n        (Allowable.toStructPerm ((preimageAction hÏ€f\n            âŸ¨(B.cons hÎµ).cons (bot_lt_coe _),\n              inr (fuzz hÎ´Îµ t).toNearLitterâŸ©).hypothesisedAllowable\n              âŸ¨Î³, Î´, Îµ, hÎ´, hÎµ, hÎ´Îµ, B, rflâŸ© ((preimageAction_lawful hÏ€f).comp _)\n              (preimageAction_comp_mapFlexible _))))â»Â¹ â€¢ a = b\n      Â· rw [inv_smul_eq_iff, â† ha]\n        rw [StructAction.hypothesisedAllowable]\n        refine' preimageAction_coherent_atom hÏ€f (B.cons hÎ´) A b _ _ _\n          (StructAction.allowable_exactlyApproximates _ _ _ _)\n        rw [ha]\n        exact hac\n      trans b\n      Â· rw [map_inv]\n        exact this\n      Â· rw [map_inv, Tree.inv_apply, â† smul_eq_iff_eq_inv_smul, â† ha]\n        rw [StructAction.hypothesisedAllowable]\n        refine' (ihAction_coherent_atom (B.cons hÎ´) A b _ _\n          ((ihAction_lawful hÏ€f _).comp _) _\n          (StructAction.allowable_exactlyApproximates _ _ _ _)).symm\n        refine' Relation.TransGen.tail' _\n          (Constrains.fuzz hÎ´ hÎµ hÎ´Îµ B _ _ (smul_mem_support hc _))\n        refine' Relation.reflTransGen_of_eq _\n        refine' Address.ext _ _ rfl _\n        change inl _ = inl _\n        simp only [â† this, ne_eq, Tree.comp_bot, Tree.toBot_inv_smul, map_inv,\n          Tree.inv_apply]\n    Â· intros A N hc\n      have hNc := Constrains.fuzz hÎ´ hÎµ hÎ´Îµ B t _ hc\n      specialize hN _ N hNc\n      obtain âŸ¨N', hNâŸ© := hN\n      have : (Tree.comp A\n        (Allowable.toStructPerm ((preimageAction hÏ€f\n          âŸ¨(B.cons hÎµ).cons (bot_lt_coe _),\n            inr (fuzz hÎ´Îµ t).toNearLitterâŸ©).hypothesisedAllowable\n              âŸ¨Î³, Î´, Îµ, hÎ´, hÎµ, hÎ´Îµ, B, rflâŸ© ((preimageAction_lawful hÏ€f).comp _)\n              (preimageAction_comp_mapFlexible _))))â»Â¹ â€¢ N = N'\n      Â· rw [inv_smul_eq_iff, â† hN]\n        rw [StructAction.hypothesisedAllowable]\n        refine' preimageAction_coherent hÏ€f (B.cons hÎ´) A N' _ _ _\n          (StructAction.allowable_exactlyApproximates _ _ _ _)\n        rw [hN]\n        exact hNc\n      trans N'\n      Â· rw [map_inv]\n        exact this\n      Â· rw [map_inv, Tree.inv_apply, â† smul_eq_iff_eq_inv_smul, â† hN]\n        rw [StructAction.hypothesisedAllowable]\n        refine' (ihAction_coherent hÏ€f (B.cons hÎ´) A N' _ _\n          ((ihAction_lawful hÏ€f _).comp _) _\n          (StructAction.allowable_exactlyApproximates _ _ _ _)).symm\n        refine' Relation.TransGen.tail' _\n          (Constrains.fuzz hÎ´ hÎµ hÎ´Îµ B _ _ (smul_mem_support hc _))\n        refine' Relation.reflTransGen_of_eq _\n        refine' Address.ext _ _ rfl _\n        change inr _ = inr _\n        simp only [â† this, ne_eq, Tree.comp_bot, Tree.toBot_inv_smul, map_inv,\n          Tree.inv_apply]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 61, 67, 65, 483, 1014, 784, 61, 65, 65, 483, 1014, 792, 1014, 787], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [140, 231], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_surjective_extends` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any `Î²`-structural approximation `Ï€` that is free, any `Î²`-extended index `A`, and any litter `L`, if for every `Î²`-extended index `B` and every atom `a`, `a` is in the range of `ConNF.StructApprox.completeAtomMap Ï€ B`, and for every `Î²`-extended index `B` and every near-litter `N`, `N` is in the range of `ConNF.StructApprox.completeNearLitterMap Ï€ B`, then `L` is in the range of `ConNF.StructApprox.completeLitterMap Ï€ A`."}
{"full_name": "ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom) {N : ConNF.NearLitter} (h : a âˆˆ ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N) :a âˆˆ Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem atom_mem_range_of_mem_completeNearLitterMap (A : ExtendedIndex Î²) (a : Atom)\n    {N : NearLitter} (h : a âˆˆ Ï€.completeNearLitterMap A N) : a âˆˆ range (Ï€.completeAtomMap A) := by\n  rw [â† SetLike.mem_coe] at h\n  rw [completeNearLitterMap_eq'] at h\n  obtain âŸ¨hâ‚, hâ‚‚âŸ© | âŸ¨hâ‚, hâ‚‚âŸ© := h\n  Â· rw [completeNearLitterMap_toNearLitter_eq] at hâ‚\n    obtain hâ‚ | hâ‚ := hâ‚\n    Â· exact completeAtomMap_surjective_extends A a âŸ¨_, hâ‚.1.symmâŸ©\n    Â· obtain âŸ¨b, hâ‚, rflâŸ© := hâ‚\n      refine' âŸ¨b, _âŸ©\n      exact completeAtomMap_eq_of_mem_domain hâ‚.2\n  Â· obtain âŸ¨b, _, rflâŸ© := hâ‚\n    exact âŸ¨b, rflâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 1014, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [232, 245], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap` states that if an atom `a` belongs to the range of the function `ConNF.StructApprox.completeNearLitterMap`, then `a` also belongs to the range of the function `ConNF.StructApprox.completeAtomMap`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_coe", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeNearLitterMap_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_coe [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) :â†‘(ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N) = ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A '' â†‘N", "code": "theorem completeNearLitterMap_coe (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) (N : NearLitter) :\n    (Ï€.completeNearLitterMap A N : Set Atom) = Ï€.completeAtomMap A '' N := by\n  ext a : 1\n  constructor\n  Â· intro h\n    obtain âŸ¨b, rflâŸ© := atom_mem_range_of_mem_completeNearLitterMap A a h\n    rw [SetLike.mem_coe, completeAtomMap_mem_completeNearLitterMap hÏ€f] at h\n    exact âŸ¨b, h, rflâŸ©\n  Â· rintro âŸ¨b, h, rflâŸ©\n    rw [SetLike.mem_coe, completeAtomMap_mem_completeNearLitterMap hÏ€f]\n    exact h\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 792, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [246, 257], "informalization": "`ConNF.StructApprox.completeNearLitterMap_coe` is a theorem in the context of Constructive Ordinal Notation (ConNF). It states that for any `Î²`-structural approximation `Ï€` that is free, any `Î²`-extended index `A`, and any near-litter `N`, the image of `N` under the function `ConNF.StructApprox.completeNearLitterMap Ï€ A` is equal to the image of `N` under the function `ConNF.StructApprox.completeAtomMap Ï€ A`."}
{"full_name": "ConNF.StructApprox.preimage_symmDiff", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimage_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.preimage_symmDiff {Î± : Type u_1} {Î² : Type u_2} {s : SetğŸ”—<|PREMISE|>ğŸ”— Î²} {t : SetğŸ”—<|PREMISE|>ğŸ”— Î²} {f : Î± â†’ Î²} :f â»Â¹' symmDiffğŸ”—<|PREMISE|>ğŸ”— s t = symmDiffğŸ”—<|PREMISE|>ğŸ”— (f â»Â¹' s) (f â»Â¹' t)", "code": "theorem preimage_symmDiff {Î± Î² : Type _} {s t : Set Î²} {f : Î± â†’ Î²} :\n    f â»Â¹' s âˆ† t = (f â»Â¹' s) âˆ† (f â»Â¹' t) :=\n  rfl\n", "additional_info": "", "used_premises": [69, 69, 62, 62], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [259, 262], "informalization": "The preimage of the symmetric difference of two sets under a function is equal to the symmetric difference of the preimages of the two sets."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_surjective_extends", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeNearLitterMap_surjective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_surjective_extends [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) (hN : N.fst âˆˆ Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)) (ha : symmDiffğŸ”—<|PREMISE|>ğŸ”— (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— N.fst) â†‘N âŠ† Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)) :N âˆˆ Set.rangeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeNearLitterMap_surjective_extends (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²)\n    (N : NearLitter) (hN : N.1 âˆˆ range (Ï€.completeLitterMap A))\n    (ha : litterSet N.1 âˆ† N âŠ† range (Ï€.completeAtomMap A)) :\n    N âˆˆ range (Ï€.completeNearLitterMap A) := by\n  obtain âŸ¨L, hNâŸ© := hN\n  refine' âŸ¨âŸ¨L, Ï€.completeAtomMap A â»Â¹' N, _âŸ©, _âŸ©\n  Â· suffices Small ((Ï€.completeAtomMap A '' L.toNearLitter) âˆ† N) by\n      have := Small.preimage (completeAtomMap_injective hÏ€f A) this\n      rw [preimage_symmDiff, preimage_image_eq _ (completeAtomMap_injective hÏ€f A)] at this\n      exact this\n    rw [â† completeNearLitterMap_coe hÏ€f]\n    refine' IsNearLitter.near _ N.2.2\n    simp only [NearLitter.isNearLitter, completeNearLitterMap_fst_eq]\n    exact hN\n  Â· refine' SetLike.coe_injective _\n    rw [completeNearLitterMap_coe hÏ€f]\n    simp only [NearLitter.coe_mk, Subtype.coe_mk, Litter.coe_toNearLitter]\n    rw [image_preimage_eq_of_subset _]\n    intro a ha'\n    by_cases h : a.1 = N.1\n    Â· rw [â† hN] at h\n      exact completeAtomMap_surjective_extends A a âŸ¨_, h.symmâŸ©\n    Â· exact ha (Or.inr âŸ¨ha', hâŸ©)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1014, 787, 62, 467, 1014, 784, 1014, 792], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [263, 286], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_surjective_extends` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any free `Î²`-structural approximation `Ï€`, any `Î²`-extended index `A`, and any near-litter `N` such that the first projection of `N` is in the range of `ConNF.StructApprox.completeLitterMap Ï€ A` and the symmetric difference of the litter set of `N` and `N` itself is a subset of the range of `ConNF.StructApprox.completeAtomMap Ï€ A`, then `N` is in the range of `ConNF.StructApprox.completeNearLitterMap Ï€ A`."}
{"full_name": "ConNF.StructApprox.completeMap_surjective_extends", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeMap_surjective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeMap_surjective_extends [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hc : âˆ€ d < c, ConNF.StructApprox.CompleteMapSurjectiveAtğŸ”—<|PREMISE|>ğŸ”— Ï€ d) :ConNF.StructApprox.CompleteMapSurjectiveAtğŸ”—<|PREMISE|>ğŸ”— Ï€ c", "code": "theorem completeMap_surjective_extends (hÏ€f : Ï€.Free) (c : Address Î²)\n    (hc : âˆ€ d : Address Î², d < c â†’ Ï€.CompleteMapSurjectiveAt d) :\n    Ï€.CompleteMapSurjectiveAt c := by\n  obtain âŸ¨A, a | NâŸ© := c\n  Â· refine' completeAtomMap_surjective_extends A a _\n    obtain âŸ¨N, hNâŸ© := hc âŸ¨A, inr a.1.toNearLitterâŸ© (Relation.TransGen.single <| Constrains.atom A a)\n    refine' âŸ¨N.1, _âŸ©\n    apply_fun Sigma.fst at hN\n    simp only [Litter.toNearLitter_fst, completeNearLitterMap_fst_eq'] at hN\n    exact hN\n  Â· refine' completeNearLitterMap_surjective_extends hÏ€f A N _ _\n    Â· refine' completeLitterMap_surjective_extends hÏ€f A N.1 _ _\n      Â· intro B a h\n        exact hc âŸ¨B, inl aâŸ© (lt_nearLitter <| Relation.TransGen.single h)\n      Â· intro B N h\n        exact hc âŸ¨B, inr NâŸ© (lt_nearLitter <| Relation.TransGen.single h)\n    Â· intro a h\n      exact hc âŸ¨A, inl aâŸ© (Relation.TransGen.single <| Constrains.symmDiff A N a h)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 1032, 1032], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [295, 313], "informalization": "The theorem `ConNF.StructApprox.completeMap_surjective_extends` is a part of the proof of the Freedom of Action in Constructive Ordinal Notation (ConNF). It asserts that for any `Î²`-structural approximation `Ï€` which is free, if `Ï€` is such that for all addresses `d` less than a given address `c`, the condition `ConNF.StructApprox.CompleteMapSurjectiveAt Ï€ d` holds, then `ConNF.StructApprox.CompleteMapSurjectiveAt Ï€ c` also holds. This theorem is used to prove that any free approximation `Ï€` exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.CompleteMapSurjectiveAt", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.CompleteMapSurjectiveAt", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.CompleteMapSurjectiveAt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î² â†’ Prop", "code": "def CompleteMapSurjectiveAt : Address Î² â†’ Prop\n  | âŸ¨A, inl aâŸ© => a âˆˆ range (Ï€.completeAtomMap A)\n  | âŸ¨A, inr NâŸ© => N âˆˆ range (Ï€.completeNearLitterMap A)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 60], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [289, 292], "informalization": "Function `ConNF.StructApprox.CompleteMapSurjectiveAt` defines a property of `Î²`-structural approximations in the context of Constructive Ordinal Notation (ConNF). Given a `Î²`-structural approximation `Ï€` and an address `âŸ¨A, inl aâŸ©` or `âŸ¨A, inr NâŸ©`, the property `CompleteMapSurjectiveAt Ï€ âŸ¨A, inl aâŸ©` holds if `a` is in the range of `Ï€.completeAtomMap A`, and `CompleteMapSurjectiveAt Ï€ âŸ¨A, inr NâŸ©` holds if `N` is in the range of `Ï€.completeNearLitterMap A`."}
{"full_name": "ConNF.StructApprox.completeMapSurjectiveAtAll", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeMapSurjectiveAtAll", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeMapSurjectiveAtAll [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructApprox.CompleteMapSurjectiveAtğŸ”—<|PREMISE|>ğŸ”— Ï€ c", "code": "theorem completeMapSurjectiveAtAll (hÏ€f : Ï€.Free) (c : Address Î²) :\n    Ï€.CompleteMapSurjectiveAt c :=\n  WellFoundedRelation.wf.induction c (completeMap_surjective_extends hÏ€f)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 1032], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [314, 317], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeMapSurjectiveAtAll` states that for any `Î²`-structural approximation `Ï€` that is free (i.e., every near-litter approximation in `Ï€` is free with respect to the corresponding `Î²`-extended index), and any address `c` in the base type (the atom or near-litter) together with the path detailing how we descend from type `Î²` to type `âŠ¥` by looking at elements of elements and so on in the model, the property `CompleteMapSurjectiveAt Ï€ c` holds, meaning that the address `c` is in the range of `Ï€`'s complete map."}
{"full_name": "ConNF.StructApprox.completeAtomMap_surjective", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAtomMap_surjective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_surjective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.SurjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeAtomMap_surjective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Surjective (Ï€.completeAtomMap A) := fun a => completeMapSurjectiveAtAll hÏ€f âŸ¨A, inl aâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1035, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [318, 320], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAtomMap_surjective` asserts that for any free `Î²`-structural approximation `Ï€` and any `Î²`-extended index `A`, the function `ConNF.StructApprox.completeAtomMap Ï€ A`, which maps each `Î²`-extended index to an atom, is surjective. This means that every atom has at least one corresponding `Î²`-extended index through this function."}
{"full_name": "Function.Surjective", "url": "Mathlib/Init/Function.html#Function.Surjective", "code_src": "mathlib4", "ptype": "def", "header": "def Function.Surjective {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) :Prop", "code": "def Surjective (f : Î± â†’ Î²) : Prop :=\n  âˆ€ b, âˆƒ a, f a = b\n", "additional_info": "A function `f : Î± â†’ Î²` is called surjective if every `b : Î²` is equal to `f a`\nfor some `a : Î±`.\nEquations\n* ğŸ—ŸFunction.SurjectiveğŸ—ŸğŸ”—../.././Mathlib/Init/Function.html#Function.SurjectiveğŸ”—  f ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  âˆ€ (b : Î²), âˆƒ (a : Î±), f a ğŸ—Ÿ=ğŸ—ŸğŸ”—../.././Init/Prelude.html#EqğŸ”—  b\n\n", "used_premises": [], "def_path": "Mathlib/Init/Function.lean", "pos": [125, 127], "informalization": "Function `Function.Surjective` is a predicate that checks if a given function `f` from `Î±` to `Î²` is surjective, meaning every element in `Î²` has at least one corresponding element in `Î±` through `f`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_surjective", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeNearLitterMap_surjective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_surjective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.SurjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeNearLitterMap_surjective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Surjective (Ï€.completeNearLitterMap A) := fun N => completeMapSurjectiveAtAll hÏ€f âŸ¨A, inr NâŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1035, 792], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [321, 323], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_surjective` is a part of the ConNF project and represents a key step in the proof of freedom of action within the Constructive Ordinal Notation (ConNF) system. It establishes that the function `ConNF.StructApprox.completeNearLitterMap` is surjective for a given `Î²`-structural approximation `Ï€` that is free, meaning it satisfies the freedom of action hypothesis. The `Î²`-structural approximation `Ï€` maps `Î²`-extended indices to near-litter approximations, and this surjectivity ensures that for every near-litter approximation, there exists a `Î²`-extended index that maps to it under the `Ï€` function. This theorem is crucial for demonstrating the power of the ConNF system to constructively build up the natural numbers and other mathematical objects using a finite set of type indices and operations defined within the system."}
{"full_name": "ConNF.StructApprox.completeLitterMap_surjective", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeLitterMap_surjective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_surjective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€f : ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Function.SurjectiveğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A)", "code": "theorem completeLitterMap_surjective (hÏ€f : Ï€.Free) (A : ExtendedIndex Î²) :\n    Surjective (Ï€.completeLitterMap A) := by\n  intro L\n  obtain âŸ¨N, hNâŸ© := completeNearLitterMap_surjective hÏ€f A L.toNearLitter\n  refine' âŸ¨N.1, _âŸ©\n  apply_fun Sigma.fst at hN\n  simp only [completeNearLitterMap_fst_eq', Litter.toNearLitter_fst] at hN\n  exact hN\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1035, 787], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [324, 332], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_surjective` proves that the function `ConNF.StructApprox.completeLitterMap` is surjective. This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), and it takes a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, and a litter `L`, and returns a litter. The theorem states that for any `Î²`-structural approximation `Ï€` that is free, and any `Î²`-extended index `A`, the function `ConNF.StructApprox.completeLitterMap Ï€ A` is surjective."}
{"full_name": "ConNF.StructApprox.transConstrained_symm", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_symm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d = ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— d c", "code": "theorem transConstrained_symm (c d : Address Î²) :\n    transConstrained c d = transConstrained d c :=\n  union_comm _ _\n", "additional_info": "", "used_premises": [1, 60, 60, 995, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [21, 24], "informalization": "The theorem `ConNF.StructApprox.transConstrained_symm` states that the function `ConNF.StructApprox.transConstrained` is symmetric, meaning that for any two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF), the set of addresses that are either strictly less than `c` or strictly less than `d` is the same as the set of addresses that are either strictly less than `d` or strictly less than `c`."}
{"full_name": "ConNF.StructApprox.reflTransConstrained_symm", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained_symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.reflTransConstrained_symm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d = ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— d c", "code": "theorem reflTransConstrained_symm (c d : Address Î²) :\n    reflTransConstrained c d = reflTransConstrained d c :=\n  union_comm _ _\n", "additional_info": "", "used_premises": [1, 60, 60, 967, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [25, 28], "informalization": "The theorem `ConNF.StructApprox.reflTransConstrained_symm` states that the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF), is symmetric with respect to `c` and `d`."}
{"full_name": "ConNF.StructApprox.transConstrained_self", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_self", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.transConstrained_self [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c c = {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î² | e < c}", "code": "theorem transConstrained_self (c : Address Î²) : transConstrained c c = {e | e < c} :=\n  union_self _\n", "additional_info": "", "used_premises": [1, 60, 995, 60], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [30, 32], "informalization": "The theorem `ConNF.StructApprox.transConstrained_self` states that for any address `c` in the context of Constructive Ordinal Notation (ConNF), the set of addresses that are either strictly less than `c` or strictly less than `c` itself is exactly the set of addresses that are strictly less than `c`."}
{"full_name": "ConNF.StructApprox.reflTransConstrained_self", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained_self", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.reflTransConstrained_self [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c c = {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î² | e â‰¤ c}", "code": "theorem reflTransConstrained_self (c : Address Î²) :\n    reflTransConstrained c c = {e | e â‰¤ c} :=\n  union_self _\n", "additional_info": "", "used_premises": [1, 60, 967, 60], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [34, 37], "informalization": "Function `ConNF.StructApprox.reflTransConstrained` defines a set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF). The theorem `ConNF.StructApprox.reflTransConstrained_self` states that for any address `c`, the set of addresses `ConNF.StructApprox.reflTransConstrained c c` is equal to the set of addresses that are less than or equal to `c`."}
{"full_name": "ConNF.StructApprox.mem_reflTransConstrained_of_mem_transConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.mem_reflTransConstrained_of_mem_transConstrained", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.mem_reflTransConstrained_of_mem_transConstrained [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (he : e âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :e âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem mem_reflTransConstrained_of_mem_transConstrained {c d e : Address Î²}\n    (he : e âˆˆ transConstrained c d) : e âˆˆ reflTransConstrained c d := by\n  obtain he | he := he\n  exact Or.inl he.to_reflTransGen\n  exact Or.inr he.to_reflTransGen\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 995, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [38, 43], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given three addresses `c`, `d`, and `e`, if `e` is in the transitive closure of `c` and `d`, then `e` is also in the reflexive-transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.transConstrained_trans", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_trans", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_trans [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {f : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (he : e âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hf : f â‰¤ e) :f âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem transConstrained_trans {c d e f : Address Î²} (he : e âˆˆ transConstrained c d)\n    (hf : f â‰¤ e) : f âˆˆ transConstrained c d := by\n  obtain he | he := he\n  exact Or.inl (Relation.TransGen.trans_right hf he)\n  exact Or.inr (Relation.TransGen.trans_right hf he)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 995, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [44, 49], "informalization": "Function `ConNF.StructApprox.transConstrained` takes two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF) and returns a set of addresses that are either strictly less than `c` or strictly less than `d`. This set represents the transitive closure of the relation defined by `c` and `d`. The theorem `ConNF.StructApprox.transConstrained_trans` states that if `e` is in the transitive closure of `c` and `d`, and `f` is less than or equal to `e`, then `f` is also in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.reflTransConstrained_trans", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained_trans", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.reflTransConstrained_trans [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {f : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (he : e âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hf : f â‰¤ e) :f âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem reflTransConstrained_trans {c d e f : Address Î²}\n    (he : e âˆˆ reflTransConstrained c d) (hf : f â‰¤ e) : f âˆˆ reflTransConstrained c d := by\n  obtain he | he := he\n  exact Or.inl (hf.trans he)\n  exact Or.inr (hf.trans he)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 967, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [50, 55], "informalization": "Given a chain of addresses `e` and `f` where `e` is in the refl-trans closure of `c` and `d`, and `f` is less than or equal to `e`, then `f` is also in the refl-trans closure of `c` and `d`. This is a property of transitive closures in the context of constructing ordinals using Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {f : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (he : e âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hf : f < e) :f âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem transConstrained_of_reflTransConstrained_of_trans_constrains {c d e f : Address Î²}\n    (he : e âˆˆ reflTransConstrained c d) (hf : f < e) : f âˆˆ transConstrained c d := by\n  obtain he | he := he\n  exact Or.inl (hf.trans_left he)\n  exact Or.inr (hf.trans_left he)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 967, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [56, 61], "informalization": "The theorem `ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains` is a mathematical statement about Constructive Ordinal Notation (ConNF), which is a system used for representing ordinals in a computer proof assistant. The theorem states that if an address `f` is strictly less than another address `e`, and `e` is in the reflexive-transitive closure of the addresses `c` and `d`, then `f` is in the transitive closure of `c` and `d`. This theorem is used to prove properties about the structure of ConNFAddresses and helps to establish the correctness and soundness of the ConNF system in representing ordinals."}
{"full_name": "ConNF.StructApprox.transConstrained_of_constrains", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_of_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_of_constrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {f : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (he : e âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hf : f â‰º e) :f âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem transConstrained_of_constrains {c d e f : Address Î²}\n    (he : e âˆˆ transConstrained c d) (hf : f â‰º e) : f âˆˆ transConstrained c d :=\n  transConstrained_trans he (Relation.ReflTransGen.single hf)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 995, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [62, 65], "informalization": "The theorem `ConNF.StructApprox.transConstrained_of_constrains` states that if `e` is in the transitive closure of `c` and `d`, and `f` is strictly less than `e`, then `f` is also in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.reflTransConstrained_of_constrains", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained_of_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.reflTransConstrained_of_constrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {f : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (he : e âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hf : f â‰º e) :f âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem reflTransConstrained_of_constrains {c d e f : Address Î²}\n    (he : e âˆˆ reflTransConstrained c d) (hf : f â‰º e) : f âˆˆ reflTransConstrained c d :=\n  reflTransConstrained_trans he (Relation.ReflTransGen.single hf)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 967, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [66, 69], "informalization": "The theorem `ConNF.StructApprox.reflTransConstrained_of_constrains` states that if `e` is in the set of addresses that are either less than or equal to `c` or less than or equal to `d`, and `f` is strictly less than `e`, then `f` is also in the set of addresses that are either less than or equal to `c` or less than or equal to `d`."}
{"full_name": "ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {e : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {f : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (he : e âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) (hf : f â‰º e) :f âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem transConstrained_of_reflTransConstrained_of_constrains {c d e f : Address Î²}\n    (he : e âˆˆ reflTransConstrained c d) (hf : f â‰º e) : f âˆˆ transConstrained c d :=\n  transConstrained_of_reflTransConstrained_of_trans_constrains he (Relation.TransGen.single hf)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 967, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [70, 73], "informalization": "The theorem `ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains` states that if `e` is in the reflexive-transitive closure of `c` and `d`, and `f` is strictly less than `e`, then `f` is in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_transConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_transConstrained", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_transConstrained [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} (hac : { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem fst_transConstrained {c d : Address Î²} {A : ExtendedIndex Î²} {a : Atom}\n    (hac : âŸ¨A, inl aâŸ© âˆˆ reflTransConstrained c d) :\n    âŸ¨A, inr a.fst.toNearLitterâŸ© âˆˆ transConstrained c d :=\n  transConstrained_of_reflTransConstrained_of_constrains hac (Constrains.atom A a)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 67, 967, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [74, 78], "informalization": "The theorem `ConNF.StructApprox.fst_transConstrained` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if an address `A` with a left injection of an atom `a` is in the reflexive-transitive closure of two addresses `c` and `d`, then the same address `A` with a right injection of the near-litter corresponding to `a` is in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_trans_constrained'", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_trans_constrained'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_trans_constrained' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} (h : { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem fst_mem_trans_constrained' {c d : Address Î²} {A : ExtendedIndex Î²} {a : Atom}\n    (h : âŸ¨A, inl aâŸ© âˆˆ transConstrained c d) :\n    âŸ¨A, inr a.fst.toNearLitterâŸ© âˆˆ transConstrained c d :=\n  transConstrained_of_constrains h (Constrains.atom A a)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 67, 995, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [79, 83], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_trans_constrained'` asserts that if an address in the transitive closure of two addresses `c` and `d` is of the form `{ path := A, value := Sum.inl a }`, where `A` is an extended index and `a` is an atom, then the corresponding near-litter address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }` is also in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_transConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_transConstrained", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_transConstrained [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} (hN : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst) } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem fst_mem_transConstrained {c d : Address Î²} {A : ExtendedIndex Î²} {N : NearLitter}\n    (hN : âŸ¨A, inr NâŸ© âˆˆ transConstrained c d) :\n    âŸ¨A, inr N.fst.toNearLitterâŸ© âˆˆ transConstrained c d := by\n  obtain hN | hN := hN\n  exact Or.inl (lt_nearLitter' hN)\n  exact Or.inr (lt_nearLitter' hN)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 65, 995, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [84, 90], "informalization": "The theorem `ConNF.StructApprox.fst_mem_transConstrained` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if a near-litter `N` is an element of the transitive closure of the relation defined by two addresses `c` and `d`, then the near-litter obtained by converting the litter of `N` to a near-litter is also an element of the transitive closure of the relation defined by `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_refl_trans_constrained'", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_refl_trans_constrained'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_refl_trans_constrained' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} (h : { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem fst_mem_refl_trans_constrained' {c d : Address Î²} {A : ExtendedIndex Î²} {a : Atom}\n    (h : âŸ¨A, inl aâŸ© âˆˆ reflTransConstrained c d) :\n    âŸ¨A, inr a.fst.toNearLitterâŸ© âˆˆ reflTransConstrained c d :=\n  reflTransConstrained_of_constrains h (Constrains.atom A a)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 67, 967, 65, 483, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [91, 95], "informalization": "The theorem `ConNF.StructApprox.fst_mem_refl_trans_constrained'` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if a certain address is in the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF), then another related address is also in the same set. This theorem is crucial for proving the correctness of the ConNF construction."}
{"full_name": "ConNF.StructApprox.fst_mem_reflTransConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_reflTransConstrained", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_reflTransConstrained [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} (hN : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem fst_mem_reflTransConstrained {c d : Address Î²} {A : ExtendedIndex Î²}\n    {N : NearLitter} (hN : âŸ¨A, inr NâŸ© âˆˆ reflTransConstrained c d) :\n    âŸ¨A, inr N.fst.toNearLitterâŸ© âˆˆ reflTransConstrained c d := by\n  obtain hN | hN := hN\n  exact Or.inl (le_nearLitter hN)\n  exact Or.inr (le_nearLitter hN)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 65, 967, 65, 483, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [96, 102], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_reflTransConstrained` states that if a near-litter `N` is an element of the set `ConNF.StructApprox.reflTransConstrained c d`, then the near-litter formed by wrapping the litter of `N` with its litter set is also an element of `ConNF.StructApprox.reflTransConstrained c d`."}
{"full_name": "ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a âˆˆ symmDiffğŸ”—<|PREMISE|>ğŸ”— (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— N.fst) â†‘N) (hN : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem fst_mem_transConstrained_of_mem_symmDiff {c d : Address Î²} {A : ExtendedIndex Î²}\n    {N : NearLitter} {a : Atom} (h : a âˆˆ litterSet N.1 âˆ† N)\n    (hN : âŸ¨A, inr NâŸ© âˆˆ transConstrained c d) :\n    âŸ¨A, inr a.fst.toNearLitterâŸ© âˆˆ transConstrained c d := by\n  obtain âŸ¨hâ‚, hâ‚‚âŸ© | âŸ¨hâ‚, hâ‚‚âŸ© := h\n  Â· rw [mem_litterSet] at hâ‚\n    rw [hâ‚]\n    exact fst_mem_transConstrained hN\n  Â· obtain hN | hN := hN\n    Â· refine' fst_mem_trans_constrained' (Or.inl _)\n      exact Relation.TransGen.head (Constrains.symmDiff A N a (Or.inr âŸ¨hâ‚, hâ‚‚âŸ©)) hN\n    Â· refine' fst_mem_trans_constrained' (Or.inr _)\n      exact Relation.TransGen.head (Constrains.symmDiff A N a (Or.inr âŸ¨hâ‚, hâ‚‚âŸ©)) hN\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 62, 467, 65, 995, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [103, 116], "informalization": "The theorem `ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff` states that if an atom `a` is in the symmetric difference of the litter set of a near-litter `N` and the near-litter `N` itself, and if `N` is in the transitive closure of two addresses `c` and `d`, then the near-litter formed by the litter of `a` is also in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a âˆˆ symmDiffğŸ”—<|PREMISE|>ğŸ”— (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— N.fst) â†‘N) (hN : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) } âˆˆ ConNF.StructApprox.reflTransConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem fst_mem_reflTransConstrained_of_mem_symmDiff {c d : Address Î²}\n    {A : ExtendedIndex Î²} {N : NearLitter} {a : Atom} (h : a âˆˆ litterSet N.1 âˆ† N)\n    (hN : âŸ¨A, inr NâŸ© âˆˆ reflTransConstrained c d) :\n    âŸ¨A, inr a.fst.toNearLitterâŸ© âˆˆ reflTransConstrained c d := by\n  obtain âŸ¨hâ‚, hâ‚‚âŸ© | âŸ¨hâ‚, hâ‚‚âŸ© := h\n  Â· rw [mem_litterSet] at hâ‚\n    rw [hâ‚]\n    exact fst_mem_reflTransConstrained hN\n  Â· obtain hN | hN := hN\n    Â· refine' fst_mem_refl_trans_constrained' (Or.inl _)\n      exact Relation.ReflTransGen.head (Constrains.symmDiff A N a (Or.inr âŸ¨hâ‚, hâ‚‚âŸ©)) hN\n    Â· refine' fst_mem_refl_trans_constrained' (Or.inr _)\n      exact Relation.ReflTransGen.head (Constrains.symmDiff A N a (Or.inr âŸ¨hâ‚, hâ‚‚âŸ©)) hN\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 62, 467, 65, 967, 65, 483, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [117, 130], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff` states that if an atom `a` belongs to the symmetric difference of the litter set of a near-litter `N` and the near-litter `N` itself, and if the near-litter `N` is in the reflexive-transitive closure of two addresses `c` and `d`, then the near-litter formed by the litter of `a` and its litter set is also in the reflexive-transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_transConstrained_of_mem", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_transConstrained_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_transConstrained_of_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a âˆˆ N) (hN : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) :{ path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— a.1) } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d", "code": "theorem fst_mem_transConstrained_of_mem {c d : Address Î²} {A : ExtendedIndex Î²}\n    {N : NearLitter} {a : Atom} (h : a âˆˆ N) (hN : âŸ¨A, inr NâŸ© âˆˆ transConstrained c d) :\n    âŸ¨A, inr a.fst.toNearLitterâŸ© âˆˆ transConstrained c d := by\n  by_cases ha : a.1 = N.1\n  Â· rw [ha]\n    exact fst_mem_transConstrained hN\n  Â· exact fst_mem_transConstrained_of_mem_symmDiff (Or.inr âŸ¨h, haâŸ©) hN\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 65, 995, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [131, 138], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_transConstrained_of_mem` asserts that if an atom `a` belongs to a near-litter `N`, and the near-litter `N` is an element of the transitive closure of the relation defined by two addresses `c` and `d`, then the near-litter formed by wrapping the litter of `a` is also an element of the transitive closure of the relation defined by `c` and `d`."}
{"full_name": "ConNF.StructApprox.constrainedAction_atomMap", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.constrainedAction_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} {hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} :(ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs B).atomMap a = { Dom := âˆƒ c âˆˆ s, { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } â‰¤ c, get := fun (x : âˆƒ c âˆˆ s, { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } â‰¤ c) => ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ B a }", "code": "theorem constrainedAction_atomMap {Ï€ : StructApprox Î²} {s : Set (Address Î²)} {hs : Small s}\n    {B : ExtendedIndex Î²} {a : Atom} :\n    (constrainedAction Ï€ s hs B).atomMap a =\n      âŸ¨âˆƒ c : Address Î², c âˆˆ s âˆ§ âŸ¨B, inl aâŸ© â‰¤ c,\n        fun _ => completeAtomMap Ï€ B aâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 69, 60, 233, 61, 978, 67, 67, 784], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [187, 193], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.constrainedAction_atomMap` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index, under the condition that the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.StructApprox.constrainedAction_litterMap", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.constrainedAction_litterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} {hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} :(ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs B).litterMap L = { Dom := âˆƒ c âˆˆ s, { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } â‰¤ c, get := fun (x : âˆƒ c âˆˆ s, { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } â‰¤ c) => ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ B (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) }", "code": "theorem constrainedAction_litterMap {Ï€ : StructApprox Î²} {s : Set (Address Î²)}\n    {hs : Small s} {B : ExtendedIndex Î²} {L : Litter} :\n    (constrainedAction Ï€ s hs B).litterMap L =\n      âŸ¨âˆƒ c : Address Î², c âˆˆ s âˆ§ âŸ¨B, inr L.toNearLitterâŸ© â‰¤ c,\n        fun _ => Ï€.completeNearLitterMap B L.toNearLitterâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 69, 60, 233, 61, 978, 65, 483, 65, 483, 792, 483], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [195, 201], "informalization": "The function `ConNF.StructApprox.constrainedAction_litterMap` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index, under the condition that the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.StructApprox.ihsAction_atomMap", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.ihsAction_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ihsAction_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} :(ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d B).atomMap a = { Dom := { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d, get := fun (x : { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) => ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ B a }", "code": "theorem ihsAction_atomMap {Ï€ : StructApprox Î²} {c d : Address Î²} {B : ExtendedIndex Î²}\n    {a : Atom} :\n    (ihsAction Ï€ c d B).atomMap a =\n      âŸ¨âŸ¨B, inl aâŸ© âˆˆ transConstrained c d,\n        fun _ => completeAtomMap Ï€ B aâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 60, 60, 61, 966, 67, 995, 67, 995, 784], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [203, 209], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.ihsAction_atomMap` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index. It takes a `Î²`-structural approximation `Ï€` and returns a function that maps each `Î²`-extended index to an atom. This function is defined using the `ConNF.HypAction.fixAtom` function, which is part of the `ConNF.HypAction` class. The `ConNF.HypAction.fixAtom` function uses the `ConNF.StructApprox.atomCompletion` and `ConNF.StructApprox.nearLitterCompletion` components of the `Î²`-structural approximation `Ï€`."}
{"full_name": "ConNF.StructApprox.ihsAction_litterMap", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.ihsAction_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ihsAction_litterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} :(ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d B).litterMap L = { Dom := { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d, get := fun (x : { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } âˆˆ ConNF.StructApprox.transConstrainedğŸ”—<|PREMISE|>ğŸ”— c d) => ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ B (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) }", "code": "theorem ihsAction_litterMap {Ï€ : StructApprox Î²} {c d : Address Î²} {B : ExtendedIndex Î²}\n    {L : Litter} :\n    (ihsAction Ï€ c d B).litterMap L =\n      âŸ¨âŸ¨B, inr L.toNearLitterâŸ© âˆˆ transConstrained c d,\n        fun _ => Ï€.completeNearLitterMap B L.toNearLitterâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 60, 60, 61, 966, 65, 483, 995, 65, 483, 995, 792, 483], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [211, 217], "informalization": "The function `ConNF.StructApprox.ihsAction_litterMap` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index in the context of Constructive Ordinal Notation (ConNF). This function is used in the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.ihsAction_symm", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.ihsAction_symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_symm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (d : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ c d = ConNF.StructApprox.ihsActionğŸ”—<|PREMISE|>ğŸ”— Ï€ d c", "code": "theorem ihsAction_symm (Ï€ : StructApprox Î²) (c d : Address Î²) :\n    ihsAction Ï€ c d = ihsAction Ï€ d c := by\n  funext\n  ext\n  Â· funext\n    rw [ihsAction_atomMap, ihsAction_atomMap, transConstrained_symm]\n  Â· funext\n    rw [ihsAction_litterMap, ihsAction_litterMap, transConstrained_symm]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 60, 60, 966, 966], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [218, 226], "informalization": "The theorem `ConNF.StructApprox.ihsAction_symm` states that the `Î²`-structural action (defined by `ConNF.StructApprox.ihsAction`) is symmetric in the sense that swapping the arguments does not change the outcome. This property is crucial for establishing the well-definedness of the `Î²`-structural action when constructing proofs about the freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.constrainedAction_mono", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction_mono", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_mono [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {s : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} {t : SetğŸ”—<|PREMISE|>ğŸ”— (ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²)} {hs : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— s} {ht : ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— t} (h : s âŠ† t) :ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ s hs â‰¤ ConNF.StructApprox.constrainedActionğŸ”—<|PREMISE|>ğŸ”— Ï€ t ht", "code": "theorem constrainedAction_mono {Ï€ : StructApprox Î²} {s t : Set (Address Î²)} {hs : Small s}\n    {ht : Small t} (h : s âŠ† t) : constrainedAction Ï€ s hs â‰¤ constrainedAction Ï€ t ht :=\n  fun _ =>\n  âŸ¨âŸ¨fun _ ha => âŸ¨ha.choose, h ha.choose_spec.1, ha.choose_spec.2âŸ©, fun _ _ => rflâŸ©,\n    âŸ¨fun _ hL => âŸ¨hL.choose, h hL.choose_spec.1, hL.choose_spec.2âŸ©, fun _ _ => rflâŸ©âŸ©\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 69, 60, 69, 60, 233, 233, 978, 978], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [239, 244], "informalization": "Let $s \\subseteq t$ be subsets of the set of $\\beta$-extended indices with the property that their cardinalities are strictly less than the cardinality of type $\\kappa$. Then, the constrained action of $\\pi$ on $s$ is less than or equal to the constrained action of $\\pi$ on $t$."}
{"full_name": "ConNF.NearLitterAction.mk_dom_symmDiff_le", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.mk_dom_symmDiff_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_dom_symmDiff_le [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap) (ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† '' PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L}", "code": "theorem mk_dom_symmDiff_le :\n    #(Ï†.litterMap.Dom âˆ† (Ï†.roughLitterMapOrElse '' Ï†.litterMap.Dom) : Set Litter) â‰¤\n      #{L : Litter | Â¬Ï†.BannedLitter L} := by\n  rw [mk_not_bannedLitter]\n  refine' le_trans (le_of_lt _) Params.Îº_lt_Î¼.le\n  exact Small.symmDiff Ï†.litterMap_dom_small Ï†.litterMap_dom_small.image\n", "additional_info": "", "used_premises": [1, 29, 62, 404, 1064, 404, 29, 1065], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [20, 26], "informalization": "The theorem `ConNF.NearLitterAction.mk_dom_symmDiff_le` states that the cardinality of the symmetric difference of the domain of `Ï†.litterMap` and the image of the domain of `Ï†.litterMap` under `ConNF.NearLitterAction.roughLitterMapOrElse` is less than or equal to the cardinality of the set of litters that are not banned by `Ï†`."}
{"full_name": "ConNF.NearLitterAction.roughLitterMapOrElse", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.roughLitterMapOrElse [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.Litter", "code": "noncomputable def roughLitterMapOrElse (L : Litter) : Litter :=\n  (Ï†.litterMapOrElse L).1\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.roughLitterMapOrElseğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—  Ï† L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (ğŸ—ŸConNF.NearLitterAction.litterMapOrElseğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.litterMapOrElseğŸ”—  Ï† L).fst\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [161, 163], "informalization": "Function `ConNF.NearLitterAction.roughLitterMapOrElse` takes a `ConNF.NearLitterAction` object `Ï†` and a `ConNF.Litter` object `L`, and returns the first component of the result of applying `ConNF.NearLitterAction.litterMapOrElse` to `Ï†` and `L`."}
{"full_name": "ConNF.NearLitterAction.BannedLitter", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.BannedLitter", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.NearLitterAction.BannedLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.Litter â†’ Prop", "code": "inductive BannedLitter : Litter â†’ Prop\n  | atomDom (a : Atom) : (Ï†.atomMap a).Dom â†’ BannedLitter a.1\n  | litterDom (L : Litter) : (Ï†.litterMap L).Dom â†’ BannedLitter L\n  | atomMap (a : Atom) (h) : BannedLitter ((Ï†.atomMap a).get h).1\n  | litterMap (L : Litter) (h) : BannedLitter ((Ï†.litterMap L).get h).1\n  | diff (L : Litter) (h) (a : Atom) :\n    a âˆˆ ((Ï†.litterMap L).get h : Set Atom) \\ litterSet ((Ï†.litterMap L).get h).1 â†’ BannedLitter a.1\n", "additional_info": "A litter that is not allowed to be used as a sandbox because it appears somewhere that\nwe need to preserve.\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [59, 66], "informalization": "The type `ConNF.NearLitterAction.BannedLitter` represents a litter that is not allowed to be used as a sandbox because it appears somewhere that we need to preserve."}
{"full_name": "ConNF.NearLitterAction.aleph0_le_not_bannedLitter", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.aleph0_le_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.aleph0_le_not_bannedLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L}", "code": "theorem aleph0_le_not_bannedLitter : â„µâ‚€ â‰¤ #{L | Â¬Ï†.BannedLitter L} := by\n  rw [mk_not_bannedLitter]\n  exact Params.Î¼_isStrongLimit.isLimit.aleph0_le\n", "additional_info": "", "used_premises": [1, 510, 29, 1065], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [27, 30], "informalization": "The theorem `ConNF.NearLitterAction.aleph0_le_not_bannedLitter` states that the cardinality of the set of litters that are not banned is at least `â„µâ‚€`, the smallest infinite cardinal number."}
{"full_name": "ConNF.NearLitterAction.litterPerm'_apply_eq", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterPerm'_apply_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} (L : ConNF.Litter) (hL : L âˆˆ PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap) :(ConNF.NearLitterAction.litterPerm'ğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).toFun L = ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† L", "code": "theorem litterPerm'_apply_eq {Ï† : NearLitterAction} {hÏ† : Ï†.Lawful} (L : Litter)\n    (hL : L âˆˆ Ï†.litterMap.Dom) : Ï†.litterPerm' hÏ† L = Ï†.roughLitterMapOrElse L :=\n  PartialPerm.complete_apply_eq _ _ _ hL\n", "additional_info": "", "used_premises": [1, 825, 404, 1068, 1064], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [52, 55], "informalization": "The function ConNF.NearLitterAction.litterPerm'_apply_eq is a theorem that states that for any litter L in the domain of the map of a near litter action Ï†, the application of the permutation litterPerm' to L is equal to the first component of the result of applying roughLitterMapOrElse to Ï† and L. This theorem ensures that the permutation on litters behaves as expected according to the laws of the near litter action."}
{"full_name": "ConNF.NearLitterAction.litterPerm'", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.litterPerm' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :PartialPermğŸ”—<|PREMISE|>ğŸ”— ConNF.Litter", "code": "noncomputable def litterPerm' (hÏ† : Ï†.Lawful) : PartialPerm Litter :=\n  PartialPerm.complete Ï†.roughLitterMapOrElse Ï†.litterMap.Dom {L | Â¬Ï†.BannedLitter L}\n    Ï†.mk_dom_symmDiff_le Ï†.aleph0_le_not_bannedLitter Ï†.disjoint_dom_not_bannedLitter\n    (Ï†.roughLitterMapOrElse_injOn hÏ†)\n", "additional_info": "A local permutation on the set of litters that occur in the domain or range of `w`.\nThis permutes both flexible and inflexible litters.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 645], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [33, 37], "informalization": "Function `ConNF.NearLitterAction.litterPerm'` is a partial permutation on the set of litters in the context of Constructive Ordinal Notation (ConNF). It represents a local permutation that permutes both flexible and inflexible litters."}
{"full_name": "ConNF.NearLitterAction.litterPerm_apply_eq", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterPerm_apply_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} (L : ConNF.Litter) (hL : L âˆˆ PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap) :(ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).toFun L = ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† L", "code": "theorem litterPerm_apply_eq {Ï† : NearLitterAction} {hÏ† : Ï†.Lawful} (L : Litter)\n    (hL : L âˆˆ Ï†.litterMap.Dom) : Ï†.litterPerm hÏ† L = Ï†.roughLitterMapOrElse L := by\n  rw [â† litterPerm'_apply_eq L hL]\n  exact PartialPerm.piecewise_apply_eq_left (Or.inl (Or.inl hL))\n", "additional_info": "", "used_premises": [1, 825, 404, 1070, 1064], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [56, 60], "informalization": "The theorem states that for any lawful near litter action `Ï†` and any litter `L` in the domain of the litter map, the partial permutation `ConNF.NearLitterAction.litterPerm Ï† hÏ†` applied to `L` is equal to `ConNF.NearLitterAction.roughLitterMapOrElse Ï† L`."}
{"full_name": "ConNF.NearLitterAction.litterPerm", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.litterPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :PartialPermğŸ”—<|PREMISE|>ğŸ”— ConNF.Litter", "code": "noncomputable def litterPerm (hÏ† : Ï†.Lawful) : PartialPerm Litter :=\n  PartialPerm.piecewise (Ï†.litterPerm' hÏ†) (Ï†.idOnBanned (Ï†.litterPerm' hÏ†).domain)\n    (by rw [â† Set.subset_compl_iff_disjoint_left]; exact fun L h => h.2)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.litterPermğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPermğŸ”—  Ï† hÏ† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸPartialPerm.piecewiseğŸ—ŸğŸ”—../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewiseğŸ”—  (ğŸ—ŸConNF.NearLitterAction.litterPerm'ğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'ğŸ”—  Ï† hÏ†)\n(ğŸ—ŸConNF.NearLitterAction.idOnBannedğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.idOnBannedğŸ”—  Ï† (ğŸ—ŸConNF.NearLitterAction.litterPerm'ğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'ğŸ”—  Ï† hÏ†).domain) â‹¯\n\n", "used_premises": [1, 825, 645], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [48, 51], "informalization": "The function `ConNF.NearLitterAction.litterPerm` is a partial permutation on the set of litters in the context of Constructive Ordinal Notation (ConNF). It is defined as a piecewise function that combines two components: `ConNF.NearLitterAction.litterPerm' Ï† hÏ†` and `ConNF.NearLitterAction.idOnBanned Ï† (ConNF.NearLitterAction.litterPerm' Ï† hÏ†).domain`. The first component, `ConNF.NearLitterAction.litterPerm' Ï† hÏ†`, is a partial permutation on the set of litters, and the second component, `ConNF.NearLitterAction.idOnBanned Ï† (ConNF.NearLitterAction.litterPerm' Ï† hÏ†).domain`, is the identity permutation on the complement of the domain of `ConNF.NearLitterAction.litterPerm' Ï† hÏ†`."}
{"full_name": "ConNF.NearLitterAction.litterPerm'_domain_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterPerm'_domain_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.litterPerm'ğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain", "code": "theorem litterPerm'_domain_small (hÏ† : Ï†.Lawful) : Small (Ï†.litterPerm' hÏ†).domain := by\n  refine' Small.union (Small.union Ï†.litterMap_dom_small Ï†.litterMap_dom_small.image) _\n  rw [Small]\n  rw [Cardinal.mk_congr (PartialPerm.sandboxSubsetEquiv _ _)]\n  simp only [mk_sum, mk_prod, mk_denumerable, lift_aleph0, lift_uzero, lift_id]\n  refine' add_lt_of_lt Params.Îº_isRegular.aleph0_le _ _ <;>\n    refine' mul_lt_of_lt Params.Îº_isRegular.aleph0_le\n      (lt_of_le_of_lt aleph0_le_mk_Î› Params.Î›_lt_Îº) _ <;>\n    refine' lt_of_le_of_lt (mk_subtype_mono (diff_subset _ _)) _\n  exact Ï†.litterMap_dom_small\n  exact Ï†.litterMap_dom_small.image\n", "additional_info": "", "used_premises": [1, 825, 233, 1068], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [61, 72], "informalization": "The theorem `ConNF.NearLitterAction.litterPerm'_domain_small` states that the domain of the partial permutation `ConNF.NearLitterAction.litterPerm'` on the set of litters in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.litterPerm_domain_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterPerm_domain_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain", "code": "theorem litterPerm_domain_small (hÏ† : Ï†.Lawful) : Small (Ï†.litterPerm hÏ†).domain :=\n  Small.union (Ï†.litterPerm'_domain_small hÏ†) (Small.mono (diff_subset _ _) Ï†.bannedLitter_small)\n", "additional_info": "", "used_premises": [1, 825, 233, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [73, 75], "informalization": "The theorem `ConNF.NearLitterAction.litterPerm_domain_small` states that the domain of the partial permutation `ConNF.NearLitterAction.litterPerm Ï† hÏ†` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterAction.atomMap_ran_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.atomMap_ran_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomMap_ran_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap)", "code": "theorem atomMap_ran_small : Small Ï†.atomMap.ran := by\n  have : Small (Ï†.atomMapOrElse '' Ï†.atomMap.Dom) := Small.image Ï†.atomMap_dom_small\n  refine' Small.mono _ this\n  rintro _ âŸ¨a, ha, rflâŸ©\n  refine' âŸ¨a, ha, _âŸ©\n  rw [atomMapOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 233, 824], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [82, 88], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.atomMap_ran_small` asserts that the range of the partial function `Ï†.atomMap`, which maps elements of a \"near-litter\" to \"atoms\" in ConNF, is a small set. This means that the cardinality of the set of all possible values that `Ï†.atomMap` can produce is strictly less than the cardinality of the type `ConNF.Îº`. This property is crucial for the construction of the natural numbers in ConNF to avoid inconsistencies in the definition of subtraction."}
{"full_name": "ConNF.NearLitterAction.needForwardImages_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needForwardImages_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.needForwardImages_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem needForwardImages_small : Small Ï†.needForwardImages :=\n  Small.mono (diff_subset _ _) Ï†.atomMap_ran_small\n", "additional_info": "", "used_premises": [1, 233, 1075], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [89, 91], "informalization": "The theorem `ConNF.NearLitterAction.needForwardImages_small` states that the set of elements in the range of the partial function `Ï†.atomMap` that are not in its domain has a cardinality strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.needForwardImages", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needForwardImages", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.needForwardImages [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def needForwardImages : Set Atom :=\n  Ï†.atomMap.ran \\ Ï†.atomMap.Dom\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.needForwardImagesğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needForwardImagesğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸPFun.ranğŸ—ŸğŸ”—../../.././Mathlib/Data/PFun.html#PFun.ranğŸ”—  Ï†.atomMap ğŸ—Ÿ\\ğŸ—ŸğŸ”—../../.././Init/Core.html#SDiff.sdiffğŸ”—  ğŸ—ŸPFun.DomğŸ—ŸğŸ”—../../.././Mathlib/Data/PFun.html#PFun.DomğŸ”—  Ï†.atomMap\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [76, 78], "informalization": "Function `ConNF.NearLitterAction.needForwardImages` computes the set of elements in the range of the partial function `Ï†.atomMap` that are not in its domain."}
{"full_name": "ConNF.NearLitterAction.needBackwardImages_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needBackwardImages_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.needBackwardImages_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem needBackwardImages_small : Small Ï†.needBackwardImages :=\n  Small.mono (diff_subset _ _) Ï†.atomMap_dom_small\n", "additional_info": "", "used_premises": [1, 233, 1077], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [92, 94], "informalization": "The theorem `ConNF.NearLitterAction.needBackwardImages_small` states that the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap` has a cardinality strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.needBackwardImages", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needBackwardImages", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.needBackwardImages [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def needBackwardImages : Set Atom :=\n  Ï†.atomMap.Dom \\ Ï†.atomMap.ran\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.needBackwardImagesğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needBackwardImagesğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸPFun.DomğŸ—ŸğŸ”—../../.././Mathlib/Data/PFun.html#PFun.DomğŸ”—  Ï†.atomMap ğŸ—Ÿ\\ğŸ—ŸğŸ”—../../.././Init/Core.html#SDiff.sdiffğŸ”—  ğŸ—ŸPFun.ranğŸ—ŸğŸ”—../../.././Mathlib/Data/PFun.html#PFun.ranğŸ”—  Ï†.atomMap\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [79, 81], "informalization": "Function `ConNF.NearLitterAction.needBackwardImages` computes the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. This set is defined as the difference between the domain of the partial function and its range."}
{"full_name": "ConNF.NearLitterAction.mk_diff_dom_ran", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.mk_diff_dom_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_diff_dom_ran [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L \\ (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆª PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap)) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem mk_diff_dom_ran (L : Litter) :\n    #(litterSet L \\ (Ï†.atomMap.Dom âˆª Ï†.atomMap.ran) : Set Atom) = #Îº := by\n  refine' le_antisymm _ _\n  Â· refine' âŸ¨âŸ¨fun a => a.1.2, _âŸ©âŸ©\n    intro a b h\n    exact Subtype.coe_injective (Prod.ext (a.prop.1.trans b.prop.1.symm) h)\n  Â· by_contra h\n    have := add_lt_of_lt Params.Îº_isRegular.aleph0_le (lt_of_not_le h)\n      (Small.union Ï†.atomMap_dom_small Ï†.atomMap_ran_small)\n    have := (le_mk_diff_add_mk (litterSet L) _).trans_lt this\n    simp only [mk_litterSet, lt_self_iff_false] at this\n", "additional_info": "", "used_premises": [1, 29, 467, 404, 824, 29], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [95, 106], "informalization": "The theorem `ConNF.NearLitterAction.mk_diff_dom_ran` asserts that the difference between the number of atoms in a litter `L` (excluding those in the domain and range of the `NearLitterAction` function `Ï†`) and the cardinality of the set of atoms in `ConNF.Îº` is equal to the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.need_images_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.need_images_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.need_images_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†) âŠ• â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem need_images_small :\n    #(Sum (â„• Ã— Ï†.needBackwardImages) (â„• Ã— Ï†.needForwardImages)) < #Îº := by\n  simp only [mk_prod, mk_denumerable, lift_aleph0, lift_uzero, mk_diff_dom_ran, mk_sum, lift_id]\n  rw [â† mul_add]\n  refine' lt_of_le_of_lt (mul_le_max _ _) (max_lt (max_lt _ _) _)\n  exact aleph0_le_mk_Î›.trans_lt Params.Î›_lt_Îº\n  exact add_lt_of_lt Params.Îº_isRegular.aleph0_le\n    Ï†.needBackwardImages_small Ï†.needForwardImages_small\n  exact aleph0_le_mk_Î›.trans_lt Params.Î›_lt_Îº\n", "additional_info": "", "used_premises": [1, 29, 1077, 1075, 29], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [107, 116], "informalization": "The theorem states that the cardinality of the union of two sets, each being the product of `â„•` (the natural numbers) with a subset of `ConNF.Atom`s (the atoms used in the notation system of Constructive Ordinal Notation, ConNF), is less than the cardinality of `ConNF.Îº`. The first set consists of pairs `(n, a)` where `n` is a natural number and `a` is an atom that needs backward images under the partial function `ConNF.NearLitterAction.atomMap`, and the second set consists of pairs `(n, b)` where `n` is a natural number and `b` is an element in the range of the partial function that is not in its domain. The inequality signifies that the union of these two sets is a small subset of `ConNF.Îº`, which is a key condition for the construction of the natural numbers in ConNF."}
{"full_name": "ConNF.NearLitterAction.le_mk_diff_dom_ran", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.le_mk_diff_dom_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.le_mk_diff_dom_ran [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†) âŠ• â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L \\ (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆª PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap))", "code": "theorem le_mk_diff_dom_ran (L : Litter) :\n    #(Sum (â„• Ã— Ï†.needBackwardImages) (â„• Ã— Ï†.needForwardImages)) â‰¤\n      #(litterSet L \\ (Ï†.atomMap.Dom âˆª Ï†.atomMap.ran) : Set Atom) := by\n  rw [mk_diff_dom_ran]\n  exact Ï†.need_images_small.le\n", "additional_info": "", "used_premises": [1, 29, 1077, 1075, 29, 467, 404, 824], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [117, 122], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.le_mk_diff_dom_ran` states that the cardinality of the union of two sets, each representing the need for backward and forward images under a partial function `Ï†.atomMap`, is less than or equal to the cardinality of the difference between the litter set corresponding to a given litter `L` and the union of the domain and range of `Ï†.atomMap`."}
{"full_name": "ConNF.NearLitterAction.orbitSet_subset", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSet_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbitSet_subset [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.NearLitterAction.orbitSetğŸ”—<|PREMISE|>ğŸ”— Ï† L âŠ† ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L \\ (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆª PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap)", "code": "theorem orbitSet_subset (L : Litter) :\n    Ï†.orbitSet L âŠ† litterSet L \\ (Ï†.atomMap.Dom âˆª Ï†.atomMap.ran) :=\n  (le_mk_iff_exists_subset.mp (Ï†.le_mk_diff_dom_ran L)).choose_spec.1\n", "additional_info": "", "used_premises": [1, 1082, 467, 404, 824], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [126, 129], "informalization": "Given a `ConNF.NearLitterAction` object `Ï†` and a `ConNF.Litter` object `L`, the set `ConNF.NearLitterAction.orbitSet Ï† L` represents the orbit of `L` under the action of `Ï†`. This set contains all the `ConNF.Atom` objects that can be reached from `L` by repeatedly applying the action defined by `Ï†`. The theorem `ConNF.NearLitterAction.orbitSet_subset` states that this orbit set is a subset of the set `ConNF.litterSet L` minus the union of the domain and range of the partial function `Ï†.atomMap`."}
{"full_name": "ConNF.NearLitterAction.orbitSet", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSet", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.orbitSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def orbitSet (L : Litter) : Set Atom :=\n  (le_mk_iff_exists_subset.mp (Ï†.le_mk_diff_dom_ran L)).choose\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.orbitSetğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSetğŸ”—  Ï† L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸExists.chooseğŸ—ŸğŸ”—../../.././Init/Classical.html#Exists.chooseğŸ”—  â‹¯\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [123, 125], "informalization": "Function `ConNF.NearLitterAction.orbitSet` is a method that, given a `ConNF.NearLitterAction` object `Ï†` and a `ConNF.Litter` object `L`, returns a set of `ConNF.Atom` objects. This set represents the orbit of `L` under the action of `Ï†`, which means it contains all the `ConNF.Atom` objects that can be reached from `L` by repeatedly applying the action defined by `Ï†`."}
{"full_name": "ConNF.NearLitterAction.not_mem_needForwardImages_of_mem_orbitSet", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.not_mem_needForwardImages_of_mem_orbitSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.not_mem_needForwardImages_of_mem_orbitSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} (h : a âˆˆ ConNF.NearLitterAction.orbitSetğŸ”—<|PREMISE|>ğŸ”— Ï† L) :a âˆ‰ ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†", "code": "theorem not_mem_needForwardImages_of_mem_orbitSet {a : Atom} {L : Litter} (h : a âˆˆ Ï†.orbitSet L) :\n    a âˆ‰ Ï†.needForwardImages := fun ha => (Ï†.orbitSet_subset L h).2 (Or.inr ha.1)\n", "additional_info": "", "used_premises": [1, 1082, 1075], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [130, 132], "informalization": "Given a `ConNF.NearLitterAction` object `Ï†` and a `ConNF.Litter` object `L`, if an `ConNF.Atom` object `a` is in the orbit of `L` under the action of `Ï†`, then `a` is not in the set of elements in the range of the partial function `Ï†.atomMap` that are not in its domain."}
{"full_name": "ConNF.NearLitterAction.not_mem_needBackwardImages_of_mem_orbitSet", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.not_mem_needBackwardImages_of_mem_orbitSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.not_mem_needBackwardImages_of_mem_orbitSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} (h : a âˆˆ ConNF.NearLitterAction.orbitSetğŸ”—<|PREMISE|>ğŸ”— Ï† L) :a âˆ‰ ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†", "code": "theorem not_mem_needBackwardImages_of_mem_orbitSet {a : Atom} {L : Litter} (h : a âˆˆ Ï†.orbitSet L) :\n    a âˆ‰ Ï†.needBackwardImages := fun ha => (Ï†.orbitSet_subset L h).2 (Or.inl ha.1)\n", "additional_info": "", "used_premises": [1, 1082, 1077], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [133, 135], "informalization": "Given a `ConNF.NearLitterAction` object `Ï†` and a `ConNF.Litter` object `L`, if an `ConNF.Atom` object `a` is in the orbit of `L` under the action of `Ï†`, then `a` is not in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`."}
{"full_name": "ConNF.NearLitterAction.mk_orbitSet", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.mk_orbitSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_orbitSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.NearLitterAction.orbitSetğŸ”—<|PREMISE|>ğŸ”— Ï† L) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— (â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†) âŠ• â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†))", "code": "theorem mk_orbitSet (L : Litter) :\n    #(Ï†.orbitSet L) = #(Sum (â„• Ã— Ï†.needBackwardImages) (â„• Ã— Ï†.needForwardImages)) :=\n  (le_mk_iff_exists_subset.mp (Ï†.le_mk_diff_dom_ran L)).choose_spec.2\n", "additional_info": "", "used_premises": [1, 29, 1082, 29, 1077, 1075], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [136, 139], "informalization": "The theorem `ConNF.NearLitterAction.mk_orbitSet` states that the cardinality of the orbit of a `ConNF.Litter` object `L` under the action of a `ConNF.NearLitterAction` object `Ï†` is equal to the cardinality of the set `â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImages Ï†) âŠ• â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImages Ï†)`."}
{"full_name": "ConNF.NearLitterAction.orbitSet_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSet_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbitSet_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.orbitSetğŸ”—<|PREMISE|>ğŸ”— Ï† L)", "code": "theorem orbitSet_small (L : Litter) : Small (Ï†.orbitSet L) := by\n  rw [Small, mk_orbitSet]\n  exact Ï†.need_images_small\n", "additional_info": "", "used_premises": [1, 233, 1082], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [161, 164], "informalization": "Given a `ConNF.NearLitterAction` object `Ï†` and a `ConNF.Litter` object `L`, the set of `ConNF.Atom` objects that can be reached from `L` by repeatedly applying the action defined by `Ï†` has a cardinality that is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage_eq", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextForwardImage_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} {a : â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} {b : â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} (hLâ‚ : Lâ‚ âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain) (hLâ‚‚ : Lâ‚‚ âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain) (h : ConNF.NearLitterAction.nextForwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚ a = ConNF.NearLitterAction.nextForwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚‚ b) :Lâ‚ = Lâ‚‚", "code": "theorem nextForwardImage_eq {Lâ‚ Lâ‚‚ : Litter} {a b : â„• Ã— Ï†.needForwardImages}\n    (hLâ‚ : Lâ‚ âˆˆ (Ï†.litterPerm hÏ†).domain) (hLâ‚‚ : Lâ‚‚ âˆˆ (Ï†.litterPerm hÏ†).domain)\n    (h : Ï†.nextForwardImage hÏ† Lâ‚ a = Ï†.nextForwardImage hÏ† Lâ‚‚ b) : Lâ‚ = Lâ‚‚ := by\n  rw [nextForwardImage, nextForwardImage] at h\n  have ha :=\n    Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† Lâ‚)).symm (inr (a.1 + 1, a.2))).prop\n  have hb :=\n    Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† Lâ‚‚)).symm (inr (b.1 + 1, b.2))).prop\n  rw [h] at ha\n  refine' (Ï†.litterPerm hÏ†).injOn hLâ‚ hLâ‚‚ _\n  exact eq_of_mem_litterSet_of_mem_litterSet ha.1 hb.1\n", "additional_info": "", "used_premises": [1, 825, 1075, 1075, 1070, 1070, 1088, 1088], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [190, 201], "informalization": "The `ConNF.NearLitterAction.nextForwardImage_eq` theorem in Lean 4 states that for a lawful near litter action Ï†, if two elements `a` and `b` are mapped by `ConNF.NearLitterAction.nextForwardImage Ï† hÏ†` to the same litter element, then the two litters containing `a` and `b` respectively must be equal."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.nextForwardImage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (L : ConNF.Litter) (a : â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)) :ConNF.Atom", "code": "noncomputable def nextForwardImage (L : Litter) (a : â„• Ã— Ï†.needForwardImages) : Atom :=\n  (Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† L)).symm (inr (a.1 + 1, a.2))\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.nextForwardImageğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImageğŸ”—  Ï† hÏ† L a ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  â†‘((ğŸ—ŸConNF.NearLitterAction.orbitSetEquivğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSetEquivğŸ”—  Ï† ((ğŸ—ŸConNF.NearLitterAction.litterPermğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPermğŸ”—  Ï† hÏ†).toFun L)).symm\n(ğŸ—ŸSum.inrğŸ—ŸğŸ”—../../.././Init/Core.html#Sum.inrğŸ”—  (a.1 ğŸ—Ÿ+ğŸ—ŸğŸ”—../../.././Init/Prelude.html#HAdd.hAddğŸ”—  1, a.2)))\n\n", "used_premises": [1, 825, 1075], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [165, 167], "informalization": "Function `ConNF.NearLitterAction.nextForwardImage` computes the next element in the range of the partial function `Ï†.atomMap` that is not in its domain, given a lawful near litter action `Ï†`, a litter `L`, and an element `a` in the set of elements in the range of `Ï†.atomMap` that are not in its domain."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImage_eq", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextBackwardImage_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} {a : â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} {b : â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} (ha : a âˆˆ ConNF.NearLitterAction.nextBackwardImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚) (hb : b âˆˆ ConNF.NearLitterAction.nextBackwardImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚‚) (hLâ‚ : Lâ‚ âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain) (hLâ‚‚ : Lâ‚‚ âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain) (h : ConNF.NearLitterAction.nextBackwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚ a = ConNF.NearLitterAction.nextBackwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚‚ b) :Lâ‚ = Lâ‚‚", "code": "theorem nextBackwardImage_eq {Lâ‚ Lâ‚‚ : Litter} {a b : â„• Ã— Ï†.needBackwardImages}\n    (ha : a âˆˆ Ï†.nextBackwardImageDomain hÏ† Lâ‚) (hb : b âˆˆ Ï†.nextBackwardImageDomain hÏ† Lâ‚‚)\n    (hLâ‚ : Lâ‚ âˆˆ (Ï†.litterPerm hÏ†).domain) (hLâ‚‚ : Lâ‚‚ âˆˆ (Ï†.litterPerm hÏ†).domain)\n    (h : Ï†.nextBackwardImage hÏ† Lâ‚ a = Ï†.nextBackwardImage hÏ† Lâ‚‚ b) : Lâ‚ = Lâ‚‚ := by\n  obtain âŸ¨m, aâŸ© := a\n  obtain âŸ¨n, bâŸ© := b\n  obtain (_ | m) := m <;>\n    obtain (_ | n) := n <;>\n    simp only [nextBackwardImage, nextBackwardImage] at h\n  Â· simp only [nextBackwardImageDomain, Function.iterate_succ, Function.comp_apply,\n      mem_setOf_eq, Function.iterate_zero, id.def] at ha hb\n    rw [â† h, ha.2] at hb\n    exact hb.2\n  Â· rw [Subtype.coe_eq_iff] at h\n    cases Ï†.not_mem_needBackwardImages_of_mem_orbitSet ((Ï†.orbitSetEquiv _).symm _).prop h.1\n  Â· symm at h\n    rw [Subtype.coe_eq_iff] at h\n    cases Ï†.not_mem_needBackwardImages_of_mem_orbitSet ((Ï†.orbitSetEquiv _).symm _).prop h.1\n  Â· have ha :=\n      Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† Lâ‚)).symm (inl (m, a))).prop\n    have hb :=\n      Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† Lâ‚‚)).symm (inl (n, b))).prop\n    rw [h] at ha\n    refine' (Ï†.litterPerm hÏ†).injOn hLâ‚ hLâ‚‚ _\n    exact eq_of_mem_litterSet_of_mem_litterSet ha.1 hb.1\n", "additional_info": "", "used_premises": [1, 825, 1077, 1077, 1090, 1090, 1070, 1070, 1091, 1091], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [202, 227], "informalization": "Function `ConNF.NearLitterAction.nextBackwardImage` is used in the context of Constructive Ordinal Notation (ConNF) to compute the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. The theorem `ConNF.NearLitterAction.nextBackwardImage_eq` states that for two elements `a` and `b` in the domain of `ConNF.NearLitterAction.nextBackwardImage`, if their next backward images are equal, then the corresponding litters `Lâ‚` and `Lâ‚‚` must also be equal."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImageDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImageDomain", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.nextBackwardImageDomain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (L : ConNF.Litter) :SetğŸ”—<|PREMISE|>ğŸ”— (â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†))", "code": "def nextBackwardImageDomain (L : Litter) : Set (â„• Ã— Ï†.needBackwardImages) :=\n  {a |\n    (a.2 : Atom).1 âˆˆ (Ï†.litterPerm hÏ†).domain âˆ§\n      ((Ï†.litterPerm hÏ†).symm^[a.1 + 1]) (a.2 : Atom).1 = L}\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 69, 1077], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [175, 179], "informalization": "Function `ConNF.NearLitterAction.nextBackwardImageDomain` computes the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. This set is defined as the difference between the domain of the partial function and its range."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImage", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImage", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.nextBackwardImage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (L : ConNF.Litter) :â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†) â†’ ConNF.Atom", "code": "noncomputable def nextBackwardImage (L : Litter) : â„• Ã— Ï†.needBackwardImages â†’ Atom\n  | (0, a) => a\n  | (n + 1, a) => (Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† L)).symm (inl (n, a))\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 1077], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [168, 171], "informalization": "Function `ConNF.NearLitterAction.nextBackwardImage` is used in the context of Constructive Ordinal Notation (ConNF) to compute the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage_injective", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextForwardImage_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {L : ConNF.Litter} {a : â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} {b : â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} (h : ConNF.NearLitterAction.nextForwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† L a = ConNF.NearLitterAction.nextForwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† L b) :a = b", "code": "theorem nextForwardImage_injective {L : Litter} {a b : â„• Ã— Ï†.needForwardImages}\n    (h : Ï†.nextForwardImage hÏ† L a = Ï†.nextForwardImage hÏ† L b) : a = b := by\n  simp only [nextForwardImage, Subtype.coe_inj, EmbeddingLike.apply_eq_iff_eq, inr.injEq,\n    Prod.mk.injEq, add_left_inj] at h\n  exact Prod.ext h.1 h.2\n", "additional_info": "", "used_premises": [1, 825, 1075, 1075, 1088, 1088], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [228, 233], "informalization": "The theorem `ConNF.NearLitterAction.nextForwardImage_injective` states that the function `ConNF.NearLitterAction.nextForwardImage`, which computes the next element in the range of the partial function `Ï†.atomMap` that is not in its domain, given a lawful near litter action `Ï†`, a litter `L`, and an element `a` in the set of elements in the range of `Ï†.atomMap` that are not in its domain, is injective."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImage_injective", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImage_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextBackwardImage_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {L : ConNF.Litter} {a : â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} {b : â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} (ha : a âˆˆ ConNF.NearLitterAction.nextBackwardImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† L) (hb : b âˆˆ ConNF.NearLitterAction.nextBackwardImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† L) (h : ConNF.NearLitterAction.nextBackwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† L a = ConNF.NearLitterAction.nextBackwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† L b) :a = b", "code": "theorem nextBackwardImage_injective {L : Litter} {a b : â„• Ã— Ï†.needBackwardImages}\n    (ha : a âˆˆ Ï†.nextBackwardImageDomain hÏ† L) (hb : b âˆˆ Ï†.nextBackwardImageDomain hÏ† L)\n    (h : Ï†.nextBackwardImage hÏ† L a = Ï†.nextBackwardImage hÏ† L b) : a = b := by\n  obtain âŸ¨m, aâŸ© := a\n  obtain âŸ¨n, bâŸ© := b\n  cases m <;> cases n <;>\n    simp only [Prod.mk.inj_iff, EmbeddingLike.apply_eq_iff_eq, nextBackwardImage,\n      true_and_iff, Subtype.coe_inj, inl.injEq, Prod.mk.injEq, Nat.succ.injEq] at h âŠ¢\n  Â· exact h\n  Â· rw [Subtype.coe_eq_iff] at h\n    cases Ï†.not_mem_needBackwardImages_of_mem_orbitSet ((Ï†.orbitSetEquiv _).symm _).prop h.1\n  Â· symm at h\n    rw [Subtype.coe_eq_iff] at h\n    cases Ï†.not_mem_needBackwardImages_of_mem_orbitSet ((Ï†.orbitSetEquiv _).symm _).prop h.1\n  Â· exact h\n", "additional_info": "", "used_premises": [1, 825, 1077, 1077, 1090, 1090, 1091, 1091], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [234, 249], "informalization": "The theorem `ConNF.NearLitterAction.nextBackwardImage_injective` states that the function `ConNF.NearLitterAction.nextBackwardImage`, which computes the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`, is injective."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage_injective'", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage_injective'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextForwardImage_injective' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} {a : â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} {b : â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} (hLâ‚ : Lâ‚ âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain) (hLâ‚‚ : Lâ‚‚ âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain) (h : ConNF.NearLitterAction.nextForwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚ a = ConNF.NearLitterAction.nextForwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚‚ b) :a = b", "code": "theorem nextForwardImage_injective' {Lâ‚ Lâ‚‚ : Litter} {a b : â„• Ã— Ï†.needForwardImages}\n    (hLâ‚ : Lâ‚ âˆˆ (Ï†.litterPerm hÏ†).domain) (hLâ‚‚ : Lâ‚‚ âˆˆ (Ï†.litterPerm hÏ†).domain)\n    (h : Ï†.nextForwardImage hÏ† Lâ‚ a = Ï†.nextForwardImage hÏ† Lâ‚‚ b) : a = b := by\n  cases Ï†.nextForwardImage_eq hÏ† hLâ‚ hLâ‚‚ h\n  exact Ï†.nextForwardImage_injective hÏ† h\n", "additional_info": "", "used_premises": [1, 825, 1075, 1075, 1070, 1070, 1088, 1088], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [250, 255], "informalization": "The theorem `ConNF.NearLitterAction.nextForwardImage_injective'` states that the function `ConNF.NearLitterAction.nextForwardImage`, which computes the next element in the range of the partial function `Ï†.atomMap` that is not in its domain, given a lawful near litter action `Ï†`, a litter `L`, and an element `a` in the set of elements in the range of `Ï†.atomMap` that are not in its domain, is injective."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImage_injective'", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImage_injective'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextBackwardImage_injective' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} {a : â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} {b : â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} (ha : a âˆˆ ConNF.NearLitterAction.nextBackwardImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚) (hb : b âˆˆ ConNF.NearLitterAction.nextBackwardImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚‚) (hLâ‚ : Lâ‚ âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain) (hLâ‚‚ : Lâ‚‚ âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain) (h : ConNF.NearLitterAction.nextBackwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚ a = ConNF.NearLitterAction.nextBackwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚‚ b) :a = b", "code": "theorem nextBackwardImage_injective' {Lâ‚ Lâ‚‚ : Litter} {a b : â„• Ã— Ï†.needBackwardImages}\n    (ha : a âˆˆ Ï†.nextBackwardImageDomain hÏ† Lâ‚) (hb : b âˆˆ Ï†.nextBackwardImageDomain hÏ† Lâ‚‚)\n    (hLâ‚ : Lâ‚ âˆˆ (Ï†.litterPerm hÏ†).domain) (hLâ‚‚ : Lâ‚‚ âˆˆ (Ï†.litterPerm hÏ†).domain)\n    (h : Ï†.nextBackwardImage hÏ† Lâ‚ a = Ï†.nextBackwardImage hÏ† Lâ‚‚ b) : a = b := by\n  cases Ï†.nextBackwardImage_eq hÏ† ha hb hLâ‚ hLâ‚‚ h\n  exact Ï†.nextBackwardImage_injective hÏ† ha hb h\n", "additional_info": "", "used_premises": [1, 825, 1077, 1077, 1090, 1090, 1070, 1070, 1091, 1091], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [256, 262], "informalization": "The function `ConNF.NearLitterAction.nextBackwardImage` is used to compute the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. The theorem `ConNF.NearLitterAction.nextBackwardImage_injective'` states that this function is injective under certain conditions."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} {a : â„• Ã— â†‘(ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} {b : â„• Ã— â†‘(ConNF.NearLitterAction.needBackwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†)} :ConNF.NearLitterAction.nextForwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚ a â‰  ConNF.NearLitterAction.nextBackwardImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† Lâ‚‚ b", "code": "theorem nextForwardImage_ne_nextBackwardImage {Lâ‚ Lâ‚‚ : Litter} {a : â„• Ã— Ï†.needForwardImages}\n    {b : â„• Ã— Ï†.needBackwardImages} : Ï†.nextForwardImage hÏ† Lâ‚ a â‰  Ï†.nextBackwardImage hÏ† Lâ‚‚ b := by\n  obtain âŸ¨n, bâŸ© := b\n  cases n\n  Â· rw [nextForwardImage, nextBackwardImage]\n    refine'\n      (ne_of_mem_of_not_mem _ (Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv _).symm _).prop).2).symm\n    exact Or.inl b.prop.1\n  Â· rw [nextForwardImage, nextBackwardImage]\n    intro h\n    cases (Ï†.orbitSetEquiv_injective h).2\n", "additional_info": "", "used_premises": [1, 825, 1075, 1077, 1088, 1091], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [263, 274], "informalization": "The theorem `ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage` states that the next element in the range of the partial function `Ï†.atomMap` that is not in its domain, given a lawful near litter action `Ï†`, a litter `L`, and an element `a` in the set of elements in the range of `Ï†.atomMap` that are not in its domain, is not equal to the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`."}
{"full_name": "ConNF.NearLitterAction.nextImageCoreDomain_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImageCoreDomain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextImageCoreDomain_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.nextImageCoreDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem nextImageCoreDomain_small : Small (Ï†.nextImageCoreDomain hÏ†) :=\n  Small.bUnion (Ï†.litterPerm_domain_small hÏ†)\n    (fun L _ => Small.image (lt_of_le_of_lt (Cardinal.mk_subtype_le _) (Ï†.orbitSet_small L)))\n", "additional_info": "", "used_premises": [1, 825, 233, 1098], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [285, 288], "informalization": "The theorem `ConNF.NearLitterAction.nextImageCoreDomain_small` states that the domain of the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.nextImageCoreDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImageCoreDomain", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.nextImageCoreDomain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def nextImageCoreDomain : Set Atom :=\n  â‹ƒ L âˆˆ (Ï†.litterPerm hÏ†).domain, Subtype.val ''\n    {a : Ï†.orbitSet L |\n      (Ï†.orbitSetEquiv L a).elim\n        (fun b => b âˆˆ Ï†.nextBackwardImageDomain hÏ† L)\n        (fun b => b âˆˆ Ï†.nextForwardImageDomain hÏ† L)}\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [278, 284], "informalization": "Function `ConNF.NearLitterAction.nextImageCoreDomain` is used in the context of Constructive Ordinal Notation (ConNF) to define the domain of the next image function for a lawful near litter action. It is defined as the union of the images of the next backward and forward image domains for each litter in the domain of the litter permutation."}
{"full_name": "ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {a : ConNF.Atom} (h : a âˆˆ ConNF.NearLitterAction.nextImageCoreDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†) :a.1 âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain", "code": "theorem litter_map_dom_of_mem_nextImageCoreDomain {a : Atom} (h : a âˆˆ Ï†.nextImageCoreDomain hÏ†) :\n    a.1 âˆˆ (Ï†.litterPerm hÏ†).domain := by\n  rw [nextImageCoreDomain] at h\n  simp only [PFun.mem_dom, iUnion_exists, mem_iUnion, mem_image, mem_setOf_eq, SetCoe.exists,\n    Subtype.coe_mk, exists_and_right, exists_eq_right, exists_prop] at h\n  obtain âŸ¨L, hL, ha, _âŸ© := h\n  have := (Ï†.orbitSet_subset L ha).1\n  rw [mem_litterSet] at this\n  rw [this]\n  exact hL\n", "additional_info": "", "used_premises": [1, 825, 1098, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [289, 299], "informalization": "The theorem `ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain` states that if an atom `a` is in the domain of the next image function for a lawful near litter action, then the litter of `a` is in the domain of the litter permutation."}
{"full_name": "ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {a : ConNF.Atom} (h : a âˆˆ ConNF.NearLitterAction.nextImageCoreDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†) :a âˆˆ ConNF.NearLitterAction.orbitSetğŸ”—<|PREMISE|>ğŸ”— Ï† a.1", "code": "theorem mem_orbitSet_of_mem_nextImageCoreDomain {a : Atom} (h : a âˆˆ Ï†.nextImageCoreDomain hÏ†) :\n    a âˆˆ Ï†.orbitSet a.1 := by\n  rw [nextImageCoreDomain] at h\n  simp only [PFun.mem_dom, iUnion_exists, mem_iUnion, mem_image, mem_setOf_eq, SetCoe.exists,\n    Subtype.coe_mk, exists_and_right, exists_eq_right, exists_prop] at h\n  obtain âŸ¨L, _, ha, _âŸ© := h\n  have := (Ï†.orbitSet_subset L ha).1\n  rw [mem_litterSet] at this\n  rw [this]\n  exact ha\n", "additional_info": "", "used_premises": [1, 825, 1098, 1082], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [300, 310], "informalization": "The theorem `ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain` states that if an atom `a` belongs to the domain of the next image function for a lawful near litter action `Ï†`, then `a` also belongs to the orbit set of `a` under the action of `Ï†`."}
{"full_name": "ConNF.NearLitterAction.nextImageDomain_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImageDomain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextImageDomain_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.nextImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem nextImageDomain_small : Small (Ï†.nextImageDomain hÏ†) :=\n  Small.union (Small.mono (inter_subset_left _ _) Ï†.needForwardImages_small)\n    (Ï†.nextImageCoreDomain_small hÏ†)\n", "additional_info": "", "used_premises": [1, 825, 233, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [372, 375], "informalization": "The theorem `ConNF.NearLitterAction.nextImageDomain_small` states that the domain of the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.nextImageDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImageDomain", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.nextImageDomain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def nextImageDomain : Set Atom :=\n  Ï†.needForwardImages âˆ© {a | a.1 âˆˆ (Ï†.litterPerm hÏ†).domain} âˆª Ï†.nextImageCoreDomain hÏ†\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [364, 366], "informalization": "Function `ConNF.NearLitterAction.nextImageDomain` is used in the context of Constructive Ordinal Notation (ConNF) to define the domain of the next image function for a lawful near litter action. It is defined as the intersection of the set of atoms that need forward images and the set of atoms whose first component is in the domain of the litter permutation, unioned with the next image core domain."}
{"full_name": "ConNF.NearLitterAction.disjoint_needForwardImages_nextImageCoreDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.disjoint_needForwardImages_nextImageCoreDomain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_needForwardImages_nextImageCoreDomain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :DisjointğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.needForwardImagesğŸ”—<|PREMISE|>ğŸ”— Ï†) (ConNF.NearLitterAction.nextImageCoreDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem disjoint_needForwardImages_nextImageCoreDomain :\n    Disjoint Ï†.needForwardImages (Ï†.nextImageCoreDomain hÏ†) := by\n  rw [Set.disjoint_iff]\n  rintro a âŸ¨haâ‚, haâ‚‚âŸ©\n  exact (Ï†.orbitSet_subset _ (Ï†.mem_orbitSet_of_mem_nextImageCoreDomain hÏ† haâ‚‚)).2 (Or.inr haâ‚.1)\n", "additional_info": "", "used_premises": [1, 825, 757, 1075, 1098], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [376, 381], "informalization": "The theorem states that the set of elements in the range of the partial function `Ï†.atomMap` that are not in its domain is disjoint from the domain of the next image function for a lawful near litter action."}
{"full_name": "ConNF.NearLitterAction.nextImage_injective", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImage_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextImage_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (a : ConNF.Atom) (b : ConNF.Atom) (ha : a âˆˆ ConNF.NearLitterAction.nextImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†) (hb : b âˆˆ ConNF.NearLitterAction.nextImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†) (h : ConNF.NearLitterAction.nextImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† a ha = ConNF.NearLitterAction.nextImageğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† b hb) :a = b", "code": "theorem nextImage_injective (a b : Atom) (ha : a âˆˆ Ï†.nextImageDomain hÏ†)\n    (hb : b âˆˆ Ï†.nextImageDomain hÏ†) (h : Ï†.nextImage hÏ† a ha = Ï†.nextImage hÏ† b hb) : a = b := by\n  obtain (ha | ha) := ha <;> obtain (hb | hb) := hb\n  Â· rw [Ï†.nextImage_eq_of_needForwardImages hÏ† a ha,\n      Ï†.nextImage_eq_of_needForwardImages hÏ† b hb] at h\n    have := Ï†.orbitSetEquiv_injective h\n    simp only [inr.injEq, Prod.mk.injEq, Subtype.mk.injEq, true_and] at this\n    exact this.2\n  Â· rw [Ï†.nextImage_eq_of_needForwardImages hÏ† a ha,\n      Ï†.nextImage_eq_of_mem_nextImageCoreDomain hÏ† b hb] at h\n    cases Ï†.orbitSetEquiv_ne_nextImageCore hÏ† _ _ ha hb h\n  Â· rw [Ï†.nextImage_eq_of_mem_nextImageCoreDomain hÏ† a ha,\n      Ï†.nextImage_eq_of_needForwardImages hÏ† b hb] at h\n    cases Ï†.orbitSetEquiv_ne_nextImageCore hÏ† _ _ hb ha h.symm\n  Â· rw [Ï†.nextImage_eq_of_mem_nextImageCoreDomain hÏ† a ha,\n      Ï†.nextImage_eq_of_mem_nextImageCoreDomain hÏ† b hb] at h\n    exact Ï†.nextImageCore_injective hÏ† a b ha hb h\n", "additional_info": "", "used_premises": [1, 825, 1102, 1102, 1105, 1105], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [414, 431], "informalization": "The theorem `ConNF.NearLitterAction.nextImage_injective` states that the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is injective. This means that if two atoms `a` and `b` are in the domain of the next image function and their next images are equal, then `a` must be equal to `b`."}
{"full_name": "ConNF.NearLitterAction.nextImage", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImage", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.nextImage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (a : ConNF.Atom) (ha : a âˆˆ ConNF.NearLitterAction.nextImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†) :ConNF.Atom", "code": "noncomputable def nextImage (a : Atom) (ha : a âˆˆ Ï†.nextImageDomain hÏ†) : Atom :=\n  ha.elim'\n    (fun ha' => (Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† a.1)).symm (inr (0, âŸ¨a, ha'.1âŸ©)))\n    (Ï†.nextImageCore hÏ† a a.1 âˆ˜ Ï†.mem_orbitSet_of_mem_nextImageCoreDomain hÏ†)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [367, 371], "informalization": "Function `ConNF.NearLitterAction.nextImage` is used in the context of Constructive Ordinal Notation (ConNF) to define the next image function for a lawful near litter action. It takes an atom `a` and a proof that `a` is in the domain of the next image function, and returns the next image of `a`."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap_dom_iff", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap_dom_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.orbitAtomMap_dom_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (a : ConNF.Atom) :(ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† a).Dom â†” (Ï†.atomMap a).Dom âˆ¨ a âˆˆ ConNF.NearLitterAction.nextImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†", "code": "theorem orbitAtomMap_dom_iff (a : Atom) :\n    (Ï†.orbitAtomMap hÏ† a).Dom â†” (Ï†.atomMap a).Dom âˆ¨ a âˆˆ Ï†.nextImageDomain hÏ† :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 825, 1107, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [437, 440], "informalization": "The theorem `ConNF.NearLitterAction.orbitAtomMap_dom_iff` states that the domain of the partial function `ConNF.NearLitterAction.orbitAtomMap` is determined by whether the atom `a` is in the domain of the atom map or in the next image domain of the near-litter action."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.orbitAtomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.Atom â†’. ConNF.Atom", "code": "noncomputable def orbitAtomMap : Atom â†’. Atom := fun a =>\n  { Dom := (Ï†.atomMap a).Dom âˆ¨ a âˆˆ Ï†.nextImageDomain hÏ†\n    get := fun h => Or.elim' h (Ï†.atomMap a).get (Ï†.nextImage hÏ† a) }\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [432, 435], "informalization": "Function `ConNF.NearLitterAction.orbitAtomMap` is used in the context of Constructive Ordinal Notation (ConNF) to define the orbit of an atom under a near-litter action. It returns a partial function from atoms to atoms, where the domain of the function is determined by whether the atom is in the domain of the atom map or in the next image domain of the near-litter action."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap_dom", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap_dom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.orbitAtomMap_dom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :PFun.DomğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†) = PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆª ConNF.NearLitterAction.nextImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†", "code": "theorem orbitAtomMap_dom : (Ï†.orbitAtomMap hÏ†).Dom = Ï†.atomMap.Dom âˆª Ï†.nextImageDomain hÏ† :=\n  rfl\n", "additional_info": "", "used_premises": [1, 825, 404, 1107, 404, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [442, 444], "informalization": "The domain of the partial function `ConNF.NearLitterAction.orbitAtomMap` is the union of the domain of the atom map `Ï†.atomMap` and the next image domain `ConNF.NearLitterAction.nextImageDomain Ï† hÏ†`."}
{"full_name": "ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :DisjointğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) (ConNF.NearLitterAction.nextImageDomainğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem disjoint_atomMap_dom_nextImageDomain : Disjoint Ï†.atomMap.Dom (Ï†.nextImageDomain hÏ†) := by\n  rw [Set.disjoint_iff]\n  rintro a âŸ¨hâ‚, hâ‚‚ | hâ‚‚âŸ©\n  Â· exact hâ‚‚.1.2 hâ‚\n  Â· exact (Ï†.orbitSet_subset _ (Ï†.mem_orbitSet_of_mem_nextImageCoreDomain hÏ† hâ‚‚)).2 (Or.inl hâ‚)\n", "additional_info": "", "used_premises": [1, 825, 757, 404, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [445, 450], "informalization": "The theorem `ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain` states that the domain of the atom map of a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is disjoint from the domain of the next image function."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap_dom_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap_dom_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbitAtomMap_dom_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†))", "code": "theorem orbitAtomMap_dom_small : Small (Ï†.orbitAtomMap hÏ†).Dom :=\n  Small.union Ï†.atomMap_dom_small (Ï†.nextImageDomain_small hÏ†)\n", "additional_info": "", "used_premises": [1, 825, 233, 404, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [479, 481], "informalization": "The theorem `ConNF.NearLitterAction.orbitAtomMap_dom_small` states that the domain of the partial function `ConNF.NearLitterAction.orbitAtomMap`, which represents the orbit of an atom under a near-litter action in the context of Constructive Ordinal Notation (ConNF), is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap_injective", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbitAtomMap_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) â¦ƒa : ConNF.Atomâ¦„ â¦ƒb : ConNF.Atomâ¦„ (ha : (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† a).Dom) (hb : (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† b).Dom) (h : (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† a).get ha = (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† b).get hb) :a = b", "code": "theorem orbitAtomMap_injective â¦ƒa b : Atomâ¦„ (ha : (Ï†.orbitAtomMap hÏ† a).Dom)\n    (hb : (Ï†.orbitAtomMap hÏ† b).Dom)\n    (h : (Ï†.orbitAtomMap hÏ† a).get ha = (Ï†.orbitAtomMap hÏ† b).get hb) : a = b := by\n  obtain (ha | ha) := ha <;> obtain (hb | hb) := hb\n  Â· rw [orbitAtomMap_eq_of_mem_dom, orbitAtomMap_eq_of_mem_dom] at h\n    exact hÏ†.atomMap_injective ha hb h\n  Â· cases Ï†.orbitAtomMap_apply_ne hÏ† ha hb h\n  Â· cases Ï†.orbitAtomMap_apply_ne hÏ† hb ha h.symm\n  Â· rw [orbitAtomMap_eq_of_mem_nextImageDomain, orbitAtomMap_eq_of_mem_nextImageDomain] at h\n    exact Ï†.nextImage_injective hÏ† a b ha hb h\n", "additional_info": "", "used_premises": [1, 825, 1107, 1107, 1107, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [523, 533], "informalization": "The theorem `ConNF.NearLitterAction.orbitAtomMap_injective` states that the orbit of an atom under a lawful near-litter action in the context of Constructive Ordinal Notation (ConNF) is injective. This means that if two atoms have the same image under the orbit map, then they must be equal."}
{"full_name": "ConNF.NearLitterAction.orbit_atom_mem", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbit_atom_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbit_atom_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (hdiff : âˆ€ (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom), symmDiffğŸ”—<|PREMISE|>ğŸ”— (â†‘((Ï†.litterMap L).get hL)) (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— ((Ï†.litterMap L).get hL).fst) âŠ† PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) (a : ConNF.Atom) (ha : (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† a).Dom) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :a.1 = L â†” (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† a).get ha âˆˆ (Ï†.litterMap L).get hL", "code": "theorem orbit_atom_mem\n    (hdiff : âˆ€ L hL,\n      ((Ï†.litterMap L).get hL : Set Atom) âˆ† litterSet ((Ï†.litterMap L).get hL).1 âŠ† Ï†.atomMap.ran)\n    (a : Atom) (ha : (Ï†.orbitAtomMap hÏ† a).Dom) (L : Litter) (hL : (Ï†.litterMap L).Dom) :\n    a.fst = L â†” (Ï†.orbitAtomMap hÏ† a).get ha âˆˆ (Ï†.litterMap L).get hL := by\n  obtain ha | ha | ha := ha\n  Â· rw [orbitAtomMap_eq_of_mem_dom]\n    exact hÏ†.atom_mem a ha L hL\n  Â· rw [Ï†.orbitAtomMap_eq_of_needForwardImages hÏ† a ha]\n    exact Ï†.orbitSetEquiv_atom_mem hÏ† hdiff a ha L hL\n  Â· rw [Ï†.orbitAtomMap_eq_of_mem_nextImageCoreDomain hÏ† a ha]\n    rw [Ï†.nextImageCore_atom_mem hÏ† hdiff a ha L hL]\n", "additional_info": "", "used_premises": [1, 825, 62, 467, 824, 1107, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [636, 648], "informalization": "The theorem states that if an atom `a` is in a specific litter `L`, then its orbit under a lawful near-litter action `Ï†` is also in the same litter `L`. The implication is proven by showing that the symmetric difference of the orbit and the litter set of `L` is a subset of the range of the atom map, which implies that the orbit is either in the domain of the atom map or in the next image domain of the near-litter action. Given that the near-litter action is lawful, the orbit must be in the domain of the atom map, and thus in the litter set of `L`."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbitsLawful", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbitsLawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fillAtomOrbitsLawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (hdiff : âˆ€ (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom), symmDiffğŸ”—<|PREMISE|>ğŸ”— (â†‘((Ï†.litterMap L).get hL)) (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— ((Ï†.litterMap L).get hL).fst) âŠ† PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) :ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.fillAtomOrbitsğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem fillAtomOrbitsLawful\n    (hdiff : âˆ€ L hL,\n      ((Ï†.litterMap L).get hL : Set Atom) âˆ† litterSet ((Ï†.litterMap L).get hL).1 âŠ† Ï†.atomMap.ran) :\n    (Ï†.fillAtomOrbits hÏ†).Lawful :=\n  { atomMap_injective := Ï†.orbitAtomMap_injective hÏ†\n    litterMap_injective := hÏ†.litterMap_injective\n    atom_mem := Ï†.orbit_atom_mem hÏ† hdiff }\n", "additional_info": "", "used_premises": [1, 825, 62, 467, 824, 825, 1114], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [656, 663], "informalization": "`ConNF.NearLitterAction.fillAtomOrbitsLawful` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if we have a lawful near litter action `Ï†` and a condition `hdiff` on the symmetric difference of the image of the litter map and the litter set, then the filled near litter action `ConNF.NearLitterAction.fillAtomOrbits Ï† hÏ†` is also lawful."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbits", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.fillAtomOrbits [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.NearLitterAction", "code": "noncomputable def fillAtomOrbits : NearLitterAction\n    where\n  atomMap := Ï†.orbitAtomMap hÏ†\n  litterMap := Ï†.litterMap\n  atomMap_dom_small := Ï†.orbitAtomMap_dom_small hÏ†\n  litterMap_dom_small := Ï†.litterMap_dom_small\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.fillAtomOrbitsğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbitsğŸ”—  Ï† hÏ† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { atomMap := ğŸ—ŸConNF.NearLitterAction.orbitAtomMapğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMapğŸ”—  Ï† hÏ†, litterMap := Ï†.litterMap, atomMap_dom_small := â‹¯,\n litterMap_dom_small := â‹¯ }\n\n", "used_premises": [1, 825], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [649, 655], "informalization": "Function `ConNF.NearLitterAction.fillAtomOrbits` is a noncomputable definition in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a lawful near litter action `Ï†` and returns a new near litter action where the domain of the atom map is extended to include all possible orbits of atoms under the action of the near litter action."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbits_atomMap", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.fillAtomOrbits_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :(ConNF.NearLitterAction.fillAtomOrbitsğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).atomMap = ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†", "code": "theorem fillAtomOrbits_atomMap : (Ï†.fillAtomOrbits hÏ†).atomMap = Ï†.orbitAtomMap hÏ† :=\n  rfl\n", "additional_info": "", "used_premises": [1, 825, 1114, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [667, 669], "informalization": "The theorem `ConNF.NearLitterAction.fillAtomOrbits_atomMap` states that the atom map of the filled near-litter action `ConNF.NearLitterAction.fillAtomOrbits Ï† hÏ†` is equal to the orbit atom map `ConNF.NearLitterAction.orbitAtomMap Ï† hÏ†`."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbits_litterMap", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.fillAtomOrbits_litterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :(ConNF.NearLitterAction.fillAtomOrbitsğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).litterMap = Ï†.litterMap", "code": "theorem fillAtomOrbits_litterMap : (Ï†.fillAtomOrbits hÏ†).litterMap = Ï†.litterMap :=\n  rfl\n", "additional_info": "", "used_premises": [1, 825, 1114], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [671, 673], "informalization": "The theorem `ConNF.NearLitterAction.fillAtomOrbits_litterMap` states that the litter map of a lawful near litter action remains unchanged after extending the domain of the atom map to include all possible orbits of atoms under the action of the near litter action."}
{"full_name": "ConNF.NearLitterAction.subset_orbitAtomMap_dom", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.subset_orbitAtomMap_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.subset_orbitAtomMap_dom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âŠ† PFun.DomğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem subset_orbitAtomMap_dom : Ï†.atomMap.Dom âŠ† (Ï†.orbitAtomMap hÏ†).Dom :=\n  subset_union_left _ _\n", "additional_info": "", "used_premises": [1, 825, 404, 404, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [674, 676], "informalization": "The theorem `ConNF.NearLitterAction.subset_orbitAtomMap_dom` states that the domain of the atom map of a lawful near-litter action is a subset of the domain of the orbit atom map. This means that if an atom is in the domain of the atom map, it is also in the domain of the orbit atom map."}
{"full_name": "ConNF.NearLitterAction.subset_orbitAtomMap_ran", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.subset_orbitAtomMap_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.subset_orbitAtomMap_ran [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âŠ† PFun.ranğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.orbitAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem subset_orbitAtomMap_ran : Ï†.atomMap.ran âŠ† (Ï†.orbitAtomMap hÏ†).ran := by\n  rintro _ âŸ¨a, ha, rflâŸ©\n  exact âŸ¨a, subset_orbitAtomMap_dom hÏ† ha, Ï†.orbitAtomMap_eq_of_mem_dom hÏ† _ _âŸ©\n", "additional_info": "", "used_premises": [1, 825, 824, 824, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [677, 680], "informalization": "In the context of Constructive Ordinal Notation (ConNF), this theorem states that the range of the atom map, which represents the set of atoms that are mapped to by the near-litter action, is a subset of the range of the orbit atom map. This orbit atom map is defined as the orbit of an atom under the near-litter action, considering the domain of the atom map and the next image domain of the near-litter action."}
{"full_name": "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_mem_map", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_mem_map", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_mem_map [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) â¦ƒL : ConNF.Litterâ¦„ (hL : (Ï†.litterMap L).Dom) â¦ƒa : ConNF.Atomâ¦„ (ha : a âˆˆ (Ï†.litterMap L).get hL) :a.1 âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain", "code": "theorem fst_mem_litterPerm_domain_of_mem_map â¦ƒL : Litterâ¦„ (hL : (Ï†.litterMap L).Dom) â¦ƒa : Atomâ¦„\n    (ha : a âˆˆ (Ï†.litterMap L).get hL) : a.1 âˆˆ (Ï†.litterPerm hÏ†).domain := by\n  by_cases h : a.1 = ((Ï†.litterMap L).get hL).1\n  Â· rw [h]\n    refine' Or.inl (Or.inl (Or.inr âŸ¨L, hL, _âŸ©))\n    rw [roughLitterMapOrElse_of_dom]\n  Â· by_cases h' : a.fst âˆˆ (Ï†.litterPerm' hÏ†).domain\n    exact Or.inl h'\n    exact Or.inr âŸ¨BannedLitter.diff L hL a âŸ¨ha, hâŸ©, h'âŸ©\n", "additional_info": "", "used_premises": [1, 825, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [681, 690], "informalization": "This theorem states that if `L` is a litter and `a` is an atom that belongs to the image of `L` under the litter map `Ï†`, then the first component of `a` (which is a natural number) belongs to the domain of the litter permutation `ConNF.NearLitterAction.litterPerm Ï† hÏ†`. This is a useful result because it allows us to apply the litter permutation to the first component of `a`, which is crucial for recursive definitions in the ConNF library."}
{"full_name": "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) â¦ƒa : ConNF.Atomâ¦„ (ha : a âˆˆ PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) :a.1 âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain", "code": "theorem fst_mem_litterPerm_domain_of_dom â¦ƒa : Atomâ¦„ (ha : a âˆˆ Ï†.atomMap.Dom) :\n    a.fst âˆˆ (Ï†.litterPerm hÏ†).domain := by\n  by_cases h' : a.fst âˆˆ (Ï†.litterPerm' hÏ†).domain\n  exact Or.inl h'\n  exact Or.inr âŸ¨BannedLitter.atomDom a ha, h'âŸ©\n", "additional_info": "", "used_premises": [1, 825, 404, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [691, 696], "informalization": "The theorem `ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom` states that if `a` is an element of the domain of the partial function `Ï†.atomMap`, then the first component of `a`, denoted as `a.1`, is an element of the domain of the partial permutation `ConNF.NearLitterAction.litterPerm Ï† hÏ†`."}
{"full_name": "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) â¦ƒa : ConNF.Atomâ¦„ (ha : a âˆˆ PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) :a.1 âˆˆ (ConNF.NearLitterAction.litterPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain", "code": "theorem fst_mem_litterPerm_domain_of_ran â¦ƒa : Atomâ¦„ (ha : a âˆˆ Ï†.atomMap.ran) :\n    a.fst âˆˆ (Ï†.litterPerm hÏ†).domain := by\n  by_cases h' : a.fst âˆˆ (Ï†.litterPerm' hÏ†).domain\n  exact Or.inl h'\n  obtain âŸ¨b, hb, rflâŸ© := ha\n  exact Or.inr âŸ¨BannedLitter.atomMap b hb, h'âŸ©\n", "additional_info": "", "used_premises": [1, 825, 824, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [697, 703], "informalization": "The theorem `ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran` proves that given a lawful near litter action `Ï†` in the context of Constructive Ordinal Notation (ConNF), for any atom `a` in the range of the atom map `Ï†.atomMap`, the first component of `a` is in the domain of the permutation of litters `ConNF.NearLitterAction.litterPerm Ï† hÏ†`. This theorem is crucial for ensuring that the near litter action is well-defined."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbits_precise", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits_precise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fillAtomOrbits_precise [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (hdiff : âˆ€ (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom), symmDiffğŸ”—<|PREMISE|>ğŸ”— (â†‘((Ï†.litterMap L).get hL)) (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— ((Ï†.litterMap L).get hL).fst) âŠ† PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) :ConNF.NearLitterAction.PreciseğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.fillAtomOrbitsğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem fillAtomOrbits_precise\n    (hdiff : âˆ€ L hL,\n      ((Ï†.litterMap L).get hL : Set Atom) âˆ† litterSet ((Ï†.litterMap L).get hL).1 âŠ† Ï†.atomMap.ran) :\n    Precise (Ï†.fillAtomOrbits hÏ†) := by\n  intro L hL\n  constructor\n  Â· exact subset_trans (hdiff L hL) (subset_orbitAtomMap_ran hÏ†)\n  Â· intro a ha ha'\n    simp only [fillAtomOrbits_atomMap, fillAtomOrbits_litterMap, mem_litterSet,\n      orbitAtomMap_dom_iff] at *\n    obtain ha | ha | ha := ha\n    Â· have := Ï†.orbitAtomMap_eq_of_mem_dom hÏ† a ha\n      rw [this, or_iff_not_imp_left]\n      intro hmap\n      have hfwd : (Ï†.atomMap a).get ha âˆˆ Ï†.needForwardImages := âŸ¨âŸ¨a, _, rflâŸ©, hmapâŸ©\n      refine' Or.inl âŸ¨hfwd, Or.inl (Or.inl _)âŸ©\n      refine' mem_of_eq_of_mem _ (Or.inl hL)\n      rw [â† ha', this]\n    Â· refine' Or.inr (Or.inr âŸ¨_, âŸ¨L, rflâŸ©, _âŸ©)\n      simp only [PFun.mem_dom, iUnion_exists, mem_iUnion, mem_image, mem_setOf_eq, SetCoe.exists,\n        Subtype.coe_mk, exists_and_right, exists_eq_right, exists_prop]\n      have haL : L = Ï†.litterPerm hÏ† a.fst\n      Â· have := (congr_arg Prod.fst\n          (Ï†.orbitAtomMap_eq_of_needForwardImages hÏ† a ha)).symm.trans ha'\n        rw [â† this]\n        exact (Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv _).symm _).prop).1\n      refine' âŸ¨Or.inl (Or.inl (Or.inl hL)), _, _âŸ©\n      Â· refine' mem_of_eq_of_mem (Ï†.orbitAtomMap_eq_of_needForwardImages hÏ† a ha) _\n        rw [haL]\n        exact ((Ï†.orbitSetEquiv _).symm _).prop\n      Â· have := Ï†.orbitAtomMap_eq_of_needForwardImages hÏ† a ha\n        obtain âŸ¨hmâ‚, hmâ‚‚âŸ© := Subtype.coe_eq_iff.mp this.symm\n        rw [Equiv.symm_apply_eq, Ï†.orbitSetEquiv_congr hmâ‚ haL.symm] at hmâ‚‚\n        refine' mem_of_eq_of_mem hmâ‚‚.symm _\n        change\n          Sum.elim (fun b => b âˆˆ Ï†.nextBackwardImageDomain hÏ† L)\n            (fun b => b âˆˆ Ï†.nextForwardImageDomain hÏ† L) (inr (0, âŸ¨a, ha.1âŸ©))\n        refine' âŸ¨ha.2, _âŸ©\n        simp only [Subtype.coe_mk, Function.iterate_one]\n        exact haL.symm\n    Â· have := Ï†.orbitAtomMap_eq_of_mem_nextImageCoreDomain hÏ† a ha\n      rw [this, nextImageCore]\n      obtain âŸ¨_, âŸ¨L', rflâŸ©, _, âŸ¨hL', rflâŸ©, a, hbL, rflâŸ© := ha\n      set b := Ï†.orbitSetEquiv L' a with hb\n      clear_value b\n      simp only [mem_setOf_eq] at hbL\n      rw [â† hb] at hbL\n      have haL' := (Ï†.orbitSet_subset _ a.prop).1\n      rw [mem_litterSet] at haL'\n      have := Ï†.orbitSetEquiv_congr (Ï†.mem_orbitSet_of_mem_nextImageCoreDomain hÏ† ?_)\n        (Ï†.orbitSet_subset _ a.prop).1\n      rw [Subtype.coe_eta] at this\n      rw [this, â† hb]\n      obtain âŸ¨_ | n, bâŸ© | âŸ¨n, bâŸ© := b <;>\n        simp only [needBackwardImages, needForwardImages, elim_inl, elim_inr,\n          nextBackwardImage, nextForwardImage] at hbL âŠ¢\n      Â· exact Or.inl b.prop.1\n      Â· refine' Or.inr (Or.inr _)\n        have hbL' := hbL.2\n        symm at hbL'\n        rw [Function.iterate_succ_apply',\n          PartialPerm.eq_symm_apply _ hL' ((Ï†.litterPerm hÏ†).symm.iterate_domain hbL.1)] at hbL'\n        refine' âŸ¨_, âŸ¨((Ï†.litterPerm hÏ†).symm^[n + 1]) (b : Atom).1, rflâŸ©, _, âŸ¨_, rflâŸ©,\n          âŸ¨(Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† (a : Atom).1)).symm (inl (n, b)), _âŸ©, _âŸ©\n        Â· exact (Ï†.litterPerm hÏ†).symm.iterate_domain hbL.1\n        Â· rw [â† hbL']\n          have := ((Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† (a : Atom).1)).symm (inl (n, b))).prop\n          rw [haL'] at this âŠ¢\n          exact this\n        Â· simp only [Function.comp_apply, mem_setOf_eq, Subtype.coe_mk, eq_self_iff_true,\n            and_true_iff]\n          rw [Ï†.orbitSetEquiv_congr _ hbL'.symm,\n            Ï†.orbitSetEquiv_congr _ (congr_arg (Ï†.litterPerm hÏ†) haL'.symm)]\n          simp only [Subtype.coe_eta, Equiv.apply_symm_apply, elim_inl]\n          exact âŸ¨âŸ¨hbL.1, rflâŸ©, rflâŸ©\n      Â· refine' Or.inr (Or.inr _)\n        refine'\n          âŸ¨_, âŸ¨(Ï†.litterPerm hÏ†)^[n + 2] (b : Atom).1, rflâŸ©, _, âŸ¨_, rflâŸ©,\n            âŸ¨(Ï†.orbitSetEquiv (Ï†.litterPerm hÏ† (a : Atom).1)).symm (inr (n + 1, b)), _âŸ©, _âŸ©\n        Â· exact (Ï†.litterPerm hÏ†).iterate_domain hbL.1\n        Â· rw [Function.iterate_succ_apply', hbL.2, haL']\n          exact ((Ï†.orbitSetEquiv _).symm _).prop\n        Â· simp only [Function.comp_apply, mem_setOf_eq, Subtype.coe_mk, eq_self_iff_true,\n            and_true_iff]\n          have := congr_arg (Ï†.litterPerm hÏ†) hbL.2\n          rw [â† Function.iterate_succ_apply' (Ï†.litterPerm hÏ†) (n + 1)] at this\n          rw [Ï†.orbitSetEquiv_congr _ this,\n            Ï†.orbitSetEquiv_congr _ (congr_arg (Ï†.litterPerm hÏ†) haL'.symm)]\n          simp only [Function.iterate_succ, Function.comp_apply, Subtype.coe_eta,\n            Equiv.apply_symm_apply, elim_inr]\n          exact âŸ¨âŸ¨hbL.1, rflâŸ©, rflâŸ©\n      Â· refine' âŸ¨_, âŸ¨L', rflâŸ©, _, âŸ¨hL', rflâŸ©, a, _, rflâŸ©\n        rw [mem_setOf_eq, â† hb]\n        exact hbL\n  Â· rw [fillAtomOrbits_litterMap] at hL\n    rintro a âŸ¨haâ‚ | âŸ¨haâ‚, _âŸ© | haâ‚, haâ‚‚âŸ© <;>\n      simp only [fillAtomOrbits_atomMap, fillAtomOrbits_litterMap, orbitAtomMap_dom,\n        mem_inter_iff, mem_union, SetLike.mem_coe] at *\n    Â· by_cases haâ‚ƒ : a âˆˆ Ï†.atomMap.ran\n      Â· obtain âŸ¨b, hbâ‚, hbâ‚‚âŸ© := haâ‚ƒ\n        refine' âŸ¨b, Or.inl hbâ‚, _âŸ©\n        rw [orbitAtomMap_eq_of_mem_dom]\n        exact hbâ‚‚\n      Â· refine' âŸ¨(Ï†.orbitSetEquiv ((Ï†.litterPerm hÏ†).symm a.1)).symm (inl (0, âŸ¨a, haâ‚, haâ‚ƒâŸ©)), _, _âŸ©\n        Â· refine' Or.inr (Or.inr âŸ¨_, âŸ¨(Ï†.litterPerm hÏ†).symm a.1, rflâŸ©, _, âŸ¨_, rflâŸ©, _âŸ©)\n          Â· exact (Ï†.litterPerm hÏ†).symm.map_domain\n              (fst_mem_litterPerm_domain_of_mem_map hÏ† hL haâ‚‚)\n          refine' âŸ¨_, _, rflâŸ©\n          simp only [mem_setOf_eq, Equiv.apply_symm_apply, elim_inl]\n          exact âŸ¨fst_mem_litterPerm_domain_of_mem_map hÏ† hL haâ‚‚, rflâŸ©\n        Â· have : ((Ï†.orbitSetEquiv ((Ï†.litterPerm hÏ†).symm a.fst)).symm\n            (inl (0, âŸ¨a, _âŸ©)) : Atom).fst = (Ï†.litterPerm hÏ†).symm a.fst\n          Â· exact (Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv _).symm _).prop).1\n          rw [orbitAtomMap_eq_of_mem_nextImageCoreDomain, nextImageCore]\n          rw [Ï†.orbitSetEquiv_congr _ this]\n          simp only [Subtype.coe_eta, Equiv.apply_symm_apply, elim_inl, nextBackwardImage]\n          refine' âŸ¨_, âŸ¨((Ï†.litterPerm hÏ†).symm) a.fst, rflâŸ©, _, âŸ¨_, rflâŸ©, _âŸ©\n          Â· exact (Ï†.litterPerm hÏ†).symm.map_domain (fst_mem_litterPerm_domain_of_dom hÏ† haâ‚)\n          Â· refine' âŸ¨_, _, rflâŸ©\n            simp only [mem_setOf_eq, Equiv.apply_symm_apply, elim_inl]\n            exact âŸ¨fst_mem_litterPerm_domain_of_dom hÏ† haâ‚, rflâŸ©\n    Â· obtain âŸ¨âŸ¨b, hbâ‚, hbâ‚‚âŸ©, _âŸ© := haâ‚\n      rw [â† hbâ‚‚]\n      refine' âŸ¨b, Or.inl hbâ‚, _âŸ©\n      rw [orbitAtomMap_eq_of_mem_dom]\n    Â· obtain âŸ¨a', ha'âŸ© := (Ï†.orbitSetEquiv a.fst).symm.surjective\n        âŸ¨a, Ï†.mem_orbitSet_of_mem_nextImageCoreDomain hÏ† haâ‚âŸ©\n      obtain âŸ¨n, a'âŸ© | âŸ¨_ | n, a'âŸ© := a'\n      Â· have :\n          ((Ï†.orbitSetEquiv (((Ï†.litterPerm hÏ†).symm^[n + 2]) (a' : Atom).fst)).symm\n                (inl (n + 1, a')) :\n              Atom) âˆˆ\n            Ï†.nextImageCoreDomain hÏ†\n        Â· refine' âŸ¨_, âŸ¨((Ï†.litterPerm hÏ†).symm^[n + 2]) (a' : Atom).fst, rflâŸ©, _, âŸ¨_, rflâŸ©, _âŸ©\n          Â· exact (Ï†.litterPerm hÏ†).symm.iterate_domain\n              (fst_mem_litterPerm_domain_of_dom hÏ† a'.prop.1)\n          Â· refine' âŸ¨_, _, rflâŸ©\n            simp only [mem_setOf_eq, Equiv.apply_symm_apply, elim_inl]\n            exact âŸ¨fst_mem_litterPerm_domain_of_dom hÏ† a'.prop.1, rflâŸ©\n        refine' âŸ¨_, Or.inr (Or.inr this), _âŸ©\n        rw [Ï†.orbitAtomMap_eq_of_mem_nextImageCoreDomain hÏ† _ this]\n        rw [nextImageCore]\n        have :\n          ((Ï†.orbitSetEquiv (((Ï†.litterPerm hÏ†).symm^[n + 2]) (a' : Atom).fst)).symm\n                  (inl (n + 1, a')) :\n                Atom).fst =\n            ((Ï†.litterPerm hÏ†).symm^[n + 2]) (a' : Atom).fst :=\n          (Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv _).symm _).prop).1\n        rw [Ï†.orbitSetEquiv_congr _ this]\n        simp only [Subtype.coe_eta, Equiv.apply_symm_apply, elim_inl, nextBackwardImage]\n        have := congr_arg Subtype.val ha'\n        change _ = a at this\n        rw [â† this]\n        refine' Ï†.orbitSetEquiv_symm_congr _\n        have := (Ï†.orbitSet_subset _\n          ((Ï†.orbitSetEquiv ((Ï†.litterPerm hÏ†).symm^[n + 2] (a' : Atom).1)).symm\n            (inl (n + 1, a'))).prop).1\n        rw [mem_litterSet] at this\n        rw [this]\n        have := Ï†.orbitSetEquiv_elim_of_mem_nextImageCoreDomain hÏ† haâ‚\n        rw [â† ha'] at this\n        simp only [Equiv.apply_symm_apply, elim_inl, nextBackwardImageDomain,\n          Function.comp_apply, mem_setOf_eq] at this\n        rw [â† this.2, Function.iterate_succ_apply', PartialPerm.right_inv]\n        exact (Ï†.litterPerm hÏ†).symm.iterate_domain this.1\n      Â· have := Ï†.orbitSetEquiv_elim_of_mem_nextImageCoreDomain hÏ† haâ‚\n        rw [â† ha'] at this\n        simp only [nextForwardImageDomain, Function.iterate_succ, Function.comp_apply, mem_setOf_eq,\n          Nat.zero_eq, Equiv.apply_symm_apply, elim_inr, Function.iterate_zero, id_eq] at this\n        refine' âŸ¨a', Or.inr (Or.inl âŸ¨a'.prop, this.1âŸ©), _âŸ©\n        rw [orbitAtomMap_eq_of_needForwardImages, Ï†.orbitSetEquiv_symm_congr this.2,\n          Subtype.coe_eta, ha']\n        exact âŸ¨a'.prop, this.1âŸ©\n      Â· have :\n          ((Ï†.orbitSetEquiv ((Ï†.litterPerm hÏ†)^[n + 1] (a' : Atom).fst)).symm (inr (n, a')) :\n              Atom) âˆˆ\n            Ï†.nextImageCoreDomain hÏ†\n        Â· refine' âŸ¨_, âŸ¨(Ï†.litterPerm hÏ†)^[n + 1] (a' : Atom).fst, rflâŸ©, _, âŸ¨_, rflâŸ©, _âŸ©\n          exact (Ï†.litterPerm hÏ†).iterate_domain (fst_mem_litterPerm_domain_of_ran hÏ† a'.prop.1)\n          refine' âŸ¨_, _, rflâŸ©\n          simp only [mem_setOf_eq, Equiv.apply_symm_apply, elim_inl]\n          exact âŸ¨fst_mem_litterPerm_domain_of_ran hÏ† a'.prop.1, rflâŸ©\n        refine' âŸ¨_, Or.inr (Or.inr this), _âŸ©\n        rw [Ï†.orbitAtomMap_eq_of_mem_nextImageCoreDomain hÏ† _ this]\n        rw [nextImageCore]\n        have :\n          ((Ï†.orbitSetEquiv ((Ï†.litterPerm hÏ†)^[n + 1] (a' : Atom).fst)).symm (inr (n, a')) :\n                Atom).fst =\n            (Ï†.litterPerm hÏ†)^[n + 1] (a' : Atom).fst :=\n          (Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv _).symm _).prop).1\n        rw [Ï†.orbitSetEquiv_congr _ this]\n        simp only [Subtype.coe_eta, Equiv.apply_symm_apply, elim_inl, nextBackwardImage]\n        have := congr_arg Subtype.val ha'\n        change _ = a at this\n        rw [â† this]\n        refine' Ï†.orbitSetEquiv_symm_congr _\n        have := (Ï†.orbitSet_subset _ ((Ï†.orbitSetEquiv\n          ((Ï†.litterPerm hÏ†)^[n + 1] (a' : Atom).fst)).symm (inr (n, a'))).prop).1\n        rw [mem_litterSet] at this\n        rw [this]\n        have := Ï†.orbitSetEquiv_elim_of_mem_nextImageCoreDomain hÏ† haâ‚\n        rw [â† ha'] at this\n        simp only [Equiv.apply_symm_apply, elim_inr, nextForwardImageDomain, Function.comp_apply,\n          mem_setOf_eq] at this\n        rw [â† this.2, Function.iterate_succ_apply', Function.iterate_succ_apply',\n          Function.iterate_succ_apply']\n", "additional_info": "", "used_premises": [1, 825, 62, 467, 824, 1123, 1114], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [704, 910], "informalization": "Given a lawful near litter action Ï†, if the symmetric difference of the litter set of any given litter L with the values of the litter map of Ï† applied to L (excluding any undefined values) is a subset of the range of the atom map of Ï†, then the near litter action obtained by filling the orbits of any undefined atoms under Ï† is precise."}
{"full_name": "ConNF.NearLitterAction.Precise", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Precise", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.Precise [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Prop", "code": "def Precise : Prop :=\n  âˆ€ â¦ƒLâ¦„ (hL : (Ï†.litterMap L).Dom), Ï†.PreciseAt hL\n", "additional_info": "An action is precise if it is precise at every litter in its domain.\nEquations\n* ğŸ—ŸConNF.NearLitterAction.PreciseğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.PreciseğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ â¦ƒL : ConNF.Litterâ¦„ (hL : (Ï†.litterMap L).Dom), ğŸ—ŸConNF.NearLitterAction.PreciseAtğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.PreciseAtğŸ”—  Ï† hL\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [225, 227], "informalization": "Function `ConNF.NearLitterAction.Precise` is a predicate that checks if a given near litter action `Ï†` is precise. A near litter action is precise if it is precise at every litter in its domain. This means that for every litter `L` in the domain of the litter map of `Ï†`, the action `Ï†` is precise at `L`."}
{"full_name": "Or.elim'_left", "url": "ConNF/FOA/Action/NearLitterAction.html#Or.elim'_left", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Or.elim'_left {Î± : Sort u_1} {p : Prop } {q : Prop } (h : p âˆ¨ q) (f : p â†’ Î±) (g : q â†’ Î±) (hp : p) :Or.elim'ğŸ”—<|PREMISE|>ğŸ”— h f g = f hp", "code": "lemma Or.elim'_left {Î± : Sort _} {p q : Prop}\n    (h : p âˆ¨ q) (f : p â†’ Î±) (g : q â†’ Î±) (hp : p) : h.elim' f g = f hp :=\n  by rw [Or.elim', dif_pos hp]\n", "additional_info": "", "used_premises": [1125], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [23, 26], "informalization": "`Or.elim'_left` is a theorem that states that if we have a disjunction `p âˆ¨ q` and two functions `f : p â†’ Î±` and `g : q â†’ Î±`, and we know that `p` is true, then `Or.elim' h f g` is equal to `f hp`, where `hp` is a proof of `p`."}
{"full_name": "Or.elim'", "url": "ConNF/FOA/Action/NearLitterAction.html#Or.elim'", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def Or.elim' {Î± : Sort u_1} {p : Prop } {q : Prop } (h : p âˆ¨ q) (f : p â†’ Î±) (g : q â†’ Î±) :Î±", "code": "noncomputable def Or.elim' {Î± : Sort _} {p q : Prop}\n    (h : p âˆ¨ q) (f : p â†’ Î±) (g : q â†’ Î±) : Î± :=\n  if hp : p then f hp else g (h.resolve_left hp)\n", "additional_info": "Noncomputably eliminates a disjunction into a (possibly predicative) universe.\nEquations\n* ğŸ—ŸOr.elim'ğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#Or.elim'ğŸ”—  h f g ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  if hp : p then f hp else g â‹¯\n\n", "used_premises": [], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [19, 22], "informalization": "`Or.elim'` is a noncomputable function that eliminates a disjunction into a possibly predicative universe. It takes a disjunction `p âˆ¨ q` and two functions `f : p â†’ Î±` and `g : q â†’ Î±`, and returns an element of type `Î±`."}
{"full_name": "ConNF.NearLitterAction.ext", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.ext :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } (x y : ConNF.NearLitterAction), x.atomMap = y.atomMap â†’ x.litterMap = y.litterMap â†’ x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [35, 36], "informalization": "`ConNF.NearLitterAction.ext` is an extensionality theorem for the `ConNF.NearLitterAction` structure. It states that two `ConNF.NearLitterAction`s are equal if their `atomMap` and `litterMap` fields are equal."}
{"full_name": "ConNF.NearLitterAction.ext_iff", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.ext_iff :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } (x y : ConNF.NearLitterAction), x = y â†” x.atomMap = y.atomMap âˆ§ x.litterMap = y.litterMap", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [35, 36], "informalization": "The `ConNF.NearLitterAction.ext_iff` theorem states that two `ConNF.NearLitterAction` objects are equal if and only if their `atomMap` and `litterMap` fields are equal."}
{"full_name": "ConNF.NearLitterAction.bannedLitter_iff", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.bannedLitter_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.bannedLitter_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :âˆ€ (a : ConNF.Litter), ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† a â†” (âˆƒ (a_1 : ConNF.Atom), (Ï†.atomMap a_1).Dom âˆ§ a = a_1.1) âˆ¨ (Ï†.litterMap a).Dom âˆ¨ (âˆƒ (a_1 : ConNF.Atom) (h : (Ï†.atomMap a_1).Dom), a = ((Ï†.atomMap a_1).get h).1) âˆ¨ (âˆƒ (L : ConNF.Litter) (h : (Ï†.litterMap L).Dom), a = ((Ï†.litterMap L).get h).fst) âˆ¨ âˆƒ (L : ConNF.Litter) (h : (Ï†.litterMap L).Dom), âˆƒ a_1 âˆˆ â†‘((Ï†.litterMap L).get h) \\ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— ((Ï†.litterMap L).get h).fst, a = a_1.1", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1065, 467], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [58, 59], "informalization": "The theorem `ConNF.NearLitterAction.bannedLitter_iff` states that a litter `a` is considered \"banned\" by a near litter action `Ï†` if and only if there exists an atom `a_1` such that `Ï†.atomMap a_1` is defined and `a = a_1.1`, or `Ï†.litterMap a` is defined, or there exists an atom `a_1` such that `Ï†.atomMap a_1` is defined and `a = ((Ï†.atomMap a_1).get h).1`, or there exists a litter `L` such that `Ï†.litterMap L` is defined and `a = ((Ï†.litterMap L).get h).fst`, or there exists a litter `L` such that `Ï†.litterMap L` is defined and there exists an atom `a_1` in `((Ï†.litterMap L).get h) \\ ConNF.litterSet ((Ï†.litterMap L).get h).fst` with `a = a_1.1`."}
{"full_name": "ConNF.NearLitterAction.BannedLitter.memMap", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.BannedLitter.memMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.BannedLitter.memMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (a : ConNF.Atom) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) (ha : a âˆˆ â†‘((Ï†.litterMap L).get hL)) :ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† a.1", "code": "theorem BannedLitter.memMap (a : Atom) (L : Litter) (hL)\n    (ha : a âˆˆ ((Ï†.litterMap L).get hL : Set Atom)) : Ï†.BannedLitter a.1 := by\n  by_cases h : a.1 = ((Ï†.litterMap L).get hL).1\n  Â· rw [h]\n    exact BannedLitter.litterMap L hL\n  Â· exact BannedLitter.diff L hL a âŸ¨ha, hâŸ©\n", "additional_info": "", "used_premises": [1, 1065], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [67, 73], "informalization": "The theorem `ConNF.NearLitterAction.BannedLitter.memMap` is a result in the context of Constructive Ordinal Notation (ConNF) which is a mathematical formalization of the Von Neumann universe of ordinals. The theorem is about the type `ConNF.NearLitterAction.BannedLitter`, which represents a litter that is not allowed as a sandbox because it appears somewhere that we need to preserve. The theorem states that if an atom `a` with a given litter `L` is in the domain of the litter map of a near litter action `Ï†`, and it is also in the image of the litter map, then the litter of `a` is banned."}
{"full_name": "ConNF.NearLitterAction.bannedLitter_small", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.bannedLitter_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.bannedLitter_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {L : ConNF.Litter | ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L}", "code": "theorem bannedLitter_small : Small {L | Ï†.BannedLitter L} := by\n  simp only [bannedLitter_iff, mem_diff, SetLike.mem_coe, mem_litterSet]\n  refine' Small.union _ (Small.union _ (Small.union _ (Small.union _ _)))\n  Â· refine' lt_of_le_of_lt _ Ï†.atomMap_dom_small\n    refine' âŸ¨âŸ¨fun a => âŸ¨_, a.prop.choose_spec.1âŸ©, fun aâ‚ aâ‚‚ h => _âŸ©âŸ©\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := aâ‚.prop.choose_spec.2\n    rw [h] at this\n    exact Subtype.coe_injective (this.trans aâ‚‚.prop.choose_spec.2.symm)\n  Â· refine' lt_of_le_of_lt _ Ï†.litterMap_dom_small\n    refine' âŸ¨âŸ¨fun L => âŸ¨_, L.propâŸ©, fun Lâ‚ Lâ‚‚ h => _âŸ©âŸ©\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    exact Subtype.coe_injective h\n  Â· refine' lt_of_le_of_lt _ Ï†.atomMap_dom_small\n    refine' âŸ¨âŸ¨fun L => âŸ¨_, L.prop.choose_spec.chooseâŸ©, fun Lâ‚ Lâ‚‚ h => _âŸ©âŸ©\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := Lâ‚.prop.choose_spec.choose_spec\n    simp_rw [h] at this\n    exact Subtype.coe_injective (this.trans Lâ‚‚.prop.choose_spec.choose_spec.symm)\n  Â· refine' lt_of_le_of_lt _ Ï†.litterMap_dom_small\n    refine' âŸ¨âŸ¨fun L => âŸ¨_, L.prop.choose_spec.chooseâŸ©, fun Lâ‚ Lâ‚‚ h => _âŸ©âŸ©\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := Lâ‚.prop.choose_spec.choose_spec\n    simp_rw [h] at this\n    exact Subtype.coe_injective (this.trans Lâ‚‚.prop.choose_spec.choose_spec.symm)\n  Â· have : Small\n      (â‹ƒ (L : Litter) (h : (Ï†.litterMap L).Dom),\n        ((Ï†.litterMap L).get h : Set Atom) \\ litterSet ((Ï†.litterMap L).get h).1)\n    Â· refine' Small.bUnion _ _\n      Â· refine' lt_of_le_of_lt _ Ï†.litterMap_dom_small\n        refine' âŸ¨âŸ¨fun N => âŸ¨_, N.propâŸ©, fun Nâ‚ Nâ‚‚ h => _âŸ©âŸ©\n        simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n        exact Subtype.coe_inj.mp h\n      Â· intro L hL\n        refine' Small.mono _ ((Ï†.litterMap L).get hL).2.prop\n        exact fun x hx => Or.inr hx\n    refine' lt_of_le_of_lt _ this\n    refine' âŸ¨âŸ¨fun L => âŸ¨L.prop.choose_spec.choose_spec.choose, _âŸ©, fun Lâ‚ Lâ‚‚ h => _âŸ©âŸ©\n    Â· simp only [mem_iUnion]\n      exact âŸ¨_, _, L.prop.choose_spec.choose_spec.choose_spec.1âŸ©\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := Lâ‚.prop.choose_spec.choose_spec.choose_spec.2\n    rw [h] at this\n    exact Subtype.coe_injective (this.trans Lâ‚‚.prop.choose_spec.choose_spec.choose_spec.2.symm)\n", "additional_info": "There are only a small amount of banned litters.", "used_premises": [1, 233, 1065], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [75, 119], "informalization": "The theorem `ConNF.NearLitterAction.bannedLitter_small` states that the set of banned litters in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.mk_not_bannedLitter", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.mk_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_not_bannedLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L} = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_not_bannedLitter : #{L | Â¬Ï†.BannedLitter L} = #Î¼ := by\n  have := mk_sum_compl {L | Ï†.BannedLitter L}\n  rw [compl_setOf, mk_litter] at this\n  rw [â† this, add_eq_right]\n  Â· by_contra h\n    have h' := add_le_add (le_of_lt Ï†.bannedLitter_small) (le_of_not_le h)\n    rw [this] at h'\n    refine' not_lt_of_le h' _\n    refine' Cardinal.add_lt_of_lt Params.Î¼_isStrongLimit.isLimit.aleph0_le Params.Îº_lt_Î¼ _\n    exact lt_of_le_of_lt Params.Îº_isRegular.aleph0_le Params.Îº_lt_Î¼\n  Â· by_contra h\n    have h' := add_le_add (le_of_lt Ï†.bannedLitter_small) (le_of_not_le h)\n    rw [this] at h'\n    refine' not_lt_of_le h' _\n    refine' Cardinal.add_lt_of_lt Params.Î¼_isStrongLimit.isLimit.aleph0_le Params.Îº_lt_Î¼ _\n    exact lt_trans Ï†.bannedLitter_small Params.Îº_lt_Î¼\n", "additional_info": "", "used_premises": [1, 29, 1065, 29], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [120, 136], "informalization": "The theorem `ConNF.NearLitterAction.mk_not_bannedLitter` states that the cardinality of the set of litters that are not banned by the near litter action `Ï†` is equal to the cardinality of the type `Î¼`."}
{"full_name": "ConNF.NearLitterAction.not_bannedLitter_nonempty", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.not_bannedLitter_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.not_bannedLitter_nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :NonemptyğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L}", "code": "theorem not_bannedLitter_nonempty : Nonempty {L | Â¬Ï†.BannedLitter L} := by\n  simp only [â† mk_ne_zero_iff, mk_not_bannedLitter, Ne.def, mk_ne_zero, not_false_iff]\n", "additional_info": "", "used_premises": [1, 212, 1065], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [137, 139], "informalization": "The theorem `ConNF.NearLitterAction.not_bannedLitter_nonempty` states that in the context of Constructive Ordinal Notation (ConNF), given a near litter action `Ï†`, there exists at least one litter `L` that is not banned, meaning it can be used as a sandbox."}
{"full_name": "ConNF.NearLitterAction.atomMapOrElse_of_dom", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.atomMapOrElse_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomMapOrElse_of_dom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) {a : ConNF.Atom} (ha : (Ï†.atomMap a).Dom) :ConNF.NearLitterAction.atomMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† a = (Ï†.atomMap a).get ha", "code": "theorem atomMapOrElse_of_dom {a : Atom} (ha : (Ï†.atomMap a).Dom) :\n    Ï†.atomMapOrElse a = (Ï†.atomMap a).get ha := by rw [atomMapOrElse, Part.getOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 1134], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [144, 146], "informalization": "Given a `ConNF.NearLitterAction` object `Ï†` and an `ConNF.Atom` object `a`, if `a` is in the domain of `Ï†.atomMap`, then `ConNF.NearLitterAction.atomMapOrElse Ï† a` returns the value of `Ï†.atomMap a`."}
{"full_name": "ConNF.NearLitterAction.atomMapOrElse", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.atomMapOrElse", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.atomMapOrElse [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (a : ConNF.Atom) :ConNF.Atom", "code": "noncomputable def atomMapOrElse (a : Atom) : Atom :=\n  (Ï†.atomMap a).getOrElse (Classical.arbitrary Atom)\n", "additional_info": "If `a` is in the domain, this is the atom map. Otherwise, this gives an arbitrary atom.\nEquations\n* ğŸ—ŸConNF.NearLitterAction.atomMapOrElseğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.atomMapOrElseğŸ”—  Ï† a ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸPart.getOrElseğŸ—ŸğŸ”—../../.././Mathlib/Data/Part.html#Part.getOrElseğŸ”—  (Ï†.atomMap a) (ğŸ—ŸClassical.arbitraryğŸ—ŸğŸ”—../../.././Mathlib/Logic/Nonempty.html#Classical.arbitraryğŸ”—  ConNF.Atom)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [141, 143], "informalization": "Function `ConNF.NearLitterAction.atomMapOrElse` takes a `ConNF.NearLitterAction` object `Ï†` and an `ConNF.Atom` object `a`. If `a` is in the domain of `Ï†.atomMap`, it returns the value of `Ï†.atomMap a`. If `a` is not in the domain, it returns an arbitrary `ConNF.Atom`."}
{"full_name": "ConNF.NearLitterAction.atomMapOrElse_injective", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.atomMapOrElse_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomMapOrElse_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :Set.InjOnğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.atomMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï†) (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap)", "code": "theorem atomMapOrElse_injective (hÏ† : Ï†.Lawful) : InjOn Ï†.atomMapOrElse Ï†.atomMap.Dom := by\n  intro a ha b hb h\n  rw [Ï†.atomMapOrElse_of_dom ha, Ï†.atomMapOrElse_of_dom hb] at h\n  exact hÏ†.atomMap_injective ha hb h\n", "additional_info": "", "used_premises": [1, 825, 111, 1134, 404], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [147, 151], "informalization": "The theorem `ConNF.NearLitterAction.atomMapOrElse_injective` states that the function `ConNF.NearLitterAction.atomMapOrElse` is injective when restricted to the domain of `Ï†.atomMap`. This means that for any two atoms `aâ‚` and `aâ‚‚` in the domain of `Ï†.atomMap`, if `ConNF.NearLitterAction.atomMapOrElse Ï† aâ‚ = ConNF.NearLitterAction.atomMapOrElse Ï† aâ‚‚`, then `aâ‚ = aâ‚‚`."}
{"full_name": "ConNF.NearLitterAction.litterMapOrElse_of_dom", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.litterMapOrElse_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterMapOrElse_of_dom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) {L : ConNF.Litter} (hL : (Ï†.litterMap L).Dom) :ConNF.NearLitterAction.litterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† L = (Ï†.litterMap L).get hL", "code": "theorem litterMapOrElse_of_dom {L : Litter} (hL : (Ï†.litterMap L).Dom) :\n    Ï†.litterMapOrElse L = (Ï†.litterMap L).get hL := by\n  rw [litterMapOrElse, Part.getOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 1137], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [157, 160], "informalization": "Function `ConNF.NearLitterAction.litterMapOrElse` takes a `ConNF.NearLitterAction` and a `ConNF.Litter`, and returns a `ConNF.NearLitter`. If the `ConNF.Litter` is in the domain of the `ConNF.NearLitterAction`, it returns the result of the litter map. Otherwise, it returns an arbitrary near-litter. The theorem `ConNF.NearLitterAction.litterMapOrElse_of_dom` states that if the `ConNF.Litter` is in the domain of the `ConNF.NearLitterAction`, then `ConNF.NearLitterAction.litterMapOrElse` returns the result of the litter map."}
{"full_name": "ConNF.NearLitterAction.litterMapOrElse", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.litterMapOrElse", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.litterMapOrElse [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.NearLitter", "code": "noncomputable def litterMapOrElse (L : Litter) : NearLitter :=\n  (Ï†.litterMap L).getOrElse (Classical.arbitrary NearLitter)\n", "additional_info": "If `L` is in the domain, this is the litter map.\nOtherwise, this gives an arbitrary near-litter.\nEquations\n* ğŸ—ŸConNF.NearLitterAction.litterMapOrElseğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.litterMapOrElseğŸ”—  Ï† L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸPart.getOrElseğŸ—ŸğŸ”—../../.././Mathlib/Data/Part.html#Part.getOrElseğŸ”—  (Ï†.litterMap L) (ğŸ—ŸClassical.arbitraryğŸ—ŸğŸ”—../../.././Mathlib/Logic/Nonempty.html#Classical.arbitraryğŸ”—  ConNF.NearLitter)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [154, 156], "informalization": "Function `ConNF.NearLitterAction.litterMapOrElse` takes a `ConNF.NearLitterAction` and a `ConNF.Litter`, and returns a `ConNF.NearLitter`. If the `ConNF.Litter` is in the domain of the `ConNF.NearLitterAction`, it returns the result of the litter map. Otherwise, it returns an arbitrary near-litter."}
{"full_name": "ConNF.NearLitterAction.roughLitterMapOrElse_of_dom", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.roughLitterMapOrElse_of_dom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) {L : ConNF.Litter} (hL : (Ï†.litterMap L).Dom) :ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† L = ((Ï†.litterMap L).get hL).fst", "code": "theorem roughLitterMapOrElse_of_dom {L : Litter} (hL : (Ï†.litterMap L).Dom) :\n    Ï†.roughLitterMapOrElse L = ((Ï†.litterMap L).get hL).1 := by\n  rw [roughLitterMapOrElse, litterMapOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 1064], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [164, 167], "informalization": "Function `ConNF.NearLitterAction.roughLitterMapOrElse` takes a `ConNF.NearLitterAction` object `Ï†` and a `ConNF.Litter` object `L`, and returns the first component of the result of applying `ConNF.NearLitterAction.litterMapOrElse` to `Ï†` and `L`."}
{"full_name": "ConNF.NearLitterAction.Lawful.le", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Lawful.le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.Lawful.le [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} {Ïˆ : ConNF.NearLitterAction} (h : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (hÏˆ : Ïˆ â‰¤ Ï†) :ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ïˆ", "code": "theorem Lawful.le {Ï† Ïˆ : NearLitterAction} (h : Ï†.Lawful) (hÏˆ : Ïˆ â‰¤ Ï†) : Ïˆ.Lawful :=\n  { atomMap_injective := by\n      intro a b ha hb hab\n      refine' h.atomMap_injective (hÏˆ.1.dom_of_dom a ha) (hÏˆ.1.dom_of_dom b hb) _\n      rwa [hÏˆ.1.get_eq, hÏˆ.1.get_eq] at hab\n    litterMap_injective := by\n      intro Lâ‚ Lâ‚‚ hâ‚ hâ‚‚ hâ‚â‚‚\n      refine' h.litterMap_injective (hÏˆ.2.dom_of_dom Lâ‚ hâ‚) (hÏˆ.2.dom_of_dom Lâ‚‚ hâ‚‚) _\n      rwa [hÏˆ.2.get_eq, hÏˆ.2.get_eq] at hâ‚â‚‚\n    atom_mem := by\n      intro a ha L hL\n      rw [h.atom_mem a (hÏˆ.1.dom_of_dom a ha) L (hÏˆ.2.dom_of_dom L hL), hÏˆ.1.get_eq, hÏˆ.2.get_eq] }\n", "additional_info": "", "used_premises": [1, 825, 825], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [203, 215], "informalization": "The theorem `ConNF.NearLitterAction.Lawful.le` states that if `Ï†` is a lawful near litter action and `Ïˆ` is a near litter action that is less than or equal to `Ï†`, then `Ïˆ` is also a lawful near litter action."}
{"full_name": "ConNF.NearLitterAction.preciseAt_iff", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.preciseAt_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preciseAt_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) â¦ƒL : ConNF.Litterâ¦„ (hL : (Ï†.litterMap L).Dom) :ConNF.NearLitterAction.PreciseAtğŸ”—<|PREMISE|>ğŸ”— Ï† hL â†” symmDiffğŸ”—<|PREMISE|>ğŸ”— (â†‘((Ï†.litterMap L).get hL)) (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— ((Ï†.litterMap L).get hL).fst) âŠ† PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆ§ (âˆ€ (a : ConNF.Atom) (ha : (Ï†.atomMap a).Dom), (Ï†.atomMap a).get ha âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L â†’ (Ï†.atomMap ((Ï†.atomMap a).get ha)).Dom) âˆ§ PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆ© â†‘((Ï†.litterMap L).get hL) âŠ† PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1141, 62, 467, 824, 467, 404, 824], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [218, 219], "informalization": "The theorem `ConNF.NearLitterAction.preciseAt_iff` states that a near litter action `Ï†` is precise at a litter `L` in its domain if and only if the symmetric difference of the image of `L` under `Ï†` and the litter set of `L` is a subset of the range of `Ï†`, and for any atom `a` in the domain of `Ï†`, if `Ï†(a)` is in the litter set of `L`, then `Ï†(Ï†(a))` is also in the domain of `Ï†`. Additionally, the intersection of the domain of `Ï†` and the image of `L` under `Ï†` is a subset of the range of `Ï†`."}
{"full_name": "ConNF.NearLitterAction.PreciseAt", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.PreciseAt", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.PreciseAt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) â¦ƒL : ConNF.Litterâ¦„ (hL : (Ï†.litterMap L).Dom) :Prop\n | diff : symmDiffğŸ”—<|PREMISE|>ğŸ”—  (â†‘((Ï†.litterMap L).get hL)) (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”—  ((Ï†.litterMap L).get hL).fst) âŠ†  PFun.ranğŸ”—<|PREMISE|>ğŸ”—  Ï†.atomMap\n | fwd : âˆ€ (a : ConNF.Atom) (ha : (Ï†.atomMap a).Dom),\n (Ï†.atomMap a).get ha âˆˆ  ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”—  L â†’ (Ï†.atomMap ((Ï†.atomMap a).get ha)).Dom\n | back : PFun.DomğŸ”—<|PREMISE|>ğŸ”—  Ï†.atomMap âˆ©  â†‘((Ï†.litterMap L).get hL) âŠ†  PFun.ranğŸ”—<|PREMISE|>ğŸ”—  Ï†.atomMap", "code": "structure PreciseAt â¦ƒL : Litterâ¦„ (hL : (Ï†.litterMap L).Dom) : Prop where\n  diff : ((Ï†.litterMap L).get hL : Set Atom) âˆ† litterSet ((Ï†.litterMap L).get hL).1 âŠ† Ï†.atomMap.ran\n  fwd : âˆ€ a ha, (Ï†.atomMap a).get ha âˆˆ litterSet L â†’ (Ï†.atomMap ((Ï†.atomMap a).get ha)).Dom\n  back : Ï†.atomMap.Dom âˆ© (Ï†.litterMap L).get hL âŠ† Ï†.atomMap.ran\n", "additional_info": "An action is precise at a litter in its domain if all atoms in the symmetric\ndifference of its image are accounted for.\n", "used_premises": [1, 62, 467, 824, 467, 404, 824], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [219, 223], "informalization": "The structure `ConNF.NearLitterAction.PreciseAt` defines a property of a near litter action in the context of Constructive Ordinal Notation (ConNF). A near litter action `Ï†` is precise at a litter `L` in its domain if the symmetric difference of the image of `L` under `Ï†` and the litter set of `L` is a subset of the range of `Ï†`, and for any atom `a` in the domain of `Ï†`, if `Ï†(a)` is in the litter set of `L`, then `Ï†(Ï†(a))` is also in the domain of `Ï†`. Additionally, the intersection of the domain of `Ï†` and the image of `L` under `Ï†` is a subset of the range of `Ï†`."}
{"full_name": "ConNF.NearLitterAction.disjoint_dom_not_bannedLitter", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.disjoint_dom_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_dom_not_bannedLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :DisjointğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap âˆª ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† '' PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap) {L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L}", "code": "theorem disjoint_dom_not_bannedLitter :\n    Disjoint (Ï†.litterMap.Dom âˆª Ï†.roughLitterMapOrElse '' Ï†.litterMap.Dom)\n      {L : Litter | Â¬Ï†.BannedLitter L} := by\n  simp only [Set.disjoint_left, mem_union, PFun.mem_dom, mem_image, mem_setOf_eq,\n    Classical.not_not]\n  rintro _ (âŸ¨_, hL, rflâŸ© | âŸ¨L, âŸ¨_, hL, rflâŸ©, rflâŸ©)\n  Â· exact BannedLitter.litterDom _ hL\n  Â· rw [Ï†.roughLitterMapOrElse_of_dom hL]\n    exact BannedLitter.litterMap _ hL\n", "additional_info": "", "used_premises": [1, 757, 404, 1064, 404, 1065], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [232, 241], "informalization": "The theorem `ConNF.NearLitterAction.disjoint_dom_not_bannedLitter` states that the union of the domain of the partial function `Ï†.litterMap` and the image of the domain of `Ï†.litterMap` under the function `ConNF.NearLitterAction.roughLitterMapOrElse` is disjoint from the set of litters that are not banned by `Ï†`."}
{"full_name": "ConNF.NearLitterAction.roughLitterMapOrElse_injOn", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse_injOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.roughLitterMapOrElse_injOn [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :Set.InjOnğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï†) (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap)", "code": "theorem roughLitterMapOrElse_injOn (hÏ† : Ï†.Lawful) :\n    InjOn Ï†.roughLitterMapOrElse Ï†.litterMap.Dom := by\n  intro Lâ‚ hLâ‚ Lâ‚‚ hLâ‚‚ h\n  rw [Ï†.roughLitterMapOrElse_of_dom hLâ‚, Ï†.roughLitterMapOrElse_of_dom hLâ‚‚] at h\n  exact hÏ†.litterMap_injective hLâ‚ hLâ‚‚ (NearLitter.inter_nonempty_of_fst_eq_fst h)\n", "additional_info": "", "used_premises": [1, 825, 111, 1064, 404], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [242, 247], "informalization": "The function `ConNF.NearLitterAction.roughLitterMapOrElse` is injective when restricted to the domain of `Ï†.litterMap`."}
{"full_name": "ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L âˆ§ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L} = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_not_bannedLitter_and_flexible : #{L | Â¬Ï†.BannedLitter L âˆ§ Flexible A L} = #Î¼ := by\n  refine' le_antisymm ((mk_subtype_le _).trans mk_litter.le) _\n  by_contra h\n  rw [not_le] at h\n  have hâ‚ := Cardinal.le_mk_diff_add_mk {L | Flexible A L} {L | Ï†.BannedLitter L}\n  rw [mk_flexible, diff_eq, inter_comm] at hâ‚\n  have hâ‚‚ := add_lt_of_lt Params.Î¼_isStrongLimit.isLimit.aleph0_le h\n    (lt_trans Ï†.bannedLitter_small Params.Îº_lt_Î¼)\n  exact hâ‚.not_lt hâ‚‚\n", "additional_info": "", "used_premises": [1, 61, 29, 1065, 842, 29], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [250, 259], "informalization": "The theorem `ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set of litters that are not banned and are also flexible is equal to the cardinality of the base type `Î¼`. This theorem is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.NearLitterAction.mk_dom_inter_flexible_symmDiff_le", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.mk_dom_inter_flexible_symmDiff_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_dom_inter_flexible_symmDiff_le [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap âˆ© {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L}) (ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† '' (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap âˆ© {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L}))) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L âˆ§ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L}", "code": "theorem mk_dom_inter_flexible_symmDiff_le :\n    #((Ï†.litterMap.Dom âˆ© {L | Flexible A L}) âˆ†\n        (Ï†.roughLitterMapOrElse '' (Ï†.litterMap.Dom âˆ© {L | Flexible A L})) : Set Litter) â‰¤\n      #{L : Litter | Â¬Ï†.BannedLitter L âˆ§ Flexible A L} := by\n  rw [mk_not_bannedLitter_and_flexible]\n  refine' le_trans (le_of_lt _) Params.Îº_lt_Î¼.le\n  exact Small.symmDiff (Small.mono (inter_subset_left _ _) Ï†.litterMap_dom_small)\n    (Small.mono (inter_subset_left _ _) Ï†.litterMap_dom_small).image\n", "additional_info": "", "used_premises": [1, 61, 29, 62, 404, 842, 1064, 404, 842, 29, 1065, 842], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [260, 268], "informalization": "The theorem is proving an inequality involving the cardinalities of two sets related to Constructive Ordinal Notation (ConNF). The left-hand side of the inequality represents the cardinality of the symmetric difference between two sets of litters. The first set contains litters that are both in the domain of `Ï†.litterMap` and are considered *flexible* by `A`, while the second set contains the results of applying `ConNF.NearLitterAction.roughLitterMapOrElse` to the first set. The right-hand side of the inequality represents the cardinality of a set of litters that are both not *banned* and *flexible* by `A`. The theorem shows that the cardinality of the left-hand side is less than or equal to the cardinality of the right-hand side."}
{"full_name": "ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :Cardinal.aleph0ğŸ”—<|PREMISE|>ğŸ”— â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L âˆ§ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L}", "code": "theorem aleph0_le_not_bannedLitter_and_flexible :\n    â„µâ‚€ â‰¤ #{L | Â¬Ï†.BannedLitter L âˆ§ Flexible A L} := by\n  rw [mk_not_bannedLitter_and_flexible]\n  exact Params.Î¼_isStrongLimit.isLimit.aleph0_le\n", "additional_info": "", "used_premises": [1, 61, 510, 29, 1065, 842], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [269, 273], "informalization": "The theorem `ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible` states that the cardinality of the set of litters that are not banned and are considered flexible is at least as large as the cardinality of the natural numbers (denoted as `â„µâ‚€`). This theorem is an important step in the proof that the natural numbers can be constructed within the context of Constructive Ordinal Notation (ConNF), using the properties of litters and f-maps."}
{"full_name": "ConNF.NearLitterAction.disjoint_dom_inter_flexible_not_bannedLitter", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.disjoint_dom_inter_flexible_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_dom_inter_flexible_not_bannedLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :DisjointğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap âˆ© {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L} âˆª ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† '' (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap âˆ© {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L})) {L : ConNF.Litter | Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† L âˆ§ ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L}", "code": "theorem disjoint_dom_inter_flexible_not_bannedLitter :\n    Disjoint\n      (Ï†.litterMap.Dom âˆ© {L | Flexible A L} âˆª\n        Ï†.roughLitterMapOrElse '' (Ï†.litterMap.Dom âˆ© {L | Flexible A L}))\n      {L : Litter | Â¬Ï†.BannedLitter L âˆ§ Flexible A L} := by\n  refine' disjoint_of_subset _ (inter_subset_left _ _) Ï†.disjoint_dom_not_bannedLitter\n  rintro a (ha | âŸ¨b, hb, rflâŸ©)\n  exact Or.inl ha.1\n  exact Or.inr âŸ¨b, hb.1, rflâŸ©\n", "additional_info": "", "used_premises": [1, 61, 757, 404, 842, 1064, 404, 842, 1065, 842], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [274, 283], "informalization": "In the context of Constructive Ordinal Notation (ConNF), this result establishes that the intersection of the domain of the litter map of a `ConNF.NearLitterAction` object and the set of `ConNF.Flexible` litters is disjoint from the set of litters that are not `ConNF.NearLitterAction.BannedLitter` and are `ConNF.Flexible`. This is an important property that ensures the consistency of the construction of the natural numbers in ConNF."}
{"full_name": "ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :Set.InjOnğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï†) (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap âˆ© {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L})", "code": "theorem roughLitterMapOrElse_injOn_dom_inter_flexible (hÏ† : Ï†.Lawful) :\n    InjOn Ï†.roughLitterMapOrElse (Ï†.litterMap.Dom âˆ© {L | Flexible A L}) :=\n  (Ï†.roughLitterMapOrElse_injOn hÏ†).mono (inter_subset_left _ _)\n", "additional_info": "", "used_premises": [1, 61, 825, 111, 1064, 404, 842], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [284, 287], "informalization": "The theorem `ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible` states that the function `ConNF.NearLitterAction.roughLitterMapOrElse`, which takes a `ConNF.NearLitterAction` object `Ï†` and a `ConNF.Litter` object `L`, and returns the first component of the result of applying `ConNF.NearLitterAction.litterMapOrElse` to `Ï†` and `L`, is injective when restricted to the intersection of the domain of `Ï†.litterMap` and the set of *flexible* litters. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Ï† : ConNF.NearLitterAction} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} (L : ConNF.Litter) (hLâ‚ : L âˆˆ PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.litterMap) (hLâ‚‚ : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) :(ConNF.NearLitterAction.flexibleLitterPartialPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† A).toFun L = ConNF.NearLitterAction.roughLitterMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† L", "code": "theorem flexibleLitterPartialPerm_apply_eq {Ï† : NearLitterAction} {hÏ† : Ï†.Lawful} (L : Litter)\n    (hLâ‚ : L âˆˆ Ï†.litterMap.Dom) (hLâ‚‚ : Flexible A L) :\n    Ï†.flexibleLitterPartialPerm hÏ† A L = Ï†.roughLitterMapOrElse L :=\n  PartialPerm.complete_apply_eq _ _ _ âŸ¨hLâ‚, hLâ‚‚âŸ©\n", "additional_info": "", "used_premises": [1, 61, 825, 404, 842, 1150, 1064], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [294, 298], "informalization": "To summarize the explanation of the Lean 4 object `ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq` in one line, it states that the application of the partial permutation `ConNF.NearLitterAction.flexibleLitterPartialPerm` to a litter `L` that is both not banned and flexible with respect to the extended index `A` yields the same result as applying the `ConNF.NearLitterAction.roughLitterMapOrElse` to `L`."}
{"full_name": "ConNF.NearLitterAction.flexibleLitterPartialPerm", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.flexibleLitterPartialPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.flexibleLitterPartialPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :PartialPermğŸ”—<|PREMISE|>ğŸ”— ConNF.Litter", "code": "noncomputable def flexibleLitterPartialPerm (hÏ† : Ï†.Lawful) (A : ExtendedIndex Î²) : PartialPerm Litter :=\n  PartialPerm.complete Ï†.roughLitterMapOrElse (Ï†.litterMap.Dom âˆ© {L | Flexible A L})\n    {L | Â¬Ï†.BannedLitter L âˆ§ Flexible A L} Ï†.mk_dom_inter_flexible_symmDiff_le\n    Ï†.aleph0_le_not_bannedLitter_and_flexible Ï†.disjoint_dom_inter_flexible_not_bannedLitter\n    (Ï†.roughLitterMapOrElse_injOn_dom_inter_flexible hÏ†)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 61, 645], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [288, 293], "informalization": "Function `ConNF.NearLitterAction.flexibleLitterPartialPerm` is a partial permutation on the set of litters in the context of Constructive Ordinal Notation (ConNF). Given a lawful near litter action `Ï†` and an extended index `A`, it constructs a partial permutation on the set of litters by completing the rough litter map `Ï†.roughLitterMapOrElse` on the intersection of its domain with the set of litters that are both not banned and flexible with respect to `A`."}
{"full_name": "ConNF.NearLitterAction.flexibleLitterPartialPerm_domain_small", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.flexibleLitterPartialPerm_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.flexibleLitterPartialPerm_domain_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.flexibleLitterPartialPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† A).domain", "code": "theorem flexibleLitterPartialPerm_domain_small (hÏ† : Ï†.Lawful) :\n    Small (Ï†.flexibleLitterPartialPerm hÏ† A).domain := by\n  refine' Small.union (Small.union _ _) _\n  Â· exact Ï†.litterMap_dom_small.mono (inter_subset_left _ _)\n  Â· exact (Ï†.litterMap_dom_small.mono (inter_subset_left _ _)).image\n  Â· rw [Small]\n    rw [Cardinal.mk_congr (PartialPerm.sandboxSubsetEquiv _ _)]\n    simp only [mk_sum, mk_prod, mk_denumerable, lift_aleph0, lift_uzero, lift_id]\n    refine' add_lt_of_lt Params.Îº_isRegular.aleph0_le _ _ <;>\n      refine' mul_lt_of_lt Params.Îº_isRegular.aleph0_le\n        (lt_of_le_of_lt aleph0_le_mk_Î› Params.Î›_lt_Îº) _ <;>\n      refine' lt_of_le_of_lt (mk_subtype_mono (diff_subset _ _)) _\n    exact Ï†.litterMap_dom_small.mono (inter_subset_left _ _)\n    exact (Ï†.litterMap_dom_small.mono (inter_subset_left _ _)).image\n", "additional_info": "", "used_premises": [1, 61, 825, 233, 1150], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [299, 313], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a lawful near litter action `Ï†` and an extended index `A`, the domain of the partial permutation `ConNF.NearLitterAction.flexibleLitterPartialPerm Ï† hÏ† A` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.refineLawful", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refineLawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.refineLawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} :ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.refineğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem refineLawful : (Ï†.refine hÏ†).Lawful :=\n  fillAtomOrbitsLawful _ _ (fillAtomRange_symmDiff_subset_ran hÏ†)\n", "additional_info": "", "used_premises": [1, 825, 825, 1153], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [26, 28], "informalization": "Function `ConNF.NearLitterAction.refine` takes a lawful near litter action `Ï†` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refineLawful` asserts that the refined near litter action is lawful."}
{"full_name": "ConNF.NearLitterAction.refine", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.refine [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.NearLitterAction", "code": "noncomputable def refine (hÏ† : Ï†.Lawful) : NearLitterAction :=\n  Ï†.fillAtomRange.fillAtomOrbits (Ï†.fillAtomRangeLawful hÏ†)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.refineğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refineğŸ”—  Ï† hÏ† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.NearLitterAction.fillAtomOrbitsğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbitsğŸ”—  (ğŸ—ŸConNF.NearLitterAction.fillAtomRangeğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRangeğŸ”—  Ï†) â‹¯\n\n", "used_premises": [1, 825], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [21, 23], "informalization": "Function `ConNF.NearLitterAction.refine` takes a lawful near litter action `Ï†` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters."}
{"full_name": "ConNF.NearLitterAction.refine_atomMap", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.refine_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} {a : ConNF.Atom} (ha : (Ï†.atomMap a).Dom) :(ConNF.NearLitterAction.refineğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).atomMap a = Ï†.atomMap a", "code": "theorem refine_atomMap {a : Atom} (ha : (Ï†.atomMap a).Dom) :\n    (Ï†.refine hÏ†).atomMap a = Ï†.atomMap a := by\n  unfold refine\n  refine' Part.ext' _ _\n  Â· simp only [ha, fillAtomOrbits_atomMap, orbitAtomMap_dom_iff,\n      fillAtomRange_atomMap, iff_true_iff]\n    exact Or.inl (Or.inl ha)\n  intros\n  refine' (Ï†.fillAtomRange.orbitAtomMap_eq_of_mem_dom _ _ (Or.inl ha)).trans _\n  exact Ï†.supportedAction_eq_of_dom ha\n", "additional_info": "", "used_premises": [1, 825, 1153], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [30, 40], "informalization": "Function `ConNF.NearLitterAction.refine_atomMap` is a part of the Constructive Ordinal Notation (ConNF) library in Lean 4. It states that the refined atom map of a lawful near litter action `Ï†` is equal to the original atom map of `Ï†`."}
{"full_name": "ConNF.NearLitterAction.refine_litterMap", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.refine_litterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} :(ConNF.NearLitterAction.refineğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).litterMap = Ï†.litterMap", "code": "theorem refine_litterMap : (Ï†.refine hÏ†).litterMap = Ï†.litterMap :=\n  rfl\n", "additional_info": "", "used_premises": [1, 825, 1153], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [47, 49], "informalization": "The function `ConNF.NearLitterAction.refine` takes a lawful near litter action `Ï†` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refine_litterMap` states that the refined litter map is equal to the original litter map."}
{"full_name": "ConNF.NearLitterAction.refine_precise", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine_precise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.refine_precise [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} :ConNF.NearLitterAction.PreciseğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.refineğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem refine_precise : Precise (Ï†.refine hÏ†) :=\n  fillAtomOrbits_precise _ (fillAtomRange_symmDiff_subset_ran hÏ†)\n", "additional_info": "", "used_premises": [1, 825, 1123, 1153], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [50, 52], "informalization": "The function `ConNF.NearLitterAction.refine` takes a lawful near litter action `Ï†` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refine_precise` states that the refined near litter action is precise, meaning it is precise at every litter in its domain."}
{"full_name": "ConNF.StructAction.refine_lawful", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.refine_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.refine_lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²} {hÏ† : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} :ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.refineğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem refine_lawful : (Ï†.refine hÏ†).Lawful := fun _ => NearLitterAction.refineLawful\n", "additional_info": "", "used_premises": [1, 808, 809, 809, 1158], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [63, 64], "informalization": "Function `ConNF.StructAction.refine_lawful` proves that the refined `Î²`-structural action satisfies the lawfulness condition for each `Î²`-extended index."}
{"full_name": "ConNF.StructAction.refine", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.refine", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.refine [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²) (hÏ† : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²", "code": "noncomputable def refine : StructAction Î² := fun A => (Ï† A).refine (hÏ† A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructAction.refineğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Refine.html#ConNF.StructAction.refineğŸ”—  Ï† hÏ† A ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.NearLitterAction.refineğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refineğŸ”—  (Ï† A) â‹¯\n\n", "used_premises": [1, 808, 809, 808], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [59, 60], "informalization": "Function `ConNF.StructAction.refine` takes a `Î²`-structural action `Ï†` and a proof that `Ï†` satisfies the lawfulness condition for each `Î²`-extended index, and returns a refined `Î²`-structural action."}
{"full_name": "ConNF.StructAction.refine_precise", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.refine_precise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.refine_precise [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²} {hÏ† : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} :ConNF.StructAction.PreciseğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.refineğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†)", "code": "theorem refine_precise : Precise (Ï†.refine hÏ†) := fun _ => NearLitterAction.refine_precise\n", "additional_info": "", "used_premises": [1, 808, 809, 1160, 1158], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [83, 84], "informalization": "The theorem `ConNF.StructAction.refine_precise` states that if `Ï†` is a `Î²`-structural action that satisfies the lawfulness condition for each `Î²`-extended index, then the refined `Î²`-structural action `ConNF.StructAction.refine Ï† hÏ†` is precise, meaning it assigns a precise near-litter action to each `Î²`-extended index."}
{"full_name": "ConNF.StructAction.Precise", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Precise", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.Precise [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def Precise {Î² : TypeIndex} (Ï† : StructAction Î²) : Prop :=\n  âˆ€ B, (Ï† B).Precise\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructAction.PreciseğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.PreciseğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (B : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  Î²), ğŸ—ŸConNF.NearLitterAction.PreciseğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.PreciseğŸ”—  (Ï† B)\n\n", "used_premises": [1, 808], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [35, 37], "informalization": "Function `ConNF.StructAction.Precise` checks if a `Î²`-structural action `Ï†` is precise, meaning it assigns a precise near-litter action to each `Î²`-extended index."}
{"full_name": "ConNF.StructAction.rc_smul_atom_eq", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.rc_smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.rc_smul_atom_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {h : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} (ha : ((Ï† B).atomMap a).Dom) :ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— Ï† h B â€¢ a = ((Ï† B).atomMap a).get ha", "code": "theorem rc_smul_atom_eq {Ï† : StructAction Î²} {h : Ï†.Lawful} {B : ExtendedIndex Î²} {a : Atom}\n    (ha : ((Ï† B).atomMap a).Dom) : Ï†.rc h B â€¢ a = ((Ï† B).atomMap a).get ha := by\n  refine' (NearLitterAction.complete_smul_atom_eq _ _).trans _\n  Â· exact Or.inl (Or.inl ha)\n  Â· simp only [refine_apply, refine_atomMap ha]\n", "additional_info": "", "used_premises": [1, 808, 809, 61, 810], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [95, 100], "informalization": "The theorem `ConNF.StructAction.rc_smul_atom_eq` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that for any `Î²`-structural action `Ï†` that is lawful, any `Î²`-extended index `B`, and any `Atom` `a`, if the domain of `Ï† B`'s atom map on `a` is not empty, then the `Î²`-structural approximation of `Ï†` applied to `B` and `a` is equal to the value of `Ï† B`'s atom map on `a` at the given domain element. This indicates that the `Î²`-structural approximation correctly extends the `Î²`-structural action."}
{"full_name": "ConNF.StructAction.rc_free", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.rc_free", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.rc_free [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (hâ‚‚ : ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.StructApprox.FreeğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— Ï† hâ‚)", "code": "theorem rc_free (Ï† : StructAction Î²) (hâ‚ : Ï†.Lawful) (hâ‚‚ : Ï†.MapFlexible) :\n    (Ï†.rc hâ‚).Free := by\n  rintro B L' ((hL' | âŸ¨L', hL', rflâŸ©) | hL')\n  Â· exact hL'.2\n  Â· rw [NearLitterAction.roughLitterMapOrElse_of_dom _ hL'.1]\n    exact hâ‚‚ B L' hL'.1 hL'.2\n  Â· exact (PartialPerm.sandboxSubset_subset _ _ hL').2\n", "additional_info": "", "used_premises": [1, 808, 809, 814, 782, 810], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [110, 117], "informalization": "The `ConNF.StructAction.rc_free` theorem proves that the `Î²`-structural approximation `ConNF.StructAction.rc Ï† hâ‚` is free. This means that for every `Î²`-extended index `A`, the near-litter approximation `(Ï€â‚€ A)` is free with respect to `A`. This theorem is a key part of the ConNF construction, which aims to define a well-founded, transitive relation on the ordinals using a recursive process that leverages the properties of `Î²`-extended indices, near-litters, and `Î²`-structural approximations."}
{"full_name": "ConNF.StructAction.smul_atom_eq", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.smul_atom_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) {hÏ† : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€ : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.completeğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†) Ï€) {a : ConNF.Atom} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (ha : ((Ï† B).atomMap a).Dom) :Ï€ B â€¢ a = ((Ï† B).atomMap a).get ha", "code": "theorem smul_atom_eq {hÏ† : Ï†.Lawful} {Ï€ : StructPerm Î²} (hÏ€ : (Ï†.complete hÏ†).ExactlyApproximates Ï€)\n    {a : Atom} {B : ExtendedIndex Î²} (ha : ((Ï† B).atomMap a).Dom) :\n    Ï€ B â€¢ a = ((Ï† B).atomMap a).get ha :=\n  (Ï† B).smul_atom_eq (hÏ€ B) ha\n", "additional_info": "", "used_premises": [1, 808, 809, 55, 803, 1164, 61], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [46, 50], "informalization": "The theorem `ConNF.StructAction.smul_atom_eq` is a part of the Constructive Ordinal Notation (ConNF) framework in Lean 4. It states that for a lawful `Î²`-structural action `Ï†`, the action of a `Î²`-structural permutation `Ï€` on an atom `a` at an extended index `B` is equal to the value of the atom map at `a` given the domain condition `ha`. This theorem is crucial for ensuring that the `Î²`-structural approximation is an exact approximation of the `Î²`-structural permutation in the context of ConNF."}
{"full_name": "ConNF.StructAction.complete", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.complete", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.complete [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (hÏ† : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²", "code": "noncomputable def complete (hÏ† : Ï†.Lawful) : StructApprox Î² := fun B => (Ï† B).complete (hÏ† B) B\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructAction.completeğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.completeğŸ”—  Ï† hÏ† B ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.NearLitterAction.completeğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.completeğŸ”—  (Ï† B) â‹¯ B\n\n", "used_premises": [1, 808, 809, 781], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [40, 41], "informalization": "Function `ConNF.StructAction.complete` constructs a `Î²`-structural approximation from a `Î²`-structural action that satisfies the lawfulness condition."}
{"full_name": "ConNF.StructAction.smul_toNearLitter_eq_of_precise", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.smul_toNearLitter_eq_of_precise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.smul_toNearLitter_eq_of_precise [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) {hÏ† : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} (hÏ†p : ConNF.StructAction.PreciseğŸ”—<|PREMISE|>ğŸ”— Ï†) {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hÏ€ : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.completeğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†) Ï€) {L : ConNF.Litter} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (hL : ((Ï† B).litterMap L).Dom) (hÏ€L : Ï€ B â€¢ L = (((Ï† B).litterMap L).get hL).fst) :Ï€ B â€¢ ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L = ((Ï† B).litterMap L).get hL", "code": "theorem smul_toNearLitter_eq_of_precise {hÏ† : Ï†.Lawful} (hÏ†p : Ï†.Precise) {Ï€ : StructPerm Î²}\n    (hÏ€ : (Ï†.complete hÏ†).ExactlyApproximates Ï€) {L : Litter} {B : ExtendedIndex Î²}\n    (hL : ((Ï† B).litterMap L).Dom)\n    (hÏ€L : Ï€ B â€¢ L = (((Ï† B).litterMap L).get hL).1) :\n    Ï€ B â€¢ L.toNearLitter = ((Ï† B).litterMap L).get hL :=\n  (Ï† B).smul_toNearLitter_eq_of_preciseAt (hÏ€ B) hL (hÏ†p B hL) hÏ€L\n", "additional_info": "", "used_premises": [1, 808, 809, 1160, 55, 803, 1164, 61, 483], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [51, 57], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructAction.smul_toNearLitter_eq_of_precise` states that if a `Î²`-structural action `Ï†` is precise, meaning it assigns a precise near-litter action to each `Î²`-extended index, and if a `Î²`-structural permutation `Ï€` exactly approximates the `Î²`-structural approximation constructed from `Ï†`, then for any `Î²`-extended index `B` and any litter `L` such that the near-litter action of `Ï†` at `B` applied to `L` is defined, the near-litter action of `Ï€` at `B` applied to the near-litter `L` is equal to the precise near-litter action of `Ï†` at `B` applied to `L`."}
{"full_name": "ConNF.StructAction.Lawful.le", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Lawful.le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.Lawful.le [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²} {Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²} (h : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (hÏˆ : Ïˆ â‰¤ Ï†) :ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ïˆ", "code": "theorem Lawful.le {Î² : TypeIndex} {Ï† Ïˆ : StructAction Î²} (h : Ï†.Lawful) (hÏˆ : Ïˆ â‰¤ Ï†) : Ïˆ.Lawful :=\n  fun B => (h B).le (hÏˆ B)\n", "additional_info": "", "used_premises": [1, 808, 808, 809, 809], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [78, 80], "informalization": "The theorem `ConNF.StructAction.Lawful.le` states that if `Ï†` is a lawful `Î²`-structural action and `Ïˆ` is a `Î²`-structural action that is less than or equal to `Ï†`, then `Ïˆ` is also a lawful `Î²`-structural action."}
{"full_name": "ConNF.StructAction.le_comp", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.le_comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.le_comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²} {Ïˆ : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²} (h : Ï† â‰¤ Ïˆ) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) :ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï† â‰¤ ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ïˆ", "code": "theorem le_comp {Î² Î³ : TypeIndex} {Ï† Ïˆ : StructAction Î²} (h : Ï† â‰¤ Ïˆ) (A : Path Î² Î³) :\n    Ï†.comp A â‰¤ Ïˆ.comp A := fun B => h (A.comp B)\n", "additional_info": "", "used_premises": [1, 808, 808, 76, 304, 304], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [81, 83], "informalization": "Given a `Î²`-structural action `Ï†` that is less than or equal to another `Î²`-structural action `Ïˆ`, and a path `A` from type index `Î²` to type index `Î³`, the derivative functor `ConNF.Tree.comp A Ï†` is less than or equal to the derivative functor `ConNF.Tree.comp A Ïˆ`."}
{"full_name": "ConNF.StructAction.Lawful.comp", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Lawful.comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.Lawful.comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— Î²} (h : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) :ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï†)", "code": "theorem Lawful.comp {Î² Î³ : TypeIndex} {Ï† : StructAction Î²} (h : Ï†.Lawful) (A : Path Î² Î³) :\n    Lawful (Ï†.comp A) := fun B =>\n  { atomMap_injective := (h (A.comp B)).atomMap_injective\n    litterMap_injective := (h (A.comp B)).litterMap_injective\n    atom_mem := (h (A.comp B)).atom_mem }\n", "additional_info": "", "used_premises": [1, 808, 809, 76, 809, 304], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [84, 89], "informalization": "The theorem `ConNF.StructAction.Lawful.comp` states that if `Ï†` is a lawful `Î²`-structural action, then the composition of `Ï†` with any path `A` from `Î²` to `Î³` is also lawful, forming a lawful `Î³`-structural action. This property is crucial for showing that every lawful `Î²`-structural action can be extended to a lawful `Î³`-structural action, which is a key step in the proof of the consistency of Constructive Ordinal Notation (ConNF) with ZFC."}
{"full_name": "ConNF.NearLitterAction.sandboxLitter_not_banned", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.sandboxLitter_not_banned", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.sandboxLitter_not_banned [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† (ConNF.NearLitterAction.sandboxLitterğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem sandboxLitter_not_banned : Â¬Ï†.BannedLitter Ï†.sandboxLitter :=\n  Ï†.not_bannedLitter_nonempty.some.prop\n", "additional_info": "", "used_premises": [1, 1065, 1170], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [24, 26], "informalization": "The sandbox litter for a near-litter action is not banned."}
{"full_name": "ConNF.NearLitterAction.sandboxLitter", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.sandboxLitter", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.sandboxLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.Litter", "code": "noncomputable def sandboxLitter : Litter :=\n  Ï†.not_bannedLitter_nonempty.some\n", "additional_info": "The *sandbox litter* for a near-litter action is an arbitrarily chosen litter that\nisn't banned.\nEquations\n* ğŸ—ŸConNF.NearLitterAction.sandboxLitterğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.sandboxLitterğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  â†‘(ğŸ—ŸNonempty.someğŸ—ŸğŸ”—../../.././Mathlib/Logic/Nonempty.html#Nonempty.someğŸ”—  â‹¯)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [21, 23], "informalization": "The sandbox litter for a near-litter action is an arbitrarily chosen litter that isn't banned."}
{"full_name": "ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(symmDiffğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) (ConNF.NearLitterAction.atomMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† '' PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap)) â‰¤ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.sandboxLitterğŸ”—<|PREMISE|>ğŸ”— Ï†))", "code": "theorem mk_atomMap_image_le_mk_sandbox :\n    #(Ï†.atomMap.Dom âˆ† (Ï†.atomMapOrElse '' Ï†.atomMap.Dom) : Set Atom) â‰¤\n      #(litterSet Ï†.sandboxLitter) := by\n  rw [mk_litterSet]\n  refine' le_trans (mk_subtype_mono symmDiff_subset_union) (le_trans (mk_union_le _ _) _)\n  refine' add_le_of_le Params.Îº_isRegular.aleph0_le _ _\n  exact le_of_lt Ï†.atomMap_dom_small\n  exact le_trans mk_image_le (le_of_lt Ï†.atomMap_dom_small)\n", "additional_info": "", "used_premises": [1, 29, 62, 404, 1134, 404, 29, 467, 1170], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [27, 35], "informalization": "The theorem `ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox` in Lean 4 is a statement about the sizes of two sets related to a `ConNF.NearLitterAction` object `Ï†`. It asserts that the cardinality of the symmetric difference between the domain of `Ï†.atomMap` and its image under `Ï†.atomMapOrElse`, is less than or equal to the cardinality of the litter set corresponding to the sandbox litter of `Ï†`. This theorem is crucial in the ConNF theory for proving the existence of a member of a specific litter in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.NearLitterAction.disjoint_sandbox", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.disjoint_sandbox", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_sandbox [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :DisjointğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆª ConNF.NearLitterAction.atomMapOrElseğŸ”—<|PREMISE|>ğŸ”— Ï† '' PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.sandboxLitterğŸ”—<|PREMISE|>ğŸ”— Ï†))", "code": "theorem disjoint_sandbox :\n    Disjoint (Ï†.atomMap.Dom âˆª Ï†.atomMapOrElse '' Ï†.atomMap.Dom) (litterSet Ï†.sandboxLitter) := by\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem]\n  rintro a âŸ¨haâ‚, haâ‚‚âŸ©\n  rw [mem_litterSet] at haâ‚‚\n  have hnb := Ï†.sandboxLitter_not_banned\n  rw [â† haâ‚‚] at hnb\n  obtain (haâ‚ | haâ‚) := haâ‚\n  Â· exact hnb (BannedLitter.atomDom a haâ‚)\n  Â· refine' hnb _\n    simp only [mem_image, PFun.mem_dom] at haâ‚\n    obtain âŸ¨b, âŸ¨_, hb, rflâŸ©, rflâŸ© := haâ‚\n    rw [Ï†.atomMapOrElse_of_dom hb]\n    exact BannedLitter.atomMap b hb\n", "additional_info": "", "used_premises": [1, 757, 404, 1134, 404, 467, 1170], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [36, 50], "informalization": "The theorem `ConNF.NearLitterAction.disjoint_sandbox` in Lean 4 states that for any near-litter action `Ï†`, the union of the domain of `Ï†.atomMap` and its image under `ConNF.NearLitterAction.atomMapOrElse` is disjoint from the litter set corresponding to the sandbox litter of `Ï†`. This theorem is crucial for the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), as it ensures that the sandbox litter is distinct from the atoms that are relevant for the definition of natural numbers."}
{"full_name": "ConNF.NearLitterAction.atomPartialPerm_domain_small", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.atomPartialPerm_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomPartialPerm_domain_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.atomPartialPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).domain", "code": "theorem atomPartialPerm_domain_small (hÏ† : Ï†.Lawful) : Small (Ï†.atomPartialPerm hÏ†).domain :=\n  Small.union (Small.union Ï†.atomMap_dom_small (lt_of_le_of_lt mk_image_le Ï†.atomMap_dom_small))\n    Ï†.sandboxSubset_small\n", "additional_info": "", "used_premises": [1, 825, 233, 1174], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [75, 78], "informalization": "The theorem `ConNF.NearLitterAction.atomPartialPerm_domain_small` asserts that the domain of the partial permutation `ConNF.NearLitterAction.atomPartialPerm Ï† hÏ†` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterAction.atomPartialPerm", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.atomPartialPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.atomPartialPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :PartialPermğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "noncomputable def atomPartialPerm (hÏ† : Ï†.Lawful) : PartialPerm Atom :=\n  PartialPerm.complete Ï†.atomMapOrElse Ï†.atomMap.Dom (litterSet Ï†.sandboxLitter)\n    Ï†.mk_atomMap_image_le_mk_sandbox\n    (by simpa only [mk_litterSet] using Params.Îº_isRegular.aleph0_le)\n    Ï†.disjoint_sandbox (Ï†.atomMapOrElse_injective hÏ†)\n", "additional_info": "A local permutation induced by completing the orbits of atoms in a near-litter action.\nThis function creates forward and backward images of atoms in the *sandbox litter*,\na litter which is away from the domain and range of the approximation in question, so it should\nnot interfere with other constructions.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 645], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [55, 60], "informalization": "Function `ConNF.NearLitterAction.atomPartialPerm` completes the orbits of atoms in a near-litter action, creating forward and backward images of atoms in the sandbox litter, which is away from the domain and range of the approximation in question, ensuring it does not interfere with other constructions."}
{"full_name": "ConNF.NearLitterAction.atomPartialPerm_apply_eq", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.atomPartialPerm_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomPartialPerm_apply_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) {a : ConNF.Atom} (ha : (Ï†.atomMap a).Dom) :(ConNF.NearLitterAction.atomPartialPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ†).toFun a = (Ï†.atomMap a).get ha", "code": "theorem atomPartialPerm_apply_eq (hÏ† : Ï†.Lawful) {a : Atom} (ha : (Ï†.atomMap a).Dom) :\n    Ï†.atomPartialPerm hÏ† a = (Ï†.atomMap a).get ha := by\n  rwa [atomPartialPerm, PartialPerm.complete_apply_eq, atomMapOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 825, 1174], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [88, 91], "informalization": "The function `ConNF.NearLitterAction.atomPartialPerm_apply_eq` establishes an equality between the application of the function `ConNF.NearLitterAction.atomPartialPerm` to an atom `a` and the value obtained by applying the atom map `Ï†.atomMap a` directly. This function is crucial in showing that the near-litter action is lawful by ensuring that the atom permutation is well-defined and that the resulting action does not alter the essential properties of the `ConNF.Params` structure."}
{"full_name": "ConNF.NearLitterAction.complete_smul_atom_eq", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.complete_smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.complete_smul_atom_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} {a : ConNF.Atom} (ha : (Ï†.atomMap a).Dom) :ConNF.NearLitterAction.completeğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† A â€¢ a = (Ï†.atomMap a).get ha", "code": "theorem complete_smul_atom_eq {hÏ† : Ï†.Lawful} {a : Atom} (ha : (Ï†.atomMap a).Dom) :\n    Ï†.complete hÏ† A â€¢ a = (Ï†.atomMap a).get ha :=\n  Ï†.atomPartialPerm_apply_eq hÏ† ha\n", "additional_info": "", "used_premises": [1, 61, 825, 1177], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [92, 95], "informalization": "Given a lawful near-litter action Ï†, a finite path A from a type Î² to the base type âŠ¥, and an atom a that is mapped to a near-litter by Ï†, the near-litter approximation (Ï†.complete A) applied to a is equal to the atom a itself."}
{"full_name": "ConNF.NearLitterAction.complete", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.complete", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.complete [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :ConNF.NearLitterApprox", "code": "noncomputable def complete (hÏ† : Ï†.Lawful) (A : ExtendedIndex Î²) : NearLitterApprox\n    where\n  atomPerm := Ï†.atomPartialPerm hÏ†\n  litterPerm := Ï†.flexibleLitterPartialPerm hÏ† A\n  domain_small _ := Small.mono (inter_subset_right _ _) (Ï†.atomPartialPerm_domain_small hÏ†)\n", "additional_info": "A near-litter approximation built from this near-litter action.\nIts action on atoms matches that of the action, and its rough action on litters\nmatches the given litter permutation.\nEquations\n* ğŸ—ŸConNF.NearLitterAction.completeğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.completeğŸ”—  Ï† hÏ† A ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { atomPerm := ğŸ—ŸConNF.NearLitterAction.atomPartialPermğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.atomPartialPermğŸ”—  Ï† hÏ†,\n litterPerm := ğŸ—ŸConNF.NearLitterAction.flexibleLitterPartialPermğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.flexibleLitterPartialPermğŸ”—  Ï† hÏ† A, domain_small := â‹¯ }\n\n", "used_premises": [1, 825, 61], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [82, 87], "informalization": "Function `ConNF.NearLitterAction.complete` constructs a near-litter approximation in the context of Constructive Ordinal Notation (ConNF), given a lawful near-litter action `Ï†` and a finite path `A` from a type `Î²` to the base type `âŠ¥`. The near-litter approximation consists of an atom permutation and a litter permutation. The atom permutation matches the action of the near-litter action on atoms, and the litter permutation matches the given litter permutation."}
{"full_name": "ConNF.NearLitterAction.complete_smul_litter_eq", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.complete_smul_litter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.complete_smul_litter_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} (L : ConNF.Litter) :ConNF.NearLitterAction.completeğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† A â€¢ L = (ConNF.NearLitterAction.flexibleLitterPartialPermğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† A).toFun L", "code": "theorem complete_smul_litter_eq {hÏ† : Ï†.Lawful} (L : Litter) :\n    Ï†.complete hÏ† A â€¢ L = Ï†.flexibleLitterPartialPerm hÏ† A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 61, 825, 1177, 1150], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [97, 100], "informalization": "The theorem `ConNF.NearLitterAction.complete_smul_litter_eq` is a simplification of the action of a lawful near-litter action on a litter in the context of Constructive Ordinal Notation (ConNF). It states that the action of a near-litter approximation (which is constructed by completing a near-litter action on a finite path from a type to the base type) on a litter is equal to the action of a partial permutation on the set of litters. This theorem is important because it helps in understanding the relationship between the abstract actions of the near-litter approximation and the concrete actions of the partial permutation."}
{"full_name": "ConNF.NearLitterAction.smul_atom_eq", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.smul_atom_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} {Ï€ : ConNF.NearLitterPerm} (hÏ€ : ConNF.NearLitterApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.completeğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† A) Ï€) {a : ConNF.Atom} (ha : (Ï†.atomMap a).Dom) :Ï€ â€¢ a = (Ï†.atomMap a).get ha", "code": "theorem smul_atom_eq {hÏ† : Ï†.Lawful} {Ï€ : NearLitterPerm}\n    (hÏ€ : (Ï†.complete hÏ† A).ExactlyApproximates Ï€) {a : Atom} (ha : (Ï†.atomMap a).Dom) :\n    Ï€ â€¢ a = (Ï†.atomMap a).get ha := by\n  rw [â† hÏ€.map_atom a (Or.inl (Or.inl ha)), Ï†.complete_smul_atom_eq ha]\n", "additional_info": "", "used_premises": [1, 61, 825, 1180, 1177], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [101, 105], "informalization": "The theorem `ConNF.NearLitterAction.smul_atom_eq` in Lean 4 is a statement about a lawful near-litter action `Ï†` in the context of Constructive Ordinal Notation (ConNF). It states that if `Ï†` is lawful and `Ï€` is a near-litter permutation that exactly approximates the near-litter action `complete Ï† hÏ† A` where `A` is a finite path from a type `Î²` to the base type `âŠ¥`, then for any atom `a` in the domain of `Ï†.atomMap`, the action of `Ï€` on `a` is equal to the value obtained by applying `Ï†.atomMap` to `a`. This means that the action of the near-litter permutation on atoms is consistent with the action defined by the near-litter action."}
{"full_name": "ConNF.NearLitterApprox.ExactlyApproximates", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterApprox.ExactlyApproximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€â‚€ : ConNF.NearLitterApprox) (Ï€ : ConNF.NearLitterPerm) extends ConNF.NearLitterApprox.ApproximatesğŸ”—<|PREMISE|>ğŸ”— :Prop\n | map_atom : âˆ€ a âˆˆ Ï€â‚€.atomPerm.domain, Ï€â‚€ â€¢  a =  Ï€ â€¢  a\n | map_litter : âˆ€ L âˆˆ Ï€â‚€.litterPerm.domain, Ï€â‚€ â€¢  L =  Ï€ â€¢  L\n | exception_mem : âˆ€ (a : ConNF.Atom), ConNF.NearLitterPerm.IsExceptionğŸ”—<|PREMISE|>ğŸ”—  Ï€ a â†’ a âˆˆ  Ï€â‚€.atomPerm.domain", "code": "structure ExactlyApproximates (Ï€â‚€ : NearLitterApprox) (Ï€ : NearLitterPerm) extends\n    Approximates Ï€â‚€ Ï€ : Prop where\n  exception_mem : âˆ€ a, Ï€.IsException a â†’ a âˆˆ Ï€â‚€.atomPerm.domain\n", "additional_info": "", "used_premises": [1, 1181, 801], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [177, 180], "informalization": "`ConNF.NearLitterApprox.ExactlyApproximates` is a structure in the context of Constructive Ordinal Notation (ConNF) that defines a relationship between two objects of type `ConNF.NearLitterApprox` and `ConNF.NearLitterPerm`. It consists of three conditions: `map_atom`, `map_litter`, and `exception_mem`. The `map_atom` condition states that for any atom `a` in the domain of `Ï€â‚€.atomPerm`, the action of `Ï€â‚€` on `a` is the same as the action of `Ï€` on `a`. Similarly, the `map_litter` condition states that for any litter `L` in the domain of `Ï€â‚€.litterPerm`, the action of `Ï€â‚€` on `L` is the same as the action of `Ï€` on `L`. These conditions ensure that `Ï€â‚€` approximates `Ï€` in the sense that their actions on atoms and litters are consistent. The `exception_mem` condition states that for any atom `a`, if `Ï€` is an exception with respect to `a`, then `a` must be in the domain of `Ï€â‚€.atomPerm`."}
{"full_name": "ConNF.NearLitterApprox.Approximates", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Approximates", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterApprox.Approximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€â‚€ : ConNF.NearLitterApprox) (Ï€ : ConNF.NearLitterPerm) :Prop\n | map_atom : âˆ€ a âˆˆ Ï€â‚€.atomPerm.domain, Ï€â‚€ â€¢  a =  Ï€ â€¢  a\n | map_litter : âˆ€ L âˆˆ Ï€â‚€.litterPerm.domain, Ï€â‚€ â€¢  L =  Ï€ â€¢  L", "code": "structure Approximates (Ï€â‚€ : NearLitterApprox) (Ï€ : NearLitterPerm) : Prop where\n  map_atom : âˆ€ a, a âˆˆ Ï€â‚€.atomPerm.domain â†’ Ï€â‚€ â€¢ a = Ï€ â€¢ a\n  map_litter : âˆ€ L, L âˆˆ Ï€â‚€.litterPerm.domain â†’ Ï€â‚€ â€¢ L = Ï€ â€¢ L\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [156, 159], "informalization": "Structure `Approximates` in the context of Constructive Ordinal Notation (ConNF) defines a relationship between two objects of type `ConNF.NearLitterApprox` and `ConNF.NearLitterPerm`. It consists of two conditions: `map_atom` and `map_litter`. The `map_atom` condition states that for any atom `a` in the domain of `Ï€â‚€.atomPerm`, the action of `Ï€â‚€` on `a` is the same as the action of `Ï€` on `a`. Similarly, the `map_litter` condition states that for any litter `L` in the domain of `Ï€â‚€.litterPerm`, the action of `Ï€â‚€` on `L` is the same as the action of `Ï€` on `L`. These conditions ensure that `Ï€â‚€` approximates `Ï€` in the sense that their actions on atoms and litters are consistent."}
{"full_name": "ConNF.NearLitterAction.smul_toNearLitter_eq_of_preciseAt", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.smul_toNearLitter_eq_of_preciseAt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.smul_toNearLitter_eq_of_preciseAt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†} {Ï€ : ConNF.NearLitterPerm} (hÏ€ : ConNF.NearLitterApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.completeğŸ”—<|PREMISE|>ğŸ”— Ï† hÏ† A) Ï€) {L : ConNF.Litter} (hL : (Ï†.litterMap L).Dom) (hÏ†L : ConNF.NearLitterAction.PreciseAtğŸ”—<|PREMISE|>ğŸ”— Ï† hL) (hÏ€L : Ï€ â€¢ L = ((Ï†.litterMap L).get hL).fst) :Ï€ â€¢ ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L = (Ï†.litterMap L).get hL", "code": "theorem smul_toNearLitter_eq_of_preciseAt {hÏ† : Ï†.Lawful} {Ï€ : NearLitterPerm}\n    (hÏ€ : (Ï†.complete hÏ† A).ExactlyApproximates Ï€) {L : Litter} (hL : (Ï†.litterMap L).Dom)\n    (hÏ†L : Ï†.PreciseAt hL) (hÏ€L : Ï€ â€¢ L = ((Ï†.litterMap L).get hL).1) :\n    Ï€ â€¢ L.toNearLitter = (Ï†.litterMap L).get hL := by\n  refine' SetLike.coe_injective _\n  ext a : 1\n  simp only [mem_smul_set_iff_inv_smul_mem, NearLitterPerm.smul_nearLitter_coe, Litter.coe_toNearLitter,\n    mem_litterSet, SetLike.mem_coe]\n  constructor\n  Â· intro ha\n    by_cases h : Ï€.IsException a\n    Â· suffices h' : Ï€â»Â¹ â€¢ a âˆˆ Ï†.atomMap.Dom\n      Â· rw [hÏ†.atom_mem _ h' L hL] at ha\n        have := hÏ€.map_atom _ (Or.inl (Or.inl h'))\n        rw [Ï†.complete_smul_atom_eq h'] at this\n        rw [this, smul_inv_smul] at ha\n        exact ha\n      rw [â† hÏ€.symm_map_atom a (hÏ€.exception_mem _ h)] at ha âŠ¢\n      obtain (hdom | hdom) | hdom :=\n        (Ï†.complete hÏ† A).atomPerm.symm.map_domain (hÏ€.exception_mem _ h)\n      Â· exact hdom\n      Â· obtain âŸ¨c, hcâ‚, hcâ‚‚âŸ© := hdom\n        rw [Ï†.atomMapOrElse_of_dom hcâ‚] at hcâ‚‚\n        have := hÏ†L.fwd c hcâ‚ (by rwa [hcâ‚‚])\n        rw [hcâ‚‚] at this\n        exact this\n      Â· exfalso\n        refine Ï†.sandboxLitter_not_banned ?_\n        rw [â† eq_of_mem_litterSet_of_mem_litterSet ha (PartialPerm.sandboxSubset_subset _ _ hdom)]\n        exact BannedLitter.litterDom L hL\n    Â· by_contra h'\n      simp only [NearLitterPerm.IsException, mem_litterSet, not_or, Classical.not_not, ha] at h\n      obtain âŸ¨b, hb, rflâŸ© :=\n        hÏ†L.diff (Or.inr âŸ¨by rw [â† hÏ€L, h.2, smul_inv_smul, mem_litterSet], h'âŸ©)\n      refine' h' ((hÏ†.atom_mem b hb L hL).mp _)\n      have := hÏ€.map_atom b (Or.inl (Or.inl hb))\n      rw [Ï†.complete_smul_atom_eq hb] at this\n      rw [this, inv_smul_smul] at ha\n      exact ha\n  Â· intro ha\n    by_cases h : Ï€â»Â¹ â€¢ a âˆˆ Ï†.atomMap.Dom\n    Â· rw [hÏ†.atom_mem _ h L hL]\n      have := hÏ€.map_atom _ (Or.inl (Or.inl h))\n      rw [Ï†.complete_smul_atom_eq h] at this\n      rw [this, smul_inv_smul]\n      exact ha\n    have haL : a âˆˆ litterSet ((Ï†.litterMap L).get hL).fst\n    Â· by_contra h'\n      obtain âŸ¨b, hb, rflâŸ© := hÏ†L.diff (Or.inl âŸ¨ha, h'âŸ©)\n      have := hÏ€.map_atom b (Or.inl (Or.inl hb))\n      rw [Ï†.complete_smul_atom_eq hb] at this\n      rw [this, inv_smul_smul] at h\n      exact h hb\n    by_contra h'\n    have hex : Ï€.IsException a\n    Â· refine' Or.inr fun h'' => h' (h''.trans _)\n      rw [inv_smul_eq_iff, hÏ€L]\n      exact haL\n    obtain (hdom | âŸ¨b, hbâ‚, hbâ‚‚âŸ©) | hdom := hÏ€.exception_mem a hex\n    Â· obtain âŸ¨b, hbâ‚, hbâ‚‚âŸ© := hÏ†L.back âŸ¨hdom, haâŸ©\n      have := hÏ€.map_atom b (Or.inl (Or.inl hbâ‚))\n      rw [Ï†.complete_smul_atom_eq hbâ‚] at this\n      rw [this, smul_eq_iff_eq_inv_smul] at hbâ‚‚\n      rw [hbâ‚‚] at hbâ‚\n      exact h hbâ‚\n    Â· rw [Ï†.atomMapOrElse_of_dom hbâ‚] at hbâ‚‚\n      have := hÏ€.map_atom b (Or.inl (Or.inl hbâ‚))\n      rw [Ï†.complete_smul_atom_eq hbâ‚, hbâ‚‚, â† inv_smul_eq_iff] at this\n      rw [this] at h\n      exact h hbâ‚\n    Â· refine' Ï†.sandboxLitter_not_banned _\n      rw [eq_of_mem_litterSet_of_mem_litterSet (PartialPerm.sandboxSubset_subset _ _ hdom) haL]\n      exact BannedLitter.litterMap L hL\n", "additional_info": "", "used_premises": [1, 61, 825, 1180, 1177, 1141, 483], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [106, 179], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a lawful near-litter action `Ï†`, a finite path `A` from a type `Î²` to the base type `âŠ¥`, and a near-litter approximation `Ï€` that exactly approximates `Ï†` along `A`, if `Ï†` is precise at a litter `L` in its domain, and `Ï€` acts on `L` in the same way as `Ï†` does, then `Ï€` acts on the near-litter corresponding to `L` in the same way as `Ï†` does."}
{"full_name": "ConNF.NearLitterAction.preimageLitter_not_banned", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitter_not_banned", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preimageLitter_not_banned [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :Â¬ ConNF.NearLitterAction.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Ï† (ConNF.NearLitterAction.preimageLitterğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem preimageLitter_not_banned : Â¬Ï†.BannedLitter Ï†.preimageLitter :=\n  Ï†.not_bannedLitter_nonempty.some.prop\n", "additional_info": "", "used_premises": [1, 1065, 1184], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [24, 26], "informalization": "The theorem `ConNF.NearLitterAction.preimageLitter_not_banned` states that for any `ConNF.NearLitterAction` object `Ï†`, the `ConNF.NearLitterAction.preimageLitter` of `Ï†` is not a `ConNF.NearLitterAction.BannedLitter`. This means that the litter returned by the `preimageLitter` method is not a litter that is not allowed to be used as a sandbox because it appears somewhere that we need to preserve."}
{"full_name": "ConNF.NearLitterAction.preimageLitter", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitter", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.preimageLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.Litter", "code": "noncomputable def preimageLitter : Litter :=\n  Ï†.not_bannedLitter_nonempty.some\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.preimageLitterğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  â†‘(ğŸ—ŸNonempty.someğŸ—ŸğŸ”—../../.././Mathlib/Logic/Nonempty.html#Nonempty.someğŸ”—  â‹¯)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [21, 23], "informalization": "Function `ConNF.NearLitterAction.preimageLitter` is a method that takes a `ConNF.NearLitterAction` object `Ï†` and returns a `ConNF.Litter` object. The `ConNF.Litter` object represents a \"litter\" in the context of Constructive Ordinal Notation (ConNF), which is a set of ordinals that are related to each other in a specific way. The `ConNF.NearLitterAction` object `Ï†` encodes a relationship between two litters, and the `preimageLitter` method returns one of the litters involved in this relationship."}
{"full_name": "ConNF.NearLitterAction.withoutPreimage_iff", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.withoutPreimage_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.withoutPreimage_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (a : ConNF.Atom) :ConNF.NearLitterAction.WithoutPreimageğŸ”—<|PREMISE|>ğŸ”— Ï† a â†” (âˆƒ (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom), a âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— ((Ï†.litterMap L).get hL).fst) âˆ§ (âˆ€ (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom), a âˆ‰ (Ï†.litterMap L).get hL) âˆ§ a âˆ‰ PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1186, 467, 824], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [31, 32], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an atom is called \"without preimage\" if it is not in the range of the approximation, but it is in a litter near some near-litter in the range. Atoms without preimage need to have something map to it, so that the resulting map that we use in the freedom of action theorem actually maps to the correct near-litter. The theorem `ConNF.NearLitterAction.withoutPreimage_iff` states that an atom is without preimage if and only if there exists a litter `L` such that the first projection of `a` is equal to `L`, and `a` is not in the range of the atom map."}
{"full_name": "ConNF.NearLitterAction.WithoutPreimage", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.WithoutPreimage", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.WithoutPreimage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (a : ConNF.Atom) :Prop\n | mem_map : âˆƒ (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom), a âˆˆ  ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”—  ((Ï†.litterMap L).get hL).fst\n | not_mem_map : âˆ€ (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom), a âˆ‰ (Ï†.litterMap L).get hL\n | not_mem_ran : a âˆ‰ PFun.ranğŸ”—<|PREMISE|>ğŸ”—  Ï†.atomMap", "code": "structure WithoutPreimage (a : Atom) : Prop where\n  mem_map : âˆƒ (L : Litter) (hL : (Ï†.litterMap L).Dom), a âˆˆ litterSet ((Ï†.litterMap L).get hL).1\n  not_mem_map : âˆ€ (L : Litter) (hL : (Ï†.litterMap L).Dom), a âˆ‰ (Ï†.litterMap L).get hL\n  not_mem_ran : a âˆ‰ Ï†.atomMap.ran\n", "additional_info": "An atom is called *without preimage* if it is not in the range of the approximation,\nbut it is in a litter near some near-litter in the range.\nAtoms without preimage need to have something map to it, so that the resulting map that we use in\nthe freedom of action theorem actually maps to the correct near-litter.\n", "used_premises": [1, 467, 824], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [32, 36], "informalization": "An atom is called \"without preimage\" if it is not in the range of the approximation, but it is in a litter near some near-litter in the range. Atoms without preimage need to have something map to it, so that the resulting map that we use in the freedom of action theorem actually maps to the correct near-litter."}
{"full_name": "ConNF.NearLitterAction.withoutPreimage_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.withoutPreimage_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.withoutPreimage_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {a : ConNF.Atom | ConNF.NearLitterAction.WithoutPreimageğŸ”—<|PREMISE|>ğŸ”— Ï† a}", "code": "theorem withoutPreimage_small : Small {a | Ï†.WithoutPreimage a} := by\n  simp only [withoutPreimage_iff, setOf_and]\n  rw [â† inter_assoc]\n  refine' Small.mono (inter_subset_left _ _) _\n  suffices\n    Small (â‹ƒ (L : Litter) (hL), litterSet ((Ï†.litterMap L).get hL).1 \\ (Ï†.litterMap L).get hL) by\n    refine' Small.mono _ this\n    rintro a âŸ¨âŸ¨L, hL, haâ‚âŸ©, haâ‚‚âŸ©\n    simp only [mem_iUnion]\n    exact âŸ¨L, hL, haâ‚, haâ‚‚ _ _âŸ©\n  refine' Small.bUnion _ _\n  Â· refine' lt_of_le_of_lt _ Ï†.litterMap_dom_small\n    refine' âŸ¨âŸ¨fun L => âŸ¨_, L.propâŸ©, _âŸ©âŸ©\n    intro Lâ‚ Lâ‚‚ h\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff, eq_self_iff_true, and_true_iff,\n      Litter.toNearLitter_injective.eq_iff, Subtype.coe_inj] at h\n    exact h\n  Â· intro L hL\n    refine' Small.mono _ ((Ï†.litterMap L).get hL).2.prop\n    exact fun x hx => Or.inl hx\n", "additional_info": "", "used_premises": [1, 233, 1186], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [37, 57], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.withoutPreimage_small` states that the set of \"without preimage\" atoms, which are atoms that are not in the range of the approximation but are in a litter near some near-litter in the range, has a cardinality that is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.preimageLitterSubset_spec", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preimageLitterSubset_spec [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.NearLitterAction.preimageLitterSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† âŠ† ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.preimageLitterğŸ”—<|PREMISE|>ğŸ”— Ï†) âˆ§ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.NearLitterAction.preimageLitterSubsetğŸ”—<|PREMISE|>ğŸ”— Ï†) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{a : ConNF.Atom | ConNF.NearLitterAction.WithoutPreimageğŸ”—<|PREMISE|>ğŸ”— Ï† a}", "code": "theorem preimageLitterSubset_spec :\n    Ï†.preimageLitterSubset âŠ† litterSet Ï†.preimageLitter âˆ§\n      (#Ï†.preimageLitterSubset) = (#{a : Atom | Ï†.WithoutPreimage a}) :=\n  (le_mk_iff_exists_subset.mp\n      (lt_of_lt_of_eq Ï†.withoutPreimage_small (mk_litterSet Ï†.preimageLitter).symm).le).choose_spec\n", "additional_info": "", "used_premises": [1, 1189, 467, 1184, 29, 1189, 29, 1186], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [64, 69], "informalization": "Function `ConNF.NearLitterAction.preimageLitterSubset` is a subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation. The theorem `ConNF.NearLitterAction.preimageLitterSubset_spec` states that this subset is a subset of the litter set corresponding to the preimage litter and has the same cardinality as the set of atoms without preimage."}
{"full_name": "ConNF.NearLitterAction.preimageLitterSubset", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.preimageLitterSubset [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def preimageLitterSubset : Set Atom :=\n  (le_mk_iff_exists_subset.mp\n      (lt_of_lt_of_eq Ï†.withoutPreimage_small (mk_litterSet Ï†.preimageLitter).symm).le).choose\n", "additional_info": "The subset of the preimage litter that is put in correspondence with the set of\natoms without preimage.\nEquations\n* ğŸ—ŸConNF.NearLitterAction.preimageLitterSubsetğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubsetğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸExists.chooseğŸ—ŸğŸ”—../../.././Init/Classical.html#Exists.chooseğŸ”—  â‹¯\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [60, 63], "informalization": "Function `ConNF.NearLitterAction.preimageLitterSubset` is a subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.NearLitterAction.preimageLitterSubset_subset", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preimageLitterSubset_subset [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.NearLitterAction.preimageLitterSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† âŠ† ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.preimageLitterğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem preimageLitterSubset_subset : Ï†.preimageLitterSubset âŠ† litterSet Ï†.preimageLitter :=\n  Ï†.preimageLitterSubset_spec.1\n", "additional_info": "", "used_premises": [1, 1189, 467, 1184], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [70, 72], "informalization": "Function `ConNF.NearLitterAction.preimageLitterSubset` is a subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation. The theorem `ConNF.NearLitterAction.preimageLitterSubset_subset` states that this subset is a subset of the litter set corresponding to the preimage litter."}
{"full_name": "ConNF.NearLitterAction.preimageLitterSubset_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preimageLitterSubset_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.preimageLitterSubsetğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem preimageLitterSubset_small : Small Ï†.preimageLitterSubset :=\n  lt_of_eq_of_lt Ï†.preimageLitterSubset_spec.2 Ï†.withoutPreimage_small\n", "additional_info": "", "used_premises": [1, 233, 1189], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [73, 75], "informalization": "Function `ConNF.NearLitterAction.preimageLitterSubset_small` proves that the subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation has a cardinality strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.mappedOutside_iff", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutside_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutside_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) (a : ConNF.Atom) :ConNF.NearLitterAction.MappedOutsideğŸ”—<|PREMISE|>ğŸ”— Ï† L hL a â†” a âˆˆ (Ï†.litterMap L).get hL âˆ§ a âˆ‰ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— ((Ï†.litterMap L).get hL).fst âˆ§ a âˆ‰ PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1193, 467, 824], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [82, 83], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutside_iff` provides a criterion for determining whether an atom is \"mapped outside\" a litter in the context of Constructive Ordinal Notation (ConNF). Specifically, it states that an atom `a` is mapped outside a litter `L` if and only if `a` is an image of an atom in `L` under the partial function `Ï†.litterMap L`, but `a` is not in the domain of `Ï†.litterMap L`, and `a` is not in the range of `Ï†.atomMap`. This condition is crucial to ensure the correctness of the ConNF construction."}
{"full_name": "ConNF.NearLitterAction.MappedOutside", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.MappedOutside", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.MappedOutside [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) (a : ConNF.Atom) :Prop\n | mem_map : a âˆˆ  (Ï†.litterMap L).get hL\n | not_mem_map : a âˆ‰ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”—  ((Ï†.litterMap L).get hL).fst\n | not_mem_ran : a âˆ‰ PFun.ranğŸ”—<|PREMISE|>ğŸ”—  Ï†.atomMap", "code": "structure MappedOutside (L : Litter) (hL : (Ï†.litterMap L).Dom) (a : Atom) : Prop where\n  mem_map : a âˆˆ (Ï†.litterMap L).get hL\n  not_mem_map : a âˆ‰ litterSet ((Ï†.litterMap L).get hL).1\n  not_mem_ran : a âˆ‰ Ï†.atomMap.ran\n", "additional_info": "The images of atoms in a litter `L` that were mapped outside the target litter, but\nwere not in the domain.\n", "used_premises": [1, 467, 824], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [83, 87], "informalization": "The structure `ConNF.NearLitterAction.MappedOutside` defines a condition for an atom `a` in the context of Constructive Ordinal Notation (ConNF). This condition is satisfied when `a` is an image of an atom in a litter `L` under a partial function `Ï†.litterMap L`, but `a` is not in the domain of `Ï†.litterMap L`, and `a` is not in the range of `Ï†.atomMap`. This condition is crucial for ensuring the correctness of the construction of ordinals in ConNF."}
{"full_name": "ConNF.NearLitterAction.mappedOutside_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutside_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutside_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {a : ConNF.Atom | ConNF.NearLitterAction.MappedOutsideğŸ”—<|PREMISE|>ğŸ”— Ï† L hL a}", "code": "theorem mappedOutside_small (L : Litter) (hL : (Ï†.litterMap L).Dom) :\n    Small {a | Ï†.MappedOutside L hL a} := by\n  simp only [mappedOutside_iff, setOf_and]\n  rw [â† inter_assoc]\n  refine' Small.mono (inter_subset_left _ _) _\n  refine' Small.mono _ ((Ï†.litterMap L).get hL).2.prop\n  exact fun x hx => Or.inr hx\n", "additional_info": "There are only `< Îº`-many atoms in a litter `L` that are mapped outside the image litter,\nand that are not already in the domain.", "used_premises": [1, 233, 1193], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [90, 97], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutside_small` states that in the context of Constructive Ordinal Notation (ConNF), there are only `< Îº`-many atoms in a litter `L` that are mapped outside the image litter, and that are not already in the domain. This result is crucial for ensuring the correctness of the construction of ordinals in ConNF."}
{"full_name": "ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) {a : ConNF.Atom} (ha : ConNF.NearLitterAction.WithoutPreimageğŸ”—<|PREMISE|>ğŸ”— Ï† a) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :Â¬ ConNF.NearLitterAction.MappedOutsideğŸ”—<|PREMISE|>ğŸ”— Ï† L hL a", "code": "theorem WithoutPreimage.not_mappedOutside {a : Atom} (ha : Ï†.WithoutPreimage a) (L : Litter)\n    (hL : (Ï†.litterMap L).Dom) : Â¬Ï†.MappedOutside L hL a := fun ha' =>\n  ha.not_mem_map L hL ha'.mem_map\n", "additional_info": "", "used_premises": [1, 1186, 1193], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [98, 101], "informalization": "The theorem `ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside` states that if an atom `a` is \"without preimage\" under a partial function `Ï†.litterMap L`, then `a` is not an image of any atom in the litter `L` under `Ï†.litterMap L`. This is a key property used in the ConNF (Constructive Ordinal Notation) project to ensure the correctness of the construction of ordinals."}
{"full_name": "ConNF.NearLitterAction.MappedOutside.not_withoutPreimage", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.MappedOutside.not_withoutPreimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.MappedOutside.not_withoutPreimage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} {hL : (Ï†.litterMap L).Dom} (ha : ConNF.NearLitterAction.MappedOutsideğŸ”—<|PREMISE|>ğŸ”— Ï† L hL a) :Â¬ ConNF.NearLitterAction.WithoutPreimageğŸ”—<|PREMISE|>ğŸ”— Ï† a", "code": "theorem MappedOutside.not_withoutPreimage {a : Atom} {L : Litter} {hL : (Ï†.litterMap L).Dom}\n    (ha : Ï†.MappedOutside L hL a) : Â¬Ï†.WithoutPreimage a := fun ha' =>\n  ha'.not_mem_map L hL ha.mem_map\n", "additional_info": "", "used_premises": [1, 1193, 1186], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [102, 105], "informalization": "The theorem `ConNF.NearLitterAction.MappedOutside.not_withoutPreimage` in the context of Constructive Ordinal Notation (ConNF) states that if an atom `a` is an image of an atom in a litter `L` under a partial function `Ï†.litterMap L`, but `a` is not in the domain of `Ï†.litterMap L`, and `a` is not in the range of `Ï†.atomMap`, then `a` cannot be \"without preimage\". This means that `a` must have something that maps to it in order to satisfy the condition for the Freedom of Action theorem."}
{"full_name": "ConNF.NearLitterAction.mk_mapped_outside_domain", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mk_mapped_outside_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_mapped_outside_domain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L \\ PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem mk_mapped_outside_domain (L : Litter) :\n    (#(litterSet L \\ Ï†.atomMap.Dom : Set Atom)) = (#Îº) := by\n  refine' le_antisymm _ _\n  Â· rw [â† mk_litterSet]\n    exact mk_subtype_mono fun x hx => hx.1\n  by_contra h\n  have := Small.union (lt_of_not_le h) Ï†.atomMap_dom_small\n  rw [diff_union_self] at this\n  exact (mk_litterSet L).not_lt (Small.mono (subset_union_left _ _) this)\n", "additional_info": "The amount of atoms in a litter that are not in the domain already is `Îº`.", "used_premises": [1, 29, 467, 404, 29], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [107, 116], "informalization": "The theorem `ConNF.NearLitterAction.mk_mapped_outside_domain` states that the cardinality of the set of atoms in a litter `L` that are not in the domain of the partial function `Ï†.atomMap` is equal to the cardinality of the type `Îº`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset_spec", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutsideSubset_spec [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† L hL âŠ† ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L \\ PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆ§ Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.NearLitterAction.mappedOutsideSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† L hL) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{a : ConNF.Atom | ConNF.NearLitterAction.MappedOutsideğŸ”—<|PREMISE|>ğŸ”— Ï† L hL a}", "code": "theorem mappedOutsideSubset_spec (L : Litter) (hL : (Ï†.litterMap L).Dom) :\n    Ï†.mappedOutsideSubset L hL âŠ† litterSet L \\ Ï†.atomMap.Dom âˆ§\n      #(Ï†.mappedOutsideSubset L hL) = #{a : Atom | Ï†.MappedOutside L hL a} :=\n  (le_mk_iff_exists_subset.mp\n      (lt_of_lt_of_eq (Ï†.mappedOutside_small L hL)\n          (Ï†.mk_mapped_outside_domain L).symm).le).choose_spec\n", "additional_info": "", "used_premises": [1, 1199, 467, 404, 29, 1199, 29, 1193], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [122, 128], "informalization": "Function `ConNF.NearLitterAction.mappedOutsideSubset` defines a subset of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `Ï†.litterMap L`. The theorem `ConNF.NearLitterAction.mappedOutsideSubset_spec` states that this subset is a subset of the litter set `ConNF.litterSet L` minus the domain of the atom map `Ï†.atomMap`, and that the cardinality of this subset is equal to the cardinality of the set of atoms that satisfy the condition `ConNF.NearLitterAction.MappedOutside`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.mappedOutsideSubset [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def mappedOutsideSubset (L : Litter) (hL : (Ï†.litterMap L).Dom) : Set Atom :=\n  (le_mk_iff_exists_subset.mp\n      (lt_of_lt_of_eq (Ï†.mappedOutside_small L hL) (Ï†.mk_mapped_outside_domain L).symm).le).choose\n", "additional_info": "To each litter we associate a subset which is to contain the atoms mapped outside it.\nEquations\n* ğŸ—ŸConNF.NearLitterAction.mappedOutsideSubsetğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubsetğŸ”—  Ï† L hL ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸExists.chooseğŸ—ŸğŸ”—../../.././Init/Classical.html#Exists.chooseğŸ”—  â‹¯\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [118, 121], "informalization": "Function `ConNF.NearLitterAction.mappedOutsideSubset` is used in the context of Constructive Ordinal Notation (ConNF) to define a subset of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `Ï†.litterMap L`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset_subset", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutsideSubset_subset [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† L hL âŠ† ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L", "code": "theorem mappedOutsideSubset_subset (L : Litter) (hL : (Ï†.litterMap L).Dom) :\n    Ï†.mappedOutsideSubset L hL âŠ† litterSet L := fun _ hx =>\n  ((Ï†.mappedOutsideSubset_spec L hL).1 hx).1\n", "additional_info": "", "used_premises": [1, 1199, 467], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [129, 132], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_subset` states that the subset of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `Ï†.litterMap L`, is a subset of the set corresponding to `L`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset_closure", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset_closure", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutsideSubset_closure [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† L hL âŠ† (PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap)á¶œ", "code": "theorem mappedOutsideSubset_closure (L : Litter) (hL : (Ï†.litterMap L).Dom) :\n    Ï†.mappedOutsideSubset L hL âŠ† Ï†.atomMap.Domá¶œ := fun _ hx =>\n  ((Ï†.mappedOutsideSubset_spec L hL).1 hx).2\n", "additional_info": "", "used_premises": [1, 1199, 404], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [133, 136], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_closure` states that the set of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `Ï†.litterMap L`, is a subset of the complement of the domain of the atom map `Ï†.atomMap`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutsideSubset_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.mappedOutsideSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† L hL)", "code": "theorem mappedOutsideSubset_small (L : Litter) (hL : (Ï†.litterMap L).Dom) :\n    Small (Ï†.mappedOutsideSubset L hL) :=\n  lt_of_eq_of_lt (Ï†.mappedOutsideSubset_spec L hL).2 (Ï†.mappedOutside_small L hL)\n", "additional_info": "", "used_premises": [1, 233, 1199], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [137, 140], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_small` states that the set of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `Ï†.litterMap L`, has a cardinality strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (a : ConNF.Atom) :(ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï† a).Dom â†” a âˆˆ PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆª ConNF.NearLitterAction.preimageLitterSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† âˆª â‹ƒ (L : ConNF.Litter), â‹ƒ (hL : (Ï†.litterMap L).Dom), ConNF.NearLitterAction.mappedOutsideSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† L hL", "code": "theorem mem_supportedActionAtomMapCore_dom_iff (a : Atom) :\n    (Ï†.supportedActionAtomMapCore a).Dom â†”\n      a âˆˆ Ï†.atomMap.Dom âˆª Ï†.preimageLitterSubset âˆª â‹ƒ (L) (hL), Ï†.mappedOutsideSubset L hL := by\n  rw [supportedActionAtomMapCore]\n  simp only [PFun.dom_mk, mem_setOf_eq, mem_union, mem_iUnion]\n  rw [or_assoc]\n  rfl\n", "additional_info": "", "used_premises": [1, 1204, 404, 1189, 1199], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [155, 162], "informalization": "The theorem `ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff` states that an atom `a` is in the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore Ï† a` if and only if `a` is in the union of three sets: the domain of the atom map `Ï†.atomMap`, the preimage litter subset `ConNF.NearLitterAction.preimageLitterSubset Ï†`, and the union of the mapped outside subsets `ConNF.NearLitterAction.mappedOutsideSubset Ï† L hL` for all litters `L` within the domain of the litter map `Ï†.litterMap L`."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.supportedActionAtomMapCore [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.Atom â†’. ConNF.Atom", "code": "noncomputable def supportedActionAtomMapCore : Atom â†’. Atom := fun a =>\n  { Dom := (Ï†.atomMap a).Dom âˆ¨ a âˆˆ Ï†.preimageLitterSubset âˆ¨ âˆƒ L hL, a âˆˆ Ï†.mappedOutsideSubset L hL\n    get := fun h =>\n      h.elim' (Ï†.atomMap a).get fun h =>\n        h.elim' (fun h => Ï†.preimageLitterEquiv âŸ¨a, hâŸ©) fun h =>\n          Ï†.mappedOutsideEquiv h.choose h.choose_spec.choose âŸ¨a, h.choose_spec.choose_specâŸ© }\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [148, 154], "informalization": "Function `ConNF.NearLitterAction.supportedActionAtomMapCore` defines a partial function from `ConNF.Atom` to `ConNF.Atom`, which is used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). This function is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Î›`, `Îº`, and `Î¼`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :PFun.DomğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï†) = PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âˆª ConNF.NearLitterAction.preimageLitterSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† âˆª â‹ƒ (L : ConNF.Litter), â‹ƒ (hL : (Ï†.litterMap L).Dom), ConNF.NearLitterAction.mappedOutsideSubsetğŸ”—<|PREMISE|>ğŸ”— Ï† L hL", "code": "theorem supportedActionAtomMapCore_dom_eq :\n    Ï†.supportedActionAtomMapCore.Dom =\n      Ï†.atomMap.Dom âˆª Ï†.preimageLitterSubset âˆª â‹ƒ (L) (hL), Ï†.mappedOutsideSubset L hL := by\n  ext a : 1\n  exact Ï†.mem_supportedActionAtomMapCore_dom_iff a\n", "additional_info": "", "used_premises": [1, 404, 1204, 404, 1189, 1199], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [163, 168], "informalization": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq` states that the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore` is equal to the union of three sets: the domain of the partial function `Ï†.atomMap`, the set `ConNF.NearLitterAction.preimageLitterSubset`, and the union of the sets `ConNF.NearLitterAction.mappedOutsideSubset` over all litters `L` in the domain of the litter map `Ï†.litterMap L`."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï†))", "code": "theorem supportedActionAtomMapCore_dom_small : Small Ï†.supportedActionAtomMapCore.Dom := by\n  rw [supportedActionAtomMapCore_dom_eq]\n  refine' Small.union (Small.union Ï†.atomMap_dom_small _) _\n  Â· exact Ï†.preimageLitterSubset_small\n  Â· refine' Small.bUnion _ _\n    Â· refine' lt_of_le_of_lt _ Ï†.litterMap_dom_small\n      refine' âŸ¨âŸ¨fun L => âŸ¨_, L.propâŸ©, fun Lâ‚ Lâ‚‚ h => _âŸ©âŸ©\n      simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff, eq_self_iff_true, and_true_iff,\n        Litter.toNearLitter_injective.eq_iff, Subtype.coe_inj] at h\n      exact h\n    Â· intro L hL\n      exact Ï†.mappedOutsideSubset_small L hL\n", "additional_info": "", "used_premises": [1, 233, 404, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [169, 181], "informalization": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small` states that the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore`, which is used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), is a small set in the sense that its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore_injective", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.supportedActionAtomMapCore_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) â¦ƒa : ConNF.Atomâ¦„ â¦ƒb : ConNF.Atomâ¦„ (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (ha : (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï† a).Dom) (hb : (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï† b).Dom) (hab : (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï† a).get ha = (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï† b).get hb) :a = b", "code": "theorem supportedActionAtomMapCore_injective â¦ƒa b : Atomâ¦„ (hÏ† : Ï†.Lawful)\n    (ha : (supportedActionAtomMapCore Ï† a).Dom) (hb : (supportedActionAtomMapCore Ï† b).Dom)\n    (hab : (Ï†.supportedActionAtomMapCore a).get ha = (Ï†.supportedActionAtomMapCore b).get hb) :\n    a = b := by\n  obtain ha | ha | âŸ¨L, hL, haâŸ© := ha <;> obtain hb | hb | âŸ¨L', hL', hbâŸ© := hb\n  Â· have := (supportedAction_eq_of_dom _ ha).symm.trans (hab.trans (supportedAction_eq_of_dom _ hb))\n    exact hÏ†.atomMap_injective ha hb this\n  Â· have := (supportedAction_eq_of_dom _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_preimageLitterSubset _ hb))\n    obtain âŸ¨hab, -âŸ© := Subtype.coe_eq_iff.mp this.symm\n    cases hab.not_mem_ran âŸ¨a, ha, rflâŸ©\n  Â· have := (supportedAction_eq_of_dom _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_mappedOutsideSubset _ hb))\n    obtain âŸ¨hab, -âŸ© := Subtype.coe_eq_iff.mp this.symm\n    cases hab.not_mem_ran âŸ¨a, ha, rflâŸ©\n  Â· have := (supportedAction_eq_of_mem_preimageLitterSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_dom _ hb))\n    obtain âŸ¨hab, -âŸ© := Subtype.coe_eq_iff.mp this\n    cases hab.not_mem_ran âŸ¨b, hb, rflâŸ©\n  Â· have := (supportedAction_eq_of_mem_preimageLitterSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_preimageLitterSubset _ hb))\n    rw [Subtype.coe_inj, EmbeddingLike.apply_eq_iff_eq] at this\n    exact Subtype.coe_inj.mpr this\n  Â· have := (supportedAction_eq_of_mem_preimageLitterSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_mappedOutsideSubset _ hb))\n    obtain âŸ¨hab, -âŸ© := Subtype.coe_eq_iff.mp this\n    cases WithoutPreimage.not_mappedOutside Ï† hab _ hL' (Ï†.mappedOutsideEquiv L' hL' âŸ¨b, hbâŸ©).prop\n  Â· have := (supportedAction_eq_of_mem_mappedOutsideSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_dom _ hb))\n    obtain âŸ¨hab, -âŸ© := Subtype.coe_eq_iff.mp this\n    cases hab.not_mem_ran âŸ¨b, hb, rflâŸ©\n  Â· have := (supportedAction_eq_of_mem_mappedOutsideSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_preimageLitterSubset _ hb))\n    obtain âŸ¨hab, -âŸ© := Subtype.coe_eq_iff.mp this.symm\n    cases WithoutPreimage.not_mappedOutside Ï† hab _ hL (Ï†.mappedOutsideEquiv L hL âŸ¨a, haâŸ©).prop\n  Â· have := (supportedAction_eq_of_mem_mappedOutsideSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_mappedOutsideSubset _ hb))\n    have := hÏ†.litterMap_injective hL hL' ?_\n    Â· cases this\n      simp only [mem_setOf_eq, coe_setOf, Subtype.coe_inj, EmbeddingLike.apply_eq_iff_eq,\n        Subtype.mk.injEq] at this\n      exact this\n    Â· obtain âŸ¨hab, -âŸ© := Subtype.coe_eq_iff.mp this\n      exact âŸ¨_, hab.1, (Ï†.mappedOutsideEquiv L' hL' âŸ¨b, hbâŸ©).prop.1âŸ©\n", "additional_info": "", "used_premises": [1, 825, 1204, 1204, 1204, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [232, 276], "informalization": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_injective` states that the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore` is injective. This function is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Î›`, `Îº`, and `Î¼`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore_mem", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.supportedActionAtomMapCore_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (a : ConNF.Atom) (ha : (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï† a).Dom) (L : ConNF.Litter) (hL : (Ï†.litterMap L).Dom) :a.1 = L â†” (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï† a).get ha âˆˆ (Ï†.litterMap L).get hL", "code": "theorem supportedActionAtomMapCore_mem (hÏ† : Ï†.Lawful) (a : Atom)\n    (ha : (Ï†.supportedActionAtomMapCore a).Dom) (L : Litter) (hL : (Ï†.litterMap L).Dom) :\n    a.fst = L â†” (Ï†.supportedActionAtomMapCore a).get ha âˆˆ (Ï†.litterMap L).get hL := by\n  obtain ha | ha | âŸ¨L', hL', haâŸ© := ha\n  Â· rw [hÏ†.atom_mem a ha L hL, supportedAction_eq_of_dom]\n  Â· rw [supportedAction_eq_of_mem_preimageLitterSubset]\n    constructor\n    Â· rintro rfl\n      have := Ï†.preimageLitterSubset_subset ha\n      rw [mem_litterSet] at this\n      rw [this] at hL\n      have := BannedLitter.litterDom _ hL\n      cases Ï†.preimageLitter_not_banned this\n    Â· intro h\n      cases (Ï†.preimageLitterEquiv âŸ¨a, haâŸ©).prop.not_mem_map L hL h\n  Â· cases Ï†.mappedOutsideSubset_subset L' hL' ha\n    rw [supportedAction_eq_of_mem_mappedOutsideSubset]\n    constructor\n    Â· rintro rfl\n      exact (Ï†.mappedOutsideEquiv _ _ âŸ¨a, haâŸ©).prop.mem_map\n    Â· intro h\n      refine' hÏ†.litterMap_injective hL' hL âŸ¨_, _, hâŸ©\n      exact (Ï†.mappedOutsideEquiv _ _ âŸ¨a, haâŸ©).prop.mem_map\n", "additional_info": "", "used_premises": [1, 825, 1204, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [277, 300], "informalization": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_mem` is a statement about the constructible ordinal notation (ConNF) in Lean 4. It describes a property of the function `ConNF.NearLitterAction.supportedActionAtomMapCore`, which is a partial function from `ConNF.Atom` to `ConNF.Atom`. The theorem states that, given a near litter action `Ï†` and an atom `a` with a certain property, if `a` is in the litter `L`, then the output of the `supportedActionAtomMapCore` function on `a` is in the near litter `Ï†.litterMap L`. This property is crucial for ensuring that the natural numbers constructed in ConNF are well-defined and follow the rules of the notation."}
{"full_name": "ConNF.NearLitterAction.fillAtomRangeLawful", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRangeLawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fillAtomRangeLawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.fillAtomRangeğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem fillAtomRangeLawful (hÏ† : Ï†.Lawful) : Ï†.fillAtomRange.Lawful\n    where\n  atomMap_injective := fun _ _ => Ï†.supportedActionAtomMapCore_injective hÏ†\n  litterMap_injective := hÏ†.litterMap_injective\n  atom_mem := Ï†.supportedActionAtomMapCore_mem hÏ†\n", "additional_info": "", "used_premises": [1, 825, 825, 1210], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [308, 313], "informalization": "`ConNF.NearLitterAction.fillAtomRange Ï†` returns a new `ConNF.NearLitterAction`, adjusted to have a small domain for the `atomMap`, and the resulting action is lawful. This theorem ensures that the adjusted action still satisfies the conditions for being lawful, meaning that the atom and litter maps are injective and the images of atoms in litters are mapped to atoms inside the corresponding near-litters."}
{"full_name": "ConNF.NearLitterAction.fillAtomRange", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.fillAtomRange [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï† : ConNF.NearLitterAction) :ConNF.NearLitterAction", "code": "noncomputable def fillAtomRange : NearLitterAction\n    where\n  atomMap := Ï†.supportedActionAtomMapCore\n  litterMap := Ï†.litterMap\n  atomMap_dom_small := Ï†.supportedActionAtomMapCore_dom_small\n  litterMap_dom_small := Ï†.litterMap_dom_small\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterAction.fillAtomRangeğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRangeğŸ”—  Ï† ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { atomMap := ğŸ—ŸConNF.NearLitterAction.supportedActionAtomMapCoreğŸ—ŸğŸ”—../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—  Ï†, litterMap := Ï†.litterMap, atomMap_dom_small := â‹¯,\n litterMap_dom_small := â‹¯ }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [301, 307], "informalization": "Function `ConNF.NearLitterAction.fillAtomRange` is a noncomputable function that takes a `ConNF.NearLitterAction` object `Ï†` and returns a new `ConNF.NearLitterAction` object. The returned object has the same `litterMap` as `Ï†`, but its `atomMap` is adjusted to ensure that the domain of `atomMap` is small. This adjustment is necessary because the domain of `atomMap` in `Ï†` might not be small, which is a requirement for `ConNF.NearLitterAction`."}
{"full_name": "ConNF.NearLitterAction.fillAtomRange_atomMap", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.fillAtomRange_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} :(ConNF.NearLitterAction.fillAtomRangeğŸ”—<|PREMISE|>ğŸ”— Ï†).atomMap = ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï†", "code": "theorem fillAtomRange_atomMap : Ï†.fillAtomRange.atomMap = Ï†.supportedActionAtomMapCore :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1210, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [317, 319], "informalization": "The `ConNF.NearLitterAction.fillAtomRange_atomMap` theorem states that the `atomMap` of the `ConNF.NearLitterAction` object returned by the `ConNF.NearLitterAction.fillAtomRange` function is equal to the `ConNF.NearLitterAction.supportedActionAtomMapCore` function."}
{"full_name": "ConNF.NearLitterAction.fillAtomRange_litterMap", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.fillAtomRange_litterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} :(ConNF.NearLitterAction.fillAtomRangeğŸ”—<|PREMISE|>ğŸ”— Ï†).litterMap = Ï†.litterMap", "code": "theorem fillAtomRange_litterMap : Ï†.fillAtomRange.litterMap = Ï†.litterMap :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1210], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [321, 323], "informalization": "Function `ConNF.NearLitterAction.fillAtomRange` is a noncomputable function that takes a `ConNF.NearLitterAction` object `Ï†` and returns a new `ConNF.NearLitterAction` object. The returned object has the same `litterMap` as `Ï†`, but its `atomMap` is adjusted to ensure that the domain of `atomMap` is small. This adjustment is necessary because the domain of `atomMap` in `Ï†` might not be small, which is a requirement for `ConNF.NearLitterAction`. The theorem `ConNF.NearLitterAction.fillAtomRange_litterMap` states that the `litterMap` of the returned object is equal to the `litterMap` of the original object `Ï†`."}
{"full_name": "ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} :PFun.DomğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âŠ† PFun.DomğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem subset_supportedActionAtomMapCore_dom :\n    Ï†.atomMap.Dom âŠ† Ï†.supportedActionAtomMapCore.Dom :=\n  subset_union_left _ _\n", "additional_info": "", "used_premises": [1, 404, 404, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [324, 327], "informalization": "The theorem `ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom` states that the domain of the partial function `Ï†.atomMap` is a subset of the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore Ï†`. This theorem is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Î›`, `Îº`, and `Î¼`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} :PFun.ranğŸ”—<|PREMISE|>ğŸ”— Ï†.atomMap âŠ† PFun.ranğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.supportedActionAtomMapCoreğŸ”—<|PREMISE|>ğŸ”— Ï†)", "code": "theorem subset_supportedActionAtomMapCore_ran :\n    Ï†.atomMap.ran âŠ† Ï†.supportedActionAtomMapCore.ran := by\n  rintro _ âŸ¨a, ha, rflâŸ©\n  exact âŸ¨a, subset_supportedActionAtomMapCore_dom ha, Ï†.supportedAction_eq_of_dom _âŸ©\n", "additional_info": "", "used_premises": [1, 824, 824, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [328, 332], "informalization": "The theorem `ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran` states that the range of the partial function `Ï†.atomMap` is a subset of the range of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore Ï†`. This theorem is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Î›`, `Îº`, and `Î¼`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï† : ConNF.NearLitterAction} (hÏ† : ConNF.NearLitterAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (L : ConNF.Litter) (hL : ((ConNF.NearLitterAction.fillAtomRangeğŸ”—<|PREMISE|>ğŸ”— Ï†).litterMap L).Dom) :symmDiffğŸ”—<|PREMISE|>ğŸ”— (â†‘(((ConNF.NearLitterAction.fillAtomRangeğŸ”—<|PREMISE|>ğŸ”— Ï†).litterMap L).get hL)) (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (((ConNF.NearLitterAction.fillAtomRangeğŸ”—<|PREMISE|>ğŸ”— Ï†).litterMap L).get hL).fst) âŠ† PFun.ranğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterAction.fillAtomRangeğŸ”—<|PREMISE|>ğŸ”— Ï†).atomMap", "code": "theorem fillAtomRange_symmDiff_subset_ran (hÏ† : Ï†.Lawful) (L : Litter)\n    (hL : (Ï†.fillAtomRange.litterMap L).Dom) :\n    ((Ï†.fillAtomRange.litterMap L).get hL : Set Atom) âˆ†\n        litterSet ((Ï†.fillAtomRange.litterMap L).get hL).fst âŠ†\n      Ï†.fillAtomRange.atomMap.ran := by\n  intro a\n  by_cases haâ‚ : a âˆˆ Ï†.atomMap.ran\n  Â· obtain âŸ¨b, hb, rflâŸ© := haâ‚\n    exact fun _ => âŸ¨b, Or.inl hb, Ï†.supportedAction_eq_of_dom hbâŸ©\n  rintro (âŸ¨haâ‚‚, haâ‚ƒâŸ© | âŸ¨haâ‚‚, haâ‚ƒâŸ©)\n  Â· refine' âŸ¨(Ï†.mappedOutsideEquiv L hL).symm âŸ¨a, haâ‚‚, haâ‚ƒ, haâ‚âŸ©, _, _âŸ©\n    Â· exact Or.inr (Or.inr âŸ¨L, hL, ((Ï†.mappedOutsideEquiv L hL).symm _).propâŸ©)\n    Â· simp only [fillAtomRange_atomMap]\n      refine' (Ï†.supportedAction_eq_of_mem_mappedOutsideSubset\n        ((Ï†.mappedOutsideEquiv L hL).symm _).prop).trans _\n      simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk]\n  Â· by_cases haâ‚„ : âˆ€ (L' : Litter) (hL' : (Ï†.litterMap L').Dom), a âˆ‰ (Ï†.litterMap L').get hL'\n    Â· refine' âŸ¨Ï†.preimageLitterEquiv.symm âŸ¨a, âŸ¨L, hL, haâ‚‚âŸ©, haâ‚„, haâ‚âŸ©, _, _âŸ©\n      Â· exact Or.inr (Or.inl (Ï†.preimageLitterEquiv.symm _).prop)\n      Â· simp only [fillAtomRange_atomMap]\n        refine' (Ï†.supportedAction_eq_of_mem_preimageLitterSubset\n          (Ï†.preimageLitterEquiv.symm _).prop).trans _\n        simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk]\n    Â· push_neg at haâ‚„\n      obtain âŸ¨L', hL', haâ‚„âŸ© := haâ‚„\n      refine' âŸ¨(Ï†.mappedOutsideEquiv L' hL').symm âŸ¨a, haâ‚„, _, haâ‚âŸ©, _, _âŸ©\n      Â· intro ha\n        have := NearLitter.inter_nonempty_of_fst_eq_fst\n          (eq_of_mem_litterSet_of_mem_litterSet haâ‚‚ ha)\n        cases hÏ†.litterMap_injective hL hL' this\n        exact haâ‚ƒ haâ‚„\n      Â· exact Or.inr (Or.inr âŸ¨L', hL', ((Ï†.mappedOutsideEquiv L' hL').symm _).propâŸ©)\n      Â· simp only [fillAtomRange_atomMap]\n        refine' (Ï†.supportedAction_eq_of_mem_mappedOutsideSubset\n          ((Ï†.mappedOutsideEquiv L' hL').symm _).prop).trans _\n        simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk]\n", "additional_info": "", "used_premises": [1, 825, 1210, 62, 1210, 467, 1210, 824, 1210], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [333, 369], "informalization": "The theorem `ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that for a lawful near litter action `Ï†`, the symmetric difference between the set of atoms in a litter `L` and the litter set corresponding to `L` is a subset of the range of the atom map of the filled atom range of `Ï†`."}
{"full_name": "ConNF.NearLitterApprox.ext", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ext :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } (x y : ConNF.NearLitterApprox), x.atomPerm = y.atomPerm â†’ x.litterPerm = y.litterPerm â†’ x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [18, 19], "informalization": "The `ConNF.NearLitterApprox.ext` theorem states that two `ConNF.NearLitterApprox` objects are equal if their `atomPerm` and `litterPerm` fields are equal."}
{"full_name": "ConNF.NearLitterApprox.ext_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ext_iff :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } (x y : ConNF.NearLitterApprox), x = y â†” x.atomPerm = y.atomPerm âˆ§ x.litterPerm = y.litterPerm", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [18, 19], "informalization": "The `ConNF.NearLitterApprox.ext_iff` theorem states that two `ConNF.NearLitterApprox` objects are equal if and only if their `atomPerm` and `litterPerm` fields are equal."}
{"full_name": "ConNF.NearLitterApprox.smul_atom_eq", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.smul_atom_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {a : ConNF.Atom} :Ï€.atomPerm.toFun a = Ï€ â€¢ a", "code": "theorem smul_atom_eq {a : Atom} : Ï€.atomPerm a = Ï€ â€¢ a :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [34, 36], "informalization": "The theorem `ConNF.NearLitterApprox.smul_atom_eq` states that for any `ConNF.NearLitterApprox` object `Ï€` and any `ConNF.Atom` object `a`, the function `Ï€.atomPerm.toFun` applied to `a` is equal to the action of `Ï€` on `a`, denoted as `Ï€ â€¢ a`."}
{"full_name": "ConNF.NearLitterApprox.smul_litter_eq", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.smul_litter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.smul_litter_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {L : ConNF.Litter} :Ï€.litterPerm.toFun L = Ï€ â€¢ L", "code": "theorem smul_litter_eq {L : Litter} : Ï€.litterPerm L = Ï€ â€¢ L :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [37, 39], "informalization": "The theorem `ConNF.NearLitterApprox.smul_litter_eq` states that for any `ConNF.NearLitterApprox` object `Ï€` and a `ConNF.Litter` object `L`, the permutation action of `Ï€` on `L` (denoted as `Ï€.litterPerm.toFun L`) is equal to the scalar multiplication of `Ï€` with `L` (denoted as `Ï€ â€¢ L`)."}
{"full_name": "ConNF.NearLitterApprox.smul_eq_smul_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.smul_eq_smul_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.smul_eq_smul_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {aâ‚ : ConNF.Atom} {aâ‚‚ : ConNF.Atom} (hâ‚ : aâ‚ âˆˆ Ï€.atomPerm.domain) (hâ‚‚ : aâ‚‚ âˆˆ Ï€.atomPerm.domain) :Ï€ â€¢ aâ‚ = Ï€ â€¢ aâ‚‚ â†” aâ‚ = aâ‚‚", "code": "theorem smul_eq_smul_atom {aâ‚ aâ‚‚ : Atom} (hâ‚ : aâ‚ âˆˆ Ï€.atomPerm.domain)\n    (hâ‚‚ : aâ‚‚ âˆˆ Ï€.atomPerm.domain) : Ï€ â€¢ aâ‚ = Ï€ â€¢ aâ‚‚ â†” aâ‚ = aâ‚‚ := by\n  rw [mk_smul_atom, mk_smul_atom,\n    â† Ï€.atomPerm.eq_symm_apply hâ‚ (Ï€.atomPerm.map_domain hâ‚‚), PartialPerm.left_inv _ hâ‚‚]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [52, 56], "informalization": "The theorem `ConNF.NearLitterApprox.smul_eq_smul_atom` states that for any two atoms `aâ‚` and `aâ‚‚` in the domain of a near litter approximation `Ï€`, `Ï€ â€¢ aâ‚ = Ï€ â€¢ aâ‚‚` if and only if `aâ‚ = aâ‚‚`."}
{"full_name": "ConNF.NearLitterApprox.smul_eq_smul_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.smul_eq_smul_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.smul_eq_smul_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} (hâ‚ : Lâ‚ âˆˆ Ï€.litterPerm.domain) (hâ‚‚ : Lâ‚‚ âˆˆ Ï€.litterPerm.domain) :Ï€ â€¢ Lâ‚ = Ï€ â€¢ Lâ‚‚ â†” Lâ‚ = Lâ‚‚", "code": "theorem smul_eq_smul_litter {Lâ‚ Lâ‚‚ : Litter} (hâ‚ : Lâ‚ âˆˆ Ï€.litterPerm.domain)\n    (hâ‚‚ : Lâ‚‚ âˆˆ Ï€.litterPerm.domain) : Ï€ â€¢ Lâ‚ = Ï€ â€¢ Lâ‚‚ â†” Lâ‚ = Lâ‚‚ := by\n  rw [mk_smul_litter, mk_smul_litter,\n    â† Ï€.litterPerm.eq_symm_apply hâ‚ (Ï€.litterPerm.map_domain hâ‚‚), PartialPerm.left_inv _ hâ‚‚]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [57, 61], "informalization": "The theorem `ConNF.NearLitterApprox.smul_eq_smul_litter` states that for any two litters `Lâ‚` and `Lâ‚‚` in the domain of a near litter approximation `Ï€`, `Ï€ â€¢ Lâ‚ = Ï€ â€¢ Lâ‚‚` if and only if `Lâ‚ = Lâ‚‚`."}
{"full_name": "ConNF.NearLitterApprox.symm_atomPerm", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm_atomPerm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.symm_atomPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) :(ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).atomPerm = PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€.atomPerm", "code": "theorem symm_atomPerm : Ï€.symm.atomPerm = Ï€.atomPerm.symm :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1223, 644], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [68, 70], "informalization": "The theorem `ConNF.NearLitterApprox.symm_atomPerm` states that the `atomPerm` component of the symmetric of a `ConNF.NearLitterApprox` object `Ï€` is equal to the inverse of the `atomPerm` component of `Ï€`."}
{"full_name": "ConNF.NearLitterApprox.symm", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterApprox.symm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) :ConNF.NearLitterApprox", "code": "def symm : NearLitterApprox where\n  atomPerm := Ï€.atomPerm.symm\n  litterPerm := Ï€.litterPerm.symm\n  domain_small := Ï€.domain_small\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterApprox.symmğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symmğŸ”—  Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { atomPerm := ğŸ—ŸPartialPerm.symmğŸ—ŸğŸ”—../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symmğŸ”—  Ï€.atomPerm, litterPerm := ğŸ—ŸPartialPerm.symmğŸ—ŸğŸ”—../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symmğŸ”—  Ï€.litterPerm, domain_small := â‹¯ }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [62, 66], "informalization": "Function `ConNF.NearLitterApprox.symm` is a method that takes a `ConNF.NearLitterApprox` object `Ï€` and returns a new `ConNF.NearLitterApprox` object, where the `atomPerm` and `litterPerm` components of `Ï€` are replaced by their symmetric counterparts. The `domain_small` component remains unchanged."}
{"full_name": "ConNF.NearLitterApprox.symm_litterPerm", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm_litterPerm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.symm_litterPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) :(ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€).litterPerm = PartialPerm.symmğŸ”—<|PREMISE|>ğŸ”— Ï€.litterPerm", "code": "theorem symm_litterPerm : Ï€.symm.litterPerm = Ï€.litterPerm.symm :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1223, 644], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [72, 74], "informalization": "The theorem `ConNF.NearLitterApprox.symm_litterPerm` states that the `litterPerm` component of the symmetric of a `ConNF.NearLitterApprox` object `Ï€` is equal to the inverse of the `litterPerm` component of `Ï€`."}
{"full_name": "ConNF.NearLitterApprox.left_inv_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.left_inv_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.left_inv_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {a : ConNF.Atom} :a âˆˆ Ï€.atomPerm.domain â†’ ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â€¢ Ï€ â€¢ a = a", "code": "theorem left_inv_atom {a} : a âˆˆ Ï€.atomPerm.domain â†’ Ï€.symm â€¢ Ï€ â€¢ a = a :=\n  Ï€.atomPerm.left_inv\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [76, 78], "informalization": "The theorem `ConNF.NearLitterApprox.left_inv_atom` states that for any `ConNF.NearLitterApprox` object `Ï€`, if an `ConNF.Atom` `a` is in the domain of `Ï€.atomPerm`, then applying `ConNF.NearLitterApprox.symm Ï€` followed by `Ï€` to `a` results in `a` itself. This theorem is a part of the proof that `ConNF.NearLitterApprox` forms a group action on `ConNF.Atom`."}
{"full_name": "ConNF.NearLitterApprox.left_inv_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.left_inv_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.left_inv_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {L : ConNF.Litter} :L âˆˆ Ï€.litterPerm.domain â†’ ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â€¢ Ï€ â€¢ L = L", "code": "theorem left_inv_litter {L} : L âˆˆ Ï€.litterPerm.domain â†’ Ï€.symm â€¢ Ï€ â€¢ L = L :=\n  Ï€.litterPerm.left_inv\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [80, 82], "informalization": "The theorem `ConNF.NearLitterApprox.left_inv_litter` states that for any `ConNF.NearLitterApprox` object `Ï€` and a `ConNF.Litter` object `L`, if `L` is in the domain of the `litterPerm` component of `Ï€`, then applying `ConNF.NearLitterApprox.symm Ï€` followed by `Ï€` to `L` results in `L` itself."}
{"full_name": "ConNF.NearLitterApprox.right_inv_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.right_inv_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.right_inv_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {a : ConNF.Atom} :a âˆˆ Ï€.atomPerm.domain â†’ Ï€ â€¢ ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â€¢ a = a", "code": "theorem right_inv_atom {a} : a âˆˆ Ï€.atomPerm.domain â†’ Ï€ â€¢ Ï€.symm â€¢ a = a :=\n  Ï€.atomPerm.right_inv\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [84, 86], "informalization": "The theorem `ConNF.NearLitterApprox.right_inv_atom` states that for any `ConNF.NearLitterApprox` object `Ï€` and any `ConNF.Atom` `a` that is in the domain of `Ï€.atomPerm`, applying `Ï€` and then its symmetric counterpart `ConNF.NearLitterApprox.symm Ï€` to `a` results in `a` itself. This property is crucial for establishing that `ConNF.NearLitterApprox` objects form a group action on `ConNF.Atom`s."}
{"full_name": "ConNF.NearLitterApprox.right_inv_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.right_inv_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.right_inv_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {L : ConNF.Litter} :L âˆˆ Ï€.litterPerm.domain â†’ Ï€ â€¢ ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â€¢ L = L", "code": "theorem right_inv_litter {L} : L âˆˆ Ï€.litterPerm.domain â†’ Ï€ â€¢ Ï€.symm â€¢ L = L :=\n  Ï€.litterPerm.right_inv\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [88, 90], "informalization": "The theorem `ConNF.NearLitterApprox.right_inv_litter` states that for any `ConNF.NearLitterApprox` object `Ï€` and any `ConNF.Litter` object `L`, if `L` is in the domain of `Ï€.litterPerm`, then `Ï€ â€¢ ConNF.NearLitterApprox.symm Ï€ â€¢ L = L`. This means that applying `Ï€` and then its symmetric counterpart `ConNF.NearLitterApprox.symm Ï€` to `L` results in `L` itself."}
{"full_name": "ConNF.NearLitterApprox.symm_smul_atom_eq_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm_smul_atom_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.symm_smul_atom_eq_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {a : ConNF.Atom} {b : ConNF.Atom} :a âˆˆ Ï€.atomPerm.domain â†’ b âˆˆ Ï€.atomPerm.domain â†’ (ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â€¢ a = b â†” a = Ï€ â€¢ b)", "code": "theorem symm_smul_atom_eq_iff {a b} :\n    a âˆˆ Ï€.atomPerm.domain â†’ b âˆˆ Ï€.atomPerm.domain â†’ (Ï€.symm â€¢ a = b â†” a = Ï€ â€¢ b) :=\n  by\n  intro ha hb\n  constructor\n  Â· rintro rfl\n    exact (Ï€.right_inv_atom ha).symm\n  Â· rintro rfl\n    exact Ï€.left_inv_atom hb\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [91, 100], "informalization": "Given a `ConNF.NearLitterApprox` object `Ï€`, this theorem states that for any two `ConNF.Atom`s `a` and `b` in the domain of `Ï€.atomPerm`, `a = Ï€ â€¢ b` if and only if `ConNF.NearLitterApprox.symm Ï€ â€¢ a = b`. This theorem is used to relate actions of the `ConNF.NearLitterApprox` object `Ï€` and its symmetric counterpart `ConNF.NearLitterApprox.symm Ï€`."}
{"full_name": "ConNF.NearLitterApprox.symm_smul_litter_eq_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm_smul_litter_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.symm_smul_litter_eq_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} :Lâ‚ âˆˆ Ï€.litterPerm.domain â†’ Lâ‚‚ âˆˆ Ï€.litterPerm.domain â†’ (ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â€¢ Lâ‚ = Lâ‚‚ â†” Lâ‚ = Ï€ â€¢ Lâ‚‚)", "code": "theorem symm_smul_litter_eq_iff {Lâ‚ Lâ‚‚} :\n    Lâ‚ âˆˆ Ï€.litterPerm.domain â†’ Lâ‚‚ âˆˆ Ï€.litterPerm.domain â†’ (Ï€.symm â€¢ Lâ‚ = Lâ‚‚ â†” Lâ‚ = Ï€ â€¢ Lâ‚‚) :=\n  by\n  intro hLâ‚ hLâ‚‚\n  constructor\n  Â· rintro rfl\n    exact (Ï€.right_inv_litter hLâ‚).symm\n  Â· rintro rfl\n    exact Ï€.left_inv_litter hLâ‚‚\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [101, 110], "informalization": "The theorem `ConNF.NearLitterApprox.symm_smul_litter_eq_iff` states that for a `ConNF.NearLitterApprox` object `Ï€` and two litters `Lâ‚` and `Lâ‚‚`, if `Lâ‚` and `Lâ‚‚` are both in the domain of `Ï€.litterPerm`, then `ConNF.NearLitterApprox.symm Ï€ â€¢ Lâ‚ = Lâ‚‚` if and only if `Lâ‚ = Ï€ â€¢ Lâ‚‚`."}
{"full_name": "ConNF.NearLitterApprox.eq_symm_apply_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.eq_symm_apply_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.eq_symm_apply_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {aâ‚ : ConNF.Atom} {aâ‚‚ : ConNF.Atom} :aâ‚ âˆˆ Ï€.atomPerm.domain â†’ aâ‚‚ âˆˆ Ï€.atomPerm.domain â†’ (aâ‚ = ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â€¢ aâ‚‚ â†” Ï€ â€¢ aâ‚ = aâ‚‚)", "code": "theorem eq_symm_apply_atom {aâ‚ aâ‚‚} :\n    aâ‚ âˆˆ Ï€.atomPerm.domain â†’ aâ‚‚ âˆˆ Ï€.atomPerm.domain â†’ (aâ‚ = Ï€.symm â€¢ aâ‚‚ â†” Ï€ â€¢ aâ‚ = aâ‚‚) :=\n  Ï€.atomPerm.eq_symm_apply\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [111, 114], "informalization": "Function `ConNF.NearLitterApprox.symm` is a method that takes a `ConNF.NearLitterApprox` object `Ï€` and returns a new `ConNF.NearLitterApprox` object, where the `atomPerm` and `litterPerm` components of `Ï€` are replaced by their symmetric counterparts. The `domain_small` component remains unchanged. The theorem `ConNF.NearLitterApprox.eq_symm_apply_atom` states that for any two atoms `aâ‚` and `aâ‚‚` in the domain of `Ï€.atomPerm`, `aâ‚` is equal to `ConNF.NearLitterApprox.symm Ï€ â€¢ aâ‚‚` if and only if `Ï€ â€¢ aâ‚` is equal to `aâ‚‚`."}
{"full_name": "ConNF.NearLitterApprox.eq_symm_apply_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.eq_symm_apply_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.eq_symm_apply_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} :Lâ‚ âˆˆ Ï€.litterPerm.domain â†’ Lâ‚‚ âˆˆ Ï€.litterPerm.domain â†’ (Lâ‚ = ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€ â€¢ Lâ‚‚ â†” Ï€ â€¢ Lâ‚ = Lâ‚‚)", "code": "theorem eq_symm_apply_litter {Lâ‚ Lâ‚‚} :\n    Lâ‚ âˆˆ Ï€.litterPerm.domain â†’ Lâ‚‚ âˆˆ Ï€.litterPerm.domain â†’ (Lâ‚ = Ï€.symm â€¢ Lâ‚‚ â†” Ï€ â€¢ Lâ‚ = Lâ‚‚) :=\n  Ï€.litterPerm.eq_symm_apply\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [115, 118], "informalization": "Function `ConNF.NearLitterApprox.symm` is a method that takes a `ConNF.NearLitterApprox` object `Ï€` and returns a new `ConNF.NearLitterApprox` object, where the `atomPerm` and `litterPerm` components of `Ï€` are replaced by their symmetric counterparts. The `domain_small` component remains unchanged. The theorem `ConNF.NearLitterApprox.eq_symm_apply_litter` states that for any two litters `Lâ‚` and `Lâ‚‚` in the domain of `Ï€.litterPerm`, `Lâ‚` equals `ConNF.NearLitterApprox.symm Ï€ â€¢ Lâ‚‚` if and only if `Ï€ â€¢ Lâ‚` equals `Lâ‚‚`."}
{"full_name": "ConNF.NearLitterApprox.nearLitter_domain_small", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.nearLitter_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.nearLitter_domain_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) (N : ConNF.NearLitter) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (â†‘N âˆ© Ï€.atomPerm.domain)", "code": "theorem nearLitter_domain_small (N : NearLitter) : Small ((N : Set Atom) âˆ© Ï€.atomPerm.domain) := by\n  rw [â† symmDiff_symmDiff_cancel_left (litterSet N.fst) N, inter_symmDiff_distrib_right]\n  exact Small.symmDiff (Ï€.domain_small N.fst) (Small.mono (inter_subset_left _ _) N.2.prop)\n", "additional_info": "", "used_premises": [1, 233], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [119, 122], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterApprox.nearLitter_domain_small` states that the intersection of a near-litter `N` and the domain of a near-litter approximation `Ï€` is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterApprox.largestSublitter_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.largestSublitter_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.largestSublitter_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) (L : ConNF.Litter) :(ConNF.NearLitterApprox.largestSublitterğŸ”—<|PREMISE|>ğŸ”— Ï€ L).litter = L", "code": "theorem largestSublitter_litter (L : Litter) : (Ï€.largestSublitter L).litter = L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1235], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [134, 136], "informalization": "The function `ConNF.NearLitterApprox.largestSublitter` returns the largest sublitter of `Ï€` on which `Ï€.atom_perm` is not defined. The theorem `ConNF.NearLitterApprox.largestSublitter_litter` states that the litter of the largest sublitter of `Ï€` is equal to `L`."}
{"full_name": "ConNF.NearLitterApprox.largestSublitter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.largestSublitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterApprox.largestSublitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) (L : ConNF.Litter) :ConNF.Sublitter", "code": "def largestSublitter (L : Litter) : Sublitter\n    where\n  litter := L\n  carrier := litterSet L \\ Ï€.atomPerm.domain\n  subset := diff_subset _ _\n  diff_small := by simpa only [sdiff_sdiff_right_self, inf_eq_inter] using Ï€.domain_small L\n", "additional_info": "Gives the largest sublitter of `Ï€` on which `Ï€.atom_perm` is not defined.\nEquations\n* ğŸ—ŸConNF.NearLitterApprox.largestSublitterğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.largestSublitterğŸ”—  Ï€ L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { litter := L, carrier := ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  L ğŸ—Ÿ\\ğŸ—ŸğŸ”—../../.././Init/Core.html#SDiff.sdiffğŸ”—  Ï€.atomPerm.domain, subset := â‹¯, diff_small := â‹¯ }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [126, 132], "informalization": "Function `ConNF.NearLitterApprox.largestSublitter` returns the largest sublitter of `Ï€` on which `Ï€.atom_perm` is not defined."}
{"full_name": "ConNF.NearLitterApprox.coe_largestSublitter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.coe_largestSublitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.coe_largestSublitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) (L : ConNF.Litter) :â†‘(ConNF.NearLitterApprox.largestSublitterğŸ”—<|PREMISE|>ğŸ”— Ï€ L) = ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L \\ Ï€.atomPerm.domain", "code": "theorem coe_largestSublitter (L : Litter) :\n    (Ï€.largestSublitter L : Set Atom) = litterSet L \\ Ï€.atomPerm.domain :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1235, 467], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [138, 141], "informalization": "The theorem `ConNF.NearLitterApprox.coe_largestSublitter` states that the largest sublitter of `Ï€` on which `Ï€.atom_perm` is not defined is equal to the set of all atoms `a` such that the first projection of `a` is equal to `L`, minus the domain of `Ï€.atom_perm`."}
{"full_name": "ConNF.NearLitterApprox.mem_largestSublitter_of_not_mem_domain", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.mem_largestSublitter_of_not_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.mem_largestSublitter_of_not_mem_domain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) (a : ConNF.Atom) (h : a âˆ‰ Ï€.atomPerm.domain) :a âˆˆ ConNF.NearLitterApprox.largestSublitterğŸ”—<|PREMISE|>ğŸ”— Ï€ a.1", "code": "theorem mem_largestSublitter_of_not_mem_domain (a : Atom) (h : a âˆ‰ Ï€.atomPerm.domain) :\n    a âˆˆ Ï€.largestSublitter a.1 :=\n  âŸ¨rfl, hâŸ©\n", "additional_info": "", "used_premises": [1, 1235], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [142, 145], "informalization": "Given a `ConNF.NearLitterApprox` object `Ï€` and an `ConNF.Atom` object `a`, if `a` is not in the domain of `Ï€.atomPerm`, then `a` is in the largest sublitter of `Ï€` on which `Ï€.atom_perm` is not defined."}
{"full_name": "ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€ : ConNF.NearLitterApprox) {a : ConNF.Atom} {L : ConNF.Litter} (h : a âˆˆ ConNF.NearLitterApprox.largestSublitterğŸ”—<|PREMISE|>ğŸ”— Ï€ L) :a âˆ‰ Ï€.atomPerm.domain", "code": "theorem not_mem_domain_of_mem_largestSublitter {a : Atom} {L : Litter}\n    (h : a âˆˆ Ï€.largestSublitter L) : a âˆ‰ Ï€.atomPerm.domain :=\n  h.2\n", "additional_info": "", "used_premises": [1, 1235], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [146, 149], "informalization": "The theorem `ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter` states that if an atom `a` belongs to the largest sublitter of a near litter approximation `Ï€` on which `Ï€.atom_perm` is not defined, then `a` does not belong to the domain of `Ï€.atom_perm`."}
{"full_name": "ConNF.NearLitterApprox.approximates_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.approximates_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.approximates_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€â‚€ : ConNF.NearLitterApprox) (Ï€ : ConNF.NearLitterPerm) :ConNF.NearLitterApprox.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€ â†” (âˆ€ a âˆˆ Ï€â‚€.atomPerm.domain, Ï€â‚€ â€¢ a = Ï€ â€¢ a) âˆ§ âˆ€ L âˆˆ Ï€â‚€.litterPerm.domain, Ï€â‚€ â€¢ L = Ï€ â€¢ L", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1181], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [155, 156], "informalization": "`ConNF.NearLitterApprox.approximates_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF), which defines a relationship between two objects of type `ConNF.NearLitterApprox` and `ConNF.NearLitterPerm`. It states that a `ConNF.NearLitterApprox` object `Ï€â‚€` approximates a `ConNF.NearLitterPerm` object `Ï€` if and only if for any atom `a` in the domain of `Ï€â‚€.atomPerm`, the action of `Ï€â‚€` on `a` is the same as the action of `Ï€` on `a`, and for any litter `L` in the domain of `Ï€â‚€.litterPerm`, the action of `Ï€â‚€` on `L` is the same as the action of `Ï€` on `L`."}
{"full_name": "ConNF.NearLitterApprox.Approximates.symm_map_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Approximates.symm_map_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.Approximates.symm_map_atom [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€â‚€ : ConNF.NearLitterApprox} {Ï€ : ConNF.NearLitterPerm} (hÏ€ : ConNF.NearLitterApprox.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€) (a : ConNF.Atom) (ha : a âˆˆ Ï€â‚€.atomPerm.domain) :ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ â€¢ a = Ï€â»Â¹ â€¢ a", "code": "theorem Approximates.symm_map_atom {Ï€â‚€ : NearLitterApprox} {Ï€ : NearLitterPerm}\n    (hÏ€ : Ï€â‚€.Approximates Ï€) (a : Atom) (ha : a âˆˆ Ï€â‚€.atomPerm.domain) :\n    Ï€â‚€.symm â€¢ a = Ï€â»Â¹ â€¢ a := by\n  have := hÏ€.map_atom (Ï€â‚€.symm â€¢ a) (Ï€â‚€.symm.atomPerm.map_domain ha)\n  rw [â† inv_smul_eq_iff] at this\n  rw [â† this, smul_left_cancel_iff]\n  exact Ï€â‚€.atomPerm.right_inv ha\n", "additional_info": "", "used_premises": [1, 1181, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [160, 167], "informalization": "The theorem states that for any `ConNF.NearLitterApprox` object `Ï€â‚€`, any `ConNF.NearLitterPerm` object `Ï€`, and an `ConNF.Atom` `a` that is in the domain of `Ï€â‚€.atomPerm`, the symmetric action of `Ï€â‚€` on `a` is equal to the inverse action of `Ï€` on `a`. This is proven under the assumption that `Ï€â‚€` approximates `Ï€` in the sense defined by the `ConNF.NearLitterApprox.Approximates` structure."}
{"full_name": "ConNF.NearLitterApprox.Approximates.symm_map_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Approximates.symm_map_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.Approximates.symm_map_litter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€â‚€ : ConNF.NearLitterApprox} {Ï€ : ConNF.NearLitterPerm} (hÏ€ : ConNF.NearLitterApprox.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€) (L : ConNF.Litter) (hL : L âˆˆ Ï€â‚€.litterPerm.domain) :ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ â€¢ L = Ï€â»Â¹ â€¢ L", "code": "theorem Approximates.symm_map_litter {Ï€â‚€ : NearLitterApprox} {Ï€ : NearLitterPerm}\n    (hÏ€ : Ï€â‚€.Approximates Ï€) (L : Litter) (hL : L âˆˆ Ï€â‚€.litterPerm.domain) :\n    Ï€â‚€.symm â€¢ L = Ï€â»Â¹ â€¢ L := by\n  have := hÏ€.map_litter (Ï€â‚€.symm â€¢ L) (Ï€â‚€.symm.litterPerm.map_domain hL)\n  rw [â† inv_smul_eq_iff] at this\n  rw [â† this, smul_left_cancel_iff]\n  exact Ï€â‚€.litterPerm.right_inv hL\n", "additional_info": "", "used_premises": [1, 1181, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [168, 175], "informalization": "`ConNF.NearLitterApprox.Approximates.symm_map_litter` is a theorem in the `ConNF` library, which is a part of the `mathlib` library for formalizing Constructive Ordinal Notation (ConNF) in the Lean 4 proof assistant. This theorem states that if `Ï€â‚€` is an approximation of `Ï€` (in the sense defined by the `ConNF.NearLitterApprox.Approximates` structure), then the symmetric version of `Ï€â‚€` (obtained by taking the symmetric permutation of both the `atomPerm` and `litterPerm` components) applied to a litter `L` in the domain of `Ï€â‚€` is the same as the inverse of `Ï€` applied to `L`."}
{"full_name": "ConNF.NearLitterApprox.exactlyApproximates_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.exactlyApproximates_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.exactlyApproximates_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Ï€â‚€ : ConNF.NearLitterApprox) (Ï€ : ConNF.NearLitterPerm) :ConNF.NearLitterApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€ â†” ConNF.NearLitterApprox.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€ âˆ§ âˆ€ (a : ConNF.Atom), ConNF.NearLitterPerm.IsExceptionğŸ”—<|PREMISE|>ğŸ”— Ï€ a â†’ a âˆˆ Ï€â‚€.atomPerm.domain", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1180, 1181, 801], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [176, 177], "informalization": "The theorem `ConNF.NearLitterApprox.exactlyApproximates_iff` states that a near litter approximation `Ï€â‚€` exactly approximates a near litter permutation `Ï€` if and only if `Ï€â‚€` approximates `Ï€` in the sense that their actions on atoms and litters are consistent, and for any atom `a`, if `Ï€` is an exception with respect to `a`, then `a` must be in the domain of `Ï€â‚€.atomPerm`."}
{"full_name": "ConNF.NearLitterApprox.ExactlyApproximates.of_isException", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates.of_isException", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ExactlyApproximates.of_isException [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€â‚€ : ConNF.NearLitterApprox} {Ï€ : ConNF.NearLitterPerm} (hÏ€ : ConNF.NearLitterApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€) (a : ConNF.Atom) (ha : a.1 âˆˆ Ï€â‚€.litterPerm.domain) :ConNF.NearLitterPerm.IsExceptionğŸ”—<|PREMISE|>ğŸ”— Ï€ a â†’ Ï€â‚€ â€¢ a âˆ‰ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (Ï€â‚€ â€¢ a.1) âˆ¨ ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ â€¢ a âˆ‰ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ â€¢ a.1)", "code": "theorem ExactlyApproximates.of_isException {Ï€â‚€ : NearLitterApprox} {Ï€ : NearLitterPerm}\n    (hÏ€ : Ï€â‚€.ExactlyApproximates Ï€) (a : Atom) (ha : a.1 âˆˆ Ï€â‚€.litterPerm.domain) :\n    Ï€.IsException a â†’ Ï€â‚€ â€¢ a âˆ‰ litterSet (Ï€â‚€ â€¢ a.1) âˆ¨ Ï€â‚€.symm â€¢ a âˆ‰ litterSet (Ï€â‚€.symm â€¢ a.1) :=\n  by\n  intro h\n  rw [hÏ€.map_litter a.fst ha, hÏ€.symm_map_litter a.fst ha, hÏ€.map_atom a (hÏ€.exception_mem a h),\n    hÏ€.symm_map_atom a (hÏ€.exception_mem a h)]\n  exact h\n", "additional_info": "", "used_premises": [1, 1180, 801, 467, 1223, 467, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [181, 189], "informalization": "In the context of Constructive Ordinal Notation (ConNF), `ConNF.NearLitterApprox.ExactlyApproximates.of_isException` is a theorem that proves a property of near liter `ConNF.NearLitterApprox` objects. It states that if `Ï€` is an exception with respect to an atom `a`, and `Ï€â‚€` exactly approximates `Ï€`, then either `Ï€â‚€ â€¢ a` is not in the litter set corresponding to `Ï€â‚€ â€¢ a.1`, or `ConNF.NearLitterApprox.symm Ï€â‚€ â€¢ a` is not in the litter set corresponding to `ConNF.NearLitterApprox.symm Ï€â‚€ â€¢ a.1`. This theorem is crucial in the construction of `ConNF`, as it helps to determine the behavior of approximations when they are exceptions."}
{"full_name": "ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€â‚€ : ConNF.NearLitterApprox} {Ï€ : ConNF.NearLitterPerm} (hÏ€ : ConNF.NearLitterApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€) (a : ConNF.Atom) (ha : a âˆ‰ Ï€â‚€.atomPerm.domain) :Ï€ â€¢ a âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (Ï€ â€¢ a.1)", "code": "theorem ExactlyApproximates.mem_litterSet {Ï€â‚€ : NearLitterApprox} {Ï€ : NearLitterPerm}\n    (hÏ€ : Ï€â‚€.ExactlyApproximates Ï€) (a : Atom) (ha : a âˆ‰ Ï€â‚€.atomPerm.domain) :\n    Ï€ â€¢ a âˆˆ litterSet (Ï€ â€¢ a.1) := by contrapose! ha; exact hÏ€.exception_mem _ (Or.inl ha)\n", "additional_info": "", "used_premises": [1, 1180, 467], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [190, 193], "informalization": "The theorem `ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet` in the context of Constructive Ordinal Notation (ConNF) states that if `Ï€â‚€` exactly approximates `Ï€`, and `a` is an atom not in the domain of `Ï€â‚€.atomPerm`, then the action of `Ï€` on `a` results in an element of the litter set corresponding to the first projection of `Ï€ â€¢ a`."}
{"full_name": "ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet_inv", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet_inv [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Ï€â‚€ : ConNF.NearLitterApprox} {Ï€ : ConNF.NearLitterPerm} (hÏ€ : ConNF.NearLitterApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€) (a : ConNF.Atom) (ha : a âˆ‰ Ï€â‚€.atomPerm.domain) :Ï€â»Â¹ â€¢ a âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (Ï€â»Â¹ â€¢ a.1)", "code": "theorem ExactlyApproximates.mem_litterSet_inv {Ï€â‚€ : NearLitterApprox} {Ï€ : NearLitterPerm}\n    (hÏ€ : Ï€â‚€.ExactlyApproximates Ï€) (a : Atom) (ha : a âˆ‰ Ï€â‚€.atomPerm.domain) :\n    Ï€â»Â¹ â€¢ a âˆˆ litterSet (Ï€â»Â¹ â€¢ a.1) := by contrapose! ha; exact hÏ€.exception_mem _ (Or.inr ha)\n", "additional_info": "", "used_premises": [1, 1180, 467], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [194, 197], "informalization": "This theorem states that if `Ï€` is an exactly approximating permutation that does not map an atom `a` to itself, then the inverse permutation `Ï€â»Â¹` applied to `a` results in an atom that is an element of the litter set corresponding to the litter `Ï€â»Â¹ â€¢ a.1`."}
{"full_name": "ConNF.StructApprox.Approximates.comp", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.Approximates.comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Approximates.comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {Ï€â‚€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— Î²} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î²} (h : ConNF.StructApprox.ApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) :ConNF.StructApprox.ApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï€â‚€) (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï€)", "code": "theorem Approximates.comp {Î² Î³ : TypeIndex} {Ï€â‚€ : StructApprox Î²} {Ï€ : StructPerm Î²}\n    (h : Ï€â‚€.Approximates Ï€) (A : Path Î² Î³) :\n    StructApprox.Approximates (Ï€â‚€.comp A) (Tree.comp A Ï€) :=\n  fun B => h (A.comp B)\n", "additional_info": "", "used_premises": [1, 781, 55, 1247, 76, 1247, 304, 304], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [34, 38], "informalization": "Function `ConNF.StructApprox.Approximates.comp` proves that if a `Î²`-structural approximation `Ï€â‚€` approximates a `Î²`-structural permutation `Ï€`, then for any path `A` from type index `Î²` to type index `Î³`, the `Î³`-structural approximation obtained by composing `Ï€â‚€` with `A` approximates the `Î³`-structural permutation obtained by composing `Ï€` with `A`."}
{"full_name": "ConNF.StructApprox.Approximates", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.Approximates", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.Approximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Ï€â‚€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— Î²) (Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def Approximates {Î² : TypeIndex} (Ï€â‚€ : StructApprox Î²) (Ï€ : StructPerm Î²) : Prop :=\n  âˆ€ A, (Ï€â‚€ A).Approximates (Ï€ A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructApprox.ApproximatesğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.ApproximatesğŸ”—  Ï€â‚€ Ï€ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ (A : ğŸ—ŸConNF.ExtendedIndexğŸ—ŸğŸ”—../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndexğŸ”—  Î²), ğŸ—ŸConNF.NearLitterApprox.ApproximatesğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ApproximatesğŸ”—  (Ï€â‚€ A) (Ï€ A)\n\n", "used_premises": [1, 781, 55], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [23, 25], "informalization": "Function `ConNF.StructApprox.Approximates` checks if a `Î²`-structural approximation `Ï€â‚€` approximates a `Î²`-structural permutation `Ï€`, meaning that for each `Î²`-extended index `A`, the near-litter approximation `Ï€â‚€ A` approximates the near-litter permutation `Ï€ A`."}
{"full_name": "ConNF.StructApprox.ExactlyApproximates.comp", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.ExactlyApproximates.comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ExactlyApproximates.comp [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} {Î³ : ConNF.TypeIndex} {Ï€â‚€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— Î²} {Ï€ : ConNF.StructPermğŸ”—<|PREMISE|>ğŸ”— Î²} (h : ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— Ï€â‚€ Ï€) (A : Quiver.PathğŸ”—<|PREMISE|>ğŸ”— Î² Î³) :ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï€â‚€) (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— A Ï€)", "code": "theorem ExactlyApproximates.comp {Î² Î³ : TypeIndex} {Ï€â‚€ : StructApprox Î²} {Ï€ : StructPerm Î²}\n    (h : Ï€â‚€.ExactlyApproximates Ï€) (A : Path Î² Î³) :\n    StructApprox.ExactlyApproximates (Ï€â‚€.comp A) (Tree.comp A Ï€) :=\n  fun B => h (A.comp B)\n", "additional_info": "", "used_premises": [1, 781, 55, 803, 76, 803, 304, 304], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [39, 43], "informalization": "Function `ConNF.StructApprox.ExactlyApproximates.comp` proves that if a `Î²`-structural approximation `Ï€â‚€` exactly approximates a `Î²`-structural permutation `Ï€`, then for any path `A` from type index `Î²` to type index `Î³`, the `Î³`-structural approximation `ConNF.Tree.comp A Ï€â‚€` exactly approximates the `Î³`-structural permutation `ConNF.Tree.comp A Ï€`."}
{"full_name": "ConNF.StructBehaviour.withLitters_lawful", "url": "ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.withLitters_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.withLitters_lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— Î²) (hÎ¾ : ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructBehaviour.withLittersğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾)", "code": "theorem withLitters_lawful (Î¾ : StructBehaviour Î²) (hÎ¾ : Î¾.Lawful) : (Î¾.withLitters hÎ¾).Lawful :=\n  fun A => (Î¾ A).withLitters_lawful (hÎ¾ A)\n", "additional_info": "", "used_premises": [1, 828, 829, 829, 1250], "def_path": "ConNF/FOA/Behaviour/StructBehaviour.lean", "pos": [29, 31], "informalization": "The theorem `ConNF.StructBehaviour.withLitters_lawful` states that if `Î¾` is a lawful `Î²`-structural action, then the `Î²`-structural action obtained by replacing each near-litter action in `Î¾` with its lawful version is also lawful."}
{"full_name": "ConNF.StructBehaviour.withLitters", "url": "ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.withLitters", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructBehaviour.withLitters [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î² : ConNF.TypeIndex} (Î¾ : ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— Î²) (hÎ¾ : ConNF.StructBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.StructBehaviourğŸ”—<|PREMISE|>ğŸ”— Î²", "code": "noncomputable def withLitters (Î¾ : StructBehaviour Î²) (hÎ¾ : Î¾.Lawful) : StructBehaviour Î² :=\n  fun A => (Î¾ A).withLitters (hÎ¾ A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructBehaviour.withLittersğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.withLittersğŸ”—  Î¾ hÎ¾ A ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.NearLitterBehaviour.withLittersğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.withLittersğŸ”—  (Î¾ A) â‹¯\n\n", "used_premises": [1, 828, 829, 828], "def_path": "ConNF/FOA/Behaviour/StructBehaviour.lean", "pos": [26, 28], "informalization": "Function `ConNF.StructBehaviour.withLitters` takes a `Î²`-structural action `Î¾` and a proof `hÎ¾` that `Î¾` is lawful, and returns a new `Î²`-structural action where each near-litter action is replaced by its lawful version."}
{"full_name": "ConNF.NearLitterBehaviour.ext_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.ext_iff :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } (x y : ConNF.NearLitterBehaviour), x = y â†” x.atomMap = y.atomMap âˆ§ x.nearLitterMap = y.nearLitterMap", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [12, 13], "informalization": "`ConNF.NearLitterBehaviour.ext_iff` is an extensionality theorem for the `ConNF.NearLitterBehaviour` structure. It states that two instances of `ConNF.NearLitterBehaviour` are equal if and only if their `atomMap` and `nearLitterMap` fields are equal."}
{"full_name": "ConNF.NearLitterBehaviour.ext", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.ext :âˆ€ {inst : ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— } (x y : ConNF.NearLitterBehaviour), x.atomMap = y.atomMap â†’ x.nearLitterMap = y.nearLitterMap â†’ x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [12, 13], "informalization": "The `ConNF.NearLitterBehaviour.ext` theorem states that two `ConNF.NearLitterBehaviour` objects are equal if their `atomMap` and `nearLitterMap` fields are equal."}
{"full_name": "ConNF.NearLitterBehaviour.map_nearLitter_fst", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.map_nearLitter_fst", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.map_nearLitter_fst [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) â¦ƒNâ‚ : ConNF.NearLitterâ¦„ â¦ƒNâ‚‚ : ConNF.NearLitterâ¦„ (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) :Nâ‚.fst = Nâ‚‚.fst â†” ((Î¾.nearLitterMap Nâ‚).get hNâ‚).fst = ((Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚).fst", "code": "theorem map_nearLitter_fst {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful) â¦ƒNâ‚ Nâ‚‚ : NearLitterâ¦„\n    (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) :\n    Nâ‚.fst = Nâ‚‚.fst â†” ((Î¾.nearLitterMap Nâ‚).get hNâ‚).fst = ((Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚).fst := by\n  constructor\n  Â· intro h\n    rw [â† NearLitter.isNear_iff_fst_eq_fst]\n    refine (Small.pFun_image (f := Î¾.atomMap) Î¾.atomMap_dom_small).mono ?_\n    intro a ha\n    obtain âŸ¨b, hb, rflâŸ© := hÎ¾.ran_of_mem_symmDiff a h hNâ‚ hNâ‚‚ ha\n    exact âŸ¨b, hb, hb, rflâŸ©\n  Â· intro h\n    by_contra h'\n    suffices : Small (((Î¾.nearLitterMap Nâ‚).get hNâ‚ : Set Atom) âˆ© (Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚)\n    Â· rw [Small, NearLitter.mk_inter_of_fst_eq_fst h, lt_self_iff_false] at this\n      exact this\n    refine (Small.pFun_image (f := Î¾.atomMap) Î¾.atomMap_dom_small).mono ?_\n    intro a ha\n    obtain âŸ¨b, hb, rflâŸ© := hÎ¾.ran_of_mem_inter a h' hNâ‚ hNâ‚‚ ha\n    exact âŸ¨b, hb, hb, rflâŸ©\n", "additional_info": "", "used_premises": [1, 823], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [42, 61], "informalization": "The theorem `ConNF.NearLitterBehaviour.map_nearLitter_fst` states that for two near-litters `Nâ‚` and `Nâ‚‚`, the first component of `Nâ‚` is equal to the first component of `Nâ‚‚` if and only if the first component of the image of `Nâ‚` under the near-litter map is equal to the first component of the image of `Nâ‚‚` under the near-litter map."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtoms_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtoms_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtoms_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.extraAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾)", "code": "theorem extraAtoms_small (Î¾ : NearLitterBehaviour) : Small Î¾.extraAtoms :=\n  Small.bUnion Î¾.nearLitterMap_dom_small (fun N _ => N.2.2.mono (fun _ => Or.inl))\n", "additional_info": "", "used_premises": [1, 233, 1255], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [68, 70], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtoms_small` states that for any `ConNF.NearLitterBehaviour` object `Î¾`, the cardinality of the set `ConNF.NearLitterBehaviour.extraAtoms Î¾` is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.extraAtoms [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def extraAtoms (Î¾ : NearLitterBehaviour) : Set Atom :=\n  â‹ƒ (N âˆˆ Î¾.nearLitterMap.Dom), litterSet N.1 \\ N\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterBehaviour.extraAtomsğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomsğŸ”—  Î¾ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  â‹ƒ N âˆˆ ğŸ—ŸPFun.DomğŸ—ŸğŸ”—../../.././Mathlib/Data/PFun.html#PFun.DomğŸ”—  Î¾.nearLitterMap, ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  N.fst ğŸ—Ÿ\\ğŸ—ŸğŸ”—../../.././Init/Core.html#SDiff.sdiffğŸ”—  â†‘N\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [65, 67], "informalization": "`ConNF.NearLitterBehaviour.extraAtoms` is a function that takes a `ConNF.NearLitterBehaviour` object `Î¾` and returns a set of `ConNF.Atom`s. This set is defined as the union of the differences between the `ConNF.litterSet` of each `N` in the domain of `Î¾.nearLitterMap` and `N` itself."}
{"full_name": "ConNF.NearLitterBehaviour.bannedLitter_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.bannedLitter_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.bannedLitter_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :âˆ€ (a : ConNF.Litter), ConNF.NearLitterBehaviour.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Î¾ a â†” (âˆƒ (a_1 : ConNF.Atom) (h : (Î¾.atomMap a_1).Dom), a = ((Î¾.atomMap a_1).get h).1) âˆ¨ (âˆƒ (N : ConNF.NearLitter) (h : (Î¾.nearLitterMap N).Dom), a = ((Î¾.nearLitterMap N).get h).fst) âˆ¨ âˆƒ (N : ConNF.NearLitter) (h : (Î¾.nearLitterMap N).Dom), âˆƒ a_1 âˆˆ â†‘((Î¾.nearLitterMap N).get h) \\ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— ((Î¾.nearLitterMap N).get h).fst, a = a_1.1", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1257, 467], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [71, 72], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a litter is considered \"banned\" if it is the image of an atom under the atom map, the image of a near-litter under the near-litter map, or if it is the difference of a near-litter's image under the near-litter map and its own litter set. The theorem `ConNF.NearLitterBehaviour.bannedLitter_iff` states that a litter is banned if and only if it satisfies one of these three conditions."}
{"full_name": "ConNF.NearLitterBehaviour.BannedLitter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.BannedLitter", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.NearLitterBehaviour.BannedLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :ConNF.Litter â†’ Prop", "code": "inductive BannedLitter (Î¾ : NearLitterBehaviour) : Litter â†’ Prop\n  | atomMap (a : Atom) (h) : BannedLitter Î¾ ((Î¾.atomMap a).get h).1\n  | nearLitterMap (N : NearLitter) (h) : BannedLitter Î¾ ((Î¾.nearLitterMap N).get h).1\n  | diff (N : NearLitter) (h) (a : Atom) :\n    a âˆˆ ((Î¾.nearLitterMap N).get h : Set Atom) \\ litterSet ((Î¾.nearLitterMap N).get h).1 â†’\n    BannedLitter Î¾ a.1\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [72, 78], "informalization": "The `ConNF.NearLitterBehaviour.BannedLitter` inductive type defines the conditions under which a litter is considered \"banned\" in the context of Constructive Ordinal Notation (ConNF). A litter is banned if it is the image of an atom under the atom map, the image of a near-litter under the near-litter map, or if it is the difference of a near-litter's image under the near-litter map and its own litter set."}
{"full_name": "ConNF.NearLitterBehaviour.bannedLitter_of_mem", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.bannedLitter_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.bannedLitter_of_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (a : ConNF.Atom) (N : ConNF.NearLitter) (hN : (Î¾.nearLitterMap N).Dom) (ha : a âˆˆ (Î¾.nearLitterMap N).get hN) :ConNF.NearLitterBehaviour.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Î¾ a.1", "code": "theorem bannedLitter_of_mem {Î¾ : NearLitterBehaviour} (a : Atom) (N : NearLitter)\n    (hN : (Î¾.nearLitterMap N).Dom) (ha : a âˆˆ (Î¾.nearLitterMap N).get hN) : Î¾.BannedLitter a.1 := by\n  by_cases h : a.1 = (Part.get (nearLitterMap Î¾ N) hN).1\n  Â· rw [h]\n    exact BannedLitter.nearLitterMap N hN\n  Â· exact BannedLitter.diff N hN _ âŸ¨ha, hâŸ©\n", "additional_info": "", "used_premises": [1, 1257], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [79, 85], "informalization": "The theorem `ConNF.NearLitterBehaviour.bannedLitter_of_mem` states that if an atom `a` is a member of the image of a near-litter `N` under the near-litter map `Î¾.nearLitterMap N`, then `a` is a banned litter in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterBehaviour.bannedLitter_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.bannedLitter_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.bannedLitter_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {L : ConNF.Litter | ConNF.NearLitterBehaviour.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Î¾ L}", "code": "theorem bannedLitter_small (Î¾ : NearLitterBehaviour) : Small {L | Î¾.BannedLitter L} := by\n  simp only [bannedLitter_iff, mem_diff, SetLike.mem_coe, mem_litterSet]\n  refine Small.union ?_ (Small.union ?_ ?_)\n  Â· refine' lt_of_le_of_lt _ Î¾.atomMap_dom_small\n    refine' âŸ¨âŸ¨fun L => âŸ¨_, L.prop.choose_spec.chooseâŸ©, fun Lâ‚ Lâ‚‚ h => _âŸ©âŸ©\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := Lâ‚.prop.choose_spec.choose_spec\n    simp_rw [h] at this\n    exact Subtype.coe_injective (this.trans Lâ‚‚.prop.choose_spec.choose_spec.symm)\n  Â· refine' lt_of_le_of_lt _ Î¾.nearLitterMap_dom_small\n    refine' âŸ¨âŸ¨fun L => âŸ¨_, L.prop.choose_spec.chooseâŸ©, fun Lâ‚ Lâ‚‚ h => _âŸ©âŸ©\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := Lâ‚.prop.choose_spec.choose_spec\n    simp_rw [h] at this\n    exact Subtype.coe_injective (this.trans Lâ‚‚.prop.choose_spec.choose_spec.symm)\n  Â· have : Small\n      (â‹ƒ (L : NearLitter) (h : (Î¾.nearLitterMap L).Dom),\n        ((Î¾.nearLitterMap L).get h : Set Atom) \\ litterSet ((Î¾.nearLitterMap L).get h).1)\n    Â· refine' Small.bUnion _ _\n      Â· refine' lt_of_le_of_lt _ Î¾.nearLitterMap_dom_small\n        refine' âŸ¨âŸ¨fun N => âŸ¨_, N.propâŸ©, fun Nâ‚ Nâ‚‚ h => _âŸ©âŸ©\n        simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n        exact Subtype.coe_inj.mp h\n      Â· intro L hL\n        refine' Small.mono _ ((Î¾.nearLitterMap L).get hL).2.prop\n        exact fun x hx => Or.inr hx\n    refine' lt_of_le_of_lt _ this\n    refine' âŸ¨âŸ¨fun L => âŸ¨L.prop.choose_spec.choose_spec.choose, _âŸ©, fun Lâ‚ Lâ‚‚ h => _âŸ©âŸ©\n    Â· simp only [mem_iUnion]\n      exact âŸ¨_, _, L.prop.choose_spec.choose_spec.choose_spec.1âŸ©\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := Lâ‚.prop.choose_spec.choose_spec.choose_spec.2\n    rw [h] at this\n    exact Subtype.coe_injective (this.trans Lâ‚‚.prop.choose_spec.choose_spec.choose_spec.2.symm)\n", "additional_info": "", "used_premises": [1, 233, 1257], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [86, 120], "informalization": "The theorem `ConNF.NearLitterBehaviour.bannedLitter_small` states that the set of litters that are considered \"banned\" in the context of Constructive Ordinal Notation (ConNF) has a cardinality that is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterBehaviour.mk_not_bannedLitter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mk_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mk_not_bannedLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterBehaviour.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Î¾ L} = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Î¼", "code": "theorem mk_not_bannedLitter (Î¾ : NearLitterBehaviour) : #{L | Â¬Î¾.BannedLitter L} = #Î¼ := by\n  have := mk_sum_compl {L | Î¾.BannedLitter L}\n  rw [compl_setOf, mk_litter] at this\n  rw [â† this, add_eq_right]\n  Â· by_contra h\n    have h' := add_le_add (le_of_lt Î¾.bannedLitter_small) (le_of_not_le h)\n    rw [this] at h'\n    refine' not_lt_of_le h' _\n    refine' Cardinal.add_lt_of_lt Params.Î¼_isStrongLimit.isLimit.aleph0_le Params.Îº_lt_Î¼ _\n    exact lt_of_le_of_lt Params.Îº_isRegular.aleph0_le Params.Îº_lt_Î¼\n  Â· by_contra h\n    have h' := add_le_add (le_of_lt Î¾.bannedLitter_small) (le_of_not_le h)\n    rw [this] at h'\n    refine' not_lt_of_le h' _\n    refine' Cardinal.add_lt_of_lt Params.Î¼_isStrongLimit.isLimit.aleph0_le Params.Îº_lt_Î¼ _\n    exact lt_trans Î¾.bannedLitter_small Params.Îº_lt_Î¼\n", "additional_info": "", "used_premises": [1, 29, 1257, 29], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [121, 137], "informalization": "The theorem `ConNF.NearLitterBehaviour.mk_not_bannedLitter` states that the cardinality of the set of litters that are not considered \"banned\" in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `Î¼` from the `ConNF.Params` class."}
{"full_name": "ConNF.NearLitterBehaviour.not_bannedLitter_nonempty", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.not_bannedLitter_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.not_bannedLitter_nonempty [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :NonemptyğŸ”—<|PREMISE|>ğŸ”— â†‘{L : ConNF.Litter | Â¬ ConNF.NearLitterBehaviour.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Î¾ L}", "code": "theorem not_bannedLitter_nonempty (Î¾ : NearLitterBehaviour) : Nonempty {L | Â¬Î¾.BannedLitter L} := by\n  simp only [â† mk_ne_zero_iff, mk_not_bannedLitter, Ne.def, mk_ne_zero, not_false_iff]\n", "additional_info": "", "used_premises": [1, 212, 1257], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [138, 140], "informalization": "The theorem `ConNF.NearLitterBehaviour.not_bannedLitter_nonempty` asserts that for any `ConNF.NearLitterBehaviour` `Î¾`, there exists at least one `ConNF.Litter` that is not `ConNF.NearLitterBehaviour.BannedLitter`."}
{"full_name": "ConNF.NearLitterBehaviour.sandboxLitter_not_banned", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.sandboxLitter_not_banned", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.sandboxLitter_not_banned [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :Â¬ ConNF.NearLitterBehaviour.BannedLitterğŸ”—<|PREMISE|>ğŸ”— Î¾ (ConNF.NearLitterBehaviour.sandboxLitterğŸ”—<|PREMISE|>ğŸ”— Î¾)", "code": "theorem sandboxLitter_not_banned (Î¾ : NearLitterBehaviour) : Â¬Î¾.BannedLitter Î¾.sandboxLitter :=\n  Î¾.not_bannedLitter_nonempty.some.prop\n", "additional_info": "", "used_premises": [1, 1257, 1263], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [144, 146], "informalization": "Function `ConNF.NearLitterBehaviour.sandboxLitter` takes a `ConNF.NearLitterBehaviour` object `Î¾` and returns a `ConNF.Litter` object that is not banned by `Î¾`."}
{"full_name": "ConNF.NearLitterBehaviour.sandboxLitter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.sandboxLitter", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterBehaviour.sandboxLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :ConNF.Litter", "code": "noncomputable def sandboxLitter (Î¾ : NearLitterBehaviour) : Litter :=\n  Î¾.not_bannedLitter_nonempty.some\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterBehaviour.sandboxLitterğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.sandboxLitterğŸ”—  Î¾ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  â†‘(ğŸ—ŸNonempty.someğŸ—ŸğŸ”—../../.././Mathlib/Logic/Nonempty.html#Nonempty.someğŸ”—  â‹¯)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [141, 143], "informalization": "Function `ConNF.NearLitterBehaviour.sandboxLitter` takes a `ConNF.NearLitterBehaviour` object `Î¾` and returns a `ConNF.Litter` object, which represents a litter in the context of Constructive Ordinal Notation (ConNF). The returned litter is chosen from the non-empty set of litters that are not banned by `Î¾`."}
{"full_name": "ConNF.NearLitterBehaviour.mem_innerAtoms_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_innerAtoms_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mem_innerAtoms_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L) (a : ConNF.Atom) :a âˆˆ ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L â†” a.1 â‰  L âˆ§ âˆ€ (N : ConNF.NearLitter), (Î¾.nearLitterMap N).Dom âˆ§ N.fst = L â†’ a âˆˆ N", "code": "theorem mem_innerAtoms_iff {Î¾ : NearLitterBehaviour}\n    (L : Litter) (hL : Î¾.LitterPresent L) (a : Atom) :\n    a âˆˆ Î¾.innerAtoms L â†” a.1 â‰  L âˆ§ âˆ€ N (_ : (Î¾.nearLitterMap N).Dom âˆ§ N.1 = L), a âˆˆ N := by\n  obtain âŸ¨N, hN, rflâŸ© := hL\n  rw [innerAtoms]\n  aesop\n", "additional_info": "", "used_premises": [1, 838, 1265], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [159, 165], "informalization": "The theorem `ConNF.NearLitterBehaviour.mem_innerAtoms_iff` states that an atom `a` belongs to the inner atoms of a near litter `L` if and only if the first component of `a` is not equal to `L` and for all near litters `N` such that the near litter map `Î¾.nearLitterMap N` is defined and the first component of `N` is equal to `L`, `a` belongs to `N`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.innerAtoms [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (L : ConNF.Litter) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def innerAtoms (Î¾ : NearLitterBehaviour) (L : Litter) : Set Atom :=\n  â‹‚ (N : NearLitter) (_ : (Î¾.nearLitterMap N).Dom âˆ§ N.1 = L), N \\ litterSet L\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterBehaviour.innerAtomsğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsğŸ”—  Î¾ L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  â‹‚ (N : ConNF.NearLitter), â‹‚ (_ : (Î¾.nearLitterMap N).Dom ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  N.fst ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  L), â†‘N ğŸ—Ÿ\\ğŸ—ŸğŸ”—../../.././Init/Core.html#SDiff.sdiffğŸ”—  ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  L\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [150, 152], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtoms` computes the inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF). It is defined as the intersection of all near litters `N` such that `Î¾.nearLitterMap N` is defined and `N.1 = L`, excluding the litter set of `L`."}
{"full_name": "ConNF.NearLitterBehaviour.mem_outerAtoms_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_outerAtoms_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterBehaviour.mem_outerAtoms_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (a : ConNF.Atom) :a âˆˆ ConNF.NearLitterBehaviour.outerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L â†” a.1 = L âˆ§ âˆ€ (N : ConNF.NearLitter), (Î¾.nearLitterMap N).Dom â†’ a âˆ‰ N", "code": "theorem mem_outerAtoms_iff {Î¾ : NearLitterBehaviour} (L : Litter) (a : Atom) :\n    a âˆˆ Î¾.outerAtoms L â†” a.1 = L âˆ§ âˆ€ N, (Î¾.nearLitterMap N).Dom â†’ a âˆ‰ N :=\n  by simp only [outerAtoms, mem_diff, mem_litterSet, mem_iUnion, SetLike.mem_coe,\n    exists_prop, not_exists, not_and]\n", "additional_info": "", "used_premises": [1, 1267], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [167, 171], "informalization": "The theorem `ConNF.NearLitterBehaviour.mem_outerAtoms_iff` is a membership condition for the set of outer atoms of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). It states that an atom `a` belongs to the set of outer atoms of `L` if and only if `a` is equal to `L` and `a` does not belong to any near litter `N` for which the near litter map `Î¾.nearLitterMap N` is defined."}
{"full_name": "ConNF.NearLitterBehaviour.outerAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.outerAtoms [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (L : ConNF.Litter) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def outerAtoms (Î¾ : NearLitterBehaviour) (L : Litter) : Set Atom :=\n  litterSet L \\ (â‹ƒ (N : NearLitter) (_ : (Î¾.nearLitterMap N).Dom), N)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterBehaviour.outerAtomsğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtomsğŸ”—  Î¾ L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.litterSetğŸ—ŸğŸ”—../../.././ConNF/BaseType/Atom.html#ConNF.litterSetğŸ”—  L ğŸ—Ÿ\\ğŸ—ŸğŸ”—../../.././Init/Core.html#SDiff.sdiffğŸ”—  â‹ƒ (N : ConNF.NearLitter), â‹ƒ (_ : (Î¾.nearLitterMap N).Dom), â†‘N\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [153, 155], "informalization": "Function `ConNF.NearLitterBehaviour.outerAtoms` defines the set of outer atoms of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is obtained by subtracting the union of all near litters from the litter set of `L`."}
{"full_name": "ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (a : ConNF.Atom) :a âˆˆ ConNF.NearLitterBehaviour.allOuterAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ â†” ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ a.1 âˆ§ âˆ€ (N : ConNF.NearLitter), (Î¾.nearLitterMap N).Dom â†’ a âˆ‰ N", "code": "theorem mem_allOuterAtoms_iff {Î¾ : NearLitterBehaviour} (a : Atom) :\n    a âˆˆ Î¾.allOuterAtoms â†” Î¾.LitterPresent a.1 âˆ§ âˆ€ N, (Î¾.nearLitterMap N).Dom â†’ a âˆ‰ N :=\n  by simp only [allOuterAtoms, mem_iUnion, mem_outerAtoms_iff, exists_and_left,\n    exists_prop, exists_eq_left']\n", "additional_info": "", "used_premises": [1, 1269, 838], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [173, 177], "informalization": "The theorem `ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff` states that an atom `a` is an element of the set `ConNF.NearLitterBehaviour.allOuterAtoms Î¾` if and only if there exists a near litter `N` such that the near litter map `Î¾.nearLitterMap N` is defined and the first component of `N` is equal to `a.1`, and for all near litters `N` such that `Î¾.nearLitterMap N` is defined, `a` is not an element of `N`."}
{"full_name": "ConNF.NearLitterBehaviour.allOuterAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.allOuterAtoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.allOuterAtoms [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def allOuterAtoms (Î¾ : NearLitterBehaviour) : Set Atom :=\n  â‹ƒ (L : Litter) (_ : Î¾.LitterPresent L), Î¾.outerAtoms L\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterBehaviour.allOuterAtomsğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.allOuterAtomsğŸ”—  Î¾ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  â‹ƒ (L : ConNF.Litter), â‹ƒ (_ : ğŸ—ŸConNF.NearLitterBehaviour.LitterPresentğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.LitterPresentğŸ”—  Î¾ L), ğŸ—ŸConNF.NearLitterBehaviour.outerAtomsğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtomsğŸ”—  Î¾ L\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [156, 158], "informalization": "Function `ConNF.NearLitterBehaviour.allOuterAtoms` defines a set of `ConNF.Atom`s, which are atoms in the context of Constructive Ordinal Notation (ConNF). This set is constructed by taking the union of the sets of outer atoms for each litter `L` that is present in the near litter behaviour `Î¾`, as determined by the condition `ConNF.NearLitterBehaviour.LitterPresent`."}
{"full_name": "ConNF.NearLitterBehaviour.litterPresent_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.litterPresent_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.litterPresent_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {L : ConNF.Litter | ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L}", "code": "theorem litterPresent_small (Î¾ : NearLitterBehaviour) : Small {L | Î¾.LitterPresent L} := by\n  have : Small (â‹ƒ (N : NearLitter) (_ : (Î¾.nearLitterMap N).Dom), {N.1})\n  Â· refine Small.bUnion Î¾.nearLitterMap_dom_small ?_\n    simp only [PFun.mem_dom, small_singleton, forall_exists_index, implies_true, forall_const]\n  refine Small.mono ?_ this\n  simp only [LitterPresent]\n  rintro _ âŸ¨N, hN, rflâŸ©\n  exact âŸ¨_, âŸ¨N, rflâŸ©, _, âŸ¨hN, rflâŸ©, rflâŸ©\n", "additional_info": "", "used_premises": [1, 233, 838], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [178, 186], "informalization": "The theorem `ConNF.NearLitterBehaviour.litterPresent_small` states that the set of litters `L` for which there exists a near litter `N` such that the near litter map `Î¾.nearLitterMap N` is defined and the first component of `N` is equal to `L`, has a cardinality strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterBehaviour.litterPresent_small'", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.litterPresent_small'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.litterPresent_small' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— {N : ConNF.NearLitter | ConNF.NearLitter.IsLitterğŸ”—<|PREMISE|>ğŸ”— N âˆ§ âˆƒ (N' : ConNF.NearLitter), (Î¾.nearLitterMap N').Dom âˆ§ N'.fst = N.fst}", "code": "theorem litterPresent_small' (Î¾ : NearLitterBehaviour) :\n    Small {N : NearLitter | N.IsLitter âˆ§ âˆƒ N', (nearLitterMap Î¾ N').Dom âˆ§ N'.fst = N.fst} := by\n  have : Small {L | âˆƒ N, (nearLitterMap Î¾ N).Dom âˆ§ N.fst = L}\n  Â· refine (Î¾.nearLitterMap_dom_small.image (f := fun N => N.1)).mono ?_\n    rintro _ âŸ¨N, hN, rflâŸ©\n    exact âŸ¨N, hN, rflâŸ©\n  refine (this.image (f := Litter.toNearLitter)).mono ?_\n  rintro _ âŸ¨âŸ¨LâŸ©, N, hN, rflâŸ©\n  refine âŸ¨N.1, âŸ¨N, hN, rflâŸ©, rflâŸ©\n", "additional_info": "", "used_premises": [1, 233, 495], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [187, 196], "informalization": "The theorem `ConNF.NearLitterBehaviour.litterPresent_small'` states that the set of near-litters that are of the form `L.toNearLitter` for some litter `L` and for which there exists a near-litter `N'` such that `Î¾.nearLitterMap N'` is defined and `N'.fst = N.fst`, has a cardinality that is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtoms_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtoms_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.innerAtoms_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L)", "code": "theorem innerAtoms_small {Î¾ : NearLitterBehaviour} (L : Litter) (hL : Î¾.LitterPresent L) :\n    Small (Î¾.innerAtoms L) := by\n  obtain âŸ¨N, hN, rflâŸ© := hL\n  refine Small.mono (biInter_subset_of_mem âŸ¨hN, rflâŸ©) ?_\n  exact Small.mono (fun _ => Or.inr) N.2.prop\n", "additional_info": "", "used_premises": [1, 838, 233, 1265], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [197, 202], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtoms_small` proves that the inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF) are small, meaning their cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterBehaviour.outerAtoms_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtoms_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.outerAtoms_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.outerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L)", "code": "theorem outerAtoms_small {Î¾ : NearLitterBehaviour} (L : Litter) (hL : Î¾.LitterPresent L) :\n    Small (Î¾.outerAtoms L) := by\n  obtain âŸ¨N, hN, rflâŸ© := hL\n  rw [outerAtoms]\n  refine Small.mono ?_ (Small.mono (fun _ => Or.inl) N.2.prop)\n  refine Set.diff_subset_diff_right ?_\n  intro a ha\n  exact âŸ¨_, âŸ¨N, rflâŸ©, _, âŸ¨hN, rflâŸ©, haâŸ©\n", "additional_info": "", "used_premises": [1, 838, 233, 1267], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [203, 211], "informalization": "The theorem `ConNF.NearLitterBehaviour.outerAtoms_small` states that the set of outer atoms of a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterBehaviour.allOuterAtoms_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.allOuterAtoms_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.allOuterAtoms_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.allOuterAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾)", "code": "theorem allOuterAtoms_small {Î¾ : NearLitterBehaviour} : Small Î¾.allOuterAtoms :=\n  Small.bUnion Î¾.litterPresent_small Î¾.outerAtoms_small\n", "additional_info": "", "used_premises": [1, 233, 1269], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [212, 214], "informalization": "The theorem `ConNF.NearLitterBehaviour.allOuterAtoms_small` states that the set of all outer atoms in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtomsCod_subset", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsCod_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.innerAtomsCod_subset [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (N : ConNF.NearLitter) (hN : (Î¾.nearLitterMap N).Dom) :ConNF.NearLitterBehaviour.innerAtomsCodğŸ”—<|PREMISE|>ğŸ”— Î¾ N.fst âŠ† â†‘((Î¾.nearLitterMap N).get hN)", "code": "theorem innerAtomsCod_subset (Î¾ : NearLitterBehaviour)\n    (N : NearLitter) (hN : (Î¾.nearLitterMap N).Dom) :\n    Î¾.innerAtomsCod N.1 âŠ† (Î¾.nearLitterMap N).get hN := by\n  intro a ha\n  refine ha.1 _ âŸ¨N, subset_antisymm ?_ ?_âŸ©\n  Â· intro a' ha'\n    exact ha' _ âŸ¨âŸ¨hN, rflâŸ©, rflâŸ©\n  Â· rintro a' ha' _ âŸ¨_, rflâŸ©\n    exact ha'\n", "additional_info": "", "used_premises": [1, 1276], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [226, 235], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtomsCod` computes the set of inner atoms for a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is defined as the intersection of the images of all near litters `N` that map to `L` under `Î¾.nearLitterMap`, excluding the range of `Î¾.atomMap`. The theorem `ConNF.NearLitterBehaviour.innerAtomsCod_subset` states that the set of inner atoms for a given litter `L` is a subset of the image of any near litter `N` that maps to `L` under `Î¾.nearLitterMap`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtomsCod", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsCod", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.innerAtomsCod [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (L : ConNF.Litter) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def innerAtomsCod (Î¾ : NearLitterBehaviour) (L : Litter) : Set Atom :=\n  (â‹‚ (N : NearLitter) (hN : (Î¾.nearLitterMap N).Dom âˆ§ N.1 = L), (Î¾.nearLitterMap N).get hN.1) \\\n    Î¾.atomMap.ran\n", "additional_info": "The codomain for the inner atoms.\nEquations\n* ğŸ—ŸConNF.NearLitterBehaviour.innerAtomsCodğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsCodğŸ”—  Î¾ L ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  (â‹‚ (N : ConNF.NearLitter), â‹‚ (hN : (Î¾.nearLitterMap N).Dom ğŸ—Ÿâˆ§ğŸ—ŸğŸ”—../../.././Init/Prelude.html#AndğŸ”—  N.fst ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  L), â†‘((Î¾.nearLitterMap N).get â‹¯)) ğŸ—Ÿ\\ğŸ—ŸğŸ”—../../.././Init/Core.html#SDiff.sdiffğŸ”—  ğŸ—ŸPFun.ranğŸ—ŸğŸ”—../../.././Mathlib/Data/PFun.html#PFun.ranğŸ”—  Î¾.atomMap\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [216, 219], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtomsCod` computes the set of inner atoms for a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is defined as the intersection of the images of all near litters `N` that map to `L` under `Î¾.nearLitterMap`, excluding the range of `Î¾.atomMap`."}
{"full_name": "ConNF.NearLitterBehaviour.mk_innerAtomsCod", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mk_innerAtomsCod", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mk_innerAtomsCod [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.NearLitterBehaviour.innerAtomsCodğŸ”—<|PREMISE|>ğŸ”— Î¾ L) = Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— ConNF.Îº", "code": "theorem mk_innerAtomsCod {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    (L : Litter) (hL : Î¾.LitterPresent L) : #(Î¾.innerAtomsCod L) = #Îº := by\n  obtain âŸ¨N, hN, rflâŸ© := hL\n  refine le_antisymm ?_ ?_\n  Â· refine (mk_le_mk_of_subset (Î¾.innerAtomsCod_subset N hN)).trans ?_\n    simp only [SetLike.coe_sort_coe, mk_nearLitter'', le_refl]\n  Â· rw [innerAtomsCod_eq N hN]\n    by_contra! h\n    have := Small.union h (Î¾.innerAtomsCod_eq_aux hÎ¾ N hN)\n    rw [diff_union_self] at this\n    refine (Small.mono (fun _ => Or.inl) this).not_le ?_\n    simp only [SetLike.coe_sort_coe, mk_nearLitter'', le_refl]\n", "additional_info": "", "used_premises": [1, 823, 838, 29, 1276, 29], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [271, 283], "informalization": "The function `ConNF.NearLitterBehaviour.innerAtomsCod` computes the set of inner atoms for a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is defined as the intersection of the images of all near litters `N` that map to `L` under `Î¾.nearLitterMap`, excluding the range of `Î¾.atomMap`. The theorem `ConNF.NearLitterBehaviour.mk_innerAtomsCod` states that the cardinality of the set of inner atoms for `L` is equal to the cardinality of `ConNF.Îº`."}
{"full_name": "ConNF.NearLitterBehaviour.mk_innerAtoms_lt", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mk_innerAtoms_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mk_innerAtoms_lt [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L) :Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L) < Cardinal.mkğŸ”—<|PREMISE|>ğŸ”— â†‘(ConNF.NearLitterBehaviour.innerAtomsCodğŸ”—<|PREMISE|>ğŸ”— Î¾ L)", "code": "theorem mk_innerAtoms_lt {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    (L : Litter) (hL : Î¾.LitterPresent L) :\n    #(Î¾.innerAtoms L) < #(Î¾.innerAtomsCod L) := by\n  rw [mk_innerAtomsCod hÎ¾ L hL]\n  exact Î¾.innerAtoms_small L hL\n", "additional_info": "", "used_premises": [1, 823, 838, 29, 1265, 29, 1276], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [284, 289], "informalization": "The theorem `ConNF.NearLitterBehaviour.mk_innerAtoms_lt` states that the cardinality of the set of inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF) is strictly less than the cardinality of the set of inner atoms for `L`, excluding the range of the atom map."}
{"full_name": "ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (a : ConNF.Atom) (ha : Â¬ (Î¾.atomMap a).Dom) {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} (hLâ‚ : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ Lâ‚) (hLâ‚‚ : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ Lâ‚‚) (haâ‚ : a âˆˆ ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ Lâ‚) (haâ‚‚ : a âˆˆ ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ Lâ‚‚) :Lâ‚ = Lâ‚‚", "code": "theorem eq_of_mem_innerAtoms {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful) (a : Atom)\n    (ha : Â¬(Î¾.atomMap a).Dom) {Lâ‚ Lâ‚‚ : Litter}\n    (hLâ‚ : Î¾.LitterPresent Lâ‚) (hLâ‚‚ : Î¾.LitterPresent Lâ‚‚)\n    (haâ‚ : a âˆˆ Î¾.innerAtoms Lâ‚) (haâ‚‚ : a âˆˆ Î¾.innerAtoms Lâ‚‚) : Lâ‚ = Lâ‚‚ := by\n  rw [mem_innerAtoms_iff Lâ‚ hLâ‚] at haâ‚\n  rw [mem_innerAtoms_iff Lâ‚‚ hLâ‚‚] at haâ‚‚\n  obtain âŸ¨Nâ‚, hNâ‚, rflâŸ© := hLâ‚\n  obtain âŸ¨Nâ‚‚, hNâ‚‚, rflâŸ© := hLâ‚‚\n  have hâ‚ := haâ‚.2 Nâ‚ âŸ¨hNâ‚, rflâŸ©\n  have hâ‚‚ := haâ‚‚.2 Nâ‚‚ âŸ¨hNâ‚‚, rflâŸ©\n  by_contra h\n  exact ha (hÎ¾.dom_of_mem_inter a h hNâ‚ hNâ‚‚ âŸ¨hâ‚, hâ‚‚âŸ©)\n", "additional_info": "", "used_premises": [1, 823, 838, 838, 1265, 1265], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [300, 312], "informalization": "The theorem `ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms` states that if `a` is an inner atom of two near litters `Lâ‚` and `Lâ‚‚`, then `Lâ‚` must be equal to `Lâ‚‚`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (a : ConNF.Atom) {L : ConNF.Litter} (hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L) (haâ‚ : a âˆˆ ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L) (haâ‚‚ : a âˆˆ ConNF.NearLitterBehaviour.allOuterAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾) :FalseğŸ”—<|PREMISE|>ğŸ”—", "code": "theorem innerAtoms_allOuterAtoms {Î¾ : NearLitterBehaviour} (a : Atom)\n    {L : Litter} (hL : Î¾.LitterPresent L)\n    (haâ‚ : a âˆˆ Î¾.innerAtoms L) (haâ‚‚ : a âˆˆ Î¾.allOuterAtoms) : False := by\n  rw [mem_innerAtoms_iff L hL] at haâ‚\n  rw [mem_allOuterAtoms_iff] at haâ‚‚\n  obtain âŸ¨N, hN, rflâŸ© := hL\n  refine haâ‚‚.2 N hN (haâ‚.2 N âŸ¨hN, rflâŸ©)\n", "additional_info": "", "used_premises": [1, 838, 1265, 1269, 891], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [313, 320], "informalization": "The theorem `ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms` states that in the context of Constructive Ordinal Notation (ConNF), given a near litter behaviour `Î¾`, an atom `a`, and a litter `L` that is present in `Î¾`, if `a` is an inner atom of `L` and `a` is also an outer atom of `Î¾`, then there is a logical contradiction, represented by `False`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_dom_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_dom_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_dom_small [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.SmallğŸ”—<|PREMISE|>ğŸ”— (PFun.DomğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾))", "code": "theorem extraAtomMap_dom_small (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) :\n    Small (Î¾.extraAtomMap hÎ¾).Dom := by\n  refine Small.union Î¾.atomMap_dom_small (Small.union ?_ Î¾.allOuterAtoms_small)\n  suffices : Small (â‹ƒ (L : Litter) (_ :  Î¾.LitterPresent L), Î¾.innerAtoms L)\n  Â· refine Small.mono ?_ this\n    rintro a âŸ¨L, hL, haâŸ©\n    exact âŸ¨_, âŸ¨L, rflâŸ©, _, âŸ¨hL, rflâŸ©, haâŸ©\n  refine Small.bUnion Î¾.litterPresent_small ?_\n  intro L hL\n  exact Î¾.innerAtoms_small L hL\n", "additional_info": "", "used_premises": [1, 823, 233, 404, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [329, 339], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_dom_small` states that the domain of the partial function `ConNF.NearLitterBehaviour.extraAtomMap`, which is used to extend the domain of the near-litter-behaviour's atom map, is strictly less than the cardinality of the type `ConNF.Îº` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterBehaviour.extraAtomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.Atom â†’. ConNF.Atom", "code": "noncomputable def extraAtomMap (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) : Atom â†’. Atom :=\n  fun a => âŸ¨\n    (Î¾.atomMap a).Dom âˆ¨ (âˆƒ L, Î¾.LitterPresent L âˆ§ a âˆˆ Î¾.innerAtoms L) âˆ¨\n      a âˆˆ Î¾.allOuterAtoms,\n    fun h => h.elim' (Î¾.atomMap a).get (fun h => h.elim'\n      (fun h => Î¾.innerAtomsEmbedding hÎ¾ _ h.choose_spec.1 âŸ¨a, h.choose_spec.2âŸ©)\n      (fun h => Î¾.outerAtomsEmbedding âŸ¨a, hâŸ©))âŸ©\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 823], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [321, 328], "informalization": "Function `ConNF.NearLitterBehaviour.extraAtomMap` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a lawful near-litter-behaviour `Î¾` and returns a partial function from `ConNF.Atom` to `ConNF.Atom`. This function is used to extend the domain of the near-litter-behaviour's atom map, ensuring that every `ConNF.Atom` has an image under the atom map."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} {a : ConNF.Atom} (ha : (Î¾.atomMap a).Dom) {L : ConNF.Litter} {hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L} (b : â†‘(ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L)) :(Î¾.atomMap a).get ha â‰  â†‘((ConNF.NearLitterBehaviour.innerAtomsEmbeddingğŸ”—<|PREMISE|>ğŸ”— hÎ¾ L hL) b)", "code": "theorem innerAtomsEmbedding_ne_atomMap {Î¾ : NearLitterBehaviour} {hÎ¾ : Î¾.Lawful}\n    {a : Atom} (ha : (Î¾.atomMap a).Dom)\n    {L : Litter} {hL : Î¾.LitterPresent L} (b : Î¾.innerAtoms L) :\n    (Î¾.atomMap a).get ha â‰  Î¾.innerAtomsEmbedding hÎ¾ L hL b := by\n  intro h\n  have := (Î¾.innerAtomsEmbedding hÎ¾ L hL b).prop\n  rw [â† h] at this\n  exact this.2 âŸ¨a, ha, rflâŸ©\n", "additional_info": "", "used_premises": [1, 823, 838, 1265, 1284], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [369, 377], "informalization": "The theorem `ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap` in Lean 4 states that the atom map of an atom `a` is not equal to the inner atoms embedding of a near litter `L` for any inner atom `b` in the set of inner atoms of `L`. This is part of the correctness proof for the inner atoms definition in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtomsEmbedding", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsEmbedding", "code_src": "con-nf", "ptype": "noncomputable def", "header": "@[irreducible]noncomputable def ConNF.NearLitterBehaviour.innerAtomsEmbedding [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L) :â†‘(ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L) â†ª â†‘(ConNF.NearLitterBehaviour.innerAtomsCodğŸ”—<|PREMISE|>ğŸ”— Î¾ L)", "code": "noncomputable irreducible_def innerAtomsEmbedding {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    (L : Litter) (hL : Î¾.LitterPresent L) :\n    Î¾.innerAtoms L â†ª Î¾.innerAtomsCod L :=\n  ((Cardinal.le_def _ _).mp (mk_innerAtoms_lt hÎ¾ L hL).le).some\n", "additional_info": "Equations\n* @ğŸ—ŸConNF.NearLitterBehaviour.innerAtomsEmbeddingğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsEmbeddingğŸ”— ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.NearLitterBehaviour.wrappedâœğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.wrapped._@.ConNF.FOA.Behaviour.NearLitterBehaviour._hyg.3119ğŸ”— .1\n\n", "used_premises": [1, 823, 838, 1265, 1276], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [290, 294], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtomsEmbedding` defines an embedding from the set of inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF) to the set of inner atoms for `L`, excluding the range of the atom map."}
{"full_name": "ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {a : ConNF.Atom} (ha : (Î¾.atomMap a).Dom) (b : â†‘(ConNF.NearLitterBehaviour.allOuterAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾)) :(Î¾.atomMap a).get ha â‰  â†‘((ConNF.NearLitterBehaviour.outerAtomsEmbeddingğŸ”—<|PREMISE|>ğŸ”— Î¾) b)", "code": "theorem outerAtomsEmbedding_ne_atomMap {Î¾ : NearLitterBehaviour}\n    {a : Atom} (ha : (Î¾.atomMap a).Dom) (b : Î¾.allOuterAtoms) :\n    (Î¾.atomMap a).get ha â‰  Î¾.outerAtomsEmbedding b := by\n  intro h\n  have := (Î¾.outerAtomsEmbedding b).prop\n  rw [â† h] at this\n  refine sandboxLitter_not_banned Î¾ ?_\n  rw [â† this]\n  exact BannedLitter.atomMap a ha\n", "additional_info": "", "used_premises": [1, 1269, 1286], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [378, 387], "informalization": "Function `ConNF.NearLitterBehaviour.outerAtomsEmbedding` defines an embedding from the set of all outer atoms in the context of Constructive Ordinal Notation (ConNF), as determined by the near litter behaviour `Î¾`, into the set of all atoms whose first projection is equal to the sandbox litter of `Î¾`. The theorem `ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap` states that for any atom `a` whose first projection is equal to the sandbox litter of `Î¾`, and any outer atom `b` in the context of `Î¾`, the image of `b` under the embedding is not equal to `a`."}
{"full_name": "ConNF.NearLitterBehaviour.outerAtomsEmbedding", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtomsEmbedding", "code_src": "con-nf", "ptype": "noncomputable def", "header": "@[irreducible]noncomputable def ConNF.NearLitterBehaviour.outerAtomsEmbedding [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) :â†‘(ConNF.NearLitterBehaviour.allOuterAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾) â†ª â†‘(ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.sandboxLitterğŸ”—<|PREMISE|>ğŸ”— Î¾))", "code": "noncomputable irreducible_def outerAtomsEmbedding (Î¾ : NearLitterBehaviour) :\n    Î¾.allOuterAtoms â†ª litterSet Î¾.sandboxLitter :=\n  ((Cardinal.le_def _ _).mp (allOuterAtoms_small.le.trans\n    (le_of_eq ((mk_litterSet _).symm)))).some\n", "additional_info": "Equations\n* @ğŸ—ŸConNF.NearLitterBehaviour.outerAtomsEmbeddingğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtomsEmbeddingğŸ”— ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.NearLitterBehaviour.wrappedâœğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.wrapped._@.ConNF.FOA.Behaviour.NearLitterBehaviour._hyg.3263ğŸ”— .1\n\n", "used_premises": [1, 1269, 467, 1263], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [295, 299], "informalization": "Function `ConNF.NearLitterBehaviour.outerAtomsEmbedding` defines an embedding from the set of all outer atoms in the context of Constructive Ordinal Notation (ConNF), as determined by the near litter behaviour `Î¾`, into the set of all atoms whose first projection is equal to the sandbox litter of `Î¾`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_injective", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_injective [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} â¦ƒa : ConNF.Atomâ¦„ â¦ƒb : ConNF.Atomâ¦„ (ha : (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ a).Dom) (hb : (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ b).Dom) (h : (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ a).get ha = (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ b).get hb) :a = b", "code": "theorem extraAtomMap_injective {Î¾ : NearLitterBehaviour} {hÎ¾ : Î¾.Lawful} â¦ƒa b : Atomâ¦„\n    (ha : (Î¾.extraAtomMap hÎ¾ a).Dom) (hb : (Î¾.extraAtomMap hÎ¾ b).Dom)\n    (h : (Î¾.extraAtomMap hÎ¾ a).get ha = (Î¾.extraAtomMap hÎ¾ b).get hb) : a = b := by\n  by_cases ha' : (Î¾.atomMap a).Dom <;> by_cases hb' : (Î¾.atomMap b).Dom\n  Â· rw [extraAtomMap_eq_of_dom a ha', extraAtomMap_eq_of_dom b hb'] at h\n    exact hÎ¾.atomMap_injective ha' hb' h\n  Â· obtain (hb | âŸ¨Lb, hLbâ‚, hLbâ‚‚âŸ© | hb) := hb\n    Â· cases hb' hb\n    Â· rw [extraAtomMap_eq_of_dom a ha', extraAtomMap_eq_of_innerAtoms b hb' Lb hLbâ‚ hLbâ‚‚] at h\n      cases innerAtomsEmbedding_ne_atomMap _ _ h\n    Â· rw [extraAtomMap_eq_of_dom a ha', extraAtomMap_eq_of_allOuterAtoms b hb' hb] at h\n      cases outerAtomsEmbedding_ne_atomMap _ _ h\n  Â· obtain (ha | âŸ¨La, hLaâ‚, hLaâ‚‚âŸ© | ha) := ha\n    Â· cases ha' ha\n    Â· rw [extraAtomMap_eq_of_innerAtoms a ha' La hLaâ‚ hLaâ‚‚, extraAtomMap_eq_of_dom b hb'] at h\n      cases innerAtomsEmbedding_ne_atomMap _ _ h.symm\n    Â· rw [extraAtomMap_eq_of_allOuterAtoms a ha' ha, extraAtomMap_eq_of_dom b hb'] at h\n      cases outerAtomsEmbedding_ne_atomMap _ _ h.symm\n  Â· obtain (ha | âŸ¨La, hLaâ‚, hLaâ‚‚âŸ© | ha) := ha\n    Â· cases ha' ha\n    Â· obtain (hb | âŸ¨Lb, hLbâ‚, hLbâ‚‚âŸ© | hb) := hb\n      Â· cases hb' hb\n      Â· rw [extraAtomMap_eq_of_innerAtoms a ha' La hLaâ‚ hLaâ‚‚,\n          extraAtomMap_eq_of_innerAtoms b hb' Lb hLbâ‚ hLbâ‚‚] at h\n        cases innerAtomsEmbedding_disjoint _ _ h\n        cases (EmbeddingLike.apply_eq_iff_eq _).mp (Subtype.coe_injective h)\n        rfl\n      Â· rw [extraAtomMap_eq_of_innerAtoms a ha' La hLaâ‚ hLaâ‚‚,\n          extraAtomMap_eq_of_allOuterAtoms b hb' hb] at h\n        cases innerAtomsEmbedding_ne_outerAtomsEmbedding _ _ h\n    Â· obtain (hb | âŸ¨Lb, hLbâ‚, hLbâ‚‚âŸ© | hb) := hb\n      Â· cases hb' hb\n      Â· rw [extraAtomMap_eq_of_allOuterAtoms a ha' ha,\n          extraAtomMap_eq_of_innerAtoms b hb' Lb hLbâ‚ hLbâ‚‚] at h\n        cases innerAtomsEmbedding_ne_outerAtomsEmbedding _ _ h.symm\n      Â· rw [extraAtomMap_eq_of_allOuterAtoms a ha' ha,\n          extraAtomMap_eq_of_allOuterAtoms b hb' hb] at h\n        cases (EmbeddingLike.apply_eq_iff_eq _).mp (Subtype.coe_injective h)\n        rfl\n", "additional_info": "", "used_premises": [1, 823, 1282, 1282, 1282, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [416, 455], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_injective` states that the `extraAtomMap` function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4 is injective. This function is used to extend the domain of the near-litter-behaviour's atom map, ensuring that every `ConNF.Atom` has an image under the atom map."}
{"full_name": "ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) {a : ConNF.Atom} {L : ConNF.Litter} (hL : ConNF.NearLitterBehaviour.LitterPresentğŸ”—<|PREMISE|>ğŸ”— Î¾ L) (ha' : Â¬ (Î¾.atomMap a).Dom) (ha : a âˆˆ ConNF.NearLitterBehaviour.innerAtomsğŸ”—<|PREMISE|>ğŸ”— Î¾ L) {N : ConNF.NearLitter} (hN : (Î¾.nearLitterMap N).Dom) :a âˆˆ N â†” N.fst = L", "code": "theorem mem_iff_of_mem_innerAtoms {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    {a : Atom} {L : Litter} (hL : Î¾.LitterPresent L)\n    (ha' : Â¬(Î¾.atomMap a).Dom) (ha : a âˆˆ Î¾.innerAtoms L)\n    {N : NearLitter} (hN : (Î¾.nearLitterMap N).Dom) :\n    a âˆˆ N â†” N.1 = L := by\n  constructor\n  Â· intro h\n    obtain âŸ¨N', hN', rflâŸ© := hL\n    have := ha _ âŸ¨N', rflâŸ© _ âŸ¨âŸ¨hN', rflâŸ©, rflâŸ©\n    by_contra! hNN'\n    exact ha' (hÎ¾.dom_of_mem_inter _ hNN' hN hN' âŸ¨h, this.1âŸ©)\n  Â· rintro rfl\n    exact (ha _ âŸ¨N, rflâŸ© _ âŸ¨âŸ¨hN, rflâŸ©, rflâŸ©).1\n", "additional_info": "", "used_premises": [1, 823, 838, 1265], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [456, 469], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms` states that for a lawful near-litter-behaviour `Î¾`, an atom `a` is a member of a near-litter `N` if and only if the first component of `N` is equal to the given litter `L`, provided that `a` is not in the domain of the atom map `Î¾.atomMap`, `a` is in the inner atoms of `L`, and the near-litter map `Î¾.nearLitterMap N` is defined."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_mem_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_mem_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} â¦ƒa : ConNF.Atomâ¦„ (ha : (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ a).Dom) â¦ƒN : ConNF.NearLitterâ¦„ (hN : (Î¾.nearLitterMap N).Dom) :(ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ a).get ha âˆˆ (Î¾.nearLitterMap N).get hN â†” a âˆˆ N", "code": "theorem extraAtomMap_mem_iff {Î¾ : NearLitterBehaviour} {hÎ¾ : Î¾.Lawful}\n    â¦ƒa : Atomâ¦„ (ha : (Î¾.extraAtomMap hÎ¾ a).Dom)\n    â¦ƒN : NearLitterâ¦„ (hN : (Î¾.nearLitterMap N).Dom) :\n    (Î¾.extraAtomMap hÎ¾ a).get ha âˆˆ (Î¾.nearLitterMap N).get hN â†” a âˆˆ N := by\n  by_cases ha' : (Î¾.atomMap a).Dom\n  Â· rw [extraAtomMap_eq_of_dom a ha']\n    exact hÎ¾.atom_mem_iff ha' hN\n  obtain (ha | âŸ¨L, hLâ‚, hLâ‚‚âŸ© | ha) := ha\n  Â· cases ha' ha\n  Â· rw [extraAtomMap_eq_of_innerAtoms a ha' L hLâ‚ hLâ‚‚,\n      mem_iff_of_mem_innerAtoms hÎ¾ hLâ‚ ha' hLâ‚‚ hN]\n    obtain âŸ¨N', hN', rflâŸ© := hLâ‚\n    constructor\n    Â· intro h\n      by_contra hNN'\n      have ha := (innerAtomsEmbedding hÎ¾ N'.1 âŸ¨N', hN', rflâŸ© âŸ¨a, hLâ‚‚âŸ©).prop.1\n        _ âŸ¨N', rflâŸ© _ âŸ¨âŸ¨hN', rflâŸ©, rflâŸ©\n      exact (innerAtomsEmbedding hÎ¾ N'.1 âŸ¨N', hN', rflâŸ© âŸ¨a, hLâ‚‚âŸ©).prop.2\n        (hÎ¾.ran_of_mem_inter _ hNN' hN hN' âŸ¨h, haâŸ©)\n    Â· intro h\n      exact (innerAtomsEmbedding hÎ¾ N'.1 âŸ¨N', hN', rflâŸ© âŸ¨a, hLâ‚‚âŸ©).prop.1\n        _ âŸ¨N, rflâŸ© _ âŸ¨âŸ¨hN, hâŸ©, rflâŸ©\n  Â· rw [extraAtomMap_eq_of_allOuterAtoms a ha' ha]\n    constructor\n    Â· intro h\n      have := bannedLitter_of_mem _ _ _ h\n      rw [(Î¾.outerAtomsEmbedding âŸ¨a, haâŸ©).prop] at this\n      cases Î¾.sandboxLitter_not_banned this\n    Â· intro h\n      obtain âŸ¨_, âŸ¨L, rflâŸ©, _, âŸ¨hL, rflâŸ©, haâŸ© := ha\n      cases ha.2 âŸ¨_, âŸ¨N, rflâŸ©, _, âŸ¨hN, rflâŸ©, hâŸ©\n", "additional_info": "", "used_premises": [1, 823, 1282, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [470, 501], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_mem_iff` states that for a lawful near-litter-behaviour `Î¾`, an atom `a` belongs to a near-litter `N` if and only if the image of `a` under the extended atom map belongs to the image of `N` under the near-litter map."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) {N : ConNF.NearLitter} (hN : (Î¾.nearLitterMap N).Dom) {a : ConNF.Atom} (ha : a âˆˆ symmDiffğŸ”—<|PREMISE|>ğŸ”— (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— N.fst) â†‘N) :(ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ a).Dom", "code": "theorem extraAtomMap_dom_of_mem_symmDiff {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    {N : NearLitter} (hN : (Î¾.nearLitterMap N).Dom) {a : Atom} (ha : a âˆˆ litterSet N.1 âˆ† N) :\n    (Î¾.extraAtomMap hÎ¾ a).Dom := by\n  by_cases ha' : (Î¾.atomMap a).Dom\n  Â· exact Or.inl ha'\n  by_cases ha'' : âˆƒ N', (Î¾.nearLitterMap N').Dom âˆ§ a âˆˆ N'\n  Â· obtain âŸ¨N', hN', haN'âŸ© := ha''\n    refine Or.inr (Or.inl ?_)\n    refine âŸ¨N'.1, âŸ¨N', hN', rflâŸ©, ?_âŸ©\n    rw [mem_innerAtoms_iff _ âŸ¨N', hN', rflâŸ©]\n    have : âˆ€ N'', (Î¾.nearLitterMap N'').Dom âˆ§ N''.fst = N'.fst â†’ a âˆˆ N''\n    Â· intro N'' hN''\n      by_contra haN''\n      exact ha' (hÎ¾.dom_of_mem_symmDiff a hN''.2 hN''.1 hN' (Or.inr âŸ¨haN', haN''âŸ©))\n    refine âŸ¨?_, thisâŸ©\n    intro h\n    obtain (ha | ha) := ha\n    Â· refine ha.2 (this N âŸ¨hN, ?_âŸ©)\n      rw [â† ha.1, h]\n    Â· refine ha' (hÎ¾.dom_of_mem_inter a ?_ hN hN' âŸ¨ha.1, haN'âŸ©)\n      rw [â† h]\n      exact Ne.symm ha.2\n  Â· push_neg at ha''\n    refine Or.inr (Or.inr ?_)\n    simp only [mem_allOuterAtoms_iff]\n    refine âŸ¨?_, ha''âŸ©\n    obtain (ha | ha) := ha\n    Â· rw [ha.1]\n      exact âŸ¨N, hN, rflâŸ©\n    Â· cases ha'' N hN ha.1\n", "additional_info": "", "used_premises": [1, 823, 62, 467, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [502, 532], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff` is a result in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if `Î¾` is a lawful near-litter-behaviour, `N` is a near-litter, and `a` is an atom that belongs to the symmetric difference of the litter set of `N`'s first projection and `N` itself, then the domain of `ConNF.NearLitterBehaviour.extraAtomMap Î¾ hÎ¾ a` is nonempty, meaning `a` has an image under the extended atom map."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_inter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_inter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) {N : ConNF.NearLitter} (hN : (Î¾.nearLitterMap N).Dom) {L : ConNF.Litter} (h : N.fst â‰  L) {a : ConNF.Atom} (haâ‚ : a âˆˆ N) (haâ‚‚ : a.1 = L) :(ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ a).Dom", "code": "theorem extraAtomMap_dom_of_mem_inter {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    {N : NearLitter} (hN : (Î¾.nearLitterMap N).Dom) {L : Litter}\n    (h : N.1 â‰  L) {a : Atom} (haâ‚ : a âˆˆ N) (haâ‚‚ : a.1 = L) :\n    (Î¾.extraAtomMap hÎ¾ a).Dom := by\n  by_cases ha' : (Î¾.atomMap a).Dom\n  Â· exact Or.inl ha'\n  refine Or.inr (Or.inl âŸ¨_, âŸ¨N, hN, rflâŸ©, ?_âŸ©)\n  rw [mem_innerAtoms_iff _ âŸ¨N, hN, rflâŸ©]\n  constructor\n  Â· rw [haâ‚‚]\n    exact h.symm\n  Â· intro N' hN'\n    by_contra ha''\n    exact ha' (hÎ¾.dom_of_mem_symmDiff a hN'.2 hN'.1 hN (Or.inr âŸ¨haâ‚, ha''âŸ©))\n", "additional_info": "", "used_premises": [1, 823, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [533, 547], "informalization": "Given a lawful near-litter-behaviour $\\xi$, an extension of the near-litter-behaviour's atom map is defined to ensure that every `ConNF.Atom` has an image under the atom map. The theorem states that if an atom `a` belongs to a near-litter `N` with a different source litter `L`, and `a`'s source is equal to `L`, then the domain of the extended atom map is nonempty for `a`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'_subset", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap'_subset [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} {Nâ‚ : ConNF.NearLitter} {Nâ‚‚ : ConNF.NearLitter} (h : Nâ‚.fst = Nâ‚‚.fst) (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) :ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚ hNâ‚ âŠ† ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚‚ hNâ‚‚", "code": "theorem extraLitterMap'_subset {Î¾ : NearLitterBehaviour} {hÎ¾ : Î¾.Lawful}\n    {Nâ‚ Nâ‚‚ : NearLitter} (h : Nâ‚.1 = Nâ‚‚.1)\n    (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) :\n    Î¾.extraLitterMap' hÎ¾ Nâ‚ hNâ‚ âŠ† Î¾.extraLitterMap' hÎ¾ Nâ‚‚ hNâ‚‚ := by\n  rintro a (âŸ¨haâ‚, haâ‚‚âŸ© | âŸ¨haâ‚, haâ‚‚âŸ©)\n  Â· simp only [mem_iUnion, mem_singleton_iff, not_exists] at haâ‚‚\n    by_cases haâ‚ƒ : a âˆˆ (Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚\n    Â· refine Or.inl âŸ¨haâ‚ƒ, ?_âŸ©\n      simp only [mem_iUnion, mem_singleton_iff, not_exists]\n      rintro a ha rfl\n      simp only [SetLike.mem_coe, extraAtomMap_mem_iff] at haâ‚ haâ‚ƒ\n      obtain (ha | ha) := ha\n      Â· cases ha.2 haâ‚ƒ\n      Â· refine haâ‚‚ a (Or.inr âŸ¨haâ‚, ?_âŸ©) rfl\n        rw [h]\n        exact ha.2\n    Â· obtain âŸ¨a, ha', rflâŸ© := hÎ¾.ran_of_mem_symmDiff a h hNâ‚ hNâ‚‚ (Or.inl âŸ¨haâ‚, haâ‚ƒâŸ©)\n      refine Or.inr âŸ¨?_, haâ‚ƒâŸ©\n      simp only [mem_iUnion, mem_singleton_iff]\n      simp only [SetLike.mem_coe, hÎ¾.atom_mem_iff] at haâ‚ haâ‚ƒ\n      have haâ‚„ : a.1 = Nâ‚.1\n      Â· by_contra haâ‚„\n        refine haâ‚‚ a (Or.inr âŸ¨haâ‚, haâ‚„âŸ©) ?_\n        rw [extraAtomMap_eq_of_dom]\n      refine âŸ¨a, Or.inl âŸ¨haâ‚„.trans h, haâ‚ƒâŸ©, ?_âŸ©\n      rw [extraAtomMap_eq_of_dom _ ha']\n  Â· simp only [mem_iUnion, mem_singleton_iff] at haâ‚\n    obtain âŸ¨a, haâ‚, rflâŸ© := haâ‚\n    rw [SetLike.mem_coe, extraAtomMap_mem_iff] at haâ‚‚\n    obtain (âŸ¨haâ‚, -âŸ© | âŸ¨haâ‚, -âŸ©) := haâ‚\n    Â· by_cases haâ‚ƒ : a âˆˆ Nâ‚‚\n      Â· refine Or.inl âŸ¨?_, ?_âŸ©\n        Â· rw [SetLike.mem_coe, extraAtomMap_mem_iff]\n          exact haâ‚ƒ\n        Â· simp only [mem_iUnion, mem_singleton_iff, not_exists]\n          intro b hb hab\n          cases extraAtomMap_injective _ _ hab\n          obtain (hb | hb) := hb\n          Â· cases hb.2 haâ‚ƒ\n          Â· rw [h] at haâ‚\n            cases hb.2 haâ‚\n      Â· refine Or.inr âŸ¨?_, ?_âŸ©\n        Â· simp only [mem_iUnion, mem_singleton_iff]\n          refine âŸ¨a, Or.inl âŸ¨?_, haâ‚ƒâŸ©, rflâŸ©\n          rw [â† h]\n          exact haâ‚\n        Â· rw [SetLike.mem_coe, extraAtomMap_mem_iff]\n          exact haâ‚ƒ\n    Â· cases haâ‚‚ haâ‚\n", "additional_info": "", "used_premises": [1, 823, 1293, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [554, 603], "informalization": "Given a lawful near-litter-behaviour `Î¾`, two near-litters `Nâ‚` and `Nâ‚‚` with the same litter set, and proofs that both `Nâ‚` and `Nâ‚‚` are in the domain of the near-litter map of `Î¾`, the extra litter map of `Nâ‚` is a subset of the extra litter map of `Nâ‚‚`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.extraLitterMap' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (N : ConNF.NearLitter) (hN : (Î¾.nearLitterMap N).Dom) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def extraLitterMap' (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful)\n    (N : NearLitter) (hN : (Î¾.nearLitterMap N).Dom) : Set Atom :=\n  (Î¾.nearLitterMap N).get hN âˆ†\n    â‹ƒ (a : Atom) (ha : a âˆˆ litterSet N.1 âˆ† N),\n      {(Î¾.extraAtomMap hÎ¾ a).get (extraAtomMap_dom_of_mem_symmDiff hÎ¾ hN ha)}\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 823, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [548, 553], "informalization": "The Lean 4 object `ConNF.NearLitterBehaviour.extraLitterMap'` is a function that, given a lawful near-litter-behaviour `Î¾`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `Î¾`, returns a set of atoms. This set is defined as the symmetric difference of the image of `N` under the near-litter map of `Î¾` and the union of the images of the atoms in the symmetric difference of the litter set of `N` and `N` itself, under the extra-atom map of `Î¾`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'_eq", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap'_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} {Nâ‚ : ConNF.NearLitter} {Nâ‚‚ : ConNF.NearLitter} (h : Nâ‚.fst = Nâ‚‚.fst) (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) :ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚ hNâ‚ = ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚‚ hNâ‚‚", "code": "theorem extraLitterMap'_eq {Î¾ : NearLitterBehaviour} {hÎ¾ : Î¾.Lawful}\n    {Nâ‚ Nâ‚‚ : NearLitter} (h : Nâ‚.1 = Nâ‚‚.1)\n    (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) :\n    Î¾.extraLitterMap' hÎ¾ Nâ‚ hNâ‚ = Î¾.extraLitterMap' hÎ¾ Nâ‚‚ hNâ‚‚ :=\n  subset_antisymm (extraLitterMap'_subset h hNâ‚ hNâ‚‚) (extraLitterMap'_subset h.symm hNâ‚‚ hNâ‚)\n", "additional_info": "", "used_premises": [1, 823, 1293, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [604, 609], "informalization": "Given a lawful near-litter-behaviour `Î¾`, two near-litters `Nâ‚` and `Nâ‚‚` with the same litter set, and proofs that both `Nâ‚` and `Nâ‚‚` are in the domain of the near-litter map of `Î¾`, the function `ConNF.NearLitterBehaviour.extraLitterMap'` returns the same set of atoms for both `Nâ‚` and `Nâ‚‚`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'_isNearLitter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'_isNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap'_isNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) {N : ConNF.NearLitter} (hN : (Î¾.nearLitterMap N).Dom) :ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— ((Î¾.nearLitterMap N).get hN).fst (ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ N hN)", "code": "theorem extraLitterMap'_isNearLitter {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    {N : NearLitter} (hN : (Î¾.nearLitterMap N).Dom) :\n    IsNearLitter ((Î¾.nearLitterMap N).get hN).1 (Î¾.extraLitterMap' hÎ¾ N hN) := by\n  rw [extraLitterMap']\n  refine ((Î¾.nearLitterMap N).get hN).2.prop.trans ?_\n  erw [IsNear, symmDiff_symmDiff_cancel_left]\n  refine Small.bUnion N.2.prop ?_\n  intro a ha\n  exact small_singleton _\n", "additional_info": "", "used_premises": [1, 823, 466, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [610, 619], "informalization": "Given a lawful near-litter-behaviour `Î¾`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `Î¾`, the function `ConNF.NearLitterBehaviour.extraLitterMap' Î¾ hÎ¾ N hN` returns a set of atoms that is near the litter set of `N`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'_disjoint", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'_disjoint", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap'_disjoint [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} {Nâ‚ : ConNF.NearLitter} {Nâ‚‚ : ConNF.NearLitter} (h : Nâ‚.fst â‰  Nâ‚‚.fst) (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) (a : ConNF.Atom) :a âˆ‰ ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚ hNâ‚ âˆ© ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚‚ hNâ‚‚", "code": "theorem extraLitterMap'_disjoint {Î¾ : NearLitterBehaviour} {hÎ¾ : Î¾.Lawful}\n    {Nâ‚ Nâ‚‚ : NearLitter} (h : Nâ‚.1 â‰  Nâ‚‚.1)\n    (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) (a : Atom) :\n    a âˆ‰ Î¾.extraLitterMap' hÎ¾ Nâ‚ hNâ‚ âˆ© Î¾.extraLitterMap' hÎ¾ Nâ‚‚ hNâ‚‚ := by\n  intro h\n  simp only [extraLitterMap', mem_inter_iff] at h\n  obtain âŸ¨haâ‚ | haâ‚, haâ‚‚ | haâ‚‚âŸ© := h\n  Â· simp only [mem_diff, SetLike.mem_coe, mem_iUnion, mem_singleton_iff, not_exists] at haâ‚ haâ‚‚\n    obtain âŸ¨a, ha, rflâŸ© := hÎ¾.ran_of_mem_inter a h hNâ‚ hNâ‚‚ âŸ¨haâ‚.1, haâ‚‚.1âŸ©\n    rw [hÎ¾.atom_mem_iff] at haâ‚ haâ‚‚\n    by_cases haâ‚ƒ : a.1 = Nâ‚.1\n    Â· refine haâ‚‚.2 a (Or.inr âŸ¨haâ‚‚.1, ?_âŸ©) ?_\n      Â· rw [mem_litterSet, haâ‚ƒ]\n        exact h\n      Â· rw [extraAtomMap_eq_of_dom]\n    Â· refine haâ‚.2 a (Or.inr âŸ¨haâ‚.1, haâ‚ƒâŸ©) ?_\n      rw [extraAtomMap_eq_of_dom]\n  Â· simp only [mem_diff, SetLike.mem_coe, mem_iUnion, mem_singleton_iff, not_exists] at haâ‚\n    simp only [mem_diff, mem_iUnion, mem_singleton_iff, SetLike.mem_coe] at haâ‚‚\n    obtain âŸ¨âŸ¨b, hb, rflâŸ©, haâ‚‚âŸ© := haâ‚‚\n    rw [extraAtomMap_mem_iff] at haâ‚ haâ‚‚\n    refine haâ‚.2 b (Or.inr âŸ¨haâ‚.1, ?_âŸ©) rfl\n    obtain (hb | hb) := hb\n    Â· rw [mem_litterSet, hb.1]\n      exact h.symm\n    Â· cases haâ‚‚ hb.1\n  Â· simp only [mem_diff, SetLike.mem_coe, mem_iUnion, mem_singleton_iff, not_exists] at haâ‚‚\n    simp only [mem_diff, mem_iUnion, mem_singleton_iff, SetLike.mem_coe] at haâ‚\n    obtain âŸ¨âŸ¨b, hb, rflâŸ©, haâ‚âŸ© := haâ‚\n    rw [extraAtomMap_mem_iff] at haâ‚ haâ‚‚\n    refine haâ‚‚.2 b (Or.inr âŸ¨haâ‚‚.1, ?_âŸ©) rfl\n    obtain (hb | hb) := hb\n    Â· rw [mem_litterSet, hb.1]\n      exact h\n    Â· cases haâ‚ hb.1\n  Â· simp only [mem_diff, mem_iUnion, mem_singleton_iff, SetLike.mem_coe] at haâ‚ haâ‚‚\n    obtain âŸ¨âŸ¨b, hb, rflâŸ©, haâ‚âŸ© := haâ‚\n    obtain âŸ¨âŸ¨c, hc, hc'âŸ©, haâ‚‚âŸ© := haâ‚‚\n    cases extraAtomMap_injective _ _ hc'\n    rw [extraAtomMap_mem_iff] at haâ‚ haâ‚‚\n    obtain (hb | hb) := hb\n    Â· obtain (hc | hc) := hc\n      Â· cases h (hb.1.symm.trans hc.1)\n      Â· cases haâ‚‚ hc.1\n    Â· cases haâ‚ hb.1\n", "additional_info": "", "used_premises": [1, 823, 1293, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [620, 665], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraLitterMap'_disjoint` asserts that the intersection of the sets `ConNF.NearLitterBehaviour.extraLitterMap' Î¾ hÎ¾ Nâ‚ hNâ‚` and `ConNF.NearLitterBehaviour.extraLitterMap' Î¾ hÎ¾ Nâ‚‚ hNâ‚‚` is empty, i.e., the two sets are disjoint. This is true provided that `Nâ‚` and `Nâ‚‚` are different near-litters, and both `Nâ‚` and `Nâ‚‚` are in the domain of the near-litter map of `Î¾`. The proof involves using properties of the near-litter-behaviour `Î¾` and the fact that `Nâ‚` and `Nâ‚‚` are different."}
{"full_name": "ConNF.NearLitterBehaviour.mem_extraLitterMap_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_extraLitterMap_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mem_extraLitterMap_iff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} {N : ConNF.NearLitter} {hN : (Î¾.nearLitterMap N).Dom} (a : ConNF.Atom) :a âˆˆ ConNF.NearLitterBehaviour.extraLitterMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ N hN â†” a âˆˆ ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ N hN", "code": "theorem mem_extraLitterMap_iff {Î¾ : NearLitterBehaviour} {hÎ¾ : Î¾.Lawful}\n    {N : NearLitter} {hN : (Î¾.nearLitterMap N).Dom} (a : Atom) :\n    a âˆˆ Î¾.extraLitterMap hÎ¾ N hN â†” a âˆˆ Î¾.extraLitterMap' hÎ¾ N hN :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 823, 1298, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [670, 674], "informalization": "The theorem `ConNF.NearLitterBehaviour.mem_extraLitterMap_iff` states that for a lawful near-litter-behaviour `Î¾`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `Î¾`, an atom `a` is in the extra-litter map of `Î¾` applied to `N` if and only if `a` is in the extra-litter map' of `Î¾` applied to `N`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.extraLitterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) (N : ConNF.NearLitter) (hN : (Î¾.nearLitterMap N).Dom) :ConNF.NearLitter", "code": "def extraLitterMap (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful)\n    (N : NearLitter) (hN : (Î¾.nearLitterMap N).Dom) : NearLitter :=\n  âŸ¨((Î¾.nearLitterMap N).get hN).1, Î¾.extraLitterMap' hÎ¾ N hN, extraLitterMap'_isNearLitter hÎ¾ hNâŸ©\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterBehaviour.extraLitterMapğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMapğŸ”—  Î¾ hÎ¾ N hN ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { fst := ((Î¾.nearLitterMap N).get hN).fst,\n snd := { val := ğŸ—ŸConNF.NearLitterBehaviour.extraLitterMap'ğŸ—ŸğŸ”—../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—  Î¾ hÎ¾ N hN, property := â‹¯ } }\n\n", "used_premises": [1, 823], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [666, 669], "informalization": "Function `ConNF.NearLitterBehaviour.extraLitterMap` takes a lawful near-litter-behaviour `Î¾`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `Î¾`. It returns a new near-litter, where the first component is the same as the first component of the image of `N` under the near-litter map of `Î¾`, and the second component is obtained by applying `ConNF.NearLitterBehaviour.extraLitterMap'`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap_eq", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} {Nâ‚ : ConNF.NearLitter} {Nâ‚‚ : ConNF.NearLitter} (h : Nâ‚.fst = Nâ‚‚.fst) (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) :ConNF.NearLitterBehaviour.extraLitterMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚ hNâ‚ = ConNF.NearLitterBehaviour.extraLitterMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚‚ hNâ‚‚", "code": "theorem extraLitterMap_eq {Î¾ : NearLitterBehaviour} {hÎ¾ : Î¾.Lawful}\n    {Nâ‚ Nâ‚‚ : NearLitter} (h : Nâ‚.1 = Nâ‚‚.1)\n    (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) :\n    Î¾.extraLitterMap hÎ¾ Nâ‚ hNâ‚ = Î¾.extraLitterMap hÎ¾ Nâ‚‚ hNâ‚‚ :=\n  NearLitter.ext (extraLitterMap'_eq h hNâ‚ hNâ‚‚)\n", "additional_info": "", "used_premises": [1, 823, 1298, 1298], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [675, 680], "informalization": "Given a lawful near-litter-behaviour `Î¾`, two near-litters `Nâ‚` and `Nâ‚‚` with the same first component, and proofs that both `Nâ‚` and `Nâ‚‚` are in the domain of the near-litter map of `Î¾`, the function `ConNF.NearLitterBehaviour.extraLitterMap` returns the same near-litter for both `Nâ‚` and `Nâ‚‚`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_mem_iff'", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_mem_iff'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_mem_iff' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} {hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾} {a : ConNF.Atom} (ha : (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ a).Dom) {N : ConNF.NearLitter} (hN : (Î¾.nearLitterMap N).Dom) :(ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ a).get ha âˆˆ ConNF.NearLitterBehaviour.extraLitterMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ N hN â†” a.1 = N.fst", "code": "theorem extraAtomMap_mem_iff' {Î¾ : NearLitterBehaviour} {hÎ¾ : Lawful Î¾}\n    {a : Atom} (ha : (Î¾.extraAtomMap hÎ¾ a).Dom)\n    {N : NearLitter} (hN : (Î¾.nearLitterMap N).Dom) :\n    (Î¾.extraAtomMap hÎ¾ a).get ha âˆˆ Î¾.extraLitterMap hÎ¾ N hN â†” a.1 = N.1 := by\n  rw [mem_extraLitterMap_iff, extraLitterMap']\n  constructor\n  Â· rintro (âŸ¨haâ‚, haâ‚‚âŸ© | âŸ¨haâ‚, haâ‚‚âŸ©)\n    Â· rw [SetLike.mem_coe, extraAtomMap_mem_iff] at haâ‚\n      contrapose! haâ‚‚\n      simp only [mem_iUnion, mem_singleton_iff]\n      exact âŸ¨a, Or.inr âŸ¨haâ‚, haâ‚‚âŸ©, rflâŸ©\n    Â· rw [SetLike.mem_coe, extraAtomMap_mem_iff] at haâ‚‚\n      simp only [mem_iUnion, mem_singleton_iff] at haâ‚\n      obtain âŸ¨b, hb, habâŸ© := haâ‚\n      cases extraAtomMap_injective _ _ hab\n      obtain (hb | hb) := hb\n      Â· exact hb.1\n      Â· cases haâ‚‚ hb.1\n  Â· intro haâ‚\n    by_cases haâ‚‚ : a âˆˆ N\n    Â· refine Or.inl âŸ¨?_, ?_âŸ©\n      Â· rw [SetLike.mem_coe, extraAtomMap_mem_iff]\n        exact haâ‚‚\n      Â· simp only [mem_iUnion, mem_singleton_iff, not_exists]\n        intro b hb hab\n        cases extraAtomMap_injective _ _ hab\n        obtain (hb | hb) := hb\n        Â· cases hb.2 haâ‚‚\n        Â· cases hb.2 haâ‚\n    Â· refine Or.inr âŸ¨?_, ?_âŸ©\n      Â· simp only [mem_iUnion, mem_singleton_iff]\n        exact âŸ¨a, Or.inl âŸ¨haâ‚, haâ‚‚âŸ©, rflâŸ©\n      Â· rw [SetLike.mem_coe, extraAtomMap_mem_iff]\n        exact haâ‚‚\n", "additional_info": "", "used_premises": [1, 823, 1282, 1282, 1298], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [713, 747], "informalization": "Given a lawful near-litter-behaviour `Î¾`, `ConNF.NearLitterBehaviour.extraAtomMap_mem_iff'` states that for any atom `a` in the domain of the extended atom map, and any near-litter `N` in the domain of the near-litter map, `a` is a member of the extended near-litter map of `N` if and only if the first component of `a` is equal to the first component of the near-litter `N`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) {Nâ‚ : ConNF.NearLitter} {Nâ‚‚ : ConNF.NearLitter} (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) (hN : Nâ‚.fst = (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— Nâ‚‚.fst).fst) {a : ConNF.Atom} (ha : a âˆˆ symmDiffğŸ”—<|PREMISE|>ğŸ”— (â†‘((Î¾.nearLitterMap Nâ‚).get hNâ‚)) (ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚‚ hNâ‚‚)) :a âˆˆ PFun.ranğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾)", "code": "theorem extraAtomMap_ran_of_mem_symmDiff {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    {Nâ‚ Nâ‚‚ : NearLitter} (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom)\n    (hN : Nâ‚.fst = (Litter.toNearLitter Nâ‚‚.1).fst)\n    {a : Atom} (ha : a âˆˆ ((Î¾.nearLitterMap Nâ‚).get hNâ‚ : Set Atom) âˆ† Î¾.extraLitterMap' hÎ¾ Nâ‚‚ hNâ‚‚) :\n    a âˆˆ (Î¾.extraAtomMap hÎ¾).ran := by\n  obtain (âŸ¨haâ‚, haâ‚‚âŸ© | âŸ¨haâ‚, haâ‚‚âŸ©) := ha\n  Â· contrapose! haâ‚‚\n    have ha' : a âˆˆ (Î¾.nearLitterMap Nâ‚‚).get hNâ‚‚\n    Â· by_contra ha'\n      obtain âŸ¨b, hb, rflâŸ© := hÎ¾.ran_of_mem_symmDiff a (by exact hN) hNâ‚ hNâ‚‚ (Or.inl âŸ¨haâ‚, ha'âŸ©)\n      refine haâ‚‚ âŸ¨b, Or.inl hb, ?_âŸ©\n      rw [extraAtomMap_eq_of_dom]\n    refine Or.inl âŸ¨ha', ?_âŸ©\n    simp only [mem_iUnion, mem_singleton_iff, not_exists]\n    rintro b hb rfl\n    exact haâ‚‚ âŸ¨b, _, rflâŸ©\n  Â· obtain (âŸ¨haâ‚, haâ‚ƒâŸ© | âŸ¨haâ‚, haâ‚ƒâŸ©) := haâ‚\n    Â· simp only [mem_iUnion, mem_singleton_iff, not_exists] at haâ‚ƒ\n      obtain âŸ¨b, hb, rflâŸ© := hÎ¾.ran_of_mem_symmDiff a (by exact hN) hNâ‚ hNâ‚‚ (Or.inr âŸ¨haâ‚, haâ‚‚âŸ©)\n      refine âŸ¨b, Or.inl hb, ?_âŸ©\n      rw [extraAtomMap_eq_of_dom]\n    Â· simp only [mem_iUnion, mem_singleton_iff] at haâ‚\n      obtain âŸ¨b, hb, rflâŸ© := haâ‚\n      exact âŸ¨_, _, rflâŸ©\n", "additional_info": "", "used_premises": [1, 823, 483, 62, 1293, 824, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [748, 772], "informalization": "The Lean 4 object `ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if `Î¾` is a lawful near-litter-behaviour, `Nâ‚` and `Nâ‚‚` are near-litters, `a` is an atom, and `a` is in the symmetric difference of the image of `Nâ‚` under the near-litter map of `Î¾` and the union of the images of the atoms in the symmetric difference of the litter set of `Nâ‚‚` and `Nâ‚‚` itself, under the extra-atom map of `Î¾`, then `a` is in the range of the extra-atom map of `Î¾`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_inter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_inter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {Î¾ : ConNF.NearLitterBehaviour} (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) {Nâ‚ : ConNF.NearLitter} {Nâ‚‚ : ConNF.NearLitter} (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom) (hN : Nâ‚.fst â‰  (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— Nâ‚‚.fst).fst) {a : ConNF.Atom} (ha : a âˆˆ â†‘((Î¾.nearLitterMap Nâ‚).get hNâ‚) âˆ© ConNF.NearLitterBehaviour.extraLitterMap'ğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾ Nâ‚‚ hNâ‚‚) :a âˆˆ PFun.ranğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.extraAtomMapğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾)", "code": "theorem extraAtomMap_ran_of_mem_inter {Î¾ : NearLitterBehaviour} (hÎ¾ : Î¾.Lawful)\n    {Nâ‚ Nâ‚‚ : NearLitter} (hNâ‚ : (Î¾.nearLitterMap Nâ‚).Dom) (hNâ‚‚ : (Î¾.nearLitterMap Nâ‚‚).Dom)\n    (hN : Nâ‚.fst â‰  (Litter.toNearLitter Nâ‚‚.1).fst)\n    {a : Atom} (ha : a âˆˆ ((Î¾.nearLitterMap Nâ‚).get hNâ‚ : Set Atom) âˆ© Î¾.extraLitterMap' hÎ¾ Nâ‚‚ hNâ‚‚) :\n    a âˆˆ (Î¾.extraAtomMap hÎ¾).ran := by\n  obtain âŸ¨haâ‚, âŸ¨haâ‚‚, haâ‚ƒâŸ© | âŸ¨haâ‚‚, haâ‚ƒâŸ©âŸ© := ha\n  Â· simp only [mem_iUnion, mem_singleton_iff, not_exists] at haâ‚ƒ\n    obtain âŸ¨b, hb, rflâŸ© := hÎ¾.ran_of_mem_inter a (by exact hN) hNâ‚ hNâ‚‚ âŸ¨haâ‚, haâ‚‚âŸ©\n    refine âŸ¨b, Or.inl hb, ?_âŸ©\n    rw [extraAtomMap_eq_of_dom]\n  Â· simp only [mem_iUnion, mem_singleton_iff] at haâ‚‚\n    obtain âŸ¨b, hb, rflâŸ© := haâ‚‚\n    rw [SetLike.mem_coe, extraAtomMap_mem_iff] at haâ‚ haâ‚ƒ\n    exact âŸ¨b, _, rflâŸ©\n", "additional_info": "", "used_premises": [1, 823, 483, 1293, 824, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [773, 787], "informalization": "Given a lawful near-litter-behaviour $\\xi$, two near-litters $N_1$ and $N_2$, with $N_1$ not equal to $N_2$ as litters, and an atom $a$ that is in the intersection of the image of $N_1$ under the near-litter map of $\\xi$ and the extra-litter map of $\\xi$ applied to $N_2$, then $a$ is in the range of the extra-atom map of $\\xi$."}
{"full_name": "ConNF.NearLitterBehaviour.withLitters_lawful", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.withLitters_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.withLitters_lawful [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] (Î¾ : ConNF.NearLitterBehaviour) (hÎ¾ : ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— Î¾) :ConNF.NearLitterBehaviour.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterBehaviour.withLittersğŸ”—<|PREMISE|>ğŸ”— Î¾ hÎ¾)", "code": "theorem withLitters_lawful (Î¾ : NearLitterBehaviour) (hÎ¾ : Î¾.Lawful) :\n    (Î¾.withLitters hÎ¾).Lawful := by\n  constructor\n  case atomMap_injective => exact extraAtomMap_injective\n  case atom_mem_iff =>\n    rintro a ha N (hN | âŸ¨âŸ¨_âŸ©, âŸ¨N, hN, hN'âŸ©âŸ©)\n    Â· rw [withLitters_nearLitterMap_of_dom hÎ¾ hN]\n      exact extraAtomMap_mem_iff ha hN\n    Â· cases hN'\n      rw [withLitters_nearLitterMap_fst hÎ¾ hN]\n      exact extraAtomMap_mem_iff' ha hN\n  case dom_of_mem_symmDiff =>\n    rintro a Nâ‚ Nâ‚‚ h (hNâ‚ | âŸ¨âŸ¨_âŸ©, âŸ¨Nâ‚, -, hNâ‚'âŸ©âŸ©) (hNâ‚‚ | âŸ¨âŸ¨_âŸ©, âŸ¨Nâ‚‚, -, hNâ‚‚'âŸ©âŸ©) ha\n    Â· exact Or.inl (hÎ¾.dom_of_mem_symmDiff a h hNâ‚ hNâ‚‚ ha)\n    Â· cases hNâ‚‚'\n      refine extraAtomMap_dom_of_mem_symmDiff hÎ¾ hNâ‚ ?_\n      rw [h]\n      rw [symmDiff_comm] at ha\n      exact ha\n    Â· cases hNâ‚'\n      refine extraAtomMap_dom_of_mem_symmDiff hÎ¾ hNâ‚‚ ?_\n      rw [â† h]\n      exact ha\n    Â· cases hNâ‚'\n      cases hNâ‚‚'\n      rw [Litter.toNearLitter_fst] at h\n      obtain (ha | ha) := ha\n      Â· rw [h] at ha\n        cases ha.2 ha.1\n      Â· rw [h] at ha\n        cases ha.2 ha.1\n  case dom_of_mem_inter =>\n    rintro a Nâ‚ Nâ‚‚ h (hNâ‚ | âŸ¨âŸ¨_âŸ©, âŸ¨Nâ‚, -, hNâ‚'âŸ©âŸ©) (hNâ‚‚ | âŸ¨âŸ¨_âŸ©, âŸ¨Nâ‚‚, -, hNâ‚‚'âŸ©âŸ©) ha\n    Â· exact Or.inl (hÎ¾.dom_of_mem_inter a h hNâ‚ hNâ‚‚ ha)\n    Â· cases hNâ‚‚'\n      exact extraAtomMap_dom_of_mem_inter hÎ¾ hNâ‚ h ha.1 ha.2\n    Â· cases hNâ‚'\n      exact extraAtomMap_dom_of_mem_inter hÎ¾ hNâ‚‚ h.symm ha.2 ha.1\n    Â· cases hNâ‚'\n      cases hNâ‚‚'\n      simp only [Litter.toNearLitter_fst, ne_eq] at h\n      cases h (ha.1.symm.trans ha.2)\n  case ran_of_mem_symmDiff =>\n    rintro a Nâ‚ Nâ‚‚ h (hNâ‚ | âŸ¨âŸ¨_âŸ©, âŸ¨Nâ‚, hNâ‚, hNâ‚'âŸ©âŸ©) (hNâ‚‚ | âŸ¨âŸ¨_âŸ©, âŸ¨Nâ‚‚, hNâ‚‚, hNâ‚‚'âŸ©âŸ©) ha\n    Â· rw [withLitters_nearLitterMap_of_dom hÎ¾ hNâ‚, withLitters_nearLitterMap_of_dom hÎ¾ hNâ‚‚] at ha\n      obtain âŸ¨b, hb, rflâŸ© := hÎ¾.ran_of_mem_symmDiff a h hNâ‚ hNâ‚‚ ha\n      refine âŸ¨b, Or.inl hb, ?_âŸ©\n      simp only [withLitters, extraAtomMap_eq_of_dom _ hb]\n    Â· cases hNâ‚‚'\n      refine extraAtomMap_ran_of_mem_symmDiff hÎ¾ hNâ‚ hNâ‚‚ h ?_\n      rw [withLitters_nearLitterMap_of_dom hÎ¾ hNâ‚,\n        withLitters_nearLitterMap_fst hÎ¾ hNâ‚‚] at ha\n      exact ha\n    Â· cases hNâ‚'\n      refine extraAtomMap_ran_of_mem_symmDiff hÎ¾ hNâ‚‚ hNâ‚ h.symm ?_\n      rw [withLitters_nearLitterMap_of_dom hÎ¾ hNâ‚‚,\n        withLitters_nearLitterMap_fst hÎ¾ hNâ‚, symmDiff_comm] at ha\n      exact ha\n    Â· cases hNâ‚'\n      cases hNâ‚‚'\n      rw [Litter.toNearLitter_fst] at h\n      simp only [h, Litter.toNearLitter_fst, symmDiff_self, bot_eq_empty, mem_empty_iff_false] at ha\n  case ran_of_mem_inter =>\n    rintro a Nâ‚ Nâ‚‚ h (hNâ‚ | âŸ¨âŸ¨_âŸ©, âŸ¨Nâ‚, hNâ‚, hNâ‚'âŸ©âŸ©) (hNâ‚‚ | âŸ¨âŸ¨_âŸ©, âŸ¨Nâ‚‚, hNâ‚‚, hNâ‚‚'âŸ©âŸ©) ha\n    Â· rw [withLitters_nearLitterMap_of_dom hÎ¾ hNâ‚, withLitters_nearLitterMap_of_dom hÎ¾ hNâ‚‚] at ha\n      obtain âŸ¨b, hb, rflâŸ© := hÎ¾.ran_of_mem_inter a h hNâ‚ hNâ‚‚ ha\n      refine âŸ¨b, Or.inl hb, ?_âŸ©\n      simp only [withLitters, extraAtomMap_eq_of_dom _ hb]\n    Â· cases hNâ‚‚'\n      refine extraAtomMap_ran_of_mem_inter hÎ¾ hNâ‚ hNâ‚‚ h ?_\n      rw [withLitters_nearLitterMap_of_dom hÎ¾ hNâ‚,\n        withLitters_nearLitterMap_fst hÎ¾ hNâ‚‚] at ha\n      exact ha\n    Â· cases hNâ‚'\n      refine extraAtomMap_ran_of_mem_inter hÎ¾ hNâ‚‚ hNâ‚ h.symm ?_\n      rw [withLitters_nearLitterMap_of_dom hÎ¾ hNâ‚‚,\n        withLitters_nearLitterMap_fst hÎ¾ hNâ‚, inter_comm] at ha\n      exact ha\n    Â· cases hNâ‚'\n      cases hNâ‚‚'\n      simp only [mem_inter_iff, SetLike.mem_coe,\n        withLitters_nearLitterMap_fst hÎ¾ hNâ‚, withLitters_nearLitterMap_fst hÎ¾ hNâ‚‚,\n        mem_extraLitterMap_iff] at ha\n      cases extraLitterMap'_disjoint (by exact h) hNâ‚ hNâ‚‚ a ha\n", "additional_info": "", "used_premises": [1, 823, 823, 832], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [788, 872], "informalization": "The theorem `ConNF.NearLitterBehaviour.withLitters_lawful` states that given a lawful near-litter-behaviour `Î¾`, the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters Î¾ hÎ¾` is also lawful."}
{"full_name": "ConNF.StructApprox.ihAction_atomMap", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.ihAction_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ihAction_atomMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— c} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} :(ConNF.StructApprox.ihActionğŸ”—<|PREMISE|>ğŸ”— H B).atomMap a = { Dom := { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } < c, get := fun (h : { path := B, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } < c) => H.atomImage B a h }", "code": "theorem ihAction_atomMap {Î² : Î›} {c : Address Î²} {H : HypAction c}\n    {B : ExtendedIndex Î²} {a : Atom} : (ihAction H B).atomMap a = âŸ¨_, fun h => H.atomImage B a hâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60, 1305, 61, 1306, 67, 67], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [53, 56], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.ihAction_atomMap` defines the atom map of a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index, given an inductive hypothesis. It injects an element of type `Î±` into the left side of the sum type `Î± âŠ• Î²`."}
{"full_name": "ConNF.HypAction", "url": "ConNF/FOA/Complete/HypAction.html#ConNF.HypAction", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.HypAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) :Type u\n | atomImage : (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) â†’ (a : ConNF.Atom) â†’ { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”—  a } <  c â†’ ConNF.Atom\n | nearLitterImage : (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”—  â†‘Î²) â†’ (N : ConNF.NearLitter) â†’ { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”—  N } <  c â†’ ConNF.NearLitter", "code": "structure HypAction {Î² : Î›} (c : Address Î²) where\n  atomImage : âˆ€ A a, âŸ¨A, inl aâŸ© < c â†’ Atom\n  nearLitterImage : âˆ€ A N, âŸ¨A, inr NâŸ© < c â†’ NearLitter\n", "additional_info": "The inductive hypothesis used to construct the induced action of an approximation in the\nfreedom of action theorem.\n", "used_premises": [1, 60, 61, 67, 61, 65], "def_path": "ConNF/FOA/Complete/HypAction.lean", "pos": [18, 21], "informalization": "The inductive hypothesis used to construct the induced action of an approximation in the freedom of action theorem."}
{"full_name": "ConNF.StructApprox.ihAction", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.ihAction", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.ihAction [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— c) :ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²", "code": "def ihAction {Î² : Î›} {c : Address Î²} (H : HypAction c) : StructAction Î² := fun B =>\n  { atomMap := fun a => âŸ¨_, fun h => H.atomImage B a hâŸ©\n    litterMap := fun L => âŸ¨_, fun h => H.nearLitterImage B L.toNearLitter hâŸ©\n    atomMap_dom_small := by\n      simp only [PFun.dom_mk]\n      have := transClosure_small (small_singleton c)\n      simp only [transClosure, mem_singleton_iff, exists_prop, exists_eq_left] at this\n      refine' Small.image_subset (fun a => âŸ¨B, inl aâŸ©) _ this _\n      Â· intro a b h\n        simpa [Address.mk.injEq, inl.injEq, true_and] using h\n      Â· rintro _ âŸ¨a, h, rflâŸ©\n        exact h\n    litterMap_dom_small := by\n      simp only [PFun.dom_mk]\n      have := transClosure_small (small_singleton c)\n      simp only [transClosure, mem_singleton_iff, exists_prop, exists_eq_left] at this\n      refine' Small.image_subset (fun L => âŸ¨B, inr L.toNearLitterâŸ©) _ this _\n      Â· intro Lâ‚ Lâ‚‚ h\n        simpa only [Address.mk.injEq, inr.injEq, Litter.toNearLitter_injective.eq_iff,\n          true_and] using h\n      Â· rintro _ âŸ¨a, h, rflâŸ©\n        exact h }\n", "additional_info": "The structural action associated to a given inductive hypothesis.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 60, 1305, 808], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [29, 51], "informalization": "Function `ConNF.StructApprox.ihAction` defines a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index, given an inductive hypothesis in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.ihAction_litterMap", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.ihAction_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ihAction_litterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— c} {B : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} :(ConNF.StructApprox.ihActionğŸ”—<|PREMISE|>ğŸ”— H B).litterMap L = { Dom := { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } < c, get := fun (h : { path := B, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) } < c) => H.nearLitterImage B (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) h }", "code": "theorem ihAction_litterMap {Î² : Î›} {c : Address Î²} {H : HypAction c}\n    {B : ExtendedIndex Î²} {L : Litter} :\n    (ihAction H B).litterMap L = âŸ¨_, fun h => H.nearLitterImage B L.toNearLitter hâŸ© :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60, 1305, 61, 1306, 65, 483, 65, 483, 483], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [58, 62], "informalization": "The theorem `ConNF.StructApprox.ihAction_litterMap` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It defines the litter map of a `Î²`-structural action as a product that assigns a near-litter action to each `Î²`-extended index, given an inductive hypothesis in the context of ConNF."}
{"full_name": "ConNF.StructAction.allowable_exactlyApproximates", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.allowable_exactlyApproximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.allowable_exactlyApproximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î³) (h : Î³ < Î²) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (hâ‚‚ : ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— Ï† hâ‚) (ConNF.Allowable.toStructPerm (ConNF.StructAction.allowableğŸ”—<|PREMISE|>ğŸ”— Ï† h hâ‚ hâ‚‚))", "code": "theorem ConNF.StructAction.allowable_exactlyApproximates {Î³ : Î›} [LtLevel Î³]\n    (Ï† : StructAction Î³) (h : Î³ < Î²) (hâ‚ : Ï†.Lawful) (hâ‚‚ : Ï†.MapFlexible) :\n    (Ï†.rc hâ‚).ExactlyApproximates (Allowable.toStructPerm (Ï†.allowable h hâ‚ hâ‚‚)) :=\n  (freedomOfAction_of_lt _ h _ (StructAction.rc_free _ hâ‚ hâ‚‚)).choose_spec\n", "additional_info": "", "used_premises": [1, 402, 779, 98, 808, 809, 814, 803, 810, 1309], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [69, 73], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructAction.allowable_exactlyApproximates` states that given a `Î³`-structural action `Ï†`, a proof `h` that `Î³ < Î²`, a proof `hâ‚` that `Ï†` is lawful, and a proof `hâ‚‚` that `Ï†` maps flexible litters to flexible litters, the refined and completed `Î³`-structural approximation `ConNF.StructAction.rc Ï† hâ‚` exactly approximates the `Î³`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructAction.allowable Ï† h hâ‚ hâ‚‚)`."}
{"full_name": "ConNF.StructAction.allowable", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.allowable", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.allowable [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Î³ : ConNF.Î›} [ConNF.LtLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î³] (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î³) (h : Î³ < Î²) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— Ï†) (hâ‚‚ : ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”— Ï†) :ConNF.Allowable â†‘Î³", "code": "noncomputable def ConNF.StructAction.allowable {Î³ : Î›} [LtLevel Î³]\n    (Ï† : StructAction Î³) (h : Î³ < Î²) (hâ‚ : Ï†.Lawful) (hâ‚‚ : Ï†.MapFlexible) : Allowable Î³ :=\n  (freedomOfAction_of_lt _ h _ (StructAction.rc_free _ hâ‚ hâ‚‚)).choose\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructAction.allowableğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.allowableğŸ”—  Ï† h hâ‚ hâ‚‚ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸExists.chooseğŸ—ŸğŸ”—../../.././Init/Classical.html#Exists.chooseğŸ”—  â‹¯\n\n", "used_premises": [1, 402, 779, 98, 808, 809, 814], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [65, 68], "informalization": "Function `ConNF.StructAction.allowable` is a noncomputable function in the context of Constructive Ordinal Notation (ConNF) that, given a `Î³`-structural action `Ï†`, a proof `h` that `Î³ < Î²`, a proof `hâ‚` that `Ï†` is lawful, and a proof `hâ‚‚` that `Ï†` maps flexible litters to flexible litters, returns a `Î³`-allowable permutation."}
{"full_name": "ConNF.StructAction.hypothesisedAllowable_exactlyApproximates", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.hypothesisedAllowable_exactlyApproximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.hypothesisedAllowable_exactlyApproximates [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : ConNF.InflexibleCoePathğŸ”—<|PREMISE|>ğŸ”— A) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— h.B â‹¯) Ï†)) (hâ‚‚ : ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— h.B â‹¯) Ï†)) :ConNF.StructApprox.ExactlyApproximatesğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructAction.rcğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— h.B â‹¯) Ï†) hâ‚) (ConNF.Allowable.toStructPerm (ConNF.StructAction.hypothesisedAllowableğŸ”—<|PREMISE|>ğŸ”— Ï† h hâ‚ hâ‚‚))", "code": "theorem ConNF.StructAction.hypothesisedAllowable_exactlyApproximates (Ï† : StructAction Î²)\n    {A : ExtendedIndex Î²} (h : InflexibleCoePath A)\n    (hâ‚ : StructAction.Lawful (Ï†.comp (h.B.cons h.hÎ´)))\n    (hâ‚‚ : StructAction.MapFlexible (Ï†.comp (h.B.cons h.hÎ´))) :\n    StructApprox.ExactlyApproximates\n      (StructAction.rc (Ï†.comp (h.B.cons h.hÎ´)) hâ‚)\n      (Allowable.toStructPerm (Ï†.hypothesisedAllowable h hâ‚ hâ‚‚)) :=\n  StructAction.allowable_exactlyApproximates (Ï†.comp (h.B.cons h.hÎ´)) _ _ _\n", "additional_info": "", "used_premises": [1, 402, 779, 808, 61, 890, 809, 304, 301, 814, 304, 301, 803, 810, 304, 301, 1311], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [84, 92], "informalization": "The theorem `ConNF.StructAction.hypothesisedAllowable_exactlyApproximates` states that given a `Î²`-structural action `Ï†`, an inflexible coe path `A`, and two hypotheses (lawfulness and map flexibility), the refined and completed `Î²`-structural approximation `ConNF.StructAction.rc (ConNF.Tree.comp (Quiver.Path.cons h.B â‹¯) Ï†) hâ‚` exactly approximates the allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructAction.hypothesisedAllowable Ï† h hâ‚ hâ‚‚)`."}
{"full_name": "ConNF.StructAction.hypothesisedAllowable", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.hypothesisedAllowable", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.hypothesisedAllowable [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï† : ConNF.StructActionğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : ConNF.InflexibleCoePathğŸ”—<|PREMISE|>ğŸ”— A) (hâ‚ : ConNF.StructAction.LawfulğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— h.B â‹¯) Ï†)) (hâ‚‚ : ConNF.StructAction.MapFlexibleğŸ”—<|PREMISE|>ğŸ”— (ConNF.Tree.compğŸ”—<|PREMISE|>ğŸ”— (Quiver.Path.consğŸ”—<|PREMISE|>ğŸ”— h.B â‹¯) Ï†)) :ConNF.Allowable â†‘h.Î´", "code": "noncomputable def ConNF.StructAction.hypothesisedAllowable (Ï† : StructAction Î²)\n    {A : ExtendedIndex Î²} (h : InflexibleCoePath A)\n    (hâ‚ : StructAction.Lawful (Ï†.comp (h.B.cons h.hÎ´)))\n    (hâ‚‚ : StructAction.MapFlexible (Ï†.comp (h.B.cons h.hÎ´))) :\n    Allowable h.Î´ :=\n  StructAction.allowable\n    (Ï†.comp (h.B.cons h.hÎ´))\n    (coe_lt_coe.mp (h.hÎ´.trans_le (le_of_path h.B)))\n    hâ‚ hâ‚‚\n", "additional_info": "Equations\n* ğŸ—ŸConNF.StructAction.hypothesisedAllowableğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.hypothesisedAllowableğŸ”—  Ï† h hâ‚ hâ‚‚ ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸConNF.StructAction.allowableğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.allowableğŸ”—  (ğŸ—ŸConNF.Tree.compğŸ—ŸğŸ”—../../.././ConNF/Structural/Tree.html#ConNF.Tree.compğŸ”—  (ğŸ—ŸQuiver.Path.consğŸ—ŸğŸ”—../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.consğŸ”—  h.B â‹¯) Ï†) â‹¯ hâ‚ hâ‚‚\n\n", "used_premises": [1, 402, 779, 808, 61, 890, 809, 304, 301, 814, 304, 301], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [74, 83], "informalization": "`ConNF.StructAction.hypothesisedAllowable` is a noncomputable definition in Lean 4 that constructs an allowable permutation from a Î²-structural action, an inflexible coe path, and two hypotheses (lawfulness and map flexibility). It uses the `ConNF.StructAction.allowable` function to construct an allowable permutation by composing the given Î²-structural action with the inflexible coe path and providing the necessary hypotheses. This allows for the construction of allowable permutations in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.litterCompletion_of_flexible", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.litterCompletion_of_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.litterCompletion_of_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) }) (hflex : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) :ConNF.StructApprox.litterCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A L H = ConNF.NearLitterApprox.flexibleCompletionğŸ”—<|PREMISE|>ğŸ”— (Ï€ A) A â€¢ L", "code": "theorem litterCompletion_of_flexible (Ï€ : StructApprox Î²) (A : ExtendedIndex Î²) (L : Litter)\n    (H : HypAction âŸ¨A, inr L.toNearLitterâŸ©) (hflex : Flexible A L) :\n    litterCompletion Ï€ A L H = NearLitterApprox.flexibleCompletion (Ï€ A) A â€¢ L := by\n  rw [litterCompletion, dif_neg, dif_neg]\n  Â· rintro âŸ¨âŸ¨âŸ¨Î³, Îµ, hÎµ, C, rflâŸ©, a, rflâŸ©âŸ©\n    exact hflex (Inflexible.mk_bot hÎµ _ _)\n  Â· rintro âŸ¨âŸ¨âŸ¨Î³, Î´, Îµ, hÎ´, hÎµ, hÎ´Îµ, C, rflâŸ©, t, rflâŸ©âŸ©\n    exact hflex (Inflexible.mk_coe hÎ´ hÎµ hÎ´Îµ _ _)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 483, 842, 1313, 1314], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [104, 112], "informalization": "The theorem `ConNF.StructApprox.litterCompletion_of_flexible` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that, given a `Î²`-structural approximation `Ï€`, an extended index `A`, a litter `L`, and a hypothesis `H` about the action of `Ï€` on `A` and `L`, the litter completion `ConNF.StructApprox.litterCompletion Ï€ A L H` is equal to the flexible completion `ConNF.NearLitterApprox.flexibleCompletion (Ï€ A) A â€¢ L`."}
{"full_name": "ConNF.StructApprox.litterCompletion", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.litterCompletion", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.litterCompletion [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (L : ConNF.Litter) (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L) }) :ConNF.Litter", "code": "noncomputable def litterCompletion (Ï€ : StructApprox Î²) (A : ExtendedIndex Î²) (L : Litter)\n    (H : HypAction âŸ¨A, inr L.toNearLitterâŸ©) : Litter :=\n  if h : Nonempty (InflexibleCoe A L) then\n    if hs : _ âˆ§ _ then\n      fuzz h.some.path.hÎ´Îµ ((ihAction H).hypothesisedAllowable h.some.path hs.1 hs.2 â€¢ h.some.t)\n    else L\n  else if h : Nonempty (InflexibleBot A L) then\n    fuzz (show (âŠ¥ : TypeIndex) â‰  (h.some.path.Îµ : Î›) from bot_ne_coe)\n      (H.atomImage (h.some.path.B.cons (bot_lt_coe _)) h.some.a h.some.constrains)\n  else NearLitterApprox.flexibleCompletion (Ï€ A) A â€¢ L\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 483], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [93, 103], "informalization": "The Lean 4 object `ConNF.StructApprox.litterCompletion` is a function that, given a `Î²`-structural approximation `Ï€`, an extended index `A`, a litter `L`, and a hypothesis `H` about the action of `Ï€` on `A` and `L`, returns a litter. This function is part of the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterApprox.flexibleCompletion [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :ConNF.NearLitterApprox", "code": "noncomputable def flexibleCompletion : NearLitterApprox\n    where\n  atomPerm := Ï€.atomPerm\n  litterPerm := flexibleCompletionLitterPerm Ï€ A\n  domain_small := Ï€.domain_small\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterApprox.flexibleCompletionğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionğŸ”—  Ï€ A ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  { atomPerm := Ï€.atomPerm, litterPerm := ğŸ—ŸConNF.NearLitterApprox.flexibleCompletionLitterPermğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionLitterPermğŸ”—  Ï€ A, domain_small := â‹¯ }\n\n", "used_premises": [1, 61], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [39, 44], "informalization": "Function `ConNF.NearLitterApprox.flexibleCompletion` takes a `ConNF.NearLitterApprox` object `Ï€` and an `ConNF.ExtendedIndex` object `A`, and returns a new `ConNF.NearLitterApprox` object. The new object has the same `atomPerm` and `domain_small` as `Ï€`, but its `litterPerm` is determined by `ConNF.NearLitterApprox.flexibleCompletionLitterPerm`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_eq", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMap_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} :ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a = ConNF.StructApprox.atomCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A a (ConNF.StructApprox.foaHypothesisğŸ”—<|PREMISE|>ğŸ”— Ï€)", "code": "theorem completeAtomMap_eq : Ï€.completeAtomMap A a = Ï€.atomCompletion A a Ï€.foaHypothesis :=\n  HypAction.fixAtom_eq _ _ _ _\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 784, 1316, 1317], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [43, 45], "informalization": "The theorem `ConNF.StructApprox.completeAtomMap_eq` states that the function `ConNF.StructApprox.completeAtomMap`, which maps each `Î²`-extended index to an atom, is equal to the function `ConNF.StructApprox.atomCompletion`, which defines the action of a `Î²`-structural approximation `Ï€` on an atom `a`."}
{"full_name": "ConNF.StructApprox.atomCompletion", "url": "ConNF/FOA/Complete/AtomCompletion.html#ConNF.StructApprox.atomCompletion", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.atomCompletion [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (a : ConNF.Atom) (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a }) :ConNF.Atom", "code": "noncomputable def atomCompletion (A : ExtendedIndex Î²) (a : Atom) (H : HypAction âŸ¨A, inl aâŸ©) :\n    Atom :=\n  if h : a âˆˆ (Ï€ A).atomPerm.domain then Ï€ A â€¢ a\n  else\n    ((Ï€ A).largestSublitter a.1).equiv\n      ((Ï€ A).largestSublitter\n        (H.nearLitterImage A a.1.toNearLitter (Relation.TransGen.single <| Constrains.atom A a)).1)\n      âŸ¨a, (Ï€ A).mem_largestSublitter_of_not_mem_domain a hâŸ©\n", "additional_info": "Computes the action of a structural approximation `Ï€` on an atom `a`.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 781, 61, 1305, 67], "def_path": "ConNF/FOA/Complete/AtomCompletion.lean", "pos": [28, 36], "informalization": "Function `ConNF.StructApprox.atomCompletion` defines the action of a `Î²`-structural approximation `Ï€` on an atom `a` in the context of Constructive Ordinal Notation (ConNF). It checks if `a` is within the domain of the permutation defined by `Ï€`, and if so, applies the permutation to `a`. If `a` is not in the domain, it uses the equivalence between the largest sublitter of `a` and the largest sublitter of the near-litter image of `a` to map `a` to an element within the domain of the permutation."}
{"full_name": "ConNF.StructApprox.foaHypothesis", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.foaHypothesis", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.foaHypothesis [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} :ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— c", "code": "noncomputable def foaHypothesis (Ï€ : StructApprox Î²) {c : Address Î²} : HypAction c :=\n  âŸ¨fun B b _ => Ï€.completeAtomMap B b, fun B N _ => Ï€.completeNearLitterMap B NâŸ©\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 60, 1305], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [34, 36], "informalization": "Function `ConNF.StructApprox.foaHypothesis` is an inductive hypothesis used in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_eq", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} :ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N = ConNF.StructApprox.nearLitterCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A N (ConNF.StructApprox.foaHypothesisğŸ”—<|PREMISE|>ğŸ”— Ï€)", "code": "theorem completeNearLitterMap_eq :\n    Ï€.completeNearLitterMap A N = Ï€.nearLitterCompletion A N Ï€.foaHypothesis :=\n  HypAction.fixNearLitter_eq _ _ _ _\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 1319, 1317], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [46, 49], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_eq` is a part of the proof of freedom of action (FOA) in the context of Constructive Ordinal Notation (ConNF). It states that the function `ConNF.StructApprox.completeNearLitterMap` is equivalent to the function `ConNF.StructApprox.nearLitterCompletion` applied to the inductive hypothesis `ConNF.StructApprox.foaHypothesis`, which is a crucial part of the proof to establish that every free approximation exactly approximates some allowable permutation. This theorem is a key step in demonstrating that the FOA is consistent with the ConNF system, ensuring that the natural numbers can be constructed constructively with the desired properties."}
{"full_name": "ConNF.StructApprox.nearLitterCompletion", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletion", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.nearLitterCompletion [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N }) :ConNF.NearLitter", "code": "noncomputable def nearLitterCompletion (Ï€ : StructApprox Î²) (A : ExtendedIndex Î²) (N : NearLitter)\n    (H : HypAction âŸ¨A, inr NâŸ©) : NearLitter :=\n  âŸ¨litterCompletion Ï€ A N.1 (nearLitterHypothesis A N H), nearLitterCompletionMap Ï€ A N H,\n    nearLitterCompletionMap_isNearLitter Ï€ A N HâŸ©\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 61, 1305, 65], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [52, 56], "informalization": "Function `ConNF.StructApprox.nearLitterCompletion` defines a `Î²`-structural approximation in the context of Constructive Ordinal Notation (ConNF), which is a product that assigns a near-litter approximation to each `Î²`-extended index. Given a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, a near-litter `N`, and a hypothesis `H` about the action of `Ï€` on `A` and `N`, the function `nearLitterCompletion` returns a near-litter that is the completion of `N` with respect to `Ï€`, `A`, and `H`."}
{"full_name": "ConNF.StructApprox.completeLitterMap_eq", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMap_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} :ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L = ConNF.StructApprox.litterCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A L (ConNF.StructApprox.foaHypothesisğŸ”—<|PREMISE|>ğŸ”— Ï€)", "code": "theorem completeLitterMap_eq :\n    Ï€.completeLitterMap A L = Ï€.litterCompletion A L Ï€.foaHypothesis := by\n  rw [completeLitterMap, completeNearLitterMap_eq]\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 787, 1313, 1317], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [50, 54], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_eq` states that the function `ConNF.StructApprox.completeLitterMap` is equal to the function `ConNF.StructApprox.litterCompletion` applied to a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, a litter `L`, and a hypothesis `ConNF.StructApprox.foaHypothesis Ï€` about the action of `Ï€` on `A` and `L`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_fst_eq", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap_fst_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_fst_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} :(ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— L)).fst = ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L", "code": "theorem completeNearLitterMap_fst_eq :\n    (Ï€.completeNearLitterMap A L.toNearLitter).1 = Ï€.completeLitterMap A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 483, 787], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [55, 58], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_fst_eq` states that for a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, and a litter `L`, the first component of the near-litter returned by `ConNF.StructApprox.completeNearLitterMap Ï€ A (ConNF.Litter.toNearLitter L)` is equal to the litter returned by `ConNF.StructApprox.completeLitterMap Ï€ A L`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_fst_eq'", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap_fst_eq'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.completeNearLitterMap_fst_eq' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} :(ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N).fst = ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N.fst", "code": "theorem completeNearLitterMap_fst_eq' :\n    (Ï€.completeNearLitterMap A N).1 = Ï€.completeLitterMap A N.1 := by\n  rw [completeNearLitterMap_eq, nearLitterCompletion, completeLitterMap_eq]\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 787], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [60, 64], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_fst_eq'` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that the first component of the result of the function `ConNF.StructApprox.completeNearLitterMap` applied to a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, and a near-litter `N`, is equal to the result of the function `ConNF.StructApprox.completeLitterMap` applied to `Ï€`, `A`, and the first component of `N`."}
{"full_name": "ConNF.StructApprox.foaHypothesis_atomImage", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.foaHypothesis_atomImage", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.foaHypothesis_atomImage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : { path := A, value := Sum.inlğŸ”—<|PREMISE|>ğŸ”— a } < c) :(ConNF.StructApprox.foaHypothesisğŸ”—<|PREMISE|>ğŸ”— Ï€).atomImage A a h = ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a", "code": "theorem foaHypothesis_atomImage {c : Address Î²} (h : âŸ¨A, inl aâŸ© < c) :\n    (Ï€.foaHypothesis : HypAction c).atomImage A a h = Ï€.completeAtomMap A a :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 60, 67, 1317, 784], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [66, 69], "informalization": "The theorem `ConNF.StructApprox.foaHypothesis_atomImage` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for a `Î²`-structural approximation `Ï€` and a `Î²`-extended index `A`, the image of an atom `a` under the function `ConNF.StructApprox.foaHypothesis` is equal to the complete atom map of `Ï€` applied to `A` and `a`."}
{"full_name": "ConNF.StructApprox.foaHypothesis_nearLitterImage", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.foaHypothesis_nearLitterImage", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.foaHypothesis_nearLitterImage [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {N : ConNF.NearLitter} {c : ConNF.AddressğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (h : { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N } < c) :(ConNF.StructApprox.foaHypothesisğŸ”—<|PREMISE|>ğŸ”— Ï€).nearLitterImage A N h = ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N", "code": "theorem foaHypothesis_nearLitterImage {c : Address Î²} (h : âŸ¨A, inr NâŸ© < c) :\n    (Ï€.foaHypothesis : HypAction c).nearLitterImage A N h = Ï€.completeNearLitterMap A N :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 60, 65, 1317, 792], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [71, 74], "informalization": "The theorem `ConNF.StructApprox.foaHypothesis_nearLitterImage` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for any `Î²`-structural approximation `Ï€`, any `Î²`-extended index `A`, and any near-litter `N`, the near-litter image of `A` and `N` under the Freedom of Action hypothesis is equal to the complete near-litter map of `Ï€` applied to `A` and `N`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_eq_of_mem_domain", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMap_eq_of_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_eq_of_mem_domain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {a : ConNF.Atom} (h : a âˆˆ (Ï€ A).atomPerm.domain) :ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A a = Ï€ A â€¢ a", "code": "theorem completeAtomMap_eq_of_mem_domain {A} {a} (h : a âˆˆ (Ï€ A).atomPerm.domain) :\n    Ï€.completeAtomMap A a = Ï€ A â€¢ a := by rw [completeAtomMap_eq, atomCompletion, dif_pos h]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 784], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [77, 79], "informalization": "The theorem `ConNF.StructApprox.completeAtomMap_eq_of_mem_domain` states that for a `Î²`-structural approximation `Ï€` and a `Î²`-extended index `A`, if an atom `a` is in the domain of the atom permutation of `Ï€ A`, then the complete atom map of `Ï€` at `A` applied to `a` is equal to the action of `Ï€ A` on `a`."}
{"full_name": "ConNF.StructApprox.completeLitterMap_eq_of_flexible", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMap_eq_of_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_eq_of_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {L : ConNF.Litter} (h : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) :ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A L = ConNF.NearLitterApprox.flexibleCompletionğŸ”—<|PREMISE|>ğŸ”— (Ï€ A) A â€¢ L", "code": "theorem completeLitterMap_eq_of_flexible {A : ExtendedIndex Î²} {L : Litter} (h : Flexible A L) :\n    Ï€.completeLitterMap A L = NearLitterApprox.flexibleCompletion (Ï€ A) A â€¢ L := by\n  rw [completeLitterMap_eq, litterCompletion_of_flexible _ _ _ _ h]\n", "additional_info": "A basic definition unfold.", "used_premises": [1, 402, 779, 781, 61, 842, 787, 1314], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [122, 125], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeLitterMap_eq_of_flexible` states that for a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, and a litter `L` that is `A`-flexible, the litter `ConNF.StructApprox.completeLitterMap Ï€ A L` is equal to `ConNF.NearLitterApprox.flexibleCompletion (Ï€ A) A â€¢ L`. This theorem serves as a basic definition unfold in the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). The `ConNF.NearLitterApprox.flexibleCompletion` function is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.toStructPerm_bot", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.toStructPerm_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.toStructPerm_bot [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] :â‡‘ConNF.Allowable.toStructPerm = â‡‘(MulEquiv.toMonoidHomğŸ”—<|PREMISE|>ğŸ”— ConNF.Tree.toBotIso)", "code": "theorem toStructPerm_bot :\n    (Allowable.toStructPerm : Allowable âŠ¥ â†’ StructPerm âŠ¥) = Tree.toBotIso.toMonoidHom :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1328], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [126, 129], "informalization": "The theorem `ConNF.StructApprox.toStructPerm_bot` states that the function `ConNF.Allowable.toStructPerm` is equal to the monoid homomorphism obtained from the multiplicative equivalence `ConNF.Tree.toBotIso`."}
{"full_name": "MulEquiv.toMonoidHom", "url": "Mathlib/Algebra/Group/Equiv/Basic.html#MulEquiv.toMonoidHom", "code_src": "mathlib4", "ptype": "def", "header": "def MulEquiv.toMonoidHom {M : Type u_6} {N : Type u_7} [MulOneClassğŸ”—<|PREMISE|>ğŸ”— M] [MulOneClassğŸ”—<|PREMISE|>ğŸ”— N] (h : M â‰ƒ* N) :M â†’* N", "code": "def toMonoidHom (h : M â‰ƒ* N) : M â†’* N :=\n  { h with map_one' := h.map_one }\n", "additional_info": "Extract the forward direction of a multiplicative equivalence\nas a multiplication-preserving function.\nEquations\n* ğŸ—ŸMulEquiv.toMonoidHomğŸ—ŸğŸ”—../../../.././Mathlib/Algebra/Group/Equiv/Basic.html#MulEquiv.toMonoidHomğŸ”—  h ğŸ—Ÿ=ğŸ—ŸğŸ”—../../../.././Init/Prelude.html#EqğŸ”—  { toOneHom := { toFun := h.toFun, map_one' := â‹¯ }, map_mul' := â‹¯ }\n\n", "used_premises": [847, 847], "def_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "pos": [638, 640], "informalization": "Function `MulEquiv.toMonoidHom` converts a multiplicative equivalence `h` between two `MulOneClass` types into a monoid homomorphism that preserves the multiplicative structure."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_eq'", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap_eq'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_eq' [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) :â†‘(ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N) = symmDiffğŸ”—<|PREMISE|>ğŸ”— (â†‘(ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst))) (ConNF.StructApprox.completeAtomMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A '' symmDiffğŸ”—<|PREMISE|>ğŸ”— (ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— N.fst) â†‘N)", "code": "theorem completeNearLitterMap_eq' (A : ExtendedIndex Î²) (N : NearLitter) :\n    (Ï€.completeNearLitterMap A N : Set Atom) =\n      (Ï€.completeNearLitterMap A N.fst.toNearLitter : Set Atom) âˆ†\n        (Ï€.completeAtomMap A '' litterSet N.fst âˆ† â†‘N) := by\n  simp only [completeNearLitterMap_eq, nearLitterCompletion, nearLitterCompletionMap,\n    nearLitterHypothesis_eq, NearLitterApprox.coe_largestSublitter, mem_diff,\n    foaHypothesis_atomImage, NearLitter.coe_mk, Subtype.coe_mk, Litter.coe_toNearLitter,\n    Litter.toNearLitter_fst, symmDiff_self, bot_eq_empty, mem_empty_iff_false, false_and_iff,\n    iUnion_neg', not_false_iff, iUnion_empty, symmDiff_empty]\n  ext a : 1\n  constructor\n  Â· rintro (âŸ¨haâ‚ | âŸ¨a, haâ‚, rflâŸ©, haâ‚‚âŸ© | âŸ¨âŸ¨_, âŸ¨b, rflâŸ©, _, âŸ¨âŸ¨hbâ‚, hbâ‚‚âŸ©, rflâŸ©, haâŸ©, haâ‚‚âŸ©)\n    Â· refine' Or.inl âŸ¨Or.inl haâ‚, _âŸ©\n      simp only [mem_image, not_exists, not_and]\n      intro b hb\n      by_cases h : b âˆˆ (Ï€ A).atomPerm.domain\n      Â· rw [completeAtomMap_eq_of_mem_domain h]\n        rintro rfl\n        exact haâ‚.2 ((Ï€ A).atomPerm.map_domain h)\n      Â· simp only [mem_iUnion, mem_singleton_iff, not_exists, and_imp] at haâ‚‚\n        exact Ne.symm (haâ‚‚ b hb h)\n    Â· by_cases h : a âˆˆ litterSet N.fst\n      Â· refine' Or.inl âŸ¨Or.inr âŸ¨a, âŸ¨h, haâ‚.2âŸ©, rflâŸ©, _âŸ©\n        simp only [mem_image, not_exists, not_and]\n        intro b hb\n        by_cases hb' : b âˆˆ (Ï€ A).atomPerm.domain\n        Â· rw [completeAtomMap_eq_of_mem_domain hb']\n          intro hab\n          cases (Ï€ A).atomPerm.injOn hb' haâ‚.2 hab\n          obtain hb | hb := hb\n          exact hb.2 haâ‚.1\n          exact hb.2 h\n        Â· simp only [mem_iUnion, mem_singleton_iff, not_exists, and_imp] at haâ‚‚\n          exact Ne.symm (haâ‚‚ b hb hb')\n      Â· refine' Or.inr âŸ¨âŸ¨a, Or.inr âŸ¨haâ‚.1, hâŸ©, _âŸ©, _âŸ©\n        Â· simp only [completeAtomMap_eq_of_mem_domain haâ‚.2]\n        rintro (ha | âŸ¨b, hbâ‚, hbâ‚‚âŸ©)\n        Â· exact ha.2 ((Ï€ A).atomPerm.map_domain haâ‚.2)\n        Â· cases (Ï€ A).atomPerm.injOn hbâ‚.2 haâ‚.2 hbâ‚‚\n          exact h hbâ‚.1\n    Â· simp only [mem_singleton_iff] at ha\n      subst ha\n      refine' Or.inr âŸ¨âŸ¨b, hbâ‚, rflâŸ©, _âŸ©\n      contrapose! haâ‚‚\n      obtain haâ‚‚ | haâ‚‚ := haâ‚‚\n      Â· exact Or.inl haâ‚‚\n      obtain âŸ¨a, haâ‚, haâ‚‚âŸ© := haâ‚‚\n      by_cases h : a âˆˆ N\n      Â· rw [â† haâ‚‚]\n        exact Or.inr âŸ¨a, âŸ¨h, haâ‚.2âŸ©, rflâŸ©\n      rw [completeAtomMap_eq_of_not_mem_domain hbâ‚‚]\n      simp only [mem_union, mem_diff, mem_litterSet, Sublitter.equiv_apply_fst_eq,\n        NearLitterApprox.largestSublitter_litter]\n      refine' Or.inl âŸ¨_, _âŸ©\n      Â· suffices b âˆˆ litterSet N.fst by\n          rw [mem_litterSet] at this\n          rw [this, completeLitterMap_eq]\n        obtain hbâ‚ | hbâ‚ := hbâ‚\n        Â· exact hbâ‚.1\n        Â· exfalso\n          rw [completeAtomMap_eq_of_not_mem_domain hbâ‚‚] at haâ‚‚\n          have : Ï€ A â€¢ a âˆˆ _ := (Ï€ A).atomPerm.map_domain haâ‚.2\n          dsimp only at haâ‚‚\n          rw [haâ‚‚] at this\n          exact NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n            (Sublitter.equiv_apply_mem _) this\n      Â· exact NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n          (Sublitter.equiv_apply_mem _)\n  Â· rintro (âŸ¨haâ‚ | âŸ¨a, haâ‚, rflâŸ©, haâ‚‚âŸ© | âŸ¨âŸ¨a, haâ‚, rflâŸ©, haâ‚‚âŸ©)\n    Â· refine' Or.inl âŸ¨Or.inl haâ‚, _âŸ©\n      simp only [mem_iUnion, mem_singleton_iff, not_exists, and_imp]\n      rintro b hb _ rfl\n      exact haâ‚‚ âŸ¨b, hb, rflâŸ©\n    Â· refine' Or.inl âŸ¨_, _âŸ©\n      Â· by_cases h : a âˆˆ N\n        Â· exact Or.inr âŸ¨a, âŸ¨h, haâ‚.2âŸ©, rflâŸ©\n        Â· simp only [mem_image, not_exists, not_and] at haâ‚‚\n          have := haâ‚‚ a (Or.inl âŸ¨haâ‚.1, hâŸ©)\n          rw [completeAtomMap_eq_of_mem_domain haâ‚.2] at this\n          cases this rfl\n      Â· contrapose! haâ‚‚\n        obtain âŸ¨_, âŸ¨b, rflâŸ©, _, âŸ¨hb, rflâŸ©, haâ‚‚âŸ© := haâ‚‚\n        simp only [mem_singleton_iff] at haâ‚‚\n        rw [haâ‚‚]\n        exact âŸ¨b, hb.1, rflâŸ©\n    Â· rw [mem_union, not_or] at haâ‚‚\n      by_cases ha : a âˆˆ litterSet N.fst\n      Â· have : a âˆ‰ (Ï€ A).atomPerm.domain := by\n          intro h\n          refine' haâ‚‚.2 âŸ¨a, âŸ¨ha, hâŸ©, _âŸ©\n          simp only [completeAtomMap_eq_of_mem_domain h]\n        refine' Or.inr âŸ¨_, _âŸ©\n        Â· exact âŸ¨_, âŸ¨a, rflâŸ©, _, âŸ¨âŸ¨haâ‚, thisâŸ©, rflâŸ©, rflâŸ©\n        Â· rintro (h | âŸ¨b, hbâ‚, hbâ‚‚âŸ©)\n          Â· exact haâ‚‚.1 h\n          simp only [completeAtomMap_eq_of_not_mem_domain this] at hbâ‚‚\n          have : Ï€ A â€¢ b âˆˆ _ := (Ï€ A).atomPerm.map_domain hbâ‚.2\n          rw [hbâ‚‚] at this\n          exact\n            NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n              (Sublitter.equiv_apply_mem _) this\n      Â· by_cases h : a âˆˆ (Ï€ A).atomPerm.domain\n        Â· refine' Or.inl âŸ¨_, _âŸ©\n          Â· simp only [completeAtomMap_eq_of_mem_domain h]\n            refine' Or.inr âŸ¨a, âŸ¨_, hâŸ©, rflâŸ©\n            obtain haâ‚ | haâ‚ := haâ‚\n            Â· cases ha haâ‚.1\n            Â· exact haâ‚.1\n          Â· simp only [mem_iUnion, mem_singleton_iff, not_exists, and_imp]\n            intro b _ hb hab\n            rw [completeAtomMap_eq_of_mem_domain h, completeAtomMap_eq_of_not_mem_domain hb] at hab\n            have : Ï€ A â€¢ a âˆˆ _ := (Ï€ A).atomPerm.map_domain h\n            rw [hab] at this\n            exact\n              NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n                (Sublitter.equiv_apply_mem _) this\n        Â· refine' Or.inr âŸ¨_, _âŸ©\n          Â· exact âŸ¨_, âŸ¨a, rflâŸ©, _, âŸ¨âŸ¨haâ‚, hâŸ©, rflâŸ©, rflâŸ©\n          rintro (h' | âŸ¨b, hbâ‚, hbâ‚‚âŸ©)\n          Â· exact haâ‚‚.1 h'\n          simp only [completeAtomMap_eq_of_not_mem_domain h] at hbâ‚‚\n          have : Ï€ A â€¢ b âˆˆ _ := (Ï€ A).atomPerm.map_domain hbâ‚.2\n          rw [hbâ‚‚] at this\n          exact NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n            (Sublitter.equiv_apply_mem _) this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 62, 792, 483, 784, 62, 467], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [131, 256], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterMap_eq'` states that for a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, and a near-litter `N`, the near-litter `ConNF.StructApprox.completeNearLitterMap Ï€ A N` is equal to the symmetric difference of the near-litter `ConNF.StructApprox.completeNearLitterMap Ï€ A (ConNF.Litter.toNearLitter N.fst)` and the set of atoms `ConNF.StructApprox.completeAtomMap Ï€ A '' symmDiff (ConNF.litterSet N.fst) â†‘N`."}
{"full_name": "ConNF.StructApprox.eq_of_mem_completeNearLitterMap", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.eq_of_mem_completeNearLitterMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.eq_of_mem_completeNearLitterMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] {Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} {Lâ‚ : ConNF.Litter} {Lâ‚‚ : ConNF.Litter} {A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²} (a : ConNF.Atom) (haâ‚ : a âˆˆ ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— Lâ‚)) (haâ‚‚ : a âˆˆ ConNF.StructApprox.completeNearLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— Lâ‚‚)) :ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A Lâ‚ = ConNF.StructApprox.completeLitterMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A Lâ‚‚", "code": "theorem eq_of_mem_completeNearLitterMap {Lâ‚ Lâ‚‚ : Litter} {A : ExtendedIndex Î²} (a : Atom)\n    (haâ‚ : a âˆˆ Ï€.completeNearLitterMap A Lâ‚.toNearLitter)\n    (haâ‚‚ : a âˆˆ Ï€.completeNearLitterMap A Lâ‚‚.toNearLitter) :\n    Ï€.completeLitterMap A Lâ‚ = Ï€.completeLitterMap A Lâ‚‚ := by\n  rw [â† SetLike.mem_coe, completeNearLitterMap_toNearLitter_eq] at haâ‚ haâ‚‚\n  obtain âŸ¨haâ‚, haâ‚'âŸ© | haâ‚ := haâ‚ <;> obtain âŸ¨haâ‚‚, haâ‚‚'âŸ© | haâ‚‚ := haâ‚‚\n  Â· exact eq_of_mem_litterSet_of_mem_litterSet haâ‚ haâ‚‚\n  Â· obtain âŸ¨b, hb, rflâŸ© := haâ‚‚\n    cases haâ‚' ((Ï€ A).atomPerm.map_domain hb.2)\n  Â· obtain âŸ¨b, hb, rflâŸ© := haâ‚\n    cases haâ‚‚' ((Ï€ A).atomPerm.map_domain hb.2)\n  Â· obtain âŸ¨b, hb, rflâŸ© := haâ‚\n    obtain âŸ¨c, hc, hc'âŸ© := haâ‚‚\n    cases (Ï€ A).atomPerm.injOn hc.2 hb.2 hc'\n    rw [eq_of_mem_litterSet_of_mem_litterSet hb.1 hc.1]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 483, 792, 483, 787, 787], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [269, 284], "informalization": "The theorem `eq_of_mem_completeNearLitterMap` states that, under certain conditions, if two litters both contain an atom `a` that is also contained in the near-litter approximation of a `Î²`-extended index `A` for a `Î²`-structural approximation `Ï€`, then the litter maps of `Lâ‚` and `Lâ‚‚` will be equal. This theorem is a key step in the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterApprox.idOnFlexible_domain", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.idOnFlexible_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.idOnFlexible_domain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :(ConNF.NearLitterApprox.idOnFlexibleğŸ”—<|PREMISE|>ğŸ”— Ï€ A).domain = {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L} \\ Ï€.litterPerm.domain", "code": "theorem idOnFlexible_domain :\n    (idOnFlexible Ï€ A).domain = {L | Flexible A L} \\ Ï€.litterPerm.domain :=\n  rfl\n", "additional_info": "", "used_premises": [1, 61, 1332, 842], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [24, 27], "informalization": "The theorem `ConNF.NearLitterApprox.idOnFlexible_domain` states that the domain of the partial permutation `ConNF.NearLitterApprox.idOnFlexible` is the set of litters that are `Flexible` with respect to a given `ConNF.ExtendedIndex` `A`, excluding those litters that are already in the domain of the `ConNF.NearLitterApprox` `Ï€.litterPerm`."}
{"full_name": "ConNF.NearLitterApprox.idOnFlexible", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.idOnFlexible", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterApprox.idOnFlexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :PartialPermğŸ”—<|PREMISE|>ğŸ”— ConNF.Litter", "code": "def idOnFlexible : PartialPerm Litter where\n  toFun := id\n  invFun := id\n  domain := {L | Flexible A L} \\ Ï€.litterPerm.domain\n  toFun_domain' _ h := h\n  invFun_domain' _ h := h\n  left_inv' _ _ := rfl\n  right_inv' _ _ := rfl\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 61, 645], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [15, 23], "informalization": "Function `ConNF.NearLitterApprox.idOnFlexible` defines a partial permutation on the set of litters, where the domain of the permutation is the set of litters that are `Flexible` with respect to a given `ConNF.ExtendedIndex` `A`, excluding those litters that are already in the domain of the `ConNF.NearLitterApprox` `Ï€.litterPerm`."}
{"full_name": "ConNF.NearLitterApprox.idOnFlexible_domain_disjoint", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.idOnFlexible_domain_disjoint", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.idOnFlexible_domain_disjoint [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :DisjointğŸ”—<|PREMISE|>ğŸ”— Ï€.litterPerm.domain (ConNF.NearLitterApprox.idOnFlexibleğŸ”—<|PREMISE|>ğŸ”— Ï€ A).domain", "code": "theorem idOnFlexible_domain_disjoint : Disjoint Ï€.litterPerm.domain (idOnFlexible Ï€ A).domain :=\n  by rw [disjoint_iff_inter_eq_empty, idOnFlexible_domain, inter_diff_self]\n", "additional_info": "", "used_premises": [1, 61, 757, 1332], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [28, 30], "informalization": "The theorem `ConNF.NearLitterApprox.idOnFlexible_domain_disjoint` asserts that two sets, the domain of the permutation `Ï€.litterPerm` and the domain of the partial permutation `ConNF.NearLitterApprox.idOnFlexible Ï€ A`, are disjoint. The domain of `Ï€.litterPerm` represents the set of litters that are permuted by the `ConNF.NearLitterApprox`, while `ConNF.NearLitterApprox.idOnFlexible Ï€ A` is a partial permutation that operates only on the set of `Flexible` litters with respect to the `ConNF.ExtendedIndex` `A`, excluding those litters that are already in the domain of `Ï€.litterPerm`. The theorem states that there is no overlap between these two sets, i.e., no litter is both in the domain of `Ï€.litterPerm` and in the domain of `ConNF.NearLitterApprox.idOnFlexible Ï€ A`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :(ConNF.NearLitterApprox.flexibleCompletionLitterPermğŸ”—<|PREMISE|>ğŸ”— Ï€ A).domain = Ï€.litterPerm.domain âˆª {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L}", "code": "theorem flexibleCompletionLitterPerm_domain :\n    (flexibleCompletionLitterPerm Ï€ A).domain = Ï€.litterPerm.domain âˆª {L | Flexible A L} := by\n  rw [flexibleCompletionLitterPerm, PartialPerm.piecewise_domain, idOnFlexible_domain,\n    union_diff_self]\n", "additional_info": "", "used_premises": [1, 61, 1335, 842], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [34, 38], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain` states that the domain of the partial permutation `ConNF.NearLitterApprox.flexibleCompletionLitterPerm Ï€ A` is equal to the union of the domain of the partial permutation `Ï€.litterPerm` and the set of all *flexible* litters with respect to the extended index `A`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletionLitterPerm", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionLitterPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterApprox.flexibleCompletionLitterPerm [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :PartialPermğŸ”—<|PREMISE|>ğŸ”— ConNF.Litter", "code": "noncomputable def flexibleCompletionLitterPerm : PartialPerm Litter :=\n  PartialPerm.piecewise Ï€.litterPerm (idOnFlexible Ï€ A) (idOnFlexible_domain_disjoint Ï€ A)\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterApprox.flexibleCompletionLitterPermğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionLitterPermğŸ”—  Ï€ A ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  ğŸ—ŸPartialPerm.piecewiseğŸ—ŸğŸ”—../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewiseğŸ”—  Ï€.litterPerm (ğŸ—ŸConNF.NearLitterApprox.idOnFlexibleğŸ—ŸğŸ”—../../.././ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.idOnFlexibleğŸ”—  Ï€ A) â‹¯\n\n", "used_premises": [1, 61, 645], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [31, 33], "informalization": "Function `ConNF.NearLitterApprox.flexibleCompletionLitterPerm` takes a `ConNF.NearLitterApprox` object `Ï€` and an `ConNF.ExtendedIndex` object `A`, and returns a `PartialPerm ConNF.Litter`, which is a partial permutation of the `ConNF.Litter` type. This function is used in the context of Constructive Ordinal Notation (ConNF) to construct a permutation of the litter type based on the given near litter approximation and extended index."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :(ConNF.NearLitterApprox.flexibleCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A).litterPerm.domain = Ï€.litterPerm.domain âˆª {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L}", "code": "theorem flexibleCompletion_litterPerm_domain :\n    (flexibleCompletion Ï€ A).litterPerm.domain = Ï€.litterPerm.domain âˆª {L | Flexible A L} := by\n  rw [flexibleCompletion, flexibleCompletionLitterPerm_domain]\n", "additional_info": "", "used_premises": [1, 61, 1314, 842], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [45, 48], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain` states that the domain of the `litterPerm` of the `ConNF.NearLitterApprox` object obtained by applying the `ConNF.NearLitterApprox.flexibleCompletion` function to a `ConNF.NearLitterApprox` object `Ï€` and an `ConNF.ExtendedIndex` object `A` is equal to the union of the domain of `Ï€.litterPerm` and the set of all `ConNF.Litter`s that are `ConNF.Flexible` with respect to `A`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) (hÏ€ : ConNF.NearLitterApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€ A) :(ConNF.NearLitterApprox.flexibleCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A).litterPerm.domain = {L : ConNF.Litter | ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L}", "code": "theorem flexibleCompletion_litterPerm_domain_free (hÏ€ : Ï€.Free A) :\n    (flexibleCompletion Ï€ A).litterPerm.domain = {L | Flexible A L} := by\n  rw [flexibleCompletion_litterPerm_domain, union_eq_right]\n  exact fun L hL => hÏ€ L hL\n", "additional_info": "", "used_premises": [1, 61, 1338, 1314, 842], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [49, 53], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free` states that the domain of the `litterPerm` of the `ConNF.NearLitterApprox` object obtained by applying the `ConNF.NearLitterApprox.flexibleCompletion` function to a `ConNF.NearLitterApprox` object `Ï€` and an `ConNF.ExtendedIndex` object `A` is exactly the set of all `ConNF.Litter`s that are `ConNF.Flexible` with respect to `A`."}
{"full_name": "ConNF.NearLitterApprox.Free", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Free", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterApprox.Free [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) :Prop", "code": "def Free [Level] [FOAAssumptions] {Î² : TypeIndex} (Ï€ : NearLitterApprox)\n    (A : ExtendedIndex Î²) : Prop :=\n  âˆ€ L âˆˆ Ï€.litterPerm.domain, Flexible A L\n", "additional_info": "Equations\n* ğŸ—ŸConNF.NearLitterApprox.FreeğŸ—ŸğŸ”—../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.FreeğŸ”—  Ï€ A ğŸ—Ÿ=ğŸ—ŸğŸ”—../../.././Init/Prelude.html#EqğŸ”—  âˆ€ L âˆˆ Ï€.litterPerm.domain, ğŸ—ŸConNF.FlexibleğŸ—ŸğŸ”—../../.././ConNF/FOA/Basic/Flexible.html#ConNF.FlexibleğŸ”—  A L\n\n", "used_premises": [1, 61], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [198, 201], "informalization": "Function `ConNF.NearLitterApprox.Free` defines a property of a `ConNF.NearLitterApprox` object `Ï€` and an `ConNF.ExtendedIndex` object `A`. It asserts that for every `L` in the domain of `Ï€.litterPerm`, the `ConNF.Flexible` property holds between `A` and `L`. This property is crucial in the context of Constructive Ordinal Notation (ConNF), where it ensures that the `ConNF.NearLitterApprox` object `Ï€` is compatible with the `ConNF.ExtendedIndex` object `A` in terms of extensionality."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_smul_eq", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_smul_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_smul_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) (L : ConNF.Litter) :ConNF.NearLitterApprox.flexibleCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A â€¢ L = (ConNF.NearLitterApprox.flexibleCompletionLitterPermğŸ”—<|PREMISE|>ğŸ”— Ï€ A).toFun L", "code": "theorem flexibleCompletion_smul_eq (L : Litter) :\n    flexibleCompletion Ï€ A â€¢ L = flexibleCompletionLitterPerm Ï€ A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 61, 1314, 1335], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [54, 57], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_eq` states that for a `ConNF.NearLitterApprox` object `Ï€` and an `ConNF.ExtendedIndex` object `A`, the action of `ConNF.NearLitterApprox.flexibleCompletion Ï€ A` on a `ConNF.Litter` object `L` is equal to the application of the partial permutation `ConNF.NearLitterApprox.flexibleCompletionLitterPerm Ï€ A` to `L`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) (L : ConNF.Litter) (hL : L âˆˆ Ï€.litterPerm.domain) :ConNF.NearLitterApprox.flexibleCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A â€¢ L = Ï€.litterPerm.toFun L", "code": "theorem flexibleCompletion_smul_of_mem_domain (L : Litter) (hL : L âˆˆ Ï€.litterPerm.domain) :\n    flexibleCompletion Ï€ A â€¢ L = Ï€.litterPerm L := by\n  rw [flexibleCompletion_smul_eq, flexibleCompletionLitterPerm,\n    PartialPerm.piecewise_apply_eq_left hL]\n", "additional_info": "", "used_premises": [1, 61, 1314], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [58, 62], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain` states that for any `ConNF.NearLitterApprox` object `Ï€`, any `ConNF.ExtendedIndex` object `A`, and any `ConNF.Litter` object `L` that is in the domain of `Ï€.litterPerm`, the action of `ConNF.NearLitterApprox.flexibleCompletion Ï€ A` on `L` is equal to the action of `Ï€.litterPerm` on `L`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_smul_flexible", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_smul_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_smul_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) (hÏ€ : ConNF.NearLitterApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€ A) (L : ConNF.Litter) (hL : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A (ConNF.NearLitterApprox.flexibleCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A â€¢ L)", "code": "theorem flexibleCompletion_smul_flexible (hÏ€ : Ï€.Free A) (L : Litter) (hL : Flexible A L) :\n    Flexible A (flexibleCompletion Ï€ A â€¢ L) := by\n  have := PartialPerm.map_domain (flexibleCompletion Ï€ A).litterPerm (x := ?_) ?_\n  Â· rw [flexibleCompletion_litterPerm_domain_free Ï€ A hÏ€] at this\n    exact this\n  Â· rw [flexibleCompletion_litterPerm_domain_free Ï€ A hÏ€]\n    exact hL\n", "additional_info": "", "used_premises": [1, 61, 1338, 842, 842, 1314], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [63, 70], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_flexible` states that if `Ï€` is a `ConNF.NearLitterApprox` object that is `ConNF.NearLitterApprox.Free` with respect to an `ConNF.ExtendedIndex` object `A`, and `L` is a `ConNF.Litter` object that is `ConNF.Flexible` with respect to `A`, then the `ConNF.NearLitterApprox.flexibleCompletion` of `Ï€` with respect to `A` applied to `L` is also `ConNF.Flexible` with respect to `A`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.TypeIndex} (Ï€ : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— Î²) (hÏ€ : ConNF.NearLitterApprox.FreeğŸ”—<|PREMISE|>ğŸ”— Ï€ A) (L : ConNF.Litter) (hL : ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A L) :ConNF.FlexibleğŸ”—<|PREMISE|>ğŸ”— A (ConNF.NearLitterApprox.symmğŸ”—<|PREMISE|>ğŸ”— (ConNF.NearLitterApprox.flexibleCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A) â€¢ L)", "code": "theorem flexibleCompletion_symm_smul_flexible (hÏ€ : Ï€.Free A) (L : Litter) (hL : Flexible A L) :\n    Flexible A ((flexibleCompletion Ï€ A).symm â€¢ L) := by\n  have := PartialPerm.map_domain (flexibleCompletion Ï€ A).symm.litterPerm (x := ?_) ?_\n  Â· rw [symm_litterPerm, PartialPerm.symm_domain,\n      flexibleCompletion_litterPerm_domain_free Ï€ A hÏ€] at this\n    exact this\n  Â· rw [symm_litterPerm, PartialPerm.symm_domain,\n      flexibleCompletion_litterPerm_domain_free Ï€ A hÏ€]\n    exact hL\n", "additional_info": "", "used_premises": [1, 61, 1338, 842, 842, 1223, 1314], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [71, 80], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible` asserts that given a `ConNF.NearLitterApprox` object `Ï€`, an `ConNF.ExtendedIndex` object `A`, and a `ConNF.Litter` object `L`, if `Ï€` is `ConNF.NearLitterApprox.Free` with respect to `A` and `L` is `ConNF.Flexible` with respect to `A`, then `ConNF.NearLitterApprox.symm (ConNF.NearLitterApprox.flexibleCompletion Ï€ A) â€¢ L` is also `ConNF.Flexible` with respect to `A`. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.nearLitterCompletionMap_isNearLitter", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletionMap_isNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.nearLitterCompletionMap_isNearLitter [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N }) :ConNF.IsNearLitterğŸ”—<|PREMISE|>ğŸ”— (ConNF.StructApprox.litterCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A N.fst (ConNF.StructApprox.nearLitterHypothesisğŸ”—<|PREMISE|>ğŸ”— A N H)) (ConNF.StructApprox.nearLitterCompletionMapğŸ”—<|PREMISE|>ğŸ”— Ï€ A N H)", "code": "theorem nearLitterCompletionMap_isNearLitter (Ï€ : StructApprox Î²) (A : ExtendedIndex Î²)\n    (N : NearLitter) (H : HypAction âŸ¨A, inr NâŸ©) :\n    IsNearLitter (Ï€.litterCompletion A N.fst (nearLitterHypothesis A N H))\n      (Ï€.nearLitterCompletionMap A N H) := by\n  rw [nearLitterCompletionMap, IsNearLitter, IsNear, NearLitterApprox.coe_largestSublitter,\n    â† symmDiff_assoc, symmDiff_comm, â† Small.symmDiff_iff _]\n  Â· rw [Set.symmDiff_def, â† diff_diff, sdiff_sdiff_right_self, union_diff_distrib,\n      sdiff_sdiff_self, bot_eq_empty, empty_union]\n    exact Small.union (Small.mono (diff_subset _ _) ((Ï€ A).domain_small _))\n      (Small.mono (diff_subset _ _) (NearLitterApprox.nearLitter_domain_small _ _).image)\n  Â· exact Small.bUnion (Small.mono (diff_subset _ _) N.2.prop) fun _ _ => small_singleton _\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 466, 1313, 1344, 1345], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [40, 51], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.nearLitterCompletionMap_isNearLitter` states that given a `Î²`-structural approximation `Ï€`, an extended index `A`, a near-litter `N`, and a hypothesis `H` about the action of `Ï€` on `A` and `N`, the litter returned by the function `ConNF.StructApprox.litterCompletion` is near the near-litter returned by the function `ConNF.StructApprox.nearLitterCompletionMap`."}
{"full_name": "ConNF.StructApprox.nearLitterHypothesis", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterHypothesis", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.nearLitterHypothesis [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N }) :ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— (ConNF.Litter.toNearLitterğŸ”—<|PREMISE|>ğŸ”— N.fst) }", "code": "def nearLitterHypothesis (A : ExtendedIndex Î²) (N : NearLitter) (H : HypAction âŸ¨A, inr NâŸ©) :\n    HypAction âŸ¨A, inr N.1.toNearLitterâŸ©\n    where\n  atomImage B a h :=\n    H.atomImage B a\n      (by\n        by_cases h' : N.IsLitter\n        Â· rw [h'.eq_fst_toNearLitter]\n          exact h\n        Â· exact Relation.TransGen.tail h (Constrains.nearLitter A N h'))\n  nearLitterImage B N' h :=\n    H.nearLitterImage B N'\n      (by\n        by_cases h' : N.IsLitter\n        Â· rw [h'.eq_fst_toNearLitter]\n          exact h\n        exact Relation.TransGen.tail h (Constrains.nearLitter A N h'))\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 61, 1305, 65, 1305, 65, 483], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [15, 32], "informalization": "Function `ConNF.StructApprox.nearLitterHypothesis` is a method within the context of Constructive Ordinal Notation (ConNF) that is used to construct the induced action of an approximation in the freedom of action theorem. It takes as input an extended index `A`, a near-litter `N`, and a hypothesis `H` of type `ConNF.HypAction`, which represents the inductive hypothesis used to construct the induced action. The output is a new hypothesis of type `ConNF.HypAction` for the near-litter `N.1.toNearLitter`."}
{"full_name": "ConNF.StructApprox.nearLitterCompletionMap", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletionMap", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.nearLitterCompletionMap [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N }) :SetğŸ”—<|PREMISE|>ğŸ”— ConNF.Atom", "code": "def nearLitterCompletionMap (Ï€ : StructApprox Î²) (A : ExtendedIndex Î²) (N : NearLitter)\n    (H : HypAction âŸ¨A, inr NâŸ©) : Set Atom :=\n  (NearLitterApprox.largestSublitter (Ï€ A) (Ï€.litterCompletion A N.1 (nearLitterHypothesis A N H)) âˆª\n      Ï€ A â€¢ ((N : Set Atom) âˆ© (Ï€ A).atomPerm.domain)) âˆ†\n    â‹ƒ (a : Atom) (ha : a âˆˆ litterSet N.1 âˆ† N \\ (Ï€ A).atomPerm.domain),\n      {H.atomImage A a (Relation.TransGen.single (Constrains.symmDiff A N a ha.1))}\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 69], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [33, 39], "informalization": "Function `ConNF.StructApprox.nearLitterCompletionMap` defines a `Î²`-structural approximation in the context of Constructive Ordinal Notation (ConNF), which is a product that assigns a near-litter approximation to each `Î²`-extended index."}
{"full_name": "ConNF.StructApprox.nearLitterCompletion_fst_eq", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletion_fst_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.nearLitterCompletion_fst_eq [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] [ConNF.Level] [ConNF.FOAAssumptions] {Î² : ConNF.Î›} [ConNF.LeLevelğŸ”—<|PREMISE|>ğŸ”— â†‘Î²] [ConNF.StructApprox.FreedomOfActionHypothesisğŸ”—<|PREMISE|>ğŸ”— Î²] (Ï€ : ConNF.StructApproxğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (A : ConNF.ExtendedIndexğŸ”—<|PREMISE|>ğŸ”— â†‘Î²) (N : ConNF.NearLitter) (H : ConNF.HypActionğŸ”—<|PREMISE|>ğŸ”— { path := A, value := Sum.inrğŸ”—<|PREMISE|>ğŸ”— N }) :(ConNF.StructApprox.nearLitterCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A N H).fst = ConNF.StructApprox.litterCompletionğŸ”—<|PREMISE|>ğŸ”— Ï€ A N.fst (ConNF.StructApprox.nearLitterHypothesisğŸ”—<|PREMISE|>ğŸ”— A N H)", "code": "theorem nearLitterCompletion_fst_eq (Ï€ : StructApprox Î²) (A : ExtendedIndex Î²) (N : NearLitter)\n    (H : HypAction âŸ¨A, inr NâŸ©) :\n    (Ï€.nearLitterCompletion A N H).1 = litterCompletion Ï€ A N.1 (nearLitterHypothesis A N H) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 1319, 1313, 1344], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [58, 62], "informalization": "The theorem `ConNF.StructApprox.nearLitterCompletion_fst_eq` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for a `Î²`-structural approximation `Ï€`, a `Î²`-extended index `A`, a near-litter `N`, and a hypothesis `H` about the action of `Ï€` on `A` and `N`, the first component of the near-litter completion `ConNF.StructApprox.nearLitterCompletion Ï€ A N H` is equal to the litter completion `ConNF.StructApprox.litterCompletion Ï€ A N.fst (ConNF.StructApprox.nearLitterHypothesis A N H)`."}
{"full_name": "ConNF.StructApprox.equiv_apply_mem", "url": "ConNF/FOA/Complete/AtomCompletion.html#ConNF.StructApprox.equiv_apply_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.equiv_apply_mem [ConNF.ParamsğŸ”—<|PREMISE|>ğŸ”— ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} {a : â†¥S} {L : ConNF.Litter} (h : â†‘((ConNF.Sublitter.equivğŸ”—<|PREMISE|>ğŸ”— S T) a) âˆˆ ConNF.litterSetğŸ”—<|PREMISE|>ğŸ”— L) :T.litter = L", "code": "theorem equiv_apply_mem {S T : Sublitter} {a} {L : Litter}\n    (h : (S.equiv T a : Atom) âˆˆ litterSet L) : T.litter = L := by\n  rw [â† Litter.litter_toSublitter L, â† Sublitter.inter_nonempty_iff]\n  exact âŸ¨_, (S.equiv T a).prop, hâŸ©\n", "additional_info": "", "used_premises": [1, 876, 467], "def_path": "ConNF/FOA/Complete/AtomCompletion.lean", "pos": [17, 21], "informalization": "The theorem `ConNF.StructApprox.equiv_apply_mem` states that for any two sublitters `S` and `T` in the context of Constructive Ordinal Notation (ConNF), and any atom `a` in `S`, if the image of `a` under the equivalence `ConNF.Sublitter.equiv S T` belongs to the set `ConNF.litterSet L` for some litter `L`, then the litter corresponding to `T` is equal to `L`."}
